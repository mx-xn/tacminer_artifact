[
    {
        "lemma_name": "eval_helper",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (bf : builtin_function) (le : letenv) (id : ident)\n  (name : string) (sg : signature) (args : exprlist) \n  (vargs : list val) (vres : val)\n  (_ : eval_exprlist ge sp e m le args vargs)\n  (_ : helper_declared prog id name sg)\n  (_ : eq (lookup_builtin_function name sg) (Some bf))\n  (_ : eq (builtin_function_sem bf vargs) (Some vres)),\neval_expr ge sp e m le (Eexternal id sg args) vres"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg args) vres",
                    "H2 : eq (builtin_function_sem bf vargs) (Some vres)",
                    "H1 : eq (lookup_builtin_function name sg) (Some bf)",
                    "H0 : helper_declared prog id name sg",
                    "H : eval_exprlist ge sp e m le args vargs",
                    "vres : val",
                    "vargs : list val",
                    "args : exprlist",
                    "sg : signature",
                    "name : string",
                    "id : ident",
                    "le : letenv",
                    "bf : builtin_function"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "H0 : helper_declared prog id name sg"
                ],
                "tactic_res": [
                    "H0 : eq (PTree.get id (prog_defmap prog))\n  (Some (Gfun (External (EF_runtime name sg))))"
                ]
            },
            {
                "tactic_sig": "apply Genv.find_def_symbol in _i .",
                "tactic_sig_no_out_arg": "apply Genv.find_def_symbol in _i .",
                "tactic_args": [
                    "H0 : eq (PTree.get id (prog_defmap prog))\n  (Some (Gfun (External (EF_runtime name sg))))"
                ],
                "tactic_res": [
                    "H0 : ex\n  (fun b : block =>\n   Logic.and (eq (Genv.find_symbol (Genv.globalenv prog) id) (Some b))\n     (eq (Genv.find_def (Genv.globalenv prog) b)\n        (Some (Gfun (External (EF_runtime name sg))))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as ( b & P & Q ) as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i as ( b & P & Q ) .",
                "tactic_args": [
                    "H0 : ex\n  (fun b : block =>\n   Logic.and (eq (Genv.find_symbol (Genv.globalenv prog) id) (Some b))\n     (eq (Genv.find_def (Genv.globalenv prog) b)\n        (Some (Gfun (External (EF_runtime name sg))))))"
                ],
                "tactic_res": [
                    "Q : eq (Genv.find_def (Genv.globalenv prog) b)\n  (Some (Gfun (External (EF_runtime name sg))))",
                    "P : eq (Genv.find_symbol (Genv.globalenv prog) id) (Some b)",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "rewrite <- Genv.find_funct_ptr_iff in _i .",
                "tactic_sig_no_out_arg": "rewrite <- Genv.find_funct_ptr_iff in _i .",
                "tactic_args": [
                    "Q : eq (Genv.find_def (Genv.globalenv prog) b)\n  (Some (Gfun (External (EF_runtime name sg))))"
                ],
                "tactic_res": [
                    "Q : eq (Genv.find_funct_ptr (Genv.globalenv prog) b)\n  (Some (External (EF_runtime name sg)))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg args) vres"
                ],
                "tactic_res": [
                    "_goal : eq (Genv.find_symbol ge id) (Some ?b)",
                    "_goal : eq (Genv.find_funct_ptr ge ?b) (Some (External ?ef))",
                    "_goal : eq (ef_sig ?ef) sg",
                    "_goal : eval_exprlist ge sp e m le args ?vl",
                    "_goal : external_call ?ef ge ?vl m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Genv.find_symbol ge id) (Some ?b)",
                    "_goal : eq (Genv.find_funct_ptr ge ?b) (Some (External ?ef))"
                ],
                "tactic_res": [
                    "_goal : eq (Genv.find_funct_ptr ge b) (Some (External ?ef))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Genv.find_funct_ptr ge b) (Some (External ?ef))",
                    "_goal : eq (ef_sig ?ef) sg",
                    "_goal : external_call ?ef ge ?vl m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eq (ef_sig (EF_runtime name sg)) sg",
                    "_goal : external_call (EF_runtime name sg) ge ?vl m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (ef_sig (EF_runtime name sg)) sg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le args ?vl",
                    "_goal : external_call (EF_runtime name sg) ge ?vl m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_runtime name sg) ge vargs m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : external_call (EF_runtime name sg) ge vargs m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_runtime name sg) ge vargs m E0 vres m"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : external_call (EF_runtime name sg) ge vargs m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : builtin_or_external_sem name sg ge vargs m E0 vres m"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : builtin_or_external_sem name sg ge vargs m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m E0 vres m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : match lookup_builtin_function name sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem name sg\nend ge vargs m E0 vres m",
                    "H1 : eq (lookup_builtin_function name sg) (Some bf)"
                ],
                "tactic_res": [
                    "_goal : known_builtin_sem bf ge vargs m E0 vres m"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : known_builtin_sem bf ge vargs m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem bf vargs) (Some vres)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem bf vargs) (Some vres)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_helper_1",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (bf : builtin_function) (le : letenv) (id : ident)\n  (name : string) (sg : signature) (arg1 : expr) (varg1 vres : val)\n  (_ : eval_expr ge sp e m le arg1 varg1)\n  (_ : helper_declared prog id name sg)\n  (_ : eq (lookup_builtin_function name sg) (Some bf))\n  (_ : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)),\neval_expr ge sp e m le (Eexternal id sg (Econs arg1 Enil)) vres"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg (Econs arg1 Enil)) vres",
                    "H2 : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)",
                    "H1 : eq (lookup_builtin_function name sg) (Some bf)",
                    "H0 : helper_declared prog id name sg",
                    "H : eval_expr ge sp e m le arg1 varg1",
                    "varg1 : val",
                    "vres : val",
                    "arg1 : expr",
                    "sg : signature",
                    "name : string",
                    "id : ident",
                    "le : letenv",
                    "bf : builtin_function"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper .",
                "tactic_sig_no_out_arg": "eapply eval_helper .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg (Econs arg1 Enil)) vres"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vargs",
                    "_goal : helper_declared prog id ?name sg",
                    "_goal : eq (lookup_builtin_function ?name sg) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf ?vargs) (Some vres)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vargs"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vargs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog id ?name sg",
                    "_goal : eq (lookup_builtin_function ?name sg) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function name sg) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function name sg) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf ?vargs) (Some vres)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem bf ?vargs) (Some vres)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vargs",
                    "_goal : eq (builtin_function_sem bf ?vargs) (Some vres)"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) (cons varg1 nil)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) (cons varg1 nil)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg1 varg1",
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg1 varg1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_helper_2",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (bf : builtin_function) (le : letenv) (id : ident)\n  (name : string) (sg : signature) (arg1 arg2 : expr)\n  (varg1 varg2 vres : val) (_ : eval_expr ge sp e m le arg1 varg1)\n  (_ : eval_expr ge sp e m le arg2 varg2)\n  (_ : helper_declared prog id name sg)\n  (_ : eq (lookup_builtin_function name sg) (Some bf))\n  (_ : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil)))\n         (Some vres)),\neval_expr ge sp e m le (Eexternal id sg (Econs arg1 (Econs arg2 Enil)))\n  vres"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg (Econs arg1 (Econs arg2 Enil)))\n  vres",
                    "H3 : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil))) (Some vres)",
                    "H2 : eq (lookup_builtin_function name sg) (Some bf)",
                    "H1 : helper_declared prog id name sg",
                    "H0 : eval_expr ge sp e m le arg2 varg2",
                    "H : eval_expr ge sp e m le arg1 varg1",
                    "varg1 : val",
                    "varg2 : val",
                    "vres : val",
                    "arg1 : expr",
                    "arg2 : expr",
                    "sg : signature",
                    "name : string",
                    "id : ident",
                    "le : letenv",
                    "bf : builtin_function"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper .",
                "tactic_sig_no_out_arg": "eapply eval_helper .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal id sg (Econs arg1 (Econs arg2 Enil)))\n  vres"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vargs",
                    "_goal : helper_declared prog id ?name sg",
                    "_goal : eq (lookup_builtin_function ?name sg) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf ?vargs) (Some vres)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vargs"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vargs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog id ?name sg",
                    "_goal : eq (lookup_builtin_function ?name sg) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function name sg) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function name sg) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf ?vargs) (Some vres)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem bf ?vargs) (Some vres)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vargs",
                    "_goal : eq (builtin_function_sem bf ?vargs) (Some vres)"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil))\n  (cons varg1 (cons varg2 nil))"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil))\n  (cons varg1 (cons varg2 nil))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg1 varg1",
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) (cons varg2 nil)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg1 varg1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) (cons varg2 nil)"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) (cons varg2 nil)"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) (cons varg2 nil)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg2 varg2",
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg2 varg2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_builtin_1",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (bf : builtin_function) (le : letenv) (id : string)\n  (sg : signature) (arg1 : expr) (varg1 vres : val)\n  (_ : eval_expr ge sp e m le arg1 varg1)\n  (_ : eq (lookup_builtin_function id sg) (Some bf))\n  (_ : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)),\neval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (Econs arg1 Enil))\n  vres"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (Econs arg1 Enil))\n  vres",
                    "H1 : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)",
                    "H0 : eq (lookup_builtin_function id sg) (Some bf)",
                    "H : eval_expr ge sp e m le arg1 varg1",
                    "varg1 : val",
                    "vres : val",
                    "arg1 : expr",
                    "sg : signature",
                    "id : string",
                    "le : letenv",
                    "bf : builtin_function"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Ebuiltin (EF_builtin id sg) (Econs arg1 Enil))\n  vres"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge ?vl m E0 vres m"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 Enil) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge ?vl m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg1 ?v1",
                    "_goal : eval_exprlist ge sp e m le Enil ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons ?v1 ?vl) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg1 ?v1",
                    "_goal : external_call (EF_builtin id sg) ge (cons ?v1 ?vl) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 ?vl) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 ?vl) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 nil) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 nil) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : builtin_or_external_sem id sg ge (cons varg1 nil) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : builtin_or_external_sem id sg ge (cons varg1 nil) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : match lookup_builtin_function id sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem id sg\nend ge (cons varg1 nil) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : match lookup_builtin_function id sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem id sg\nend ge (cons varg1 nil) m E0 vres m",
                    "H0 : eq (lookup_builtin_function id sg) (Some bf)"
                ],
                "tactic_res": [
                    "_goal : known_builtin_sem bf ge (cons varg1 nil) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : known_builtin_sem bf ge (cons varg1 nil) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem bf (cons varg1 nil)) (Some vres)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_builtin_2",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (bf : builtin_function) (le : letenv) (id : string)\n  (sg : signature) (arg1 arg2 : expr) (varg1 varg2 vres : val)\n  (_ : eval_expr ge sp e m le arg1 varg1)\n  (_ : eval_expr ge sp e m le arg2 varg2)\n  (_ : eq (lookup_builtin_function id sg) (Some bf))\n  (_ : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil)))\n         (Some vres)),\neval_expr ge sp e m le\n  (Ebuiltin (EF_builtin id sg) (Econs arg1 (Econs arg2 Enil))) vres"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin id sg) (Econs arg1 (Econs arg2 Enil))) vres",
                    "H2 : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil))) (Some vres)",
                    "H1 : eq (lookup_builtin_function id sg) (Some bf)",
                    "H0 : eval_expr ge sp e m le arg2 varg2",
                    "H : eval_expr ge sp e m le arg1 varg1",
                    "varg1 : val",
                    "varg2 : val",
                    "vres : val",
                    "arg1 : expr",
                    "arg2 : expr",
                    "sg : signature",
                    "id : string",
                    "le : letenv",
                    "bf : builtin_function"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin id sg) (Econs arg1 (Econs arg2 Enil))) vres"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge ?vl m E0 vres m"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg1 (Econs arg2 Enil)) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge ?vl m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg1 ?v1",
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons ?v1 ?vl) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg1 ?v1",
                    "_goal : external_call (EF_builtin id sg) ge (cons ?v1 ?vl) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 ?vl) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) ?vl"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) ?vl"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le (Econs arg2 Enil) ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 ?vl) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le arg2 ?v1",
                    "_goal : eval_exprlist ge sp e m le Enil ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons ?v1 ?vl)) m E0\n  vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le arg2 ?v1",
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons ?v1 ?vl)) m E0\n  vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons varg2 ?vl)) m E0\n  vres m"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil ?vl"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le Enil ?vl"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le Enil ?vl",
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons varg2 ?vl)) m E0\n  vres m"
                ],
                "tactic_res": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons varg2 nil)) m E0\n  vres m"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : external_call (EF_builtin id sg) ge (cons varg1 (cons varg2 nil)) m E0\n  vres m"
                ],
                "tactic_res": [
                    "_goal : builtin_or_external_sem id sg ge (cons varg1 (cons varg2 nil)) m E0\n  vres m"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : builtin_or_external_sem id sg ge (cons varg1 (cons varg2 nil)) m E0\n  vres m"
                ],
                "tactic_res": [
                    "_goal : match lookup_builtin_function id sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem id sg\nend ge (cons varg1 (cons varg2 nil)) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : match lookup_builtin_function id sg with\n| Some bf => known_builtin_sem bf\n| None => external_functions_sem id sg\nend ge (cons varg1 (cons varg2 nil)) m E0 vres m",
                    "H1 : eq (lookup_builtin_function id sg) (Some bf)"
                ],
                "tactic_res": [
                    "_goal : known_builtin_sem bf ge (cons varg1 (cons varg2 nil)) m E0 vres m"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : known_builtin_sem bf ge (cons varg1 (cons varg2 nil)) m E0 vres m"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil))) (Some vres)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem bf (cons varg1 (cons varg2 nil))) (Some vres)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_splitlong",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until sem .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr)\n  (f : forall (_ : expr) (_ : expr), expr) (v : val)\n  (sem : forall _ : val, val)\n  (_ : forall (le0 : letenv) (a0 b : expr) (x y : val)\n         (_ : eval_expr ge sp e m le0 a0 x)\n         (_ : eval_expr ge sp e m le0 b y),\n       ex\n         (fun v0 : val =>\n          Logic.and (eval_expr ge sp e m le0 (f a0 b) v0)\n            (forall (p q : Int.int) (_ : eq x (Vint p))\n               (_ : eq y (Vint q)),\n             eq v0 (sem (Vlong (Int64.ofwords p q))))))\n  (_ : match v with\n       | Vlong _ => True\n       | _ => eq (sem v) Vundef\n       end) (_ : eval_expr ge sp e m le a v),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong a f) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : forall (le : letenv) (a b : expr) (x y : val)\n         (_ : eval_expr ge sp e m le a x)\n         (_ : eval_expr ge sp e m le b y),\n       ex\n         (fun v : val =>\n          Logic.and (eval_expr ge sp e m le (f a b) v)\n            (forall (p q : Int.int) (_ : eq x (Vint p))\n               (_ : eq y (Vint q)),\n             eq v (sem (Vlong (Int64.ofwords p q))))))\n  (_ : match v with\n       | Vlong _ => True\n       | _ => eq (sem v) Vundef\n       end) (_ : eval_expr ge sp e m le a v),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong a f) v')\n     (Val.lessdef (sem v) v'))",
                    "sem : forall _ : val, val",
                    "v : val",
                    "f : forall (_ : expr) (_ : expr), expr",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros EXEC UNDEF .",
                "tactic_args": [
                    "_goal : forall\n  (_ : forall (le : letenv) (a b : expr) (x y : val)\n         (_ : eval_expr ge sp e m le a x)\n         (_ : eval_expr ge sp e m le b y),\n       ex\n         (fun v : val =>\n          Logic.and (eval_expr ge sp e m le (f a b) v)\n            (forall (p q : Int.int) (_ : eq x (Vint p))\n               (_ : eq y (Vint q)),\n             eq v (sem (Vlong (Int64.ofwords p q))))))\n  (_ : match v with\n       | Vlong _ => True\n       | _ => eq (sem v) Vundef\n       end) (_ : eval_expr ge sp e m le a v),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong a f) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a v,\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong a f) v')\n     (Val.lessdef (sem v) v'))",
                    "UNDEF : match v with\n| Vlong _ => True\n| _ => eq (sem v) Vundef\nend",
                    "EXEC : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a b) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (sem (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "unfold splitlong .",
                "tactic_sig_no_out_arg": "unfold splitlong .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a v,\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong a f) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a v,\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match splitlong_match a with\n        | splitlong_case1 h l => f h l\n        | splitlong_default e =>\n            Elet e\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)))\n        end v') (Val.lessdef (sem v) v'))"
                ]
            },
            {
                "tactic_sig": "case ( splitlong_match _i ) .",
                "tactic_sig_no_out_arg": "case ( splitlong_match _i ) .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a v,\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match splitlong_match a with\n        | splitlong_case1 h l => f h l\n        | splitlong_default e =>\n            Elet e\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)))\n        end v') (Val.lessdef (sem v) v'))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall (h l : expr)\n  (_ : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil)))\n         v),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem v) v'))",
                    "_goal : forall (e0 : expr) (_ : eval_expr ge sp e m le e0 v),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h l : expr)\n  (_ : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil)))\n         v),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem v) v'))",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil))) v",
                    "h : expr",
                    "l : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (e0 : expr) (_ : eval_expr ge sp e m le e0 v),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))",
                    "H : eval_expr ge sp e m le e0 v",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) v",
                    "H3 : eval_expr ge sp e m le l v0",
                    "H2 : eval_expr ge sp e m le h v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords v1 v0)) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "EXEC : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a b) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (sem (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal3",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal2 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (f ?Goal1 ?Goal2) v)\n           (forall (p q : Int.int) (_ : eq ?Goal3 (Vint p))\n              (_ : eq ?Goal4 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal3",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal2 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (f ?Goal1 ?Goal2) v)\n           (forall (p q : Int.int) (_ : eq ?Goal3 (Vint p))\n              (_ : eq ?Goal4 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "H2 : eval_expr ge sp e m le h v1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h ?Goal0) v)\n           (forall (p q : Int.int) (_ : eq v1 (Vint p))\n              (_ : eq ?Goal1 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h ?Goal0) v)\n           (forall (p q : Int.int) (_ : eq v1 (Vint p))\n              (_ : eq ?Goal1 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "H3 : eval_expr ge sp e m le l v0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h l) v)\n           (forall (p q : Int.int) (_ : eq v1 (Vint p))\n              (_ : eq v0 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v' [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h l) v)\n           (forall (p q : Int.int) (_ : eq v1 (Vint p))\n              (_ : eq v0 (Vint q)),\n            eq v (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "B : forall (p q : Int.int) (_ : eq v1 (Vint p)) (_ : eq v0 (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m le (f h l) v'",
                    "v' : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and (eval_expr ge sp e m le (f h l) v')\n     (Val.lessdef (sem (Val.longofwords v1 v0)) v'))",
                    "v' : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (f h l) v')\n  (Val.lessdef (sem (Val.longofwords v1 v0)) v')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (f h l) v')\n  (Val.lessdef (sem (Val.longofwords v1 v0)) v')"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h l) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0)) v'"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h l) v'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0)) v'",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0)) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0)) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vlong i) v0)) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vfloat f0) v0)) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vsingle f0) v0)) v'",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vptr b i) v0)) v'",
                    "B : forall (p q : Int.int) (_ : eq Vundef (Vint p)) (_ : eq v0 (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h Vundef",
                    "UNDEF : match Val.longofwords Vundef v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords Vundef v0)) Vundef\nend",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p)) (_ : eq v0 (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h (Vint i)",
                    "UNDEF : match Val.longofwords (Vint i) v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords (Vint i) v0)) Vundef\nend",
                    "i : Int.int",
                    "B : forall (p q : Int.int) (_ : eq (Vlong i) (Vint p)) (_ : eq v0 (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h (Vlong i)",
                    "UNDEF : match Val.longofwords (Vlong i) v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords (Vlong i) v0)) Vundef\nend",
                    "i : Int64.int",
                    "B : forall (p q : Int.int) (_ : eq (Vfloat f0) (Vint p))\n  (_ : eq v0 (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h (Vfloat f0)",
                    "UNDEF : match Val.longofwords (Vfloat f0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords (Vfloat f0) v0)) Vundef\nend",
                    "f0 : float",
                    "B : forall (p q : Int.int) (_ : eq (Vsingle f0) (Vint p))\n  (_ : eq v0 (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h (Vsingle f0)",
                    "UNDEF : match Val.longofwords (Vsingle f0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords (Vsingle f0) v0)) Vundef\nend",
                    "f0 : float32",
                    "B : forall (p q : Int.int) (_ : eq (Vptr b i) (Vint p))\n  (_ : eq v0 (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H2 : eval_expr ge sp e m le h (Vptr b i)",
                    "UNDEF : match Val.longofwords (Vptr b i) v0 with\n| Vlong _ => True\n| _ => eq (sem (Val.longofwords (Vptr b i) v0)) Vundef\nend",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vlong i) v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vfloat f0) v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vsingle f0) v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vptr b i) v0)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v'",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'",
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq Vundef (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l Vundef",
                    "UNDEF : eq (sem Vundef) Vundef",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vint i0) (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l (Vint i0)",
                    "UNDEF : True",
                    "i0 : Int.int",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vlong i0) (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l (Vlong i0)",
                    "i0 : Int64.int",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vfloat f0) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l (Vfloat f0)",
                    "f0 : float",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vsingle f0) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l (Vsingle f0)",
                    "f0 : float32",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vptr b i0) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "H3 : eval_expr ge sp e m le l (Vptr b i0)",
                    "i0 : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : eq (sem Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0))) v'",
                    "B : forall (p q : Int.int) (_ : eq (Vint i) (Vint p))\n  (_ : eq (Vint i0) (Vint q)), eq v' (sem (Vlong (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)))\n  (sem (Vlong (Int64.ofwords ?p ?q)))",
                    "_goal : eq (Vint i) (Vint ?p)",
                    "_goal : eq (Vint i0) (Vint ?q)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)))\n  (sem (Vlong (Int64.ofwords ?p ?q)))",
                    "_goal : eq (Vint i) (Vint ?p)",
                    "_goal : eq (Vint i0) (Vint ?q)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint i) (Vint i)",
                    "_goal : eq (Vint i0) (Vint i0)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i) (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i0) (Vint i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( _i ( _i : : _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_sig_no_out_arg": "exploit ( _i ( _i : : _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))",
                    "EXEC : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a b) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (sem (Vlong (Int64.ofwords p q)))))",
                    "v : val",
                    "le : letenv"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons v le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal",
                    "_goal : eval_expr ge sp e m (cons v le) (Eop Olowlong (Econs (Eletvar 0) Enil))\n  ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq ?Goal (Vint p))\n              (_ : eq ?Goal0 (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons v le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal",
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq ?Goal (Vint p))\n              (_ : eq ?Goal0 (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq (Val.hiword v) (Vint p))\n              (_ : eq ?Goal (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons v le) (Eop Olowlong (Econs (Eletvar 0) Enil))\n  ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq (Val.hiword v) (Vint p))\n              (_ : eq ?Goal (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq (Val.hiword v) (Vint p))\n              (_ : eq (Val.loword v) (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v' [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v0 : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v0)\n           (forall (p q : Int.int) (_ : eq (Val.hiword v) (Vint p))\n              (_ : eq (Val.loword v) (Vint q)),\n            eq v0 (sem (Vlong (Int64.ofwords p q))))),\nex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword v) (Vint p))\n  (_ : eq (Val.loword v) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons v le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "v' : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v' : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n     (Val.lessdef (sem v) v'))",
                    "v' : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e0\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n  (Val.lessdef (sem v) v')"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e0\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))) v')\n  (Val.lessdef (sem v) v')"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v'",
                    "_goal : Val.lessdef (sem v) v'"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v'"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le e0 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le e0 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons v le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons v le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem v) v'",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "_goal : Val.lessdef (sem (Vint i)) v'",
                    "_goal : Val.lessdef (sem (Vlong i)) v'",
                    "_goal : Val.lessdef (sem (Vfloat f0)) v'",
                    "_goal : Val.lessdef (sem (Vsingle f0)) v'",
                    "_goal : Val.lessdef (sem (Vptr b i)) v'",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword Vundef) (Vint p))\n  (_ : eq (Val.loword Vundef) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons Vundef le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 Vundef",
                    "UNDEF : eq (sem Vundef) Vundef",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vint i)) (Vint p))\n  (_ : eq (Val.loword (Vint i)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons (Vint i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 (Vint i)",
                    "UNDEF : eq (sem (Vint i)) Vundef",
                    "i : Int.int",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vlong i)) (Vint p))\n  (_ : eq (Val.loword (Vlong i)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons (Vlong i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 (Vlong i)",
                    "UNDEF : True",
                    "i : Int64.int",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vfloat f0)) (Vint p))\n  (_ : eq (Val.loword (Vfloat f0)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons (Vfloat f0) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 (Vfloat f0)",
                    "UNDEF : eq (sem (Vfloat f0)) Vundef",
                    "f0 : float",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vsingle f0)) (Vint p))\n  (_ : eq (Val.loword (Vsingle f0)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons (Vsingle f0) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 (Vsingle f0)",
                    "UNDEF : eq (sem (Vsingle f0)) Vundef",
                    "f0 : float32",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vptr b i)) (Vint p))\n  (_ : eq (Val.loword (Vptr b i)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m (cons (Vptr b i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v'",
                    "H : eval_expr ge sp e m le e0 (Vptr b i)",
                    "UNDEF : eq (sem (Vptr b i)) Vundef",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef) v'",
                    "UNDEF : eq (sem Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vint i)) v'",
                    "UNDEF : eq (sem (Vint i)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) v'"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i)) v'"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vfloat f0)) v'",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vsingle f0)) v'",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vptr b i)) v'",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) v'",
                    "B : forall (p q : Int.int) (_ : eq (Val.hiword (Vlong i)) (Vint p))\n  (_ : eq (Val.loword (Vlong i)) (Vint q)),\neq v' (sem (Vlong (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))",
                    "_goal : eq (Val.hiword (Vlong i)) (Vint ?p)",
                    "_goal : eq (Val.loword (Vlong i)) (Vint ?q)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.hiword (Vlong i)) (Vint ?p)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong (Int64.ofwords ?p ?q)))",
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?q)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.loword (Vlong i)) (Vint ?q)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?q)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?q)))",
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?q)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i)) (sem (Vlong i))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_splitlong_strict",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until v .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr)\n  (f : forall (_ : expr) (_ : expr), expr) (va : Int64.int) \n  (v : val) (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : forall (le0 : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le0 (f a1 a2) v),\neval_expr ge sp e m le (splitlong a f) v"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le (splitlong a f) v",
                    "v : val",
                    "va : Int64.int",
                    "f : forall (_ : expr) (_ : expr), expr",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold splitlong .",
                "tactic_sig_no_out_arg": "unfold splitlong .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le (splitlong a f) v"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le\n  match splitlong_match a with\n  | splitlong_case1 h l => f h l\n  | splitlong_default e =>\n      Elet e\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))\n  end v"
                ]
            },
            {
                "tactic_sig": "case ( splitlong_match _i ) .",
                "tactic_sig_no_out_arg": "case ( splitlong_match _i ) .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le\n  match splitlong_match a with\n  | splitlong_case1 h l => f h l\n  | splitlong_default e =>\n      Elet e\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))\n  end v",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall (h l : expr)\n  (_ : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil)))\n         (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le (f h l) v",
                    "_goal : forall (e0 : expr) (_ : eval_expr ge sp e m le e0 (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h l : expr)\n  (_ : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil)))\n         (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le (f h l) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h l) v",
                    "H0 : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\neval_expr ge sp e m le (f a1 a2) v",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs h (Econs l Enil)))\n  (Vlong va)",
                    "h : expr",
                    "l : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (e0 : expr) (_ : eval_expr ge sp e m le e0 (Vlong va))\n  (_ : forall (le : letenv) (a1 a2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\n       eval_expr ge sp e m le (f a1 a2) v),\neval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "H : eval_expr ge sp e m le e0 (Vlong va)",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) (Vlong va)",
                    "H4 : eval_expr ge sp e m le l v0",
                    "H3 : eval_expr ge sp e m le h v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "v1 : val"
                ],
                "tactic_res": [
                    "H : eq (Val.longofwords Vundef v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h Vundef",
                    "H : eq (Val.longofwords (Vint i) v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h (Vint i)",
                    "i : Int.int",
                    "H : eq (Val.longofwords (Vlong i) v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h (Vlong i)",
                    "i : Int64.int",
                    "H : eq (Val.longofwords (Vfloat f0) v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h (Vfloat f0)",
                    "f0 : float",
                    "H : eq (Val.longofwords (Vsingle f0) v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h (Vsingle f0)",
                    "f0 : float32",
                    "H : eq (Val.longofwords (Vptr b i) v0) (Vlong va)",
                    "H3 : eval_expr ge sp e m le h (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq (Val.longofwords Vundef v0) (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq (Val.longofwords (Vint i) v0) (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h l) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h l) v"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong va)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "v0 : val"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong va)",
                    "H4 : eval_expr ge sp e m le l Vundef",
                    "H : eq (Vlong (Int64.ofwords i i0)) (Vlong va)",
                    "H4 : eval_expr ge sp e m le l (Vint i0)",
                    "i0 : Int.int",
                    "H4 : eval_expr ge sp e m le l (Vlong i0)",
                    "i0 : Int64.int",
                    "H4 : eval_expr ge sp e m le l (Vfloat f0)",
                    "f0 : float",
                    "H4 : eval_expr ge sp e m le l (Vsingle f0)",
                    "f0 : float32",
                    "H4 : eval_expr ge sp e m le l (Vptr b i0)",
                    "i0 : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq Vundef (Vlong va)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq (Vlong (Int64.ofwords i i0)) (Vlong va)"
                ],
                "tactic_res": [
                    "H0 : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1\n         (Vint (Int64.hiword (Int64.ofwords i i0))))\n  (_ : eval_expr ge sp e m le a2\n         (Vint (Int64.loword (Int64.ofwords i i0)))),\neval_expr ge sp e m le (f a1 a2) v"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq Vundef (Vlong va)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq Vundef (Vlong va)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq Vundef (Vlong va)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H : eq Vundef (Vlong va)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h l) v",
                    "H0 : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1\n         (Vint (Int64.hiword (Int64.ofwords i i0))))\n  (_ : eval_expr ge sp e m le a2\n         (Vint (Int64.loword (Int64.ofwords i i0)))),\neval_expr ge sp e m le (f a1 a2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le h (Vint (Int64.hiword (Int64.ofwords i i0)))",
                    "_goal : eval_expr ge sp e m le l (Vint (Int64.loword (Int64.ofwords i i0)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.hi_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.hi_ofwords .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le h (Vint (Int64.hiword (Int64.ofwords i i0)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le h (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le h (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.lo_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.lo_ofwords .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le l (Vint (Int64.loword (Int64.ofwords i i0)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le l (Vint i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le l (Vint i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va))),\neval_expr ge sp e m le (f a1 a2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword va))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword va))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_splitlong2",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until sem .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr)\n  (f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr)\n  (va vb : val) (sem : forall (_ : val) (_ : val), val)\n  (_ : forall (le0 : letenv) (a1 a2 b1 b2 : expr) \n         (x1 x2 y1 y2 : val) (_ : eval_expr ge sp e m le0 a1 x1)\n         (_ : eval_expr ge sp e m le0 a2 x2)\n         (_ : eval_expr ge sp e m le0 b1 y1)\n         (_ : eval_expr ge sp e m le0 b2 y2),\n       ex\n         (fun v : val =>\n          Logic.and (eval_expr ge sp e m le0 (f a1 a2 b1 b2) v)\n            (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n               (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n               (_ : eq y2 (Vint q2)),\n             eq v\n               (sem (Vlong (Int64.ofwords p1 p2))\n                  (Vlong (Int64.ofwords q1 q2))))))\n  (_ : match va with\n       | Vlong _ =>\n           match vb with\n           | Vlong _ => True\n           | _ => eq (sem va vb) Vundef\n           end\n       | _ => eq (sem va vb) Vundef\n       end) (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong2 a b f) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n         (_ : eval_expr ge sp e m le a1 x1)\n         (_ : eval_expr ge sp e m le a2 x2)\n         (_ : eval_expr ge sp e m le b1 y1)\n         (_ : eval_expr ge sp e m le b2 y2),\n       ex\n         (fun v : val =>\n          Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n            (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n               (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n               (_ : eq y2 (Vint q2)),\n             eq v\n               (sem (Vlong (Int64.ofwords p1 p2))\n                  (Vlong (Int64.ofwords q1 q2))))))\n  (_ : match va with\n       | Vlong _ =>\n           match vb with\n           | Vlong _ => True\n           | _ => eq (sem va vb) Vundef\n           end\n       | _ => eq (sem va vb) Vundef\n       end) (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong2 a b f) v)\n     (Val.lessdef (sem va vb) v))",
                    "sem : forall (_ : val) (_ : val), val",
                    "va : val",
                    "vb : val",
                    "f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros EXEC UNDEF .",
                "tactic_args": [
                    "_goal : forall\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n         (_ : eval_expr ge sp e m le a1 x1)\n         (_ : eval_expr ge sp e m le a2 x2)\n         (_ : eval_expr ge sp e m le b1 y1)\n         (_ : eval_expr ge sp e m le b2 y2),\n       ex\n         (fun v : val =>\n          Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n            (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n               (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n               (_ : eq y2 (Vint q2)),\n             eq v\n               (sem (Vlong (Int64.ofwords p1 p2))\n                  (Vlong (Int64.ofwords q1 q2))))))\n  (_ : match va with\n       | Vlong _ =>\n           match vb with\n           | Vlong _ => True\n           | _ => eq (sem va vb) Vundef\n           end\n       | _ => eq (sem va vb) Vundef\n       end) (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong2 a b f) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong2 a b f) v)\n     (Val.lessdef (sem va vb) v))",
                    "UNDEF : match va with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem va vb) Vundef\n    end\n| _ => eq (sem va vb) Vundef\nend",
                    "EXEC : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (sem (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "unfold splitlong2 .",
                "tactic_sig_no_out_arg": "unfold splitlong2 .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (splitlong2 a b f) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match splitlong2_match a b with\n        | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n        | splitlong2_case2 h1 l1 t2 =>\n            Elet t2\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)))\n        | splitlong2_case3 t1 h2 l2 =>\n            Elet t1\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2))\n        | splitlong2_default e1 e2 =>\n            Elet e1\n              (Elet (lift e2)\n                 (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                    (Eop Olowlong (Econs (Eletvar 1) Enil))\n                    (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (Eop Olowlong (Econs (Eletvar 0) Enil))))\n        end v) (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "case ( splitlong2_match _i _i ) .",
                "tactic_sig_no_out_arg": "case ( splitlong2_match _i _i ) .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a va)\n  (_ : eval_expr ge sp e m le b vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match splitlong2_match a b with\n        | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n        | splitlong2_case2 h1 l1 t2 =>\n            Elet t2\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)))\n        | splitlong2_case3 t1 h2 l2 =>\n            Elet t1\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2))\n        | splitlong2_default e1 e2 =>\n            Elet e1\n              (Elet (lift e2)\n                 (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                    (Eop Olowlong (Econs (Eletvar 1) Enil))\n                    (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (Eop Olowlong (Econs (Eletvar 0) Enil))))\n        end v) (Val.lessdef (sem va vb) v))",
                    "a : expr",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : forall (h1 l1 h2 l2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) va)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem va vb) v))",
                    "_goal : forall (h1 l1 t2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) va)\n  (_ : eval_expr ge sp e m le t2 vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem va vb) v))",
                    "_goal : forall (t1 h2 l2 : expr) (_ : eval_expr ge sp e m le t1 va)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v) (Val.lessdef (sem va vb) v))",
                    "_goal : forall (e1 e2 : expr) (_ : eval_expr ge sp e m le e1 va)\n  (_ : eval_expr ge sp e m le e2 vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h1 l1 h2 l2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) va)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) vb),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem va vb) v))",
                    "H0 : eval_expr ge sp e m le (Eop Omakelong (Econs h2 (Econs l2 Enil))) vb",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs h1 (Econs l1 Enil))) va",
                    "h1 : expr",
                    "l1 : expr",
                    "h2 : expr",
                    "l2 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h1 l1 t2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) va)\n  (_ : eval_expr ge sp e m le t2 vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem va vb) v))",
                    "H0 : eval_expr ge sp e m le t2 vb",
                    "t2 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (t1 h2 l2 : expr) (_ : eval_expr ge sp e m le t1 va)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v) (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v) (Val.lessdef (sem va vb) v))",
                    "H : eval_expr ge sp e m le t1 va",
                    "t1 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (e1 e2 : expr) (_ : eval_expr ge sp e m le e1 va)\n  (_ : eval_expr ge sp e m le e2 vb),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))",
                    "H0 : eval_expr ge sp e m le e2 vb",
                    "H : eval_expr ge sp e m le e1 va",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (Val.longofwords v2 v3) vb",
                    "H : eq (Val.longofwords v1 v0) va",
                    "H4 : eval_expr ge sp e m le l2 v3",
                    "H5 : eval_expr ge sp e m le h2 v2",
                    "H3 : eval_expr ge sp e m le l1 v0",
                    "H2 : eval_expr ge sp e m le h1 v1",
                    "v2 : val",
                    "v3 : val",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) Vundef\n    end\n| _ => eq (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "exploit ( _i _i _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( _i _i _i _i _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))",
                    "EXEC : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (sem (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "le : letenv",
                    "h1 : expr",
                    "l1 : expr",
                    "h2 : expr",
                    "l2 : expr"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le h1 ?Goal2",
                    "_goal : eval_expr ge sp e m le l1 ?Goal3",
                    "_goal : eval_expr ge sp e m le h2 ?Goal4",
                    "_goal : eval_expr ge sp e m le l2 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal2 (Vint p1))\n              (_ : eq ?Goal3 (Vint p2)) (_ : eq ?Goal4 (Vint q1))\n              (_ : eq ?Goal5 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le h1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal2 (Vint p1))\n              (_ : eq ?Goal3 (Vint p2)) (_ : eq ?Goal4 (Vint q1))\n              (_ : eq ?Goal5 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq ?Goal2 (Vint p2)) (_ : eq ?Goal3 (Vint q1))\n              (_ : eq ?Goal4 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le l1 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq ?Goal2 (Vint p2)) (_ : eq ?Goal3 (Vint q1))\n              (_ : eq ?Goal4 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le h2 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le l2 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq v3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq v3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq v3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1))\n              (_ : eq v3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3))\n        v))",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n  (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (f h1 l1 h2 l2) v)\n  (Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) (Val.longofwords v2 v3)) v",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0) (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0) (Val.longofwords v2 v3))\n  v",
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vlong i) v0) (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vfloat f0) v0) (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vsingle f0) v0) (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vptr b0 i) v0) (Val.longofwords v2 v3)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq Vundef (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 Vundef",
                    "UNDEF : match Val.longofwords Vundef v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq (sem (Val.longofwords Vundef v0) (Val.longofwords v2 v3))\n          Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords Vundef v0) (Val.longofwords v2 v3)) Vundef\nend",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 (Vint i)",
                    "UNDEF : match Val.longofwords (Vint i) v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq (sem (Val.longofwords (Vint i) v0) (Val.longofwords v2 v3))\n          Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords (Vint i) v0) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "i : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vlong i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 (Vlong i)",
                    "UNDEF : match Val.longofwords (Vlong i) v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq (sem (Val.longofwords (Vlong i) v0) (Val.longofwords v2 v3))\n          Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords (Vlong i) v0) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "i : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vfloat f0) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 (Vfloat f0)",
                    "UNDEF : match Val.longofwords (Vfloat f0) v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem (Val.longofwords (Vfloat f0) v0) (Val.longofwords v2 v3))\n          Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords (Vfloat f0) v0) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vsingle f0) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 (Vsingle f0)",
                    "UNDEF : match Val.longofwords (Vsingle f0) v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem (Val.longofwords (Vsingle f0) v0)\n             (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords (Vsingle f0) v0) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vptr b0 i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq v2 (Vint q1)) (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H2 : eval_expr ge sp e m le h1 (Vptr b0 i)",
                    "UNDEF : match Val.longofwords (Vptr b0 i) v0 with\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem (Val.longofwords (Vptr b0 i) v0) (Val.longofwords v2 v3))\n          Vundef\n    end\n| _ =>\n    eq (sem (Val.longofwords (Vptr b0 i) v0) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0) (Val.longofwords v2 v3))\n  v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end (Val.longofwords v2 v3)) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vlong i) v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end (Val.longofwords v2 v3)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vfloat f0) v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end (Val.longofwords v2 v3)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vsingle f0) v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end (Val.longofwords v2 v3)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Val.longofwords (Vptr b0 i) v0) (Val.longofwords v2 v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match Val.longofwords v2 v3 with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end (Val.longofwords v2 v3)) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end (Val.longofwords v2 v3)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end (Val.longofwords v2 v3)) v",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n  v",
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq Vundef (Vint p2)) (_ : eq v2 (Vint q1)) \n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 Vundef",
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq v2 (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 (Vint i0)",
                    "UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n      Vundef\nend",
                    "i0 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vlong i0) (Vint p2)) (_ : eq v2 (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 (Vlong i0)",
                    "i0 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vfloat f0) (Vint p2)) (_ : eq v2 (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 (Vfloat f0)",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vsingle f0) (Vint p2)) (_ : eq v2 (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 (Vsingle f0)",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vptr b0 i0) (Vint p2)) (_ : eq v2 (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le l1 (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : eq (sem Vundef (Val.longofwords v2 v3)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n  v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n  v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n      Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n      Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n      Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v2 v3)) v",
                    "UNDEF : match Val.longofwords v2 v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n      Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords v2 v3))\n  v",
                    "v2 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords Vundef v3)) v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vint i1) v3)) v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vlong i1) v3)) v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vfloat f0) v3)) v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vsingle f0) v3))\n  v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vptr b0 i1) v3))\n  v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq Vundef (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 Vundef",
                    "UNDEF : match Val.longofwords Vundef v3 with\n| Vlong _ => True\n| _ =>\n    eq (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords Vundef v3))\n      Vundef\nend",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 (Vint i1)",
                    "UNDEF : match Val.longofwords (Vint i1) v3 with\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vint i1) v3))\n      Vundef\nend",
                    "i1 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vlong i1) (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 (Vlong i1)",
                    "UNDEF : match Val.longofwords (Vlong i1) v3 with\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vlong i1) v3))\n      Vundef\nend",
                    "i1 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vfloat f0) (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 (Vfloat f0)",
                    "UNDEF : match Val.longofwords (Vfloat f0) v3 with\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         (Val.longofwords (Vfloat f0) v3)) Vundef\nend",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vsingle f0) (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 (Vsingle f0)",
                    "UNDEF : match Val.longofwords (Vsingle f0) v3 with\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         (Val.longofwords (Vsingle f0) v3)) Vundef\nend",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vptr b0 i1) (Vint q1))\n  (_ : eq v3 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H5 : eval_expr ge sp e m le h2 (Vptr b0 i1)",
                    "UNDEF : match Val.longofwords (Vptr b0 i1) v3 with\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         (Val.longofwords (Vptr b0 i1) v3)) Vundef\nend",
                    "i1 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords Vundef v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vint i1) v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v",
                    "UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         match v3 with\n         | Vint n2 => Vlong (Int64.ofwords i1 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vlong i1) v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         match v3 with\n         | Vint n2 => Vlong (Int64.ofwords i1 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vfloat f0) v3)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         match v3 with\n         | Vint n2 => Vlong (Int64.ofwords i1 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vsingle f0) v3))\n  v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         match v3 with\n         | Vint n2 => Vlong (Int64.ofwords i1 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Val.longofwords (Vptr b0 i1) v3))\n  v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : match\n  match v3 with\n  | Vint n2 => Vlong (Int64.ofwords i1 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong (Int64.ofwords i i0))\n         match v3 with\n         | Vint n2 => Vlong (Int64.ofwords i1 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0))\n     match v3 with\n     | Vint n2 => Vlong (Int64.ofwords i1 n2)\n     | _ => Vundef\n     end) v",
                    "v3 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2))) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq Vundef (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 Vundef",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vint i2) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vint i2)",
                    "UNDEF : True",
                    "i2 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vlong i2) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vlong i2)",
                    "i2 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vfloat f0) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vfloat f0)",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vsingle f0) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vsingle f0)",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vptr b0 i2) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vptr b0 i2)",
                    "i2 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2))) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2))) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2))) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Vint i1) (Vint q1))\n  (_ : eq (Vint i2) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i) (Vint ?p1)",
                    "_goal : eq (Vint i0) (Vint ?p2)",
                    "_goal : eq (Vint i1) (Vint ?q1)",
                    "_goal : eq (Vint i2) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords i1 i2)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i) (Vint ?p1)",
                    "_goal : eq (Vint i0) (Vint ?p2)",
                    "_goal : eq (Vint i1) (Vint ?q1)",
                    "_goal : eq (Vint i2) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint i) (Vint i)",
                    "_goal : eq (Vint i0) (Vint i0)",
                    "_goal : eq (Vint i1) (Vint i1)",
                    "_goal : eq (Vint i2) (Vint i2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i) (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i0) (Vint i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i1) (Vint i1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Vint i2) (Vint i2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) va",
                    "H4 : eval_expr ge sp e m le l1 v0",
                    "H3 : eval_expr ge sp e m le h1 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords v1 v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords v1 v0) vb) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "exploit ( _i ( _i : : _i ) ( lift _i ) ( lift _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_sig_no_out_arg": "exploit ( _i ( _i : : _i ) ( lift _i ) ( lift _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))",
                    "EXEC : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (sem (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "vb : val",
                    "le : letenv",
                    "h1 : expr",
                    "l1 : expr"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons vb le) (lift h1) ?Goal1",
                    "_goal : eval_expr ge sp e m (cons vb le) (lift l1) ?Goal2",
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal3",
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal1 (Vint p1))\n              (_ : eq ?Goal2 (Vint p2)) (_ : eq ?Goal3 (Vint q1))\n              (_ : eq ?Goal4 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb le) (lift h1) ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal1 (Vint p1))\n              (_ : eq ?Goal2 (Vint p2)) (_ : eq ?Goal3 (Vint q1))\n              (_ : eq ?Goal4 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq ?Goal1 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb le) (lift l1) ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq ?Goal1 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq (Val.loword vb) (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb le)\n              (f (lift h1) (lift l1)\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n              (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq (Val.loword vb) (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq v1 (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t2\n           (f (lift h1) (lift l1)\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (Val.lessdef (sem (Val.longofwords v1 v0) vb) v))",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n  (Val.lessdef (sem (Val.longofwords v1 v0) vb) v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n  (Val.lessdef (sem (Val.longofwords v1 v0) vb) v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) vb) v"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le t2 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le t2 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords v1 v0) vb) v",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0) vb) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0) vb) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vlong i) v0) vb) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vfloat f0) v0) vb) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vsingle f0) v0) vb) v",
                    "_goal : Val.lessdef (sem (Val.longofwords (Vptr b0 i) v0) vb) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq Vundef (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 Vundef",
                    "UNDEF : match Val.longofwords Vundef v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords Vundef v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords Vundef v0) vb) Vundef\nend",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 (Vint i)",
                    "UNDEF : match Val.longofwords (Vint i) v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords (Vint i) v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords (Vint i) v0) vb) Vundef\nend",
                    "i : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vlong i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 (Vlong i)",
                    "UNDEF : match Val.longofwords (Vlong i) v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords (Vlong i) v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords (Vlong i) v0) vb) Vundef\nend",
                    "i : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vfloat f0) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 (Vfloat f0)",
                    "UNDEF : match Val.longofwords (Vfloat f0) v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords (Vfloat f0) v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords (Vfloat f0) v0) vb) Vundef\nend",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vsingle f0) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 (Vsingle f0)",
                    "UNDEF : match Val.longofwords (Vsingle f0) v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords (Vsingle f0) v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords (Vsingle f0) v0) vb) Vundef\nend",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vptr b0 i) (Vint p1))\n  (_ : eq v0 (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h1 (Vptr b0 i)",
                    "UNDEF : match Val.longofwords (Vptr b0 i) v0 with\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ => eq (sem (Val.longofwords (Vptr b0 i) v0) vb) Vundef\n    end\n| _ => eq (sem (Val.longofwords (Vptr b0 i) v0) vb) Vundef\nend",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords Vundef v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vint i) v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end vb) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end vb) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vlong i) v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end vb) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vfloat f0) v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end vb) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vsingle f0) v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end vb) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Val.longofwords (Vptr b0 i) v0) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ =>\n    match vb with\n    | Vlong _ => True\n    | _ =>\n        eq\n          (sem\n             match v0 with\n             | Vint n2 => Vlong (Int64.ofwords i n2)\n             | _ => Vundef\n             end vb) Vundef\n    end\n| _ =>\n    eq\n      (sem\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i n2)\n         | _ => Vundef\n         end vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end vb) v",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v",
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq Vundef (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 Vundef",
                    "UNDEF : eq (sem Vundef vb) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 (Vint i0)",
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong (Int64.ofwords i i0)) vb) Vundef\nend",
                    "i0 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vlong i0) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 (Vlong i0)",
                    "i0 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vfloat f0) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 (Vfloat f0)",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vsingle f0) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 (Vsingle f0)",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vptr b0 i0) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l1 (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong (Int64.ofwords i i0)) vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong (Int64.ofwords i i0)) vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong (Int64.ofwords i i0)) vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong (Int64.ofwords i i0)) vb) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) vb) v",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vint i1)) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vfloat f0)) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vsingle f0)) v",
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vptr b0 i1)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2)) (_ : eq (Val.hiword Vundef) (Vint q1))\n  (_ : eq (Val.loword Vundef) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons Vundef le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 Vundef",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vint i1)) (Vint q1))\n  (_ : eq (Val.loword (Vint i1)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vint i1) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vint i1)",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) (Vint i1)) Vundef",
                    "i1 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vlong i1)) (Vint q1))\n  (_ : eq (Val.loword (Vlong i1)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vlong i1) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vlong i1)",
                    "UNDEF : True",
                    "i1 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vfloat f0)) (Vint q1))\n  (_ : eq (Val.loword (Vfloat f0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vfloat f0) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vfloat f0)",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) (Vfloat f0)) Vundef",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vsingle f0)) (Vint q1))\n  (_ : eq (Val.loword (Vsingle f0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vsingle f0) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vsingle f0)",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) (Vsingle f0)) Vundef",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vptr b0 i1)) (Vint q1))\n  (_ : eq (Val.loword (Vptr b0 i1)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vptr b0 i1) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vptr b0 i1)",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) (Vptr b0 i1)) Vundef",
                    "i1 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) Vundef) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vint i1)) v",
                    "UNDEF : eq (sem (Vlong (Int64.ofwords i i0)) (Vint i1)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vfloat f0)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vsingle f0)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vptr b0 i1)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Vint i) (Vint p1))\n  (_ : eq (Vint i0) (Vint p2))\n  (_ : eq (Val.hiword (Vlong i1)) (Vint q1))\n  (_ : eq (Val.loword (Vlong i1)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i) (Vint ?p1)",
                    "_goal : eq (Vint i0) (Vint ?p2)",
                    "_goal : eq (Val.hiword (Vlong i1)) (Vint ?q1)",
                    "_goal : eq (Val.loword (Vlong i1)) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i) (Vint ?p1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i0) (Vint ?p2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.hiword (Vlong i1)) (Vint ?q1)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.hiword i1)) (Vint ?q1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.hiword i1)) (Vint ?q1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.loword (Vlong i1)) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.loword i1)) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) ?q2)))",
                    "_goal : eq (Vint (Int64.loword i1)) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) (Int64.loword i1))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0))\n     (Vlong (Int64.ofwords (Int64.hiword i1) (Int64.loword i1))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))\n  (sem (Vlong (Int64.ofwords i i0)) (Vlong i1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (Val.longofwords v1 v0) vb",
                    "H4 : eval_expr ge sp e m le l2 v0",
                    "H3 : eval_expr ge sp e m le h2 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v) (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))",
                    "UNDEF : match va with\n| Vlong _ =>\n    match Val.longofwords v1 v0 with\n    | Vlong _ => True\n    | _ => eq (sem va (Val.longofwords v1 v0)) Vundef\n    end\n| _ => eq (sem va (Val.longofwords v1 v0)) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "exploit ( _i ( _i : : _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ( lift _i ) ( lift _i ) ) .",
                "tactic_sig_no_out_arg": "exploit ( _i ( _i : : _i ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ( lift _i ) ( lift _i ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))",
                    "EXEC : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (sem (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "va : val",
                    "le : letenv",
                    "h2 : expr",
                    "l2 : expr"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons va le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal0",
                    "_goal : eval_expr ge sp e m (cons va le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal1",
                    "_goal : eval_expr ge sp e m (cons va le) (lift h2) ?Goal2",
                    "_goal : eval_expr ge sp e m (cons va le) (lift l2) ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal0 (Vint p1))\n              (_ : eq ?Goal1 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons va le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal0 (Vint p1))\n              (_ : eq ?Goal1 (Vint p2)) (_ : eq ?Goal2 (Vint q1))\n              (_ : eq ?Goal3 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq ?Goal0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons va le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq ?Goal0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq ?Goal0 (Vint q1)) (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons va le) (lift h2) ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq ?Goal0 (Vint q1)) (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2)) (_ : eq v1 (Vint q1))\n              (_ : eq ?Goal0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons va le) (lift l2) ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2)) (_ : eq v1 (Vint q1))\n              (_ : eq ?Goal0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2)) (_ : eq v1 (Vint q1))\n              (_ : eq v0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons va le)\n              (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil)) \n                 (lift h2) (lift l2)) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2)) (_ : eq v1 (Vint q1))\n              (_ : eq v0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword va) (Vint p1))\n  (_ : eq (Val.loword va) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons va le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet t1\n           (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)) \n              (lift h2) (lift l2))) v)\n     (Val.lessdef (sem va (Val.longofwords v1 v0)) v))",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet t1\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)) \n           (lift h2) (lift l2))) v)\n  (Val.lessdef (sem va (Val.longofwords v1 v0)) v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet t1\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)) \n           (lift h2) (lift l2))) v)\n  (Val.lessdef (sem va (Val.longofwords v1 v0)) v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v",
                    "_goal : Val.lessdef (sem va (Val.longofwords v1 v0)) v"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le t1 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le t1 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons va le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons va le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem va (Val.longofwords v1 v0)) v",
                    "va : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v1 v0)) v",
                    "_goal : Val.lessdef (sem (Vint i) (Val.longofwords v1 v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v",
                    "_goal : Val.lessdef (sem (Vfloat f0) (Val.longofwords v1 v0)) v",
                    "_goal : Val.lessdef (sem (Vsingle f0) (Val.longofwords v1 v0)) v",
                    "_goal : Val.lessdef (sem (Vptr b0 i) (Val.longofwords v1 v0)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword Vundef) (Vint p1))\n  (_ : eq (Val.loword Vundef) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons Vundef le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 Vundef",
                    "UNDEF : eq (sem Vundef (Val.longofwords v1 v0)) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword (Vint i)) (Vint p1))\n  (_ : eq (Val.loword (Vint i)) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vint i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 (Vint i)",
                    "UNDEF : eq (sem (Vint i) (Val.longofwords v1 v0)) Vundef",
                    "i : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vlong i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 (Vlong i)",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords v1 v0)) Vundef\nend",
                    "i : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vfloat f0)) (Vint p1))\n  (_ : eq (Val.loword (Vfloat f0)) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vfloat f0) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 (Vfloat f0)",
                    "UNDEF : eq (sem (Vfloat f0) (Val.longofwords v1 v0)) Vundef",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vsingle f0)) (Vint p1))\n  (_ : eq (Val.loword (Vsingle f0)) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vsingle f0) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 (Vsingle f0)",
                    "UNDEF : eq (sem (Vsingle f0) (Val.longofwords v1 v0)) Vundef",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vptr b0 i)) (Vint p1))\n  (_ : eq (Val.loword (Vptr b0 i)) (Vint p2)) (_ : eq v1 (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vptr b0 i) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H : eval_expr ge sp e m le t1 (Vptr b0 i)",
                    "UNDEF : eq (sem (Vptr b0 i) (Val.longofwords v1 v0)) Vundef",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef (Val.longofwords v1 v0)) v",
                    "UNDEF : eq (sem Vundef (Val.longofwords v1 v0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vint i) (Val.longofwords v1 v0)) v",
                    "UNDEF : eq (sem (Vint i) (Val.longofwords v1 v0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vfloat f0) (Val.longofwords v1 v0)) v",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords v1 v0)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vsingle f0) (Val.longofwords v1 v0)) v",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords v1 v0)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vptr b0 i) (Val.longofwords v1 v0)) v",
                    "UNDEF : match Val.longofwords v1 v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords v1 v0)) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords v1 v0)) v",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords Vundef v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vint i0) v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vlong i0) v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vfloat f0) v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vsingle f0) v0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vptr b0 i0) v0)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2)) (_ : eq Vundef (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 Vundef",
                    "UNDEF : match Val.longofwords Vundef v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords Vundef v0)) Vundef\nend",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 (Vint i0)",
                    "UNDEF : match Val.longofwords (Vint i0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords (Vint i0) v0)) Vundef\nend",
                    "i0 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Vlong i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 (Vlong i0)",
                    "UNDEF : match Val.longofwords (Vlong i0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords (Vlong i0) v0)) Vundef\nend",
                    "i0 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Vfloat f0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 (Vfloat f0)",
                    "UNDEF : match Val.longofwords (Vfloat f0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords (Vfloat f0) v0)) Vundef\nend",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Vsingle f0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 (Vsingle f0)",
                    "UNDEF : match Val.longofwords (Vsingle f0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords (Vsingle f0) v0)) Vundef\nend",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Vptr b0 i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H3 : eval_expr ge sp e m le h2 (Vptr b0 i0)",
                    "UNDEF : match Val.longofwords (Vptr b0 i0) v0 with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) (Val.longofwords (Vptr b0 i0) v0)) Vundef\nend",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords Vundef v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2)) (_ : eq Vundef (Vint q1))\n  (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vint i0) v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong i)\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i0 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vlong i0) v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vlong i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong i)\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i0 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vfloat f0) v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vfloat f0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong i)\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i0 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vsingle f0) v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vsingle f0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong i)\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i0 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Val.longofwords (Vptr b0 i0) v0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vptr b0 i0) (Vint q1)) (_ : eq v0 (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : match\n  match v0 with\n  | Vint n2 => Vlong (Int64.ofwords i0 n2)\n  | _ => Vundef\n  end\nwith\n| Vlong _ => True\n| _ =>\n    eq\n      (sem (Vlong i)\n         match v0 with\n         | Vint n2 => Vlong (Int64.ofwords i0 n2)\n         | _ => Vundef\n         end) Vundef\nend"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (sem (Vlong i)\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i0 n2)\n     | _ => Vundef\n     end) v",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v",
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq Vundef (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 Vundef",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vint i1) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vint i1)",
                    "UNDEF : True",
                    "i1 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vlong i1) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vlong i1)",
                    "i1 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vfloat f0) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vfloat f0)",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vsingle f0) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vsingle f0)",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vptr b0 i1) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H4 : eval_expr ge sp e m le l2 (Vptr b0 i1)",
                    "i1 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1))) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Vint (Int64.hiword i)) (Vint p1))\n  (_ : eq (Vint (Int64.loword i)) (Vint p2))\n  (_ : eq (Vint i0) (Vint q1)) (_ : eq (Vint i1) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p1)",
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?p2)",
                    "_goal : eq (Vint i0) (Vint ?q1)",
                    "_goal : eq (Vint i1) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?p2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint i0) (Vint ?q1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 ?q2)))",
                    "_goal : eq (Vint i1) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 i1)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords i0 i1)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))\n  (sem (Vlong i) (Vlong (Int64.ofwords i0 i1)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( _i ( _i : : _i : : _i ) ( Eop Ohighlong ( Eletvar 1 : : : Enil ) ) ( Eop Olowlong ( Eletvar 1 : : : Enil ) ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_sig_no_out_arg": "exploit ( _i ( _i : : _i : : _i ) ( Eop Ohighlong ( Eletvar 1 : : : Enil ) ) ( Eop Olowlong ( Eletvar 1 : : : Enil ) ) ( Eop Ohighlong ( Eletvar 0 : : : Enil ) ) ( Eop Olowlong ( Eletvar 0 : : : Enil ) ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))",
                    "EXEC : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (f a1 a2 b1 b2) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (sem (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "vb : val",
                    "va : val",
                    "le : letenv"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Ohighlong (Econs (Eletvar 1) Enil)) ?Goal",
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Olowlong (Econs (Eletvar 1) Enil)) ?Goal0",
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal1",
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal (Vint p1))\n              (_ : eq ?Goal0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Ohighlong (Econs (Eletvar 1) Enil)) ?Goal",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int) (_ : eq ?Goal (Vint p1))\n              (_ : eq ?Goal0 (Vint p2)) (_ : eq ?Goal1 (Vint q1))\n              (_ : eq ?Goal2 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq ?Goal (Vint p2)) (_ : eq ?Goal0 (Vint q1))\n              (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Olowlong (Econs (Eletvar 1) Enil)) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq ?Goal (Vint p2)) (_ : eq ?Goal0 (Vint q1))\n              (_ : eq ?Goal1 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq ?Goal (Vint q1)) (_ : eq ?Goal0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq ?Goal (Vint q1)) (_ : eq ?Goal0 (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq ?Goal (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons vb (cons va le))\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq ?Goal (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq (Val.loword vb) (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons vb (cons va le))\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))) v)\n           (forall (p1 p2 q1 q2 : Int.int)\n              (_ : eq (Val.hiword va) (Vint p1))\n              (_ : eq (Val.loword va) (Vint p2))\n              (_ : eq (Val.hiword vb) (Vint q1))\n              (_ : eq (Val.loword vb) (Vint q2)),\n            eq v\n              (sem (Vlong (Int64.ofwords p1 p2))\n                 (Vlong (Int64.ofwords q1 q2))))),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword va) (Vint p1))\n  (_ : eq (Val.loword va) (Vint p2)) (_ : eq (Val.hiword vb) (Vint q1))\n  (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons va le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e1\n           (Elet (lift e2)\n              (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n                 (Eop Olowlong (Econs (Eletvar 1) Enil))\n                 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (sem va vb) v))",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n              (Eop Olowlong (Econs (Eletvar 1) Enil))\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n  (Val.lessdef (sem va vb) v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n              (Eop Olowlong (Econs (Eletvar 1) Enil))\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n  (Val.lessdef (sem va vb) v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v",
                    "_goal : Val.lessdef (sem va vb) v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem va vb) v",
                    "va : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "_goal : Val.lessdef (sem (Vint i) vb) v",
                    "_goal : Val.lessdef (sem (Vlong i) vb) v",
                    "_goal : Val.lessdef (sem (Vfloat f0) vb) v",
                    "_goal : Val.lessdef (sem (Vsingle f0) vb) v",
                    "_goal : Val.lessdef (sem (Vptr b0 i) vb) v",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword Vundef) (Vint p1))\n  (_ : eq (Val.loword Vundef) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons Vundef le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 Vundef",
                    "UNDEF : eq (sem Vundef vb) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int) (_ : eq (Val.hiword (Vint i)) (Vint p1))\n  (_ : eq (Val.loword (Vint i)) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons (Vint i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 (Vint i)",
                    "UNDEF : eq (sem (Vint i) vb) Vundef",
                    "i : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 (Vlong i)",
                    "UNDEF : match vb with\n| Vlong _ => True\n| _ => eq (sem (Vlong i) vb) Vundef\nend",
                    "i : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vfloat f0)) (Vint p1))\n  (_ : eq (Val.loword (Vfloat f0)) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons (Vfloat f0) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 (Vfloat f0)",
                    "UNDEF : eq (sem (Vfloat f0) vb) Vundef",
                    "f0 : float",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vsingle f0)) (Vint p1))\n  (_ : eq (Val.loword (Vsingle f0)) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons (Vsingle f0) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 (Vsingle f0)",
                    "UNDEF : eq (sem (Vsingle f0) vb) Vundef",
                    "f0 : float32",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vptr b0 i)) (Vint p1))\n  (_ : eq (Val.loword (Vptr b0 i)) (Vint p2))\n  (_ : eq (Val.hiword vb) (Vint q1)) (_ : eq (Val.loword vb) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons vb (cons (Vptr b0 i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H : eval_expr ge sp e m le e1 (Vptr b0 i)",
                    "UNDEF : eq (sem (Vptr b0 i) vb) Vundef",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem Vundef vb) v",
                    "UNDEF : eq (sem Vundef vb) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vint i) vb) v",
                    "UNDEF : eq (sem (Vint i) vb) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) vb) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) vb) v"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) vb) v",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vint i0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vfloat f0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vsingle f0)) v",
                    "_goal : Val.lessdef (sem (Vlong i) (Vptr b0 i0)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword Vundef) (Vint q1))\n  (_ : eq (Val.loword Vundef) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons Vundef (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 Vundef",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vint i0)) (Vint q1))\n  (_ : eq (Val.loword (Vint i0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vint i0) (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vint i0)",
                    "UNDEF : eq (sem (Vlong i) (Vint i0)) Vundef",
                    "i0 : Int.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vlong i0)) (Vint q1))\n  (_ : eq (Val.loword (Vlong i0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vlong i0) (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vlong i0)",
                    "UNDEF : True",
                    "i0 : Int64.int",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vfloat f0)) (Vint q1))\n  (_ : eq (Val.loword (Vfloat f0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vfloat f0) (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vfloat f0)",
                    "UNDEF : eq (sem (Vlong i) (Vfloat f0)) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vsingle f0)) (Vint q1))\n  (_ : eq (Val.loword (Vsingle f0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vsingle f0) (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vsingle f0)",
                    "UNDEF : eq (sem (Vlong i) (Vsingle f0)) Vundef",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vptr b0 i0)) (Vint q1))\n  (_ : eq (Val.loword (Vptr b0 i0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m (cons (Vptr b0 i0) (cons (Vlong i) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vptr b0 i0)",
                    "UNDEF : eq (sem (Vlong i) (Vptr b0 i0)) Vundef",
                    "i0 : Ptrofs.int"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) Vundef) v",
                    "UNDEF : eq (sem (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vint i0)) v",
                    "UNDEF : eq (sem (Vlong i) (Vint i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) v"
                ]
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vfloat f0)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vsingle f0)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vptr b0 i0)) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vfloat f0) vb) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vsingle f0) vb) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try ( rewrite _i ; auto ) .",
                "tactic_sig_no_out_arg": "try ( rewrite _i ; auto ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vptr b0 i) vb) v",
                    "UNDEF : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite _i .",
                "tactic_sig_no_out_arg": "erewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) v",
                    "B : forall (p1 p2 q1 q2 : Int.int)\n  (_ : eq (Val.hiword (Vlong i)) (Vint p1))\n  (_ : eq (Val.loword (Vlong i)) (Vint p2))\n  (_ : eq (Val.hiword (Vlong i0)) (Vint q1))\n  (_ : eq (Val.loword (Vlong i0)) (Vint q2)),\neq v (sem (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Val.hiword (Vlong i)) (Vint ?p1)",
                    "_goal : eq (Val.loword (Vlong i)) (Vint ?p2)",
                    "_goal : eq (Val.hiword (Vlong i0)) (Vint ?q1)",
                    "_goal : eq (Val.loword (Vlong i0)) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.hiword (Vlong i)) (Vint ?p1)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords ?p1 ?p2)) (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.hiword i)) (Vint ?p1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.loword (Vlong i)) (Vint ?p2)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?p2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) ?p2))\n     (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.loword i)) (Vint ?p2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.hiword (Vlong i0)) (Vint ?q1)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.hiword i0)) (Vint ?q1)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords ?q1 ?q2)))",
                    "_goal : eq (Vint (Int64.hiword i0)) (Vint ?q1)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) ?q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.loword (Vlong i0)) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint (Int64.loword i0)) (Vint ?q2)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) ?q2)))",
                    "_goal : eq (Vint (Int64.loword i0)) (Vint ?q2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) (Int64.loword i0))))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite ! Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0))\n  (sem (Vlong (Int64.ofwords (Int64.hiword i) (Int64.loword i)))\n     (Vlong (Int64.ofwords (Int64.hiword i0) (Int64.loword i0))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) (sem (Vlong i) (Vlong i0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (sem (Vlong i) (Vlong i0)) (sem (Vlong i) (Vlong i0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_splitlong2_strict",
        "proof": [
            {
                "tactic_sig": "assert ( INV : forall v1 v2 n , Val.longofwords v1 v2 = Vlong n -> v1 = Vint ( Int64.hiword n ) /\\ v2 = Vint ( Int64.loword n ) ) .",
                "tactic_sig_no_out_arg": "assert ( INV : forall v1 v2 n , Val.longofwords v1 v2 = Vlong n -> v1 = Vint ( Int64.hiword n ) /\\ v2 = Vint ( Int64.loword n ) ) .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "INV : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "H : eq (Val.longofwords v1 v2) (Vlong n)",
                    "n : Int64.int",
                    "v1 : val",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq Vundef (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vlong i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vfloat f) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vsingle f) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vptr b i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "H : eq (Val.longofwords Vundef v2) (Vlong n)",
                    "H : eq (Val.longofwords (Vint i) v2) (Vlong n)",
                    "i : Int.int",
                    "H : eq (Val.longofwords (Vlong i) v2) (Vlong n)",
                    "i : Int64.int",
                    "H : eq (Val.longofwords (Vfloat f) v2) (Vlong n)",
                    "f : float",
                    "H : eq (Val.longofwords (Vsingle f) v2) (Vlong n)",
                    "f : float32",
                    "H : eq (Val.longofwords (Vptr b i) v2) (Vlong n)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq (Val.longofwords Vundef v2) (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq Vundef (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq (Val.longofwords (Vint i) v2) (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vlong i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vfloat f) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vsingle f) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H : eq\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords i n2)\n  | _ => Vundef\n  end (Vlong n)"
                ],
                "tactic_res": [
                    "H : eq Vundef (Vlong n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vptr b i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))",
                    "v2 : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq Vundef (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vint i0) (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vlong i0) (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vfloat f) (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vsingle f) (Vint (Int64.loword n)))",
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vptr b i0) (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)",
                    "H : eq (Vlong (Int64.ofwords i i0)) (Vlong n)",
                    "i0 : Int.int",
                    "i0 : Int64.int",
                    "f : float",
                    "f : float32",
                    "i0 : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq Vundef (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vint i0) (Vint (Int64.loword n)))",
                    "H : eq (Vlong (Int64.ofwords i i0)) (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword (Int64.ofwords i i0))))\n  (eq (Vint i0) (Vint (Int64.loword (Int64.ofwords i i0))))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vlong i0) (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vfloat f) (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vsingle f) (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword n)))\n  (eq (Vptr b i0) (Vint (Int64.loword n)))",
                    "H : eq Vundef (Vlong n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.hi_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.hi_ofwords .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint (Int64.hiword (Int64.ofwords i i0))))\n  (eq (Vint i0) (Vint (Int64.loword (Int64.ofwords i i0))))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq (Vint i) (Vint i))\n  (eq (Vint i0) (Vint (Int64.loword (Int64.ofwords i i0))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.lo_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.lo_ofwords .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint i))\n  (eq (Vint i0) (Vint (Int64.loword (Int64.ofwords i i0))))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eq (Vint i) (Vint i)) (eq (Vint i0) (Vint i0))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (eq (Vint i) (Vint i)) (eq (Vint i0) (Vint i0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr)\n  (f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr)\n  (va vb : Int64.int) (v : val)\n  (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le0 (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (splitlong2 a b f) v"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr)\n  (f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr)\n  (va vb : Int64.int) (v : val)\n  (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le0 (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (splitlong2 a b f) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until v .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr)\n  (f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr)\n  (va vb : Int64.int) (v : val)\n  (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le0 (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (splitlong2 a b f) v"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (splitlong2 a b f) v",
                    "v : val",
                    "va : Int64.int",
                    "vb : Int64.int",
                    "f : forall (_ : expr) (_ : expr) (_ : expr) (_ : expr), expr",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold splitlong2 .",
                "tactic_sig_no_out_arg": "unfold splitlong2 .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (splitlong2 a b f) v"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  match splitlong2_match a b with\n  | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n  | splitlong2_case2 h1 l1 t2 =>\n      Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))\n  | splitlong2_case3 t1 h2 l2 =>\n      Elet t1\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)) \n           (lift h2) (lift l2))\n  | splitlong2_default e1 e2 =>\n      Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n              (Eop Olowlong (Econs (Eletvar 1) Enil))\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil))))\n  end v"
                ]
            },
            {
                "tactic_sig": "case ( splitlong2_match _i _i ) .",
                "tactic_sig_no_out_arg": "case ( splitlong2_match _i _i ) .",
                "tactic_args": [
                    "_goal : forall (_ : eval_expr ge sp e m le a (Vlong va))\n  (_ : eval_expr ge sp e m le b (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  match splitlong2_match a b with\n  | splitlong2_case1 h1 l1 h2 l2 => f h1 l1 h2 l2\n  | splitlong2_case2 h1 l1 t2 =>\n      Elet t2\n        (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)))\n  | splitlong2_case3 t1 h2 l2 =>\n      Elet t1\n        (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil)) \n           (lift h2) (lift l2))\n  | splitlong2_default e1 e2 =>\n      Elet e1\n        (Elet (lift e2)\n           (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n              (Eop Olowlong (Econs (Eletvar 1) Enil))\n              (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (Eop Olowlong (Econs (Eletvar 0) Enil))))\n  end v",
                    "a : expr",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : forall (h1 l1 h2 l2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) \n         (Vlong va))\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) \n         (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "_goal : forall (h1 l1 t2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) \n         (Vlong va)) (_ : eval_expr ge sp e m le t2 (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "_goal : forall (t1 h2 l2 : expr) (_ : eval_expr ge sp e m le t1 (Vlong va))\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) \n         (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v",
                    "_goal : forall (e1 e2 : expr) (_ : eval_expr ge sp e m le e1 (Vlong va))\n  (_ : eval_expr ge sp e m le e2 (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h1 l1 h2 l2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) \n         (Vlong va))\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) \n         (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "H1 : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f a1 a2 b1 b2) v",
                    "H0 : eval_expr ge sp e m le (Eop Omakelong (Econs h2 (Econs l2 Enil)))\n  (Vlong vb)",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs h1 (Econs l1 Enil)))\n  (Vlong va)",
                    "h1 : expr",
                    "l1 : expr",
                    "h2 : expr",
                    "l2 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h1 l1 t2 : expr)\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h1 (Econs l1 Enil))) \n         (Vlong va)) (_ : eval_expr ge sp e m le t2 (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "H0 : eval_expr ge sp e m le t2 (Vlong vb)",
                    "t2 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (t1 h2 l2 : expr) (_ : eval_expr ge sp e m le t1 (Vlong va))\n  (_ : eval_expr ge sp e m le\n         (Eop Omakelong (Econs h2 (Econs l2 Enil))) \n         (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v",
                    "H : eval_expr ge sp e m le t1 (Vlong va)",
                    "t1 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (e1 e2 : expr) (_ : eval_expr ge sp e m le e1 (Vlong va))\n  (_ : eval_expr ge sp e m le e2 (Vlong vb))\n  (_ : forall (le : letenv) (a1 a2 b1 b2 : expr)\n         (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n         (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n         (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n         (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\n       eval_expr ge sp e m le (f a1 a2 b1 b2) v),\neval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v",
                    "H0 : eval_expr ge sp e m le e2 (Vlong vb)",
                    "H : eval_expr ge sp e m le e1 (Vlong va)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (Val.longofwords v2 v3) (Vlong vb)",
                    "H : eq (Val.longofwords v1 v0) (Vlong va)",
                    "H5 : eval_expr ge sp e m le l2 v3",
                    "H6 : eval_expr ge sp e m le h2 v2",
                    "H4 : eval_expr ge sp e m le l1 v0",
                    "H3 : eval_expr ge sp e m le h1 v1",
                    "v2 : val",
                    "v3 : val",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "INV : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords ?Goal2 ?Goal3) (Vlong ?Goal4)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal2 (Vint (Int64.hiword ?Goal4)))\n        (eq ?Goal3 (Vint (Int64.loword ?Goal4))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords ?Goal2 ?Goal3) (Vlong ?Goal4)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal2 (Vint (Int64.hiword ?Goal4)))\n        (eq ?Goal3 (Vint (Int64.loword ?Goal4))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "H : eq (Val.longofwords v1 v0) (Vlong va)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros [ EQ1 EQ2 ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "EQ2 : eq v0 (Vint (Int64.loword va))",
                    "EQ1 : eq v1 (Vint (Int64.hiword va))"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "INV : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords ?Goal2 ?Goal3) (Vlong ?Goal4)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal2 (Vint (Int64.hiword ?Goal4)))\n        (eq ?Goal3 (Vint (Int64.loword ?Goal4))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords ?Goal2 ?Goal3) (Vlong ?Goal4)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal2 (Vint (Int64.hiword ?Goal4)))\n        (eq ?Goal3 (Vint (Int64.loword ?Goal4))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "H0 : eq (Val.longofwords v2 v3) (Vlong vb)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v2 (Vint (Int64.hiword vb)))\n        (eq v3 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros [ EQ3 EQ4 ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v2 (Vint (Int64.hiword vb)))\n        (eq v3 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v",
                    "EQ4 : eq v3 (Vint (Int64.loword vb))",
                    "EQ3 : eq v2 (Vint (Int64.hiword vb))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)))\n  (Vlong vb)",
                    "H : eq (Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)))\n  (Vlong va)",
                    "H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb))",
                    "H6 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))",
                    "H4 : eval_expr ge sp e m le l1 (Vint (Int64.loword va))",
                    "H3 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (f h1 l1 h2 l2) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) (Vlong va)",
                    "H5 : eval_expr ge sp e m le l1 v0",
                    "H4 : eval_expr ge sp e m le h1 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "INV : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords ?Goal1 ?Goal2) (Vlong ?Goal3)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal1 (Vint (Int64.hiword ?Goal3)))\n        (eq ?Goal2 (Vint (Int64.loword ?Goal3))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords ?Goal1 ?Goal2) (Vlong ?Goal3)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal1 (Vint (Int64.hiword ?Goal3)))\n        (eq ?Goal2 (Vint (Int64.loword ?Goal3))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros [ EQ1 EQ2 ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword va)))\n        (eq v0 (Vint (Int64.loword va))),\neval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v",
                    "EQ2 : eq v0 (Vint (Int64.loword va))",
                    "EQ1 : eq v1 (Vint (Int64.hiword va))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eval_expr ge sp e m le l1 (Vint (Int64.loword va))",
                    "H : eq (Val.longofwords (Vint (Int64.hiword va)) (Vint (Int64.loword va)))\n  (Vlong va)",
                    "H4 : eval_expr ge sp e m le h1 (Vint (Int64.hiword va))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t2\n     (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le t2 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le t2 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (f (lift h1) (lift l1) (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H1 : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f a1 a2 b1 b2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le) (lift h1)\n  (Vint (Int64.hiword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le) (lift l1)\n  (Vint (Int64.loword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword vb))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword vb))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le) (lift h1)\n  (Vint (Int64.hiword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le) (lift l1)\n  (Vint (Int64.loword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword vb))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword vb))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (Val.longofwords v1 v0) (Vlong vb)",
                    "H5 : eval_expr ge sp e m le l2 v0",
                    "H4 : eval_expr ge sp e m le h2 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "exploit _i .",
                "tactic_sig_no_out_arg": "exploit _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v",
                    "INV : forall (v1 v2 : val) (n : Int64.int)\n  (_ : eq (Val.longofwords v1 v2) (Vlong n)),\nLogic.and (eq v1 (Vint (Int64.hiword n)))\n  (eq v2 (Vint (Int64.loword n)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords ?Goal0 ?Goal1) (Vlong ?Goal2)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal0 (Vint (Int64.hiword ?Goal2)))\n        (eq ?Goal1 (Vint (Int64.loword ?Goal2))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords ?Goal0 ?Goal1) (Vlong ?Goal2)",
                    "_goal : forall\n  _ : Logic.and (eq ?Goal0 (Vint (Int64.hiword ?Goal2)))\n        (eq ?Goal1 (Vint (Int64.loword ?Goal2))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword vb)))\n        (eq v0 (Vint (Int64.loword vb))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword vb)))\n        (eq v0 (Vint (Int64.loword vb))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword vb)))\n        (eq v0 (Vint (Int64.loword vb))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros [ EQ1 EQ2 ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq v1 (Vint (Int64.hiword vb)))\n        (eq v0 (Vint (Int64.loword vb))),\neval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v",
                    "EQ2 : eq v0 (Vint (Int64.loword vb))",
                    "EQ1 : eq v1 (Vint (Int64.hiword vb))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eval_expr ge sp e m le l2 (Vint (Int64.loword vb))",
                    "H0 : eq (Val.longofwords (Vint (Int64.hiword vb)) (Vint (Int64.loword vb)))\n  (Vlong vb)",
                    "H4 : eval_expr ge sp e m le h2 (Vint (Int64.hiword vb))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet t1\n     (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n        (lift l2))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le t1 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le t1 ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (f (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil)) (lift h2) \n     (lift l2)) v",
                    "H1 : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f a1 a2 b1 b2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le) (lift h2)\n  (Vint (Int64.hiword vb))",
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le) (lift l2)\n  (Vint (Int64.loword vb))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le)\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le) (lift h2)\n  (Vint (Int64.hiword vb))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong va) le) (lift l2)\n  (Vint (Int64.loword vb))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e1\n     (Elet (lift e2)\n        (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n           (Eop Olowlong (Econs (Eletvar 1) Enil))\n           (Eop Ohighlong (Econs (Eletvar 0) Enil))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (f (Eop Ohighlong (Econs (Eletvar 1) Enil))\n     (Eop Olowlong (Econs (Eletvar 1) Enil))\n     (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (Eop Olowlong (Econs (Eletvar 0) Enil))) v",
                    "H1 : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword va)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword va)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword vb)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword vb))),\neval_expr ge sp e m le (f a1 a2 b1 b2) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Ohighlong (Econs (Eletvar 1) Enil)) (Vint (Int64.hiword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Olowlong (Econs (Eletvar 1) Enil)) (Vint (Int64.loword va))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword vb))",
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword vb))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Ohighlong (Econs (Eletvar 1) Enil)) (Vint (Int64.hiword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Olowlong (Econs (Eletvar 1) Enil)) (Vint (Int64.loword va))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Ohighlong (Econs (Eletvar 0) Enil)) (Vint (Int64.hiword vb))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons (Vlong vb) (cons (Vlong va) le))\n  (Eop Olowlong (Econs (Eletvar 0) Enil)) (Vint (Int64.loword vb))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "is_longconst_sound",
        "proof": [
            {
                "tactic_sig": "unfold is_longconst .",
                "tactic_sig_no_out_arg": "unfold is_longconst .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int64.int)\n  (_ : eq (is_longconst a) (Some n)) (_ : eval_expr ge sp e m le a x),\neq x (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int64.int)\n  (_ : eq\n         match is_longconst_match a with\n         | is_longconst_case1 h l => Some (Int64.ofwords h l)\n         | is_longconst_default _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vlong n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until n .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int64.int)\n  (_ : eq\n         match is_longconst_match a with\n         | is_longconst_case1 h l => Some (Int64.ofwords h l)\n         | is_longconst_default _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : eq\n         match is_longconst_match a with\n         | is_longconst_case1 h l => Some (Int64.ofwords h l)\n         | is_longconst_default _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vlong n)",
                    "n : Int64.int",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros LC .",
                "tactic_args": [
                    "_goal : forall\n  (_ : eq\n         match is_longconst_match a with\n         | is_longconst_case1 h l => Some (Int64.ofwords h l)\n         | is_longconst_default _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a x, eq x (Vlong n)",
                    "LC : eq\n  match is_longconst_match a with\n  | is_longconst_case1 h l => Some (Int64.ofwords h l)\n  | is_longconst_default _ => None\n  end (Some n)"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst_match _i ) as [_o _o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst_match _i ) .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a x, eq x (Vlong n)",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le\n        (Eop Omakelong\n           (Econs (Eop (Ointconst h) Enil)\n              (Econs (Eop (Ointconst l) Enil) Enil))) x, \neq x (Vlong n)",
                    "_goal : forall _ : eval_expr ge sp e m le e0 x, eq x (Vlong n)",
                    "LC : eq (Some (Int64.ofwords h l)) (Some n)",
                    "h : Int.int",
                    "l : Int.int",
                    "LC : eq None (Some n)",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le\n        (Eop Omakelong\n           (Econs (Eop (Ointconst h) Enil)\n              (Econs (Eop (Ointconst l) Enil) Enil))) x, \neq x (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vlong n)",
                    "H : eval_expr ge sp e m le\n  (Eop Omakelong\n     (Econs (Eop (Ointconst h) Enil)\n        (Econs (Eop (Ointconst l) Enil) Enil))) x"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le e0 x, eq x (Vlong n)"
                ],
                "tactic_res": [
                    "H : eval_expr ge sp e m le e0 x"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "LC : eq (Some (Int64.ofwords h l)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vlong (Int64.ofwords h l))"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eq\n  (eval_operation ge sp Omakelong (cons (Vint h) (cons (Vint l) nil)) m)\n  (Some x)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H5 : eq\n  (eval_operation ge sp Omakelong (cons (Vint h) (cons (Vint l) nil)) m)\n  (Some x)"
                ],
                "tactic_res": [
                    "H5 : eq (Some (Vlong (Int64.ofwords h l))) (Some x)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq x (Vlong (Int64.ofwords h l))",
                    "H5 : eq (Some (Vlong (Int64.ofwords h l))) (Some x)"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords h l)) (Vlong (Int64.ofwords h l))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords h l)) (Vlong (Int64.ofwords h l))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : eq x (Vlong n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "is_longconst_zero_sound",
        "proof": [
            {
                "tactic_sig": "unfold is_longconst_zero .",
                "tactic_sig_no_out_arg": "unfold is_longconst_zero .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eq (is_longconst_zero a) true) (_ : eval_expr ge sp e m le a x),\neq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eq\n         match is_longconst a with\n         | Some n => Int64.eq n Int64.zero\n         | None => false\n         end true) (_ : eval_expr ge sp e m le a x),\neq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eq\n         match is_longconst a with\n         | Some n => Int64.eq n Int64.zero\n         | None => false\n         end true) (_ : eval_expr ge sp e m le a x),\neq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vlong Int64.zero)",
                    "H0 : eval_expr ge sp e m le a x",
                    "H : eq\n  match is_longconst a with\n  | Some n => Int64.eq n Int64.zero\n  | None => false\n  end true",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ n| ] eqn : E .",
                "tactic_args": [
                    "a : expr"
                ],
                "tactic_res": [
                    "H : eq (Int64.eq n Int64.zero) true",
                    "E : eq (is_longconst a) (Some n)",
                    "n : Int64.int",
                    "H : eq false true",
                    "E : eq (is_longconst a) None"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "revert _i .",
                "tactic_sig_no_out_arg": "revert _i .",
                "tactic_args": [
                    "_goal : eq x (Vlong Int64.zero)",
                    "H : eq (Int64.eq n Int64.zero) true"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.eq n Int64.zero) true, eq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.eq n Int64.zero) true, eq x (Vlong Int64.zero)",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : if Int64.eq n Int64.zero\n       then eq n Int64.zero\n       else not (eq n Int64.zero))\n  (_ : eq (Int64.eq n Int64.zero) true), eq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  (_ : if Int64.eq n Int64.zero\n       then eq n Int64.zero\n       else not (eq n Int64.zero))\n  (_ : eq (Int64.eq n Int64.zero) true), eq x (Vlong Int64.zero)",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq n Int64.zero) (_ : eq true true),\neq x (Vlong Int64.zero)",
                    "_goal : forall (_ : not (eq n Int64.zero)) (_ : eq false true),\neq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall (_ : eq n Int64.zero) (_ : eq true true),\neq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq true true, eq x (Vlong Int64.zero)",
                    "H : eq n Int64.zero"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall (_ : not (eq n Int64.zero)) (_ : eq false true),\neq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq false true, eq x (Vlong Int64.zero)",
                    "H : not (eq n Int64.zero)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq true true, eq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vlong Int64.zero)",
                    "H1 : eq true true"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "E : eq (is_longconst a) (Some Int64.zero)"
                ]
            },
            {
                "tactic_sig": "eapply is_longconst_sound .",
                "tactic_sig_no_out_arg": "eapply is_longconst_sound .",
                "tactic_args": [
                    "_goal : eq x (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst ?a) (Some Int64.zero)",
                    "_goal : eval_expr ge sp e m ?le ?a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst ?a) (Some Int64.zero)",
                    "_goal : eval_expr ge sp e m ?le ?a x"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?le a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : forall _ : eq false true, eq x (Vlong Int64.zero)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_lowlong",
        "proof": [
            {
                "tactic_sig": "unfold lowlong .",
                "tactic_sig_no_out_arg": "unfold lowlong .",
                "tactic_args": [
                    "_goal : unary_constructor_sound lowlong Val.loword"
                ],
                "tactic_res": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match lowlong_match e with\n   | lowlong_case1 _ e2 => e2\n   | lowlong_default e0 => Eop Olowlong (Econs e0 Enil)\n   end) Val.loword"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match lowlong_match e with\n   | lowlong_case1 _ e2 => e2\n   | lowlong_default e0 => Eop Olowlong (Econs e0 Enil)\n   end) Val.loword"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match lowlong_match a with\n        | lowlong_case1 _ e2 => e2\n        | lowlong_default e => Eop Olowlong (Econs e Enil)\n        end v) (Val.lessdef (Val.loword x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros until x .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match lowlong_match a with\n        | lowlong_case1 _ e2 => e2\n        | lowlong_default e => Eop Olowlong (Econs e Enil)\n        end v) (Val.lessdef (Val.loword x) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a x,\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match lowlong_match a with\n        | lowlong_case1 _ e2 => e2\n        | lowlong_default e => Eop Olowlong (Econs e Enil)\n        end v) (Val.lessdef (Val.loword x) v))",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( lowlong_match _i ) as [_o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( lowlong_match _i ) .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a x,\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match lowlong_match a with\n        | lowlong_case1 _ e2 => e2\n        | lowlong_default e => Eop Olowlong (Econs e Enil)\n        end v) (Val.lessdef (Val.loword x) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil)))\n        x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword x) v))",
                    "_goal : forall _ : eval_expr ge sp e m le e0 x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.loword x) v))",
                    "e1 : expr",
                    "e2 : expr",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil)))\n        x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword x) v))",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil))) x"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le e0 x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.loword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.loword x) v))",
                    "H : eval_expr ge sp e m le e0 x"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) x",
                    "H3 : eval_expr ge sp e m le e2 v0",
                    "H2 : eval_expr ge sp e m le e1 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e2 v)\n     (Val.lessdef (Val.loword (Val.longofwords v1 v0)) v))",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le e2 v0)\n  (Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le e2 v0)\n  (Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le e2 v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le e2 v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords v1 v0)) v0",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords Vundef v0)) v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vint i) v0)) v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vlong i) v0)) v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vfloat f) v0)) v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vsingle f) v0)) v0",
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vptr b i) v0)) v0",
                    "H2 : eval_expr ge sp e m le e1 Vundef",
                    "H2 : eval_expr ge sp e m le e1 (Vint i)",
                    "i : Int.int",
                    "H2 : eval_expr ge sp e m le e1 (Vlong i)",
                    "i : Int64.int",
                    "H2 : eval_expr ge sp e m le e1 (Vfloat f)",
                    "f : float",
                    "H2 : eval_expr ge sp e m le e1 (Vsingle f)",
                    "f : float32",
                    "H2 : eval_expr ge sp e m le e1 (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords Vundef v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vint i) v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vlong i) v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vfloat f) v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vsingle f) v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Val.longofwords (Vptr b i) v0)) v0"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.loword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) v0",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.loword Vundef) Vundef",
                    "_goal : Val.lessdef (Val.loword (Vlong (Int64.ofwords i i0))) (Vint i0)",
                    "_goal : Val.lessdef (Val.loword Vundef) (Vlong i0)",
                    "_goal : Val.lessdef (Val.loword Vundef) (Vfloat f)",
                    "_goal : Val.lessdef (Val.loword Vundef) (Vsingle f)",
                    "_goal : Val.lessdef (Val.loword Vundef) (Vptr b i0)",
                    "H3 : eval_expr ge sp e m le e2 Vundef",
                    "H3 : eval_expr ge sp e m le e2 (Vint i0)",
                    "i0 : Int.int",
                    "H3 : eval_expr ge sp e m le e2 (Vlong i0)",
                    "i0 : Int64.int",
                    "H3 : eval_expr ge sp e m le e2 (Vfloat f)",
                    "f : float",
                    "H3 : eval_expr ge sp e m le e2 (Vsingle f)",
                    "f : float32",
                    "H3 : eval_expr ge sp e m le e2 (Vptr b i0)",
                    "i0 : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword Vundef) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword (Vlong (Int64.ofwords i i0))) (Vint i0)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword Vundef) (Vlong i0)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword Vundef) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword Vundef) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword Vundef) (Vptr b i0)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.lo_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.lo_ofwords .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint (Int64.loword (Int64.ofwords i i0))) (Vint i0)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint i0) (Vint i0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint i0) (Vint i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( Val.loword _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.loword _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.loword x) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x))\n  (Val.lessdef (Val.loword x) (Val.loword x))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x))\n  (Val.lessdef (Val.loword x) (Val.loword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x)",
                    "_goal : Val.lessdef (Val.loword x) (Val.loword x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.loword x) (Val.loword x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop Olowlong (Econs e0 Enil)) (Val.loword x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_highlong",
        "proof": [
            {
                "tactic_sig": "unfold highlong .",
                "tactic_sig_no_out_arg": "unfold highlong .",
                "tactic_args": [
                    "_goal : unary_constructor_sound highlong Val.hiword"
                ],
                "tactic_res": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match highlong_match e with\n   | highlong_case1 e1 _ => e1\n   | highlong_default e0 => Eop Ohighlong (Econs e0 Enil)\n   end) Val.hiword"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match highlong_match e with\n   | highlong_case1 e1 _ => e1\n   | highlong_default e0 => Eop Ohighlong (Econs e0 Enil)\n   end) Val.hiword"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match highlong_match a with\n        | highlong_case1 e1 _ => e1\n        | highlong_default e => Eop Ohighlong (Econs e Enil)\n        end v) (Val.lessdef (Val.hiword x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros until x .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match highlong_match a with\n        | highlong_case1 e1 _ => e1\n        | highlong_default e => Eop Ohighlong (Econs e Enil)\n        end v) (Val.lessdef (Val.hiword x) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a x,\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match highlong_match a with\n        | highlong_case1 e1 _ => e1\n        | highlong_default e => Eop Ohighlong (Econs e Enil)\n        end v) (Val.lessdef (Val.hiword x) v))",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( highlong_match _i ) as [_o _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( highlong_match _i ) .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a x,\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match highlong_match a with\n        | highlong_case1 e1 _ => e1\n        | highlong_default e => Eop Ohighlong (Econs e Enil)\n        end v) (Val.lessdef (Val.hiword x) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil)))\n        x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword x) v))",
                    "_goal : forall _ : eval_expr ge sp e m le e0 x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.hiword x) v))",
                    "e1 : expr",
                    "e2 : expr",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil)))\n        x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword x) v))",
                    "H : eval_expr ge sp e m le (Eop Omakelong (Econs e1 (Econs e2 Enil))) x"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le e0 x,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.hiword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.hiword x) v))",
                    "H : eval_expr ge sp e m le e0 x"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Val.longofwords v1 v0) x",
                    "H3 : eval_expr ge sp e m le e2 v0",
                    "H2 : eval_expr ge sp e m le e1 v1",
                    "v1 : val",
                    "v0 : val"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le e1 v)\n     (Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v))",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le e1 v1)\n  (Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le e1 v1)\n  (Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le e1 v1",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le e1 v1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords v1 v0)) v1",
                    "v1 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords Vundef v0)) Vundef",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vint i) v0)) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vlong i) v0)) (Vlong i)",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vfloat f) v0)) (Vfloat f)",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vsingle f) v0)) (Vsingle f)",
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vptr b i) v0)) (Vptr b i)",
                    "H2 : eval_expr ge sp e m le e1 Vundef",
                    "H2 : eval_expr ge sp e m le e1 (Vint i)",
                    "i : Int.int",
                    "H2 : eval_expr ge sp e m le e1 (Vlong i)",
                    "i : Int64.int",
                    "H2 : eval_expr ge sp e m le e1 (Vfloat f)",
                    "f : float",
                    "H2 : eval_expr ge sp e m le e1 (Vsingle f)",
                    "f : float32",
                    "H2 : eval_expr ge sp e m le e1 (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords Vundef v0)) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vint i) v0)) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vlong i) v0)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vfloat f) v0)) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vsingle f) v0)) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Val.longofwords (Vptr b i) v0)) (Vptr b i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.hiword\n     match v0 with\n     | Vint n2 => Vlong (Int64.ofwords i n2)\n     | _ => Vundef\n     end) (Vint i)",
                    "v0 : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword (Vlong (Int64.ofwords i i0))) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)",
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)",
                    "H3 : eval_expr ge sp e m le e2 Vundef",
                    "H3 : eval_expr ge sp e m le e2 (Vint i0)",
                    "i0 : Int.int",
                    "H3 : eval_expr ge sp e m le e2 (Vlong i0)",
                    "i0 : Int64.int",
                    "H3 : eval_expr ge sp e m le e2 (Vfloat f)",
                    "f : float",
                    "H3 : eval_expr ge sp e m le e2 (Vsingle f)",
                    "f : float32",
                    "H3 : eval_expr ge sp e m le e2 (Vptr b i0)",
                    "i0 : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword (Vlong (Int64.ofwords i i0))) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword Vundef) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.hi_ofwords .",
                "tactic_sig_no_out_arg": "rewrite Int64.hi_ofwords .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint (Int64.hiword (Int64.ofwords i i0))) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vint i) (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vint i) (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( Val.hiword _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.hiword _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) v)\n     (Val.lessdef (Val.hiword x) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil))\n     (Val.hiword x)) (Val.lessdef (Val.hiword x) (Val.hiword x))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil))\n     (Val.hiword x)) (Val.lessdef (Val.hiword x) (Val.hiword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) (Val.hiword x)",
                    "_goal : Val.lessdef (Val.hiword x) (Val.hiword x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) (Val.hiword x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) (Val.hiword x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.hiword x) (Val.hiword x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop Ohighlong (Econs e0 Enil)) (Val.hiword x)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longconst",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (n : Int64.int),\neval_expr ge sp e m le (longconst n) (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)",
                    "n : Int64.int",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vlong (Int64.ofwords (Int64.hiword n) (Int64.loword n))))\n  (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : eq (Some (Vlong (Int64.ofwords (Int64.hiword n) (Int64.loword n))))\n  (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vlong n)) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Vlong n)) (Some (Vlong n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_intoflong",
        "proof": []
    },
    {
        "lemma_name": "eval_longofintu",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound longofintu Val.longofintu"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofintu a) v)\n     (Val.lessdef (Val.longofintu x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofintu a) v)\n     (Val.lessdef (Val.longofintu x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofintu a) v)\n     (Val.lessdef (Val.longofintu x) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longofintu .",
                "tactic_sig_no_out_arg": "unfold longofintu .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofintu a) v)\n     (Val.lessdef (Val.longofintu x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil) a) v)\n     (Val.lessdef (Val.longofintu x) v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil) a) v)\n     (Val.lessdef (Val.longofintu x) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a)\n     ?v) (Val.lessdef (Val.longofintu x) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a)\n     ?v) (Val.lessdef (Val.longofintu x) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a) ?v",
                    "_goal : Val.lessdef (Val.longofintu x) ?v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (makelong (Eop (Ointconst Int.zero) Enil) a) ?v",
                    "_goal : Val.lessdef (Val.longofintu x) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.longofintu x)\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "unfold Val.longofintu .",
                "tactic_sig_no_out_arg": "unfold Val.longofintu .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofintu x)\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match x with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match x with\n  | Vint n => Vlong (Int64.repr (Int.unsigned n))\n  | _ => Vundef\n  end\n  match x with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i))",
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( Int64.repr ( Int.unsigned _i ) ) with ( Int64.ofwords Int.zero _i ) .",
                "tactic_sig_no_out_arg": "replace ( Int64.repr ( Int.unsigned _i ) ) with ( Int64.ofwords Int.zero _i ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.unsigned i)))\n  (Vlong (Int64.ofwords Int.zero i))",
                    "i : Int.int",
                    "i : Int.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.ofwords Int.zero i))\n  (Vlong (Int64.ofwords Int.zero i))",
                    "_goal : eq (Int64.ofwords Int.zero i) (Int64.repr (Int.unsigned i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.ofwords Int.zero i))\n  (Vlong (Int64.ofwords Int.zero i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords Int.zero i) (Int64.repr (Int.unsigned i))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords Int.zero i) (Int64.repr (Int.unsigned i))"
                ]
            },
            {
                "tactic_sig": "apply Int64.same_bits_eq .",
                "tactic_sig_no_out_arg": "apply Int64.same_bits_eq .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords Int.zero i) (Int64.repr (Int.unsigned i))"
                ],
                "tactic_res": [
                    "_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Int64.testbit (Int64.repr (Int.unsigned i)) i0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Int64.testbit (Int64.repr (Int.unsigned i)) i0)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Int64.testbit (Int64.repr (Int.unsigned i)) i0)",
                    "H0 : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)",
                    "i0 : Z"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.testbit_repr by auto .",
                "tactic_sig_no_out_arg": "rewrite Int64.testbit_repr by auto .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Int64.testbit (Int64.repr (Int.unsigned i)) i0)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Z.testbit (Int.unsigned i) i0)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_ofwords by auto .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_ofwords by auto .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords Int.zero i) i0)\n  (Z.testbit (Int.unsigned i) i0)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit Int.zero (Z.sub i0 Int.zwordsize))\n  (Z.testbit (Int.unsigned i) i0)"
                ]
            },
            {
                "tactic_sig": "fold ( Int.testbit _i _i ) .",
                "tactic_sig_no_out_arg": "fold ( Int.testbit _i _i ) .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit Int.zero (Z.sub i0 Int.zwordsize))\n  (Z.testbit (Int.unsigned i) i0)",
                    "i : Int.int",
                    "i0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit Int.zero (Z.sub i0 Int.zwordsize))\n  (Int.testbit i i0)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i Int.zwordsize ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i Int.zwordsize ) .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit Int.zero (Z.sub i0 Int.zwordsize))\n  (Int.testbit i i0)",
                    "i0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit i i0) (Int.testbit i i0)",
                    "_goal : eq (Int.testbit Int.zero (Z.sub i0 Int.zwordsize)) (Int.testbit i i0)",
                    "l : Z.lt i0 Int.zwordsize",
                    "g : Z.ge i0 Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int.testbit i i0) (Int.testbit i i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int.bits_zero .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero .",
                "tactic_args": [
                    "_goal : eq (Int.testbit Int.zero (Z.sub i0 Int.zwordsize)) (Int.testbit i i0)"
                ],
                "tactic_res": [
                    "_goal : eq false (Int.testbit i i0)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_above by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_above by lia .",
                "tactic_args": [
                    "_goal : eq false (Int.testbit i i0)"
                ],
                "tactic_res": [
                    "_goal : eq false false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longofint",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound longofint Val.longofint"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofint a) v)\n     (Val.lessdef (Val.longofint x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofint a) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofint a) v)\n     (Val.lessdef (Val.longofint x) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longofint .",
                "tactic_sig_no_out_arg": "unfold longofint .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofint a) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match longofint_match a with\n        | longofint_case1 n => longconst (Int64.repr (Int.signed n))\n        | longofint_default e =>\n            Elet e\n              (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))\n        end v) (Val.lessdef (Val.longofint x) v))"
                ]
            },
            {
                "tactic_sig": "destruct ( longofint_match _i ) as [_o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( longofint_match _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match longofint_match a with\n        | longofint_case1 n => longconst (Int64.repr (Int.signed n))\n        | longofint_default e =>\n            Elet e\n              (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))\n        end v) (Val.lessdef (Val.longofint x) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v)\n     (Val.lessdef (Val.longofint x) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))",
                    "H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x",
                    "n : Int.int",
                    "H : eval_expr ge sp e m le e0 x",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v)\n     (Val.lessdef (Val.longofint (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) v)\n     (Val.lessdef (Val.longofint (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) ?v)\n  (Val.lessdef (Val.longofint (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) ?v)\n  (Val.lessdef (Val.longofint (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) ?v",
                    "_goal : Val.lessdef (Val.longofint (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.repr (Int.signed n))) ?v",
                    "_goal : Val.lessdef (Val.longofint (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.longofint (Vint n))\n  (Vlong (Int64.repr (Int.signed n)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vint n))\n  (Vlong (Int64.repr (Int.signed n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_shrimm _i _i _i _i ( Int.repr 31 ) ( _i : : _i ) ( Eletvar 0 ) ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_shrimm _i _i _i _i ( Int.repr 31 ) ( _i : : _i ) ( Eletvar 0 ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))",
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "x : val",
                    "le : letenv"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons x le) (Eletvar 0) ?Goal",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons x le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr ?Goal (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons x le) (Eletvar 0) ?Goal",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons x le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr ?Goal (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons x le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr x (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons x le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr x (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))",
                    "B : Val.lessdef (Val.shr x (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons x le) (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet e0\n           (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0))) v)\n     (Val.lessdef (Val.longofint x) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0)))\n     ?v) (Val.lessdef (Val.longofint x) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0)))\n     ?v) (Val.lessdef (Val.longofint x) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0)))\n  ?v",
                    "_goal : Val.lessdef (Val.longofint x) ?v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet e0 (makelong (shrimm (Eletvar 0) (Int.repr 31)) (Eletvar 0)))\n  ?v",
                    "_goal : Val.lessdef (Val.longofint x) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.longofint x) (Val.longofwords v1 x)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint x) (Val.longofwords v1 x)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.longofint Vundef) (Val.longofwords v1 Vundef)",
                    "_goal : Val.lessdef (Val.longofint (Vint i)) (Val.longofwords v1 (Vint i))",
                    "_goal : Val.lessdef (Val.longofint (Vlong i)) (Val.longofwords v1 (Vlong i))",
                    "_goal : Val.lessdef (Val.longofint (Vfloat f)) (Val.longofwords v1 (Vfloat f))",
                    "_goal : Val.lessdef (Val.longofint (Vsingle f))\n  (Val.longofwords v1 (Vsingle f))",
                    "_goal : Val.lessdef (Val.longofint (Vptr b i)) (Val.longofwords v1 (Vptr b i))",
                    "B : Val.lessdef (Val.shr Vundef (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons Vundef le) (shrimm (Eletvar 0) (Int.repr 31))\n  v1",
                    "H : eval_expr ge sp e m le e0 Vundef",
                    "B : Val.lessdef (Val.shr (Vint i) (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons (Vint i) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "H : eval_expr ge sp e m le e0 (Vint i)",
                    "i : Int.int",
                    "B : Val.lessdef (Val.shr (Vlong i) (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons (Vlong i) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "H : eval_expr ge sp e m le e0 (Vlong i)",
                    "i : Int64.int",
                    "B : Val.lessdef (Val.shr (Vfloat f) (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons (Vfloat f) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "H : eval_expr ge sp e m le e0 (Vfloat f)",
                    "f : float",
                    "B : Val.lessdef (Val.shr (Vsingle f) (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons (Vsingle f) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "H : eval_expr ge sp e m le e0 (Vsingle f)",
                    "f : float32",
                    "B : Val.lessdef (Val.shr (Vptr b i) (Vint (Int.repr 31))) v1",
                    "A : eval_expr ge sp e m (cons (Vptr b i) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v1",
                    "H : eval_expr ge sp e m le e0 (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint Vundef) (Val.longofwords v1 Vundef)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 Vundef)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 Vundef)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vint i)) (Val.longofwords v1 (Vint i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords v1 (Vint i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords v1 (Vint i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords v1 (Vint i))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vlong i)) (Val.longofwords v1 (Vlong i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vlong i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vlong i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vfloat f)) (Val.longofwords v1 (Vfloat f))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vfloat f))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vfloat f))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vsingle f))\n  (Val.longofwords v1 (Vsingle f))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vsingle f))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vsingle f))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.longofint (Vptr b i)) (Val.longofwords v1 (Vptr b i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vptr b i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v1 (Vptr b i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.shr (Vint i) (Vint (Int.repr 31))) v1"
                ],
                "tactic_res": [
                    "B : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords v1 (Vint i))",
                    "B : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef) v1"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))",
                    "A : eval_expr ge sp e m (cons (Vint i) le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr i (Int.repr 31))\n   else Vundef)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))"
                ]
            },
            {
                "tactic_sig": "replace ( Int64.repr ( Int.signed _i ) ) with ( Int64.ofwords ( Int.shr _i ( Int.repr 31 ) ) _i ) .",
                "tactic_sig_no_out_arg": "replace ( Int64.repr ( Int.signed _i ) ) with ( Int64.ofwords ( Int.shr _i ( Int.repr 31 ) ) _i ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.repr (Int.signed i)))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))",
                    "i : Int.int",
                    "i : Int.int",
                    "i : Int.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.ofwords (Int.shr i (Int.repr 31)) i))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))",
                    "_goal : eq (Int64.ofwords (Int.shr i (Int.repr 31)) i)\n  (Int64.repr (Int.signed i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.ofwords (Int.shr i (Int.repr 31)) i))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr i (Int.repr 31))\n      else Vundef) (Vint i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.shr i (Int.repr 31)) i)\n  (Int64.repr (Int.signed i))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.shr i (Int.repr 31)) i)\n  (Int64.repr (Int.signed i))"
                ]
            },
            {
                "tactic_sig": "apply Int64.same_bits_eq .",
                "tactic_sig_no_out_arg": "apply Int64.same_bits_eq .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.shr i (Int.repr 31)) i)\n  (Int64.repr (Int.signed i))"
                ],
                "tactic_res": [
                    "_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Int64.testbit (Int64.repr (Int.signed i)) i0)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i0 : Z) (_ : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Int64.testbit (Int64.repr (Int.signed i)) i0)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Int64.testbit (Int64.repr (Int.signed i)) i0)",
                    "H0 : Logic.and (Z.le 0 i0) (Z.lt i0 Int64.zwordsize)",
                    "i0 : Z"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.testbit_repr by auto .",
                "tactic_sig_no_out_arg": "rewrite Int64.testbit_repr by auto .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Int64.testbit (Int64.repr (Int.signed i)) i0)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Z.testbit (Int.signed i) i0)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_ofwords by auto .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_ofwords by auto .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords (Int.shr i (Int.repr 31)) i) i0)\n  (Z.testbit (Int.signed i) i0)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Z.testbit (Int.signed i) i0)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_signed by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_signed by lia .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Z.testbit (Int.signed i) i0)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Int.testbit i\n     (if zlt i0 Int.zwordsize then i0 else Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i Int.zwordsize ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i Int.zwordsize ) .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt i0 Int.zwordsize\n   then Int.testbit i i0\n   else Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Int.testbit i\n     (if zlt i0 Int.zwordsize then i0 else Z.sub Int.zwordsize 1))",
                    "i0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit i i0) (Int.testbit i i0)",
                    "_goal : eq (Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Int.testbit i (Z.sub Int.zwordsize 1))",
                    "l : Z.lt i0 Int.zwordsize",
                    "g : Z.ge i0 Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int.testbit i i0) (Int.testbit i i0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Int64.zwordsize = 2 * Int.zwordsize ) by reflexivity .",
                "tactic_sig_no_out_arg": "assert ( Int64.zwordsize = 2 * Int.zwordsize ) by reflexivity .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq Int64.zwordsize (Z.mul 2 Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_shr by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_shr by lia .",
                "tactic_args": [
                    "_goal : eq (Int.testbit (Int.shr i (Int.repr 31)) (Z.sub i0 Int.zwordsize))\n  (Int.testbit i (Z.sub Int.zwordsize 1))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Int.testbit i\n     (if\n       zlt\n         (Z.add (Z.sub i0 Int.zwordsize) (Int.unsigned (Int.repr 31)))\n         Int.zwordsize\n      then Z.add (Z.sub i0 Int.zwordsize) (Int.unsigned (Int.repr 31))\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit i (Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "change ( Int.unsigned ( Int.repr 31 ) ) with ( Int.zwordsize - 1 ) .",
                "tactic_sig_no_out_arg": "change ( Int.unsigned ( Int.repr 31 ) ) with ( Int.zwordsize - 1 ) .",
                "tactic_args": [
                    "_goal : eq\n  (Int.testbit i\n     (if\n       zlt\n         (Z.add (Z.sub i0 Int.zwordsize) (Int.unsigned (Int.repr 31)))\n         Int.zwordsize\n      then Z.add (Z.sub i0 Int.zwordsize) (Int.unsigned (Int.repr 31))\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit i (Z.sub Int.zwordsize 1))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Int.testbit i\n     (if\n       zlt (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n         Int.zwordsize\n      then Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit i (Z.sub Int.zwordsize 1))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq\n  (Int.testbit i\n     (if\n       zlt (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n         Int.zwordsize\n      then Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1)\n      else Z.sub Int.zwordsize 1))\n  (Int.testbit i (Z.sub Int.zwordsize 1))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if\n    zlt (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n      Int.zwordsize\n   then Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1)\n   else Z.sub Int.zwordsize 1) (Z.sub Int.zwordsize 1)"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( _i - Int.zwordsize + ( Int.zwordsize - 1 ) ) Int.zwordsize ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( _i - Int.zwordsize + ( Int.zwordsize - 1 ) ) Int.zwordsize ) .",
                "tactic_args": [
                    "_goal : eq\n  (if\n    zlt (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n      Int.zwordsize\n   then Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1)\n   else Z.sub Int.zwordsize 1) (Z.sub Int.zwordsize 1)",
                    "i0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n  (Z.sub Int.zwordsize 1)",
                    "_goal : eq (Z.sub Int.zwordsize 1) (Z.sub Int.zwordsize 1)",
                    "l : Z.lt (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n  Int.zwordsize",
                    "g0 : Z.ge (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n  Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (Z.add (Z.sub i0 Int.zwordsize) (Z.sub Int.zwordsize 1))\n  (Z.sub Int.zwordsize 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (Z.sub Int.zwordsize 1) (Z.sub Int.zwordsize 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_negl",
        "proof": [
            {
                "tactic_sig": "unfold negl .",
                "tactic_sig_no_out_arg": "unfold negl .",
                "tactic_args": [
                    "_goal : unary_constructor_sound negl Val.negl"
                ],
                "tactic_res": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match is_longconst e with\n   | Some n => longconst (Int64.neg n)\n   | None =>\n       Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs e Enil)\n   end) Val.negl"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound\n  (fun e : expr =>\n   match is_longconst e with\n   | Some n => longconst (Int64.neg n)\n   | None =>\n       Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs e Enil)\n   end) Val.negl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n => longconst (Int64.neg n)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l)\n              (Econs a Enil)\n        end v) (Val.lessdef (Val.negl x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n => longconst (Int64.neg n)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l)\n              (Econs a Enil)\n        end v) (Val.lessdef (Val.negl x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n => longconst (Int64.neg n)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l)\n              (Econs a Enil)\n        end v) (Val.lessdef (Val.negl x) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) eqn : E .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n => longconst (Int64.neg n)\n        | None =>\n            Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l)\n              (Econs a Enil)\n        end v) (Val.lessdef (Val.negl x) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.neg i)) v)\n     (Val.lessdef (Val.negl x) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n        v) (Val.lessdef (Val.negl x) v))",
                    "E : eq (is_longconst a) (Some i)",
                    "i : Int64.int",
                    "E : eq (is_longconst a) None"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.neg i)) v)\n     (Val.lessdef (Val.negl x) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.neg i)) ?v)\n  (Val.lessdef (Val.negl x) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.neg i)) ?v)\n  (Val.lessdef (Val.negl x) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.neg i)) ?v",
                    "_goal : Val.lessdef (Val.negl x) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.neg i)) ?v",
                    "_goal : Val.lessdef (Val.negl x) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "exploit is_longconst_sound .",
                "tactic_sig_no_out_arg": "exploit is_longconst_sound .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong i),\nVal.lessdef (Val.negl x) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.negl x) (Vlong (Int64.neg i))",
                    "EQ : eq x (Vlong i)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.negl x) (Vlong (Int64.neg i))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.negl (Vlong i)) (Vlong (Int64.neg i))",
                    "H : eval_expr ge sp e m le a (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.negl (Vlong i)) (Vlong (Int64.neg i))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.neg i)) (Vlong (Int64.neg i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.neg i)) (Vlong (Int64.neg i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists ( Val.negl _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.negl _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n        v) (Val.lessdef (Val.negl x) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n     (Val.negl x)) (Val.lessdef (Val.negl x) (Val.negl x))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n     (Val.negl x)) (Val.lessdef (Val.negl x) (Val.negl x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n  (Val.negl x)",
                    "_goal : Val.lessdef (Val.negl x) (Val.negl x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n  (Val.negl x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n  (Val.negl x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.negl x) (Val.negl x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( eval_builtin_1 ( BI_standard BI_negl ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_builtin_1 ( BI_standard BI_negl ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Ebuiltin (EF_builtin \"__builtin_negl\" sig_l_l) (Econs a Enil))\n  (Val.negl x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (lookup_builtin_function \"__builtin_negl\" sig_l_l)\n  (Some (BI_standard BI_negl))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_negl) (cons ?varg1 nil))\n  (Some (Val.negl x))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_negl) (cons ?varg1 nil))\n  (Some (Val.negl x))"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_negl) (cons x nil))\n  (Some (Val.negl x))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_negl\" sig_l_l)\n  (Some (BI_standard BI_negl))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_negl) (cons x nil))\n  (Some (Val.negl x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_notl",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound notl Val.notl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (notl a) v)\n     (Val.lessdef (Val.notl x) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (notl a) v)\n     (Val.lessdef (Val.notl x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (notl a) v)\n     (Val.lessdef (Val.notl x) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold notl .",
                "tactic_sig_no_out_arg": "unfold notl .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (notl a) v)\n     (Val.lessdef (Val.notl x) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a (fun h l : expr => makelong (notint h) (notint l)))\n        v) (Val.lessdef (Val.notl x) v))"
                ]
            },
            {
                "tactic_sig": "apply eval_splitlong .",
                "tactic_sig_no_out_arg": "apply eval_splitlong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a (fun h l : expr => makelong (notint h) (notint l)))\n        v) (Val.lessdef (Val.notl x) v))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.notl x) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (notint a) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "H1 : eval_expr ge sp e m le0 b y",
                    "H0 : eval_expr ge sp e m le0 a0 x0",
                    "x0 : val",
                    "y : val",
                    "a0 : expr",
                    "b : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_notint .",
                "tactic_sig_no_out_arg": "exploit eval_notint .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (notint ?Goal5) v)\n           (Val.lessdef (Val.notint ?Goal6) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (notint ?Goal5) v)\n           (Val.lessdef (Val.notint ?Goal6) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "H0 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (notint a0) v)\n           (Val.lessdef (Val.notint x0) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ va [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (notint a0) v)\n           (Val.lessdef (Val.notint x0) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "B : Val.lessdef (Val.notint x0) va",
                    "A : eval_expr ge sp e m le0 (notint a0) va",
                    "va : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_notint .",
                "tactic_sig_no_out_arg": "exploit eval_notint .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (notint ?Goal5) v)\n           (Val.lessdef (Val.notint ?Goal6) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (notint ?Goal5) v)\n           (Val.lessdef (Val.notint ?Goal6) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "H1 : eval_expr ge sp e m le0 b y"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (notint b) v)\n           (Val.lessdef (Val.notint y) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ vb [ C D ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (notint b) v)\n           (Val.lessdef (Val.notint y) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "D : Val.lessdef (Val.notint y) vb",
                    "C : eval_expr ge sp e m le0 (notint b) vb",
                    "vb : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (notint a0) (notint b)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.notl (Vlong (Int64.ofwords p q)))))",
                    "va : val",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n     (Val.longofwords va vb))\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n     (Val.longofwords va vb))\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n  (Val.longofwords va vb)",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (makelong (notint a0) (notint b))\n  (Val.longofwords va vb)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q)))",
                    "H3 : eq y (Vint q)",
                    "H2 : eq x0 (Vint p)",
                    "p : Int.int",
                    "q : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "D : Val.lessdef (Val.notint (Vint q)) vb",
                    "B : Val.lessdef (Val.notint (Vint p)) va",
                    "H1 : eval_expr ge sp e m le0 b (Vint q)",
                    "H0 : eval_expr ge sp e m le0 a0 (Vint p)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords va vb) (Val.notl (Vlong (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords va vb) (Vlong (Int64.not (Int64.ofwords p q)))",
                    "D : Val.lessdef (Vint (Int.not q)) vb",
                    "B : Val.lessdef (Vint (Int.not p)) va"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords va vb) (Vlong (Int64.not (Int64.ofwords p q)))",
                    "B : Val.lessdef (Vint (Int.not p)) va"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.not p)) vb)\n  (Vlong (Int64.not (Int64.ofwords p q)))",
                    "A : eval_expr ge sp e m le0 (notint a0) (Vint (Int.not p))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.not p)) vb)\n  (Vlong (Int64.not (Int64.ofwords p q)))",
                    "D : Val.lessdef (Vint (Int.not q)) vb"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.not p)) (Vint (Int.not q)))\n  (Vlong (Int64.not (Int64.ofwords p q)))",
                    "C : eval_expr ge sp e m le0 (notint b) (Vint (Int.not q))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.not p)) (Vint (Int.not q)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.not p) (Int.not q)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ]
            },
            {
                "tactic_sig": "unfold Int.not .",
                "tactic_sig_no_out_arg": "unfold Int.not .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.not p) (Int.not q)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.xor p Int.mone) (Int.xor q Int.mone)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- Int64.decompose_xor .",
                "tactic_sig_no_out_arg": "rewrite <- Int64.decompose_xor .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.xor p Int.mone) (Int.xor q Int.mone)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.xor (Int64.ofwords p q) (Int64.ofwords Int.mone Int.mone)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.xor (Int64.ofwords p q) (Int64.ofwords Int.mone Int.mone)))\n  (Vlong (Int64.not (Int64.ofwords p q)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.notl x) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.notl Vundef) Vundef",
                    "_goal : eq (Val.notl (Vint i)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.notl (Vfloat f)) Vundef",
                    "_goal : eq (Val.notl (Vsingle f)) Vundef",
                    "_goal : eq (Val.notl (Vptr b i)) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.notl Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.notl (Vint i)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.notl (Vfloat f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.notl (Vsingle f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.notl (Vptr b i)) Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longoffloat",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.longoffloat x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.longoffloat x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longoffloat .",
                "tactic_sig_no_out_arg": "unfold longoffloat .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_dtos sig_f_l (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_dtos sig_f_l (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (Econs a Enil))\n     ?v) (Val.lessdef y ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (Econs a Enil))\n     ?v) (Val.lessdef y ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (Econs a Enil)) ?v",
                    "_goal : Val.lessdef y ?v"
                ]
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_dtos ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_dtos ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_dtos sig_f_l (Econs a Enil)) ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l",
                    "_goal : eq (lookup_builtin_function ?name sig_f_l)\n  (Some (BI_standard BI_i64_dtos))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtos) (cons ?varg1 nil))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtos) (cons ?varg1 nil))\n  (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtos) (cons x nil))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtos) (cons x nil))\n  (Some ?v)",
                    "_goal : Val.lessdef y ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtos ?name sig_f_l",
                    "_goal : eq (lookup_builtin_function ?name sig_f_l)\n  (Some (BI_standard BI_i64_dtos))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_dtos\" sig_f_l)\n  (Some (BI_standard BI_i64_dtos))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_dtos\" sig_f_l)\n  (Some (BI_standard BI_i64_dtos))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longuoffloat",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.longuoffloat x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuoffloat a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuoffloat a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.longuoffloat x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longuoffloat .",
                "tactic_sig_no_out_arg": "unfold longuoffloat .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuoffloat a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_dtou sig_f_l (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_dtou sig_f_l (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (Econs a Enil))\n     ?v) (Val.lessdef y ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (Econs a Enil))\n     ?v) (Val.lessdef y ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (Econs a Enil)) ?v",
                    "_goal : Val.lessdef y ?v"
                ]
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_dtou ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_dtou ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_dtou sig_f_l (Econs a Enil)) ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l",
                    "_goal : eq (lookup_builtin_function ?name sig_f_l)\n  (Some (BI_standard BI_i64_dtou))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtou) (cons ?varg1 nil))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtou) (cons ?varg1 nil))\n  (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtou) (cons x nil))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_dtou) (cons x nil))\n  (Some ?v)",
                    "_goal : Val.lessdef y ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_dtou ?name sig_f_l",
                    "_goal : eq (lookup_builtin_function ?name sig_f_l)\n  (Some (BI_standard BI_i64_dtou))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_dtou\" sig_f_l)\n  (Some (BI_standard BI_i64_dtou))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_dtou\" sig_f_l)\n  (Some (BI_standard BI_i64_dtou))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_floatoflong",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.floatoflong x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflong a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflong a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.floatoflong x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold floatoflong .",
                "tactic_sig_no_out_arg": "unfold floatoflong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflong a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_stod sig_l_f (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_stod sig_l_f (Econs a Enil)) v)\n     (Val.lessdef y v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y",
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_stod ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_stod ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stod sig_l_f (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_stod ?name sig_l_f",
                    "_goal : eq (lookup_builtin_function ?name sig_l_f)\n  (Some (BI_standard BI_i64_stod))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stod) (cons ?varg1 nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stod) (cons ?varg1 nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stod) (cons x nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stod ?name sig_l_f",
                    "_goal : eq (lookup_builtin_function ?name sig_l_f)\n  (Some (BI_standard BI_i64_stod))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_stod\" sig_l_f)\n  (Some (BI_standard BI_i64_stod))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_stod\" sig_l_f)\n  (Some (BI_standard BI_i64_stod))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stod) (cons x nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vfloat (Float.of_long n)\n     | _ => Vundef\n     end) (Some y)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vfloat (Float.of_long n)\n     | _ => Vundef\n     end) (Some y)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some (Vfloat (Float.of_long i))) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq (Val.floatoflong Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.floatoflong (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.floatoflong (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.floatoflong (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.floatoflong (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.floatoflong (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Vfloat (Float.of_long i))) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some (Vfloat (Float.of_long i))) (Some y)",
                    "H0 : eq (Some (Vfloat (Float.of_long i))) (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vfloat (Float.of_long i))) (Some (Vfloat (Float.of_long i)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Vfloat (Float.of_long i))) (Some (Vfloat (Float.of_long i)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflong (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_floatoflongu",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.floatoflongu x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflongu a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflongu a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.floatoflongu x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold floatoflongu .",
                "tactic_sig_no_out_arg": "unfold floatoflongu .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (floatoflongu a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_utod sig_l_f (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_utod sig_l_f (Econs a Enil)) v)\n     (Val.lessdef y v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y",
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_utod ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_utod ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utod sig_l_f (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_utod ?name sig_l_f",
                    "_goal : eq (lookup_builtin_function ?name sig_l_f)\n  (Some (BI_standard BI_i64_utod))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utod) (cons ?varg1 nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utod) (cons ?varg1 nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utod) (cons x nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utod ?name sig_l_f",
                    "_goal : eq (lookup_builtin_function ?name sig_l_f)\n  (Some (BI_standard BI_i64_utod))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_utod\" sig_l_f)\n  (Some (BI_standard BI_i64_utod))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_utod\" sig_l_f)\n  (Some (BI_standard BI_i64_utod))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utod) (cons x nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vfloat (Float.of_longu n)\n     | _ => Vundef\n     end) (Some y)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vfloat (Float.of_longu n)\n     | _ => Vundef\n     end) (Some y)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some (Vfloat (Float.of_longu i))) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq (Val.floatoflongu Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.floatoflongu (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.floatoflongu (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.floatoflongu (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.floatoflongu (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.floatoflongu (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Vfloat (Float.of_longu i))) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some (Vfloat (Float.of_longu i))) (Some y)",
                    "H0 : eq (Some (Vfloat (Float.of_longu i))) (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vfloat (Float.of_longu i)))\n  (Some (Vfloat (Float.of_longu i)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Vfloat (Float.of_longu i)))\n  (Some (Vfloat (Float.of_longu i)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.floatoflongu (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longofsingle",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.longofsingle x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofsingle a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofsingle a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.longofsingle x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longofsingle .",
                "tactic_sig_no_out_arg": "unfold longofsingle .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longofsingle a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "x : val"
                ],
                "tactic_res": [
                    "H0 : eq (Val.longofsingle Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.longofsingle (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.longofsingle (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.longofsingle (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.longofsingle (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.longofsingle (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Vlong (Float32.to_long f)) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq (option_map Vlong (Float32.to_long f)) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq (option_map Vlong (Float32.to_long f)) (Some y)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longofsingle (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Float32.to_long _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Float32.to_long _i ) as [ n| ] eqn : EQ .",
                "tactic_args": [
                    "f : float32"
                ],
                "tactic_res": [
                    "H2 : eq (option_map Vlong (Some n)) (Some y)",
                    "EQ : eq (Float32.to_long f) (Some n)",
                    "n : Int64.int",
                    "H2 : eq (option_map Vlong None) (Some y)",
                    "EQ : eq (Float32.to_long f) None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H2 : eq (option_map Vlong (Some n)) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq (Some (Vlong n)) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H2 : eq (Some (Vlong n)) (Some y)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H2 : eq (option_map Vlong None) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef y v))",
                    "H2 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_floatofsingle .",
                "tactic_sig_no_out_arg": "exploit eval_floatofsingle .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (floatofsingle ?Goal4) v)\n           (Val.lessdef (Val.floatofsingle ?Goal5) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (floatofsingle ?Goal4) v)\n           (Val.lessdef (Val.floatofsingle ?Goal5) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( v & A & B ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))",
                    "B : Val.lessdef (Val.floatofsingle (Vsingle f)) v",
                    "A : eval_expr ge sp e m le (floatofsingle a) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.floatofsingle (Vsingle f)) v"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vfloat (Float.of_single f)) v"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vfloat (Float.of_single f)) v"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))"
                ]
            },
            {
                "tactic_sig": "apply Float32.to_long_double in _i .",
                "tactic_sig_no_out_arg": "apply Float32.to_long_double in _i .",
                "tactic_args": [
                    "EQ : eq (Float32.to_long f) (Some n)"
                ],
                "tactic_res": [
                    "EQ : eq (Float.to_long (Float32.to_double f)) (Some n)"
                ]
            },
            {
                "tactic_sig": "eapply eval_longoffloat .",
                "tactic_sig_no_out_arg": "eapply eval_longoffloat .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (floatofsingle a) ?x",
                    "_goal : eq (Val.longoffloat ?x) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (floatofsingle a) ?x",
                    "_goal : eq (Val.longoffloat ?x) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Val.longoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Float.to_long (Float.of_single f)))\n  (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "change ( Float.of_single _i ) with ( Float32.to_double _i ) .",
                "tactic_sig_no_out_arg": "change ( Float.of_single _i ) with ( Float32.to_double _i ) .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Float.to_long (Float.of_single f)))\n  (Some (Vlong n))",
                    "f : float32",
                    "f : float32"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Float.to_long (Float32.to_double f)))\n  (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Float.to_long (Float32.to_double f)))\n  (Some (Vlong n))",
                    "EQ : eq (Float.to_long (Float32.to_double f)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Some n)) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Some n)) (Some (Vlong n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_longuofsingle",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.longuofsingle x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuofsingle a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuofsingle a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.longuofsingle x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold longuofsingle .",
                "tactic_sig_no_out_arg": "unfold longuofsingle .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longuofsingle a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "x : val"
                ],
                "tactic_res": [
                    "H0 : eq (Val.longuofsingle Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.longuofsingle (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.longuofsingle (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.longuofsingle (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.longuofsingle (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.longuofsingle (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Vlong (Float32.to_longu f)) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq (option_map Vlong (Float32.to_longu f)) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq (option_map Vlong (Float32.to_longu f)) (Some y)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.longuofsingle (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Float32.to_longu _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Float32.to_longu _i ) as [ n| ] eqn : EQ .",
                "tactic_args": [
                    "f : float32"
                ],
                "tactic_res": [
                    "H2 : eq (option_map Vlong (Some n)) (Some y)",
                    "EQ : eq (Float32.to_longu f) (Some n)",
                    "n : Int64.int",
                    "H2 : eq (option_map Vlong None) (Some y)",
                    "EQ : eq (Float32.to_longu f) None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H2 : eq (option_map Vlong (Some n)) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq (Some (Vlong n)) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H2 : eq (Some (Vlong n)) (Some y)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H2 : eq (option_map Vlong None) (Some y)"
                ],
                "tactic_res": [
                    "H2 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef y v))",
                    "H2 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_floatofsingle .",
                "tactic_sig_no_out_arg": "exploit eval_floatofsingle .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (floatofsingle ?Goal4) v)\n           (Val.lessdef (Val.floatofsingle ?Goal5) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (floatofsingle ?Goal4) v)\n           (Val.lessdef (Val.floatofsingle ?Goal5) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( v & A & B ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (floatofsingle a) v)\n           (Val.lessdef (Val.floatofsingle (Vsingle f)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))",
                    "B : Val.lessdef (Val.floatofsingle (Vsingle f)) v",
                    "A : eval_expr ge sp e m le (floatofsingle a) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.floatofsingle (Vsingle f)) v"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vfloat (Float.of_single f)) v"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vfloat (Float.of_single f)) v"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (floatofsingle a) (Vfloat (Float.of_single f))"
                ]
            },
            {
                "tactic_sig": "apply Float32.to_longu_double in _i .",
                "tactic_sig_no_out_arg": "apply Float32.to_longu_double in _i .",
                "tactic_args": [
                    "EQ : eq (Float32.to_longu f) (Some n)"
                ],
                "tactic_res": [
                    "EQ : eq (Float.to_longu (Float32.to_double f)) (Some n)"
                ]
            },
            {
                "tactic_sig": "eapply eval_longuoffloat .",
                "tactic_sig_no_out_arg": "eapply eval_longuoffloat .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (longuoffloat (floatofsingle a)) v)\n     (Val.lessdef (Vlong n) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (floatofsingle a) ?x",
                    "_goal : eq (Val.longuoffloat ?x) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (floatofsingle a) ?x",
                    "_goal : eq (Val.longuoffloat ?x) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longuoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Val.longuoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longuoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longuoffloat (Vfloat (Float.of_single f))) (Some (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Float.to_longu (Float.of_single f)))\n  (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "change ( Float.of_single _i ) with ( Float32.to_double _i ) .",
                "tactic_sig_no_out_arg": "change ( Float.of_single _i ) with ( Float32.to_double _i ) .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Float.to_longu (Float.of_single f)))\n  (Some (Vlong n))",
                    "f : float32",
                    "f : float32"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Float.to_longu (Float32.to_double f)))\n  (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Float.to_longu (Float32.to_double f)))\n  (Some (Vlong n))",
                    "EQ : eq (Float.to_longu (Float32.to_double f)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Vlong (Some n)) (Some (Vlong n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (option_map Vlong (Some n)) (Some (Vlong n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_singleoflong",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.singleoflong x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflong a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflong a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.singleoflong x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold singleoflong .",
                "tactic_sig_no_out_arg": "unfold singleoflong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflong a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_stof sig_l_s (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_stof sig_l_s (Econs a Enil)) v)\n     (Val.lessdef y v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y",
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_stof ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_stof ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_stof sig_l_s (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_stof ?name sig_l_s",
                    "_goal : eq (lookup_builtin_function ?name sig_l_s)\n  (Some (BI_standard BI_i64_stof))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stof) (cons ?varg1 nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stof) (cons ?varg1 nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stof) (cons x nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_stof ?name sig_l_s",
                    "_goal : eq (lookup_builtin_function ?name sig_l_s)\n  (Some (BI_standard BI_i64_stof))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_stof\" sig_l_s)\n  (Some (BI_standard BI_i64_stof))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_stof\" sig_l_s)\n  (Some (BI_standard BI_i64_stof))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_stof) (cons x nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vsingle (Float32.of_long n)\n     | _ => Vundef\n     end) (Some y)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vsingle (Float32.of_long n)\n     | _ => Vundef\n     end) (Some y)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some (Vsingle (Float32.of_long i))) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq (Val.singleoflong Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.singleoflong (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.singleoflong (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.singleoflong (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.singleoflong (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.singleoflong (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Vsingle (Float32.of_long i))) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some (Vsingle (Float32.of_long i))) (Some y)",
                    "H0 : eq (Some (Vsingle (Float32.of_long i))) (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vsingle (Float32.of_long i)))\n  (Some (Vsingle (Float32.of_long i)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Vsingle (Float32.of_long i)))\n  (Some (Vsingle (Float32.of_long i)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflong (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_singleoflongu",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.singleoflongu x) (Some y)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflongu a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflongu a) v)\n     (Val.lessdef y v))",
                    "H0 : eq (Val.singleoflongu x) (Some y)",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold singleoflongu .",
                "tactic_sig_no_out_arg": "unfold singleoflongu .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (singleoflongu a) v)\n     (Val.lessdef y v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_utof sig_l_s (Econs a Enil)) v)\n     (Val.lessdef y v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_utof sig_l_s (Econs a Enil)) v)\n     (Val.lessdef y v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y)\n  (Val.lessdef y y)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y",
                    "_goal : Val.lessdef y y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef y y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply ( eval_helper_1 ( BI_standard BI_i64_utof ) ) .",
                "tactic_sig_no_out_arg": "eapply ( eval_helper_1 ( BI_standard BI_i64_utof ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eexternal i64_utof sig_l_s (Econs a Enil)) y"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : helper_declared prog i64_utof ?name sig_l_s",
                    "_goal : eq (lookup_builtin_function ?name sig_l_s)\n  (Some (BI_standard BI_i64_utof))",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utof) (cons ?varg1 nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utof) (cons ?varg1 nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utof) (cons x nil))\n  (Some y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_utof ?name sig_l_s",
                    "_goal : eq (lookup_builtin_function ?name sig_l_s)\n  (Some (BI_standard BI_i64_utof))"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_utof\" sig_l_s)\n  (Some (BI_standard BI_i64_utof))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_utof\" sig_l_s)\n  (Some (BI_standard BI_i64_utof))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_i64_utof) (cons x nil))\n  (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vsingle (Float32.of_longu n)\n     | _ => Vundef\n     end) (Some y)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq\n  (Some\n     match x with\n     | Vlong n => Vsingle (Float32.of_longu n)\n     | _ => Vundef\n     end) (Some y)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some (Vsingle (Float32.of_longu i))) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq (Val.singleoflongu Vundef) (Some y)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H0 : eq (Val.singleoflongu (Vint i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H0 : eq (Val.singleoflongu (Vlong i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H0 : eq (Val.singleoflongu (Vfloat f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H0 : eq (Val.singleoflongu (Vsingle f)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H0 : eq (Val.singleoflongu (Vptr b i)) (Some y)",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu Vundef) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu (Vint i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu (Vlong i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Vsingle (Float32.of_longu i))) (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some (Vsingle (Float32.of_longu i))) (Some y)",
                    "H0 : eq (Some (Vsingle (Float32.of_longu i))) (Some y)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Vsingle (Float32.of_longu i)))\n  (Some (Vsingle (Float32.of_longu i)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Vsingle (Float32.of_longu i)))\n  (Some (Vsingle (Float32.of_longu i)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu (Vfloat f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu (Vsingle f)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (Val.singleoflongu (Vptr b i)) (Some y)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some y)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Some Vundef) (Some y)",
                    "H0 : eq None (Some y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_andl",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound andl Val.andl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (andl a b) v)\n     (Val.lessdef (Val.andl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (andl a b) v)\n     (Val.lessdef (Val.andl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (andl a b) v)\n     (Val.lessdef (Val.andl x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold andl .",
                "tactic_sig_no_out_arg": "unfold andl .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (andl a b) v)\n     (Val.lessdef (Val.andl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (and h1 h2) (and l1 l2)))\n        v) (Val.lessdef (Val.andl x y) v))"
                ]
            },
            {
                "tactic_sig": "apply eval_splitlong2 .",
                "tactic_sig_no_out_arg": "apply eval_splitlong2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (and h1 h2) (and l1 l2)))\n        v) (Val.lessdef (Val.andl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.andl x y) Vundef\n    end\n| _ => eq (Val.andl x y) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2",
                    "H3 : eval_expr ge sp e m le0 b1 y1",
                    "H2 : eval_expr ge sp e m le0 a2 x2",
                    "H1 : eval_expr ge sp e m le0 a1 x1",
                    "x1 : val",
                    "x2 : val",
                    "y1 : val",
                    "y2 : val",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_and .",
                "tactic_sig_no_out_arg": "exploit eval_and .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (and ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.and ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (and ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.and ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H1 : eval_expr ge sp e m le0 a1 x1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a1 ?Goal0) v)\n           (Val.lessdef (Val.and x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a1 ?Goal0) v)\n           (Val.lessdef (Val.and x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H3 : eval_expr ge sp e m le0 b1 y1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a1 b1) v)\n           (Val.lessdef (Val.and x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ va [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a1 b1) v)\n           (Val.lessdef (Val.and x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "B : Val.lessdef (Val.and x1 y1) va",
                    "A : eval_expr ge sp e m le0 (and a1 b1) va",
                    "va : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_and .",
                "tactic_sig_no_out_arg": "exploit eval_and .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (and ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.and ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (and ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.and ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H2 : eval_expr ge sp e m le0 a2 x2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a2 ?Goal0) v)\n           (Val.lessdef (Val.and x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a2 ?Goal0) v)\n           (Val.lessdef (Val.and x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a2 b2) v)\n           (Val.lessdef (Val.and x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ vb [ C D ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (and a2 b2) v)\n           (Val.lessdef (Val.and x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "D : Val.lessdef (Val.and x2 y2) vb",
                    "C : eval_expr ge sp e m le0 (and a2 b2) vb",
                    "vb : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.andl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "va : val",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.andl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.andl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n  (Val.longofwords va vb)",
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (makelong (and a1 b1) (and a2 b2))\n  (Val.longofwords va vb)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H8 : eq y2 (Vint q2)",
                    "H7 : eq y1 (Vint q1)",
                    "H6 : eq x2 (Vint p2)",
                    "H5 : eq x1 (Vint p1)",
                    "p1 : Int.int",
                    "p2 : Int.int",
                    "q1 : Int.int",
                    "q2 : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb",
                    "B : Val.lessdef (Val.and (Vint p1) (Vint q1)) va",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint q2)",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint q1)",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint p2)",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint p1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.and (Vint p1) (Vint q1)) va"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vint (Int.and p1 q1)) va"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "B : Val.lessdef (Vint (Int.and p1 q1)) va"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.and p1 q1)) vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m le0 (and a1 b1) (Vint (Int.and p1 q1))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "D : Val.lessdef (Val.and (Vint p2) (Vint q2)) vb"
                ],
                "tactic_res": [
                    "D : Val.lessdef (Vint (Int.and p2 q2)) vb"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.and p1 q1)) vb)\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "D : Val.lessdef (Vint (Int.and p2 q2)) vb"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.and p1 q1)) (Vint (Int.and p2 q2)))\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "C : eval_expr ge sp e m le0 (and a2 b2) (Vint (Int.and p2 q2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.and p1 q1)) (Vint (Int.and p2 q2)))\n  (Val.andl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2)))\n  (Vlong (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2)))\n  (Vlong (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))\n  (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_and .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_and .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))\n  (Int64.and (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))\n  (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))\n  (Int64.ofwords (Int.and p1 q1) (Int.and p2 q2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.andl x y) Vundef\n    end\n| _ => eq (Val.andl x y) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.andl Vundef y) Vundef",
                    "_goal : eq (Val.andl (Vint i) y) Vundef",
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.andl (Vlong i) y) Vundef\nend",
                    "_goal : eq (Val.andl (Vfloat f) y) Vundef",
                    "_goal : eq (Val.andl (Vsingle f) y) Vundef",
                    "_goal : eq (Val.andl (Vptr b0 i) y) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl Vundef y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vint i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.andl (Vlong i) y) Vundef\nend"
                ],
                "tactic_res": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.andl (Vlong i) y) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vfloat f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vsingle f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vptr b0 i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.andl (Vlong i) y) Vundef\nend",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.andl (Vlong i) Vundef) Vundef",
                    "_goal : eq (Val.andl (Vlong i) (Vint i0)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.andl (Vlong i) (Vfloat f)) Vundef",
                    "_goal : eq (Val.andl (Vlong i) (Vsingle f)) Vundef",
                    "_goal : eq (Val.andl (Vlong i) (Vptr b0 i0)) Vundef",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vlong i) (Vint i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vlong i) (Vfloat f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vlong i) (Vsingle f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.andl (Vlong i) (Vptr b0 i0)) Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_orl",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound orl Val.orl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (orl a b) v)\n     (Val.lessdef (Val.orl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (orl a b) v)\n     (Val.lessdef (Val.orl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (orl a b) v)\n     (Val.lessdef (Val.orl x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold orl .",
                "tactic_sig_no_out_arg": "unfold orl .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (orl a b) v)\n     (Val.lessdef (Val.orl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (or h1 h2) (or l1 l2)))\n        v) (Val.lessdef (Val.orl x y) v))"
                ]
            },
            {
                "tactic_sig": "apply eval_splitlong2 .",
                "tactic_sig_no_out_arg": "apply eval_splitlong2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (or h1 h2) (or l1 l2)))\n        v) (Val.lessdef (Val.orl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.orl x y) Vundef\n    end\n| _ => eq (Val.orl x y) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2",
                    "H3 : eval_expr ge sp e m le0 b1 y1",
                    "H2 : eval_expr ge sp e m le0 a2 x2",
                    "H1 : eval_expr ge sp e m le0 a1 x1",
                    "x1 : val",
                    "x2 : val",
                    "y1 : val",
                    "y2 : val",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (or ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.or ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (or ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.or ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H1 : eval_expr ge sp e m le0 a1 x1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal0) v)\n           (Val.lessdef (Val.or x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal0) v)\n           (Val.lessdef (Val.or x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H3 : eval_expr ge sp e m le0 b1 y1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 b1) v)\n           (Val.lessdef (Val.or x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ va [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 b1) v)\n           (Val.lessdef (Val.or x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "B : Val.lessdef (Val.or x1 y1) va",
                    "A : eval_expr ge sp e m le0 (or a1 b1) va",
                    "va : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (or ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.or ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (or ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.or ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H2 : eval_expr ge sp e m le0 a2 x2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a2 ?Goal0) v)\n           (Val.lessdef (Val.or x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a2 ?Goal0) v)\n           (Val.lessdef (Val.or x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a2 b2) v)\n           (Val.lessdef (Val.or x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ vb [ C D ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a2 b2) v)\n           (Val.lessdef (Val.or x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "D : Val.lessdef (Val.or x2 y2) vb",
                    "C : eval_expr ge sp e m le0 (or a2 b2) vb",
                    "vb : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.orl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "va : val",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.orl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.orl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n  (Val.longofwords va vb)",
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (makelong (or a1 b1) (or a2 b2))\n  (Val.longofwords va vb)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H8 : eq y2 (Vint q2)",
                    "H7 : eq y1 (Vint q1)",
                    "H6 : eq x2 (Vint p2)",
                    "H5 : eq x1 (Vint p1)",
                    "p1 : Int.int",
                    "p2 : Int.int",
                    "q1 : Int.int",
                    "q2 : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb",
                    "B : Val.lessdef (Val.or (Vint p1) (Vint q1)) va",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint q2)",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint q1)",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint p2)",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint p1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.or (Vint p1) (Vint q1)) va"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vint (Int.or p1 q1)) va"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "B : Val.lessdef (Vint (Int.or p1 q1)) va"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.or p1 q1)) vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m le0 (or a1 b1) (Vint (Int.or p1 q1))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "D : Val.lessdef (Val.or (Vint p2) (Vint q2)) vb"
                ],
                "tactic_res": [
                    "D : Val.lessdef (Vint (Int.or p2 q2)) vb"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.or p1 q1)) vb)\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "D : Val.lessdef (Vint (Int.or p2 q2)) vb"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.or p1 q1)) (Vint (Int.or p2 q2)))\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "C : eval_expr ge sp e m le0 (or a2 b2) (Vint (Int.or p2 q2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.or p1 q1)) (Vint (Int.or p2 q2)))\n  (Val.orl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2)))\n  (Vlong (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2)))\n  (Vlong (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))\n  (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_or .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_or .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))\n  (Int64.or (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))\n  (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))\n  (Int64.ofwords (Int.or p1 q1) (Int.or p2 q2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.orl x y) Vundef\n    end\n| _ => eq (Val.orl x y) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.orl Vundef y) Vundef",
                    "_goal : eq (Val.orl (Vint i) y) Vundef",
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.orl (Vlong i) y) Vundef\nend",
                    "_goal : eq (Val.orl (Vfloat f) y) Vundef",
                    "_goal : eq (Val.orl (Vsingle f) y) Vundef",
                    "_goal : eq (Val.orl (Vptr b0 i) y) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl Vundef y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vint i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.orl (Vlong i) y) Vundef\nend"
                ],
                "tactic_res": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.orl (Vlong i) y) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vfloat f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vsingle f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vptr b0 i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.orl (Vlong i) y) Vundef\nend",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.orl (Vlong i) Vundef) Vundef",
                    "_goal : eq (Val.orl (Vlong i) (Vint i0)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.orl (Vlong i) (Vfloat f)) Vundef",
                    "_goal : eq (Val.orl (Vlong i) (Vsingle f)) Vundef",
                    "_goal : eq (Val.orl (Vlong i) (Vptr b0 i0)) Vundef",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vlong i) (Vint i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vlong i) (Vfloat f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vlong i) (Vsingle f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.orl (Vlong i) (Vptr b0 i0)) Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_xorl",
        "proof": [
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound xorl Val.xorl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (xorl a b) v)\n     (Val.lessdef (Val.xorl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (xorl a b) v)\n     (Val.lessdef (Val.xorl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (xorl a b) v)\n     (Val.lessdef (Val.xorl x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold xorl .",
                "tactic_sig_no_out_arg": "unfold xorl .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (xorl a b) v)\n     (Val.lessdef (Val.xorl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (xor h1 h2) (xor l1 l2)))\n        v) (Val.lessdef (Val.xorl x y) v))"
                ]
            },
            {
                "tactic_sig": "apply eval_splitlong2 .",
                "tactic_sig_no_out_arg": "apply eval_splitlong2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr => makelong (xor h1 h2) (xor l1 l2)))\n        v) (Val.lessdef (Val.xorl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.xorl x y) Vundef\n    end\n| _ => eq (Val.xorl x y) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2",
                    "H3 : eval_expr ge sp e m le0 b1 y1",
                    "H2 : eval_expr ge sp e m le0 a2 x2",
                    "H1 : eval_expr ge sp e m le0 a1 x1",
                    "x1 : val",
                    "x2 : val",
                    "y1 : val",
                    "y2 : val",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_xor .",
                "tactic_sig_no_out_arg": "exploit eval_xor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (xor ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xor ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (xor ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xor ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H1 : eval_expr ge sp e m le0 a1 x1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a1 ?Goal0) v)\n           (Val.lessdef (Val.xor x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a1 ?Goal0) v)\n           (Val.lessdef (Val.xor x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H3 : eval_expr ge sp e m le0 b1 y1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a1 b1) v)\n           (Val.lessdef (Val.xor x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ va [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a1 b1) v)\n           (Val.lessdef (Val.xor x1 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "B : Val.lessdef (Val.xor x1 y1) va",
                    "A : eval_expr ge sp e m le0 (xor a1 b1) va",
                    "va : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_xor .",
                "tactic_sig_no_out_arg": "exploit eval_xor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (xor ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xor ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (xor ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xor ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H2 : eval_expr ge sp e m le0 a2 x2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a2 ?Goal0) v)\n           (Val.lessdef (Val.xor x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a2 ?Goal0) v)\n           (Val.lessdef (Val.xor x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a2 b2) v)\n           (Val.lessdef (Val.xor x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ vb [ C D ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (xor a2 b2) v)\n           (Val.lessdef (Val.xor x2 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "D : Val.lessdef (Val.xor x2 y2) vb",
                    "C : eval_expr ge sp e m le0 (xor a2 b2) vb",
                    "vb : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i _i ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2)) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.xorl (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "va : val",
                    "vb : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.xorl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n     (Val.longofwords va vb))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords va vb)\n     (Val.xorl (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n  (Val.longofwords va vb)",
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (makelong (xor a1 b1) (xor a2 b2))\n  (Val.longofwords va vb)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords va vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H8 : eq y2 (Vint q2)",
                    "H7 : eq y1 (Vint q1)",
                    "H6 : eq x2 (Vint p2)",
                    "H5 : eq x1 (Vint p1)",
                    "p1 : Int.int",
                    "p2 : Int.int",
                    "q1 : Int.int",
                    "q2 : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb",
                    "B : Val.lessdef (Val.xor (Vint p1) (Vint q1)) va",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint q2)",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint q1)",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint p2)",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint p1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.xor (Vint p1) (Vint q1)) va"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vint (Int.xor p1 q1)) va"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords va vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "B : Val.lessdef (Vint (Int.xor p1 q1)) va"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.xor p1 q1)) vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "A : eval_expr ge sp e m le0 (xor a1 b1) (Vint (Int.xor p1 q1))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "D : Val.lessdef (Val.xor (Vint p2) (Vint q2)) vb"
                ],
                "tactic_res": [
                    "D : Val.lessdef (Vint (Int.xor p2 q2)) vb"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.xor p1 q1)) vb)\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "D : Val.lessdef (Vint (Int.xor p2 q2)) vb"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.xor p1 q1)) (Vint (Int.xor p2 q2)))\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "C : eval_expr ge sp e m le0 (xor a2 b2) (Vint (Int.xor p2 q2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.xor p1 q1)) (Vint (Int.xor p2 q2)))\n  (Val.xorl (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2)))\n  (Vlong (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2)))\n  (Vlong (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))\n  (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_xor .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_xor .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))\n  (Int64.xor (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))\n  (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))\n  (Int64.ofwords (Int.xor p1 q1) (Int.xor p2 q2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.xorl x y) Vundef\n    end\n| _ => eq (Val.xorl x y) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.xorl Vundef y) Vundef",
                    "_goal : eq (Val.xorl (Vint i) y) Vundef",
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.xorl (Vlong i) y) Vundef\nend",
                    "_goal : eq (Val.xorl (Vfloat f) y) Vundef",
                    "_goal : eq (Val.xorl (Vsingle f) y) Vundef",
                    "_goal : eq (Val.xorl (Vptr b0 i) y) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl Vundef y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vint i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.xorl (Vlong i) y) Vundef\nend"
                ],
                "tactic_res": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.xorl (Vlong i) y) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vfloat f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vsingle f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vptr b0 i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.xorl (Vlong i) y) Vundef\nend",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.xorl (Vlong i) Vundef) Vundef",
                    "_goal : eq (Val.xorl (Vlong i) (Vint i0)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.xorl (Vlong i) (Vfloat f)) Vundef",
                    "_goal : eq (Val.xorl (Vlong i) (Vsingle f)) Vundef",
                    "_goal : eq (Val.xorl (Vlong i) (Vptr b0 i0)) Vundef",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vlong i) (Vint i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vlong i) (Vfloat f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vlong i) (Vsingle f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.xorl (Vlong i) (Vptr b0 i0)) Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "is_intconst_sound",
        "proof": [
            {
                "tactic_sig": "unfold is_intconst .",
                "tactic_sig_no_out_arg": "unfold is_intconst .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int.int)\n  (_ : eq (is_intconst a) (Some n)) (_ : eval_expr ge sp e m le a x),\neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int.int)\n  (_ : eq\n         match a with\n         | Eop (Ointconst n0) Enil => Some n0\n         | Eop (Ointconst n0) (Econs _ _) => None\n         | _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vint n)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until n .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (n : Int.int)\n  (_ : eq\n         match a with\n         | Eop (Ointconst n0) Enil => Some n0\n         | Eop (Ointconst n0) (Econs _ _) => None\n         | _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : eq\n         match a with\n         | Eop (Ointconst n) Enil => Some n\n         | Eop (Ointconst n) (Econs _ _) => None\n         | _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vint n)",
                    "n : Int.int",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros LC .",
                "tactic_args": [
                    "_goal : forall\n  (_ : eq\n         match a with\n         | Eop (Ointconst n) Enil => Some n\n         | Eop (Ointconst n) (Econs _ _) => None\n         | _ => None\n         end (Some n)) (_ : eval_expr ge sp e m le a x), \neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le a x, eq x (Vint n)",
                    "LC : eq\n  match a with\n  | Eop (Ointconst n) Enil => Some n\n  | Eop (Ointconst n) (Econs _ _) => None\n  | _ => None\n  end (Some n)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o | _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le a x, eq x (Vint n)",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Evar i) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop o e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eload m0 a e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Econdition c a1 a2) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Elet a1 a2) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eletvar n0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Ebuiltin e0 e1) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eexternal i s e0) x, eq x (Vint n)",
                    "LC : eq None (Some n)",
                    "i : ident",
                    "LC : eq\n  match o with\n  | Ointconst n =>\n      match e0 with\n      | Enil => Some n\n      | Econs _ _ => None\n      end\n  | _ => None\n  end (Some n)",
                    "e0 : exprlist",
                    "o : operation",
                    "a : Op.addressing",
                    "m0 : memory_chunk",
                    "a1 : expr",
                    "a2 : expr",
                    "c : condexpr",
                    "n0 : nat",
                    "e1 : exprlist",
                    "e0 : external_function",
                    "s : signature"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Evar i) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop o e0) x, eq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop o e0) x, eq x (Vint n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eload m0 a e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Econdition c a1 a2) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Elet a1 a2) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eletvar n0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Ebuiltin e0 e1) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eexternal i s e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o | _o _o | _o _o _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o | _o | _o | _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o | _o | _o _o | _o _o | _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o | _o | _o | _o | _o _o _o | _o _o _o | _o _o | _o | _o _o _o | _o | _o _o _o | _o _o _o | _o | _o | _o | _o | _o | _o | _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o _o _o | _o | _o | _o | _o _o | _o _o | _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop o e0) x, eq x (Vint n)",
                    "o : operation"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omove e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Olongconst n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ofloatconst n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osingleconst n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddrstack ofs) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oadd e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oneg e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onegshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osub e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osubshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omul e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omuladd e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulsub e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odiv e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivu e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oand e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oor e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorimm n0) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oxor e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onot e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onotshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Obic e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Obicshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oorn e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oornshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oeqv e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oeqvshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshr e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshru e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshrximm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozext s) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osext s) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshlzext s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshlsext s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextshr a s) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextshr a s) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshiftl s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oextend x0 a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omakelong e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olowlong e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ohighlong e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlext x0 a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oneglshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osublshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osublext x0 a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omull e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulladd e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullsub e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullhs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullhu e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivlu e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oandl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandlimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oorl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorlimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oxorl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorlimm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onotl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onotlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Obicl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Obiclshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oornl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oornlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oeqvl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oeqvlshift s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshll e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshrl e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshrlu e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshrlximm n0) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextl s) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextl s) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshllzext s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshllsext s a) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextshrl a s) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextshrl a s) e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oabsf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivf e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oabsfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivfs e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoffloat e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofsingle e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointoffloat e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointuoffloat e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofint e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofintu e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointofsingle e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointuofsingle e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleofint e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleofintu e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olongoffloat e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olonguoffloat e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatoflong e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatoflongu e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olongofsingle e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olonguofsingle e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoflong e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoflongu e0) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ocmp cond) e0) x, eq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osel cond ty) e0) x,\neq x (Vint n)",
                    "LC : eq None (Some n)",
                    "LC : eq match e0 with\n   | Enil => Some n0\n   | Econs _ _ => None\n   end (Some n)",
                    "n0 : Int.int",
                    "n0 : Int64.int",
                    "n0 : float",
                    "n0 : float32",
                    "ofs : Ptrofs.int",
                    "id : ident",
                    "a : amount32",
                    "s : shift",
                    "s : Z",
                    "a : amount64",
                    "x0 : extension",
                    "cond : condition",
                    "ty : typ"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omove e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) e0) x,\neq x (Vint n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Olongconst n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ofloatconst n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osingleconst n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddrsymbol id ofs) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddrstack ofs) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oadd e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oneg e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onegshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osub e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osubshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omul e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omuladd e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulsub e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odiv e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivu e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oand e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oor e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorimm n0) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oxor e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onot e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onotshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Obic e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Obicshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oorn e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oornshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oeqv e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oeqvshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshr e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshru e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshrximm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozext s) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osext s) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshlzext s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshlsext s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextshr a s) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextshr a s) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshiftl s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oextend x0 a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omakelong e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olowlong e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ohighlong e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlext x0 a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oaddlimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oneglshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osublshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osublext x0 a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omull e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulladd e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullsub e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullhs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omullhu e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivlu e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oandl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oandlimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oorl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oorlimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oxorl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oxorlimm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onotl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Onotlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Obicl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Obiclshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oornl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oornlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oeqvl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oeqvlshift s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshll e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshrl e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oshrlu e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshrlximm n0) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextl s) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextl s) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshllzext s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Oshllsext s a) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ozextshrl a s) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osextshrl a s) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oabsf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivf e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Onegfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oabsfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Oaddfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osubfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Omulfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Odivfs e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoffloat e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofsingle e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointoffloat e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointuoffloat e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofint e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatofintu e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointofsingle e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ointuofsingle e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleofint e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleofintu e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olongoffloat e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olonguoffloat e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatoflong e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Ofloatoflongu e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olongofsingle e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Olonguofsingle e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoflong e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop Osingleoflongu e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ocmp cond) e0) x, eq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Osel cond ty) e0) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) e0) x,\neq x (Vint n)",
                    "e0 : exprlist"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x,\neq x (Vint n)",
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) (Econs e0 e1)) x,\neq x (Vint n)",
                    "LC : eq (Some n0) (Some n)",
                    "LC : eq None (Some n)",
                    "e1 : exprlist",
                    "e0 : expr"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x,\neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x,\neq x (Vint n)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) (Econs e0 e1)) x,\neq x (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n0) Enil) x,\neq x (Vint n)",
                    "LC : eq (Some n0) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x,\neq x (Vint n)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x,\neq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : eq x (Vint n)",
                    "H : eval_expr ge sp e m le (Eop (Ointconst n) Enil) x"
                ]
            },
            {
                "tactic_sig": "InvEval .",
                "tactic_sig_no_out_arg": "InvEval .",
                "tactic_args": [
                    "_goal : eq x (Vint n)"
                ],
                "tactic_res": [
                    "_goal : eq (Vint n) (Vint n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Vint n) (Vint n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shift_imm",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros until a3 .",
                "tactic_args": [
                    "_goal : forall (P : forall _ : expr, Prop) (n : Int.int) (a0 a1 a2 a3 : expr)\n  (_ : forall _ : eq n Int.zero, P a0)\n  (_ : forall\n         (_ : Logic.and (Z.le 0 (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int.zwordsize))\n         (_ : eq (Int.ltu n Int.iwordsize) true)\n         (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n         (_ : eq (Int.ltu n Int64.iwordsize') true), \n       P a1)\n  (_ : forall\n         (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int64.zwordsize))\n         (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\n       P a2) (_ : P a3),\nP\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ],
                "tactic_res": [
                    "_goal : forall (_ : forall _ : eq n Int.zero, P a0)\n  (_ : forall\n         (_ : Logic.and (Z.le 0 (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int.zwordsize))\n         (_ : eq (Int.ltu n Int.iwordsize) true)\n         (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n         (_ : eq (Int.ltu n Int64.iwordsize') true), \n       P a1)\n  (_ : forall\n         (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int64.zwordsize))\n         (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\n       P a2) (_ : P a3),\nP\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "a0 : expr",
                    "a1 : expr",
                    "a2 : expr",
                    "a3 : expr",
                    "n : Int.int",
                    "P : forall _ : expr, Prop"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros A0 A1 A2 A3 .",
                "tactic_args": [
                    "_goal : forall (_ : forall _ : eq n Int.zero, P a0)\n  (_ : forall\n         (_ : Logic.and (Z.le 0 (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int.zwordsize))\n         (_ : eq (Int.ltu n Int.iwordsize) true)\n         (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n         (_ : eq (Int.ltu n Int64.iwordsize') true), \n       P a1)\n  (_ : forall\n         (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n                (Z.lt (Int.unsigned n) Int64.zwordsize))\n         (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\n       P a2) (_ : P a3),\nP\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ],
                "tactic_res": [
                    "_goal : P\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "A3 : P a3",
                    "A2 : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true), \nP a2",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true), P a1",
                    "A0 : forall _ : eq n Int.zero, P a0"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.eq_spec _i Int.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.eq_spec _i Int.zero ) .",
                "tactic_args": [
                    "_goal : P\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int.eq n Int.zero then eq n Int.zero else not (eq n Int.zero),\nP\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ]
            },
            {
                "tactic_sig": "case ( Int.eq _i Int.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int.eq _i Int.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int.eq n Int.zero then eq n Int.zero else not (eq n Int.zero),\nP\n  (if Int.eq n Int.zero\n   then a0\n   else\n    if Int.ltu n Int.iwordsize\n    then a1\n    else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int.zero, P a0",
                    "_goal : forall _ : not (eq n Int.zero),\nP\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int.zero, P a0"
                ],
                "tactic_res": [
                    "_goal : P a0",
                    "H : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq n Int.zero),\nP\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ],
                "tactic_res": [
                    "_goal : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "H : not (eq n Int.zero)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : P a0",
                    "A0 : forall _ : eq n Int.zero, P a0"
                ],
                "tactic_res": [
                    "_goal : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq n Int.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( NZ : Int.unsigned _i <> 0 ) .",
                "tactic_sig_no_out_arg": "assert ( NZ : Int.unsigned _i <> 0 ) .",
                "tactic_args": [
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : not (eq (Int.unsigned n) 0)",
                    "NZ : not (eq (Int.unsigned n) 0)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : not (eq (Int.unsigned n) 0)"
                ],
                "tactic_res": [
                    "_goal : not (eq (Int.unsigned n) 0)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : not (eq (Int.unsigned n) 0)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int.unsigned n) 0, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int.unsigned n) 0, False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq (Int.unsigned n) 0"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "_goal : False",
                    "H : not (eq n Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int.repr_unsigned _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int.repr_unsigned _i ) .",
                "tactic_args": [
                    "_goal : eq n Int.zero",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : eq (Int.repr (Int.unsigned n)) Int.zero"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Int.repr (Int.unsigned n)) Int.zero",
                    "H0 : eq (Int.unsigned n) 0"
                ],
                "tactic_res": [
                    "_goal : eq (Int.repr 0) Int.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int.repr 0) Int.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ],
                "tactic_res": [
                    "_goal : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int.iwordsize ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int.iwordsize ) eqn : LT .",
                "tactic_args": [
                    "_goal : P\n  (if Int.ltu n Int.iwordsize\n   then a1\n   else if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : P a1",
                    "_goal : P (if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize)) (_ : eq true true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true), P a1",
                    "LT : eq (Int.ltu n Int.iwordsize) true",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize)) (_ : eq false true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true), P a1",
                    "LT : eq (Int.ltu n Int.iwordsize) false"
                ]
            },
            {
                "tactic_sig": "exploit Int.ltu_iwordsize_inv .",
                "tactic_sig_no_out_arg": "exploit Int.ltu_iwordsize_inv .",
                "tactic_args": [
                    "_goal : P a1"
                ],
                "tactic_res": [
                    "_goal : eq (Int.ltu ?Goal0 Int.iwordsize) true",
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned ?Goal0))\n        (Z.lt (Int.unsigned ?Goal0) Int.zwordsize), \nP a1"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Int.ltu ?Goal0 Int.iwordsize) true",
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned ?Goal0))\n        (Z.lt (Int.unsigned ?Goal0) Int.zwordsize), \nP a1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.zwordsize), P a1"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.zwordsize), P a1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.zwordsize), P a1"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros RANGE .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) Int.zwordsize), P a1"
                ],
                "tactic_res": [
                    "_goal : P a1",
                    "RANGE : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "assert ( 0 <= Int.zwordsize - Int.unsigned _i < Int.zwordsize ) by lia .",
                "tactic_sig_no_out_arg": "assert ( 0 <= Int.zwordsize - Int.unsigned _i < Int.zwordsize ) by lia .",
                "tactic_args": [
                    "n : Int.int"
                ],
                "tactic_res": [
                    "H0 : Logic.and (Z.le 0 (Z.sub Int.zwordsize (Int.unsigned n)))\n  (Z.lt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : P a1",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize)) (_ : eq true true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true), P a1"
                ],
                "tactic_res": [
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)",
                    "_goal : eq true true",
                    "_goal : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true",
                    "_goal : eq (Int.ltu n Int64.iwordsize') true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Int.ltu , Int.sub .",
                "tactic_sig_no_out_arg": "unfold Int.ltu , Int.sub .",
                "tactic_args": [
                    "_goal : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned\n         (Int.repr\n            (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned n))))\n      (Int.unsigned Int.iwordsize)\n   then true\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr_wordsize .",
                "tactic_args": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned\n         (Int.repr\n            (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned n))))\n      (Int.unsigned Int.iwordsize)\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned (Int.repr (Z.sub Int.zwordsize (Int.unsigned n))))\n      Int.zwordsize\n   then true\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr .",
                "tactic_args": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned (Int.repr (Z.sub Int.zwordsize (Int.unsigned n))))\n      Int.zwordsize\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize\n   then true\n   else false) true",
                    "_goal : Logic.and (Z.le 0 (Z.sub Int.zwordsize (Int.unsigned n)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned n)) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "rewrite zlt_true .",
                "tactic_sig_no_out_arg": "rewrite zlt_true .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "_goal : Z.lt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt (Z.sub Int.zwordsize (Int.unsigned n)) Int.zwordsize"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize Int.wordsize_max_unsigned .",
                "tactic_sig_no_out_arg": "generalize Int.wordsize_max_unsigned .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Z.sub Int.zwordsize (Int.unsigned n)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned n)) Int.max_unsigned)"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub Int.zwordsize (Int.unsigned n)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned n)) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub Int.zwordsize (Int.unsigned n)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned n)) Int.max_unsigned)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Int.ltu .",
                "tactic_sig_no_out_arg": "unfold Int.ltu .",
                "tactic_args": [
                    "_goal : eq (Int.ltu n Int64.iwordsize') true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt (Int.unsigned n) (Int.unsigned Int64.iwordsize')\n   then true\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite zlt_true .",
                "tactic_sig_no_out_arg": "rewrite zlt_true .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt (Int.unsigned n) (Int.unsigned Int64.iwordsize')\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "_goal : Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')"
                ]
            },
            {
                "tactic_sig": "change ( Int.unsigned Int64.iwordsize' ) with 64 .",
                "tactic_sig_no_out_arg": "change ( Int.unsigned Int64.iwordsize' ) with 64 .",
                "tactic_args": [
                    "_goal : Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Int.unsigned n) 64"
                ]
            },
            {
                "tactic_sig": "change Int.zwordsize with 32 in _i .",
                "tactic_sig_no_out_arg": "change Int.zwordsize with 32 in _i .",
                "tactic_args": [
                    "RANGE : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ],
                "tactic_res": [
                    "RANGE : Logic.and (Z.le 0 (Int.unsigned n)) (Z.lt (Int.unsigned n) 32)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt (Int.unsigned n) 64"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int64.iwordsize' ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int64.iwordsize' ) eqn : LT' .",
                "tactic_args": [
                    "_goal : P (if Int.ltu n Int64.iwordsize' then a2 else a3)",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : P a2",
                    "_goal : P a3",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize)) (_ : eq false true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq true true), P a1",
                    "LT' : eq (Int.ltu n Int64.iwordsize') true",
                    "A1 : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize)) (_ : eq false true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq false true), P a1",
                    "LT' : eq (Int.ltu n Int64.iwordsize') false"
                ]
            },
            {
                "tactic_sig": "exploit Int.ltu_inv .",
                "tactic_sig_no_out_arg": "exploit Int.ltu_inv .",
                "tactic_args": [
                    "_goal : P a2"
                ],
                "tactic_res": [
                    "_goal : eq (Int.ltu ?Goal0 ?Goal1) true",
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned ?Goal0))\n        (Z.lt (Int.unsigned ?Goal0) (Int.unsigned ?Goal1)), \nP a2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Int.ltu ?Goal0 ?Goal1) true",
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned ?Goal0))\n        (Z.lt (Int.unsigned ?Goal0) (Int.unsigned ?Goal1)), \nP a2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')), \nP a2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')), \nP a2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')), \nP a2"
                ]
            },
            {
                "tactic_sig": "change ( Int.unsigned Int64.iwordsize' ) with ( Int.zwordsize * 2 ) .",
                "tactic_sig_no_out_arg": "change ( Int.unsigned Int64.iwordsize' ) with ( Int.zwordsize * 2 ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Int.unsigned Int64.iwordsize')), \nP a2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Z.mul Int.zwordsize 2)), \nP a2"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros RANGE .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (Z.le 0 (Int.unsigned n))\n        (Z.lt (Int.unsigned n) (Z.mul Int.zwordsize 2)), \nP a2"
                ],
                "tactic_res": [
                    "_goal : P a2",
                    "RANGE : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Z.mul Int.zwordsize 2))"
                ]
            },
            {
                "tactic_sig": "assert ( Int.zwordsize <= Int.unsigned _i ) .",
                "tactic_sig_no_out_arg": "assert ( Int.zwordsize <= Int.unsigned _i ) .",
                "tactic_args": [
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : Z.le Int.zwordsize (Int.unsigned n)",
                    "H0 : Z.le Int.zwordsize (Int.unsigned n)"
                ]
            },
            {
                "tactic_sig": "unfold Int.ltu in _i .",
                "tactic_sig_no_out_arg": "unfold Int.ltu in _i .",
                "tactic_args": [
                    "LT : eq (Int.ltu n Int.iwordsize) false"
                ],
                "tactic_res": [
                    "LT : eq\n  (if zlt (Int.unsigned n) (Int.unsigned Int.iwordsize)\n   then true\n   else false) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr_wordsize in _i .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr_wordsize in _i .",
                "tactic_args": [
                    "LT : eq\n  (if zlt (Int.unsigned n) (Int.unsigned Int.iwordsize)\n   then true\n   else false) false"
                ],
                "tactic_res": [
                    "LT : eq (if zlt (Int.unsigned n) Int.zwordsize then true else false) false"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( Int.unsigned _i ) Int.zwordsize ) as [_o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( Int.unsigned _i ) Int.zwordsize ) .",
                "tactic_args": [
                    "n : Int.int"
                ],
                "tactic_res": [
                    "LT : eq true false",
                    "l : Z.lt (Int.unsigned n) Int.zwordsize",
                    "LT : eq false false",
                    "g : Z.ge (Int.unsigned n) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.le Int.zwordsize (Int.unsigned n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : P a2",
                    "A2 : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true), \nP a2"
                ],
                "tactic_res": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)",
                    "_goal : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold Int.ltu , Int.sub .",
                "tactic_sig_no_out_arg": "unfold Int.ltu , Int.sub .",
                "tactic_args": [
                    "_goal : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned\n         (Int.repr\n            (Z.sub (Int.unsigned n) (Int.unsigned Int.iwordsize))))\n      (Int.unsigned Int.iwordsize)\n   then true\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr_wordsize .",
                "tactic_args": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned\n         (Int.repr\n            (Z.sub (Int.unsigned n) (Int.unsigned Int.iwordsize))))\n      (Int.unsigned Int.iwordsize)\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned (Int.repr (Z.sub (Int.unsigned n) Int.zwordsize)))\n      Int.zwordsize\n   then true\n   else false) true"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr .",
                "tactic_args": [
                    "_goal : eq\n  (if\n    zlt\n      (Int.unsigned (Int.repr (Z.sub (Int.unsigned n) Int.zwordsize)))\n      Int.zwordsize\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize\n   then true\n   else false) true",
                    "_goal : Logic.and (Z.le 0 (Z.sub (Int.unsigned n) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned n) Int.zwordsize) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "rewrite zlt_true .",
                "tactic_sig_no_out_arg": "rewrite zlt_true .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize\n   then true\n   else false) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "_goal : Z.lt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt (Z.sub (Int.unsigned n) Int.zwordsize) Int.zwordsize"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize Int.wordsize_max_unsigned .",
                "tactic_sig_no_out_arg": "generalize Int.wordsize_max_unsigned .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Z.sub (Int.unsigned n) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned n) Int.zwordsize) Int.max_unsigned)"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub (Int.unsigned n) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned n) Int.zwordsize) Int.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le 0 (Z.sub (Int.unsigned n) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned n) Int.zwordsize) Int.max_unsigned)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : P a3"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shllimm",
        "proof": [
            {
                "tactic_sig": "unfold shllimm .",
                "tactic_sig_no_out_arg": "unfold shllimm .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound (fun e : expr => shllimm e n)\n  (fun v : val => Val.shll v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong\n          (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n          (shlimm l n))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      makelong (shlimm (lowlong e) (Int.sub n Int.iwordsize))\n        (Eop (Ointconst Int.zero) Enil)\n     else\n      Eexternal i64_shl sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shll v (Vint n))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong\n          (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n          (shlimm l n))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      makelong (shlimm (lowlong e) (Int.sub n Int.iwordsize))\n        (Eop (Ointconst Int.zero) Enil)\n     else\n      Eexternal i64_shl sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shll v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong\n                (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n                (shlimm l n))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n              (Eop (Ointconst Int.zero) Enil)\n           else\n            Eexternal i64_shl sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong\n                (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n                (shlimm l n))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n              (Eop (Ointconst Int.zero) Enil)\n           else\n            Eexternal i64_shl sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong\n                (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n                (shlimm l n))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n              (Eop (Ointconst Int.zero) Enil)\n           else\n            Eexternal i64_shl sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "n : Int.int"
                ]
            },
            {
                "tactic_sig": "apply eval_shift_imm .",
                "tactic_sig_no_out_arg": "apply eval_shift_imm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong\n                (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n                (shlimm l n))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n              (Eop (Ointconst Int.zero) Enil)\n           else\n            Eexternal i64_shl sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong\n              (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n              (shlimm l n))) v) (Val.lessdef (Val.shll x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shl sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H0 : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong\n              (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n              (shlimm l n))) v) (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong\n              (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n              (shlimm l n))) v) (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true",
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true",
                    "H1 : eq (Int.ltu n Int.iwordsize) true",
                    "H0 : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "H0 : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint Int.zero)) v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shll x (Vint Int.zero)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shll x (Vint Int.zero)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shll x (Vint Int.zero)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.shll x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll x (Vint Int.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll x (Vint Int.zero)) x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll Vundef (Vint Int.zero)) Vundef",
                    "_goal : Val.lessdef (Val.shll (Vint i) (Vint Int.zero)) (Vint i)",
                    "_goal : Val.lessdef (Val.shll (Vlong i) (Vint Int.zero)) (Vlong i)",
                    "_goal : Val.lessdef (Val.shll (Vfloat f) (Vint Int.zero)) (Vfloat f)",
                    "_goal : Val.lessdef (Val.shll (Vsingle f) (Vint Int.zero)) (Vsingle f)",
                    "_goal : Val.lessdef (Val.shll (Vptr b i) (Vint Int.zero)) (Vptr b i)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll Vundef (Vint Int.zero)) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vint i) (Vint Int.zero)) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vlong i) (Vint Int.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vfloat f) (Vint Int.zero)) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vsingle f) (Vint Int.zero)) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vptr b i) (Vint Int.zero)) (Vptr b i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change ( Int64.shl' _i Int.zero ) with ( Int64.shl _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "change ( Int64.shl' _i Int.zero ) with ( Int64.shl _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl' i Int.zero)\n   else Vundef) (Vlong i)",
                    "i : Int64.int",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl i Int64.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.shl_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.shl_zero .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shl i Int64.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply eval_splitlong with ( sem := fun _i => Val.shll _i ( Vint _i ) ) .",
                "tactic_sig_no_out_arg": "apply eval_splitlong with ( sem := fun _i => Val.shll _i ( Vint _i ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong\n              (or (shlimm h n) (shruimm l (Int.sub Int.iwordsize n)))\n              (shlimm l n))) v) (Val.lessdef (Val.shll x (Vint n)) v))",
                    "x : val",
                    "x : val",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shll x (Vint n)) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong\n           (or (shlimm a n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y",
                    "H4 : eval_expr ge sp e m le0 a0 x0",
                    "x0 : val",
                    "y : val",
                    "a0 : expr",
                    "b : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_shlimm .",
                "tactic_sig_no_out_arg": "exploit eval_shlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H4 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 n) v)\n           (Val.lessdef (Val.shl x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 n) v)\n           (Val.lessdef (Val.shl x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B1 : Val.lessdef (Val.shl x0 (Vint n)) v1",
                    "A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shlimm .",
                "tactic_sig_no_out_arg": "exploit eval_shlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm b ?Goal2) v)\n           (Val.lessdef (Val.shl y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm b ?Goal2) v)\n           (Val.lessdef (Val.shl y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm b n) v)\n           (Val.lessdef (Val.shl y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm b n) v)\n           (Val.lessdef (Val.shl y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B2 : Val.lessdef (Val.shl y (Vint n)) v2",
                    "A2 : eval_expr ge sp e m le0 (shlimm b n) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shruimm .",
                "tactic_sig_no_out_arg": "exploit eval_shruimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shruimm b (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v3 [ A3 B3 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shruimm b (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B3 : Val.lessdef (Val.shru y (Vint (Int.sub Int.iwordsize n))) v3",
                    "A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A1 : eval_expr ge sp e m le0 (shlimm a0 n) v1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shlimm a0 n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shlimm a0 n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n)) v3"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v4 [ A4 B4 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B4 : Val.lessdef (Val.or v1 v3) v4",
                    "A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n))) v4",
                    "v4 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong\n           (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n           (shlimm b n)) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n        (shlimm b n)) ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n        (shlimm b n)) ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n     (shlimm b n)) ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n     (shlimm b n)) ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v4 v2)\n  (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v4 v2)\n  (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v4 v2)\n  (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))",
                    "H7 : eq y (Vint q)",
                    "H6 : eq x0 (Vint p)",
                    "p : Int.int",
                    "q : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "B3 : Val.lessdef (Val.shru (Vint q) (Vint (Int.sub Int.iwordsize n))) v3",
                    "B2 : Val.lessdef (Val.shl (Vint q) (Vint n)) v2",
                    "B1 : Val.lessdef (Val.shl (Vint p) (Vint n)) v1",
                    "H5 : eval_expr ge sp e m le0 b (Vint q)",
                    "H4 : eval_expr ge sp e m le0 a0 (Vint p)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v4 v2)\n  (Val.shll (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v4 v2)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.ofwords p q) n)\n   else Vundef)",
                    "B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shru q (Int.sub Int.iwordsize n))\n   else Vundef) v3",
                    "B2 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl q n) else Vundef) v2",
                    "B1 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shl p n) else Vundef) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H1 : eq (Int.ltu n Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (Vint (Int.shl q n)) v2",
                    "B1 : Val.lessdef (Vint (Int.shl p n)) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v4 v2)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' (Int64.ofwords p q) n)\n   else Vundef)",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v4 v2) (Vlong (Int64.shl' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int.shl p n)) v1"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef (Val.or (Vint (Int.shl p n)) v3) v4",
                    "A1 : eval_expr ge sp e m le0 (shlimm a0 n) (Vint (Int.shl p n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v4 v2) (Vlong (Int64.shl' (Int64.ofwords p q) n))",
                    "B2 : Val.lessdef (Vint (Int.shl q n)) v2"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v4 (Vint (Int.shl q n)))\n  (Vlong (Int64.shl' (Int64.ofwords p q) n))",
                    "A2 : eval_expr ge sp e m le0 (shlimm b n) (Vint (Int.shl q n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B3 : Val.lessdef (Vint (Int.shru q (Int.sub Int.iwordsize n))) v3"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shl p n))\n     (Vint (Int.shru q (Int.sub Int.iwordsize n)))) v4",
                    "A3 : eval_expr ge sp e m le0 (shruimm b (Int.sub Int.iwordsize n))\n  (Vint (Int.shru q (Int.sub Int.iwordsize n)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shl p n))\n     (Vint (Int.shru q (Int.sub Int.iwordsize n)))) v4"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n  v4"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v4 (Vint (Int.shl q n)))\n  (Vlong (Int64.shl' (Int64.ofwords p q) n))",
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n  v4"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Val.longofwords\n     (Vint\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n     (Vint (Int.shl q n))) (Vlong (Int64.shl' (Int64.ofwords p q) n))",
                    "A4 : eval_expr ge sp e m le0\n  (or (shlimm a0 n) (shruimm b (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (Val.longofwords\n     (Vint\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n))))\n     (Vint (Int.shl q n))) (Vlong (Int64.shl' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n))) (Vlong (Int64.shl' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_shl_1 .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_shl_1 .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n))) (Vlong (Int64.shl' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n)))\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n)))",
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n)))\n  (Vlong\n     (Int64.ofwords\n        (Int.or (Int.shl p n) (Int.shru q (Int.sub Int.iwordsize n)))\n        (Int.shl q n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shll x (Vint n)) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.shll Vundef (Vint n)) Vundef",
                    "_goal : eq (Val.shll (Vint i) (Vint n)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.shll (Vfloat f) (Vint n)) Vundef",
                    "_goal : eq (Val.shll (Vsingle f) (Vint n)) Vundef",
                    "_goal : eq (Val.shll (Vptr b i) (Vint n)) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shll Vundef (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shll (Vint i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shll (Vfloat f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shll (Vsingle f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shll (Vptr b i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_lowlong .",
                "tactic_sig_no_out_arg": "exploit eval_lowlong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (lowlong ?Goal1) v)\n           (Val.lessdef (Val.loword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (lowlong ?Goal1) v)\n           (Val.lessdef (Val.loword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (lowlong a) v)\n           (Val.lessdef (Val.loword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (lowlong a) v)\n           (Val.lessdef (Val.loword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "B1 : Val.lessdef (Val.loword x) v1",
                    "A1 : eval_expr ge sp e m le (lowlong a) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shlimm .",
                "tactic_sig_no_out_arg": "exploit eval_shlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shlimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shl ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shlimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shl ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "A1 : eval_expr ge sp e m le (lowlong a) v1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (shlimm (lowlong a) ?Goal0) v)\n           (Val.lessdef (Val.shl v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (shlimm (lowlong a) ?Goal0) v)\n           (Val.lessdef (Val.shl v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (shlimm (lowlong a) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "B2 : Val.lessdef (Val.shl v1 (Vint (Int.sub n Int.iwordsize))) v2",
                    "A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n           (Eop (Ointconst Int.zero) Enil)) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n        (Eop (Ointconst Int.zero) Enil)) ?v)\n  (Val.lessdef (Val.shll x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n        (Eop (Ointconst Int.zero) Enil)) ?v)\n  (Val.lessdef (Val.shll x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n     (Eop (Ointconst Int.zero) Enil)) ?v",
                    "_goal : Val.lessdef (Val.shll x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (makelong (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n     (Eop (Ointconst Int.zero) Enil)) ?v",
                    "_goal : Val.lessdef (Val.shll x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll x (Vint n)) (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll x (Vint n)) (Val.longofwords v2 (Vint Int.zero))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll Vundef (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef (Val.shll (Vint i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef (Val.shll (Vlong i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef (Val.shll (Vfloat f) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef (Val.shll (Vsingle f) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef (Val.shll (Vptr b i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "B1 : Val.lessdef (Val.loword Vundef) v1",
                    "H : eval_expr ge sp e m le a Vundef",
                    "B1 : Val.lessdef (Val.loword (Vint i)) v1",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "B1 : Val.lessdef (Val.loword (Vlong i)) v1",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "B1 : Val.lessdef (Val.loword (Vfloat f)) v1",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "B1 : Val.lessdef (Val.loword (Vsingle f)) v1",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "B1 : Val.lessdef (Val.loword (Vptr b i)) v1",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll Vundef (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vint i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vlong i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' i n)\n   else Vundef) (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' i n)\n   else Vundef) (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' i n)\n   else Vundef) (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vfloat f) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vsingle f) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll (Vptr b i) (Vint n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int64.iwordsize' ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int64.iwordsize' ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shl' i n)\n   else Vundef) (Val.longofwords v2 (Vint Int.zero))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords v2 (Vint Int.zero))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v2 (Vint Int.zero))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.loword (Vlong i)) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int64.loword i)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int64.loword i)) v1"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.shl (Vint (Int64.loword i)) (Vint (Int.sub n Int.iwordsize))) v2",
                    "A1 : eval_expr ge sp e m le (lowlong a) (Vint (Int64.loword i))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.shl (Vint (Int64.loword i)) (Vint (Int.sub n Int.iwordsize))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n  v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords v2 (Vint Int.zero))",
                    "B2 : Val.lessdef (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n  v2"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords\n     (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n     (Vint Int.zero))",
                    "A2 : eval_expr ge sp e m le (shlimm (lowlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Val.longofwords\n     (Vint (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)))\n     (Vint Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.ofwords\n        (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)) Int.zero))"
                ]
            },
            {
                "tactic_sig": "erewrite <- Int64.decompose_shl_2 .",
                "tactic_sig_no_out_arg": "erewrite <- Int64.decompose_shl_2 .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.ofwords\n        (Int.shl (Int64.loword i) (Int.sub n Int.iwordsize)) Int.zero))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong (Int64.shl' (Int64.ofwords ?xh (Int64.loword i)) n))",
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int64.hiword _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int64.hiword _i ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong (Int64.shl' (Int64.ofwords ?xh (Int64.loword i)) n))",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.shl' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n))\n  (Vlong\n     (Int64.shl' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n)) (Vlong (Int64.shl' i n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i n)) (Vlong (Int64.shl' i n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shl sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shl sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shll x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shl sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shll x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shl sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shll x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shl sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : helper_declared prog i64_shl ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shl\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shl\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shl)\n     (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shl)\n     (cons x (cons (Vint n) nil))) (Some ?v)",
                    "_goal : Val.lessdef (Val.shll x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll x (Vint n)) (Val.shll x (Vint n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll x (Vint n)) (Val.shll x (Vint n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shll",
        "proof": [
            {
                "tactic_sig": "unfold shll .",
                "tactic_sig_no_out_arg": "unfold shll .",
                "tactic_args": [
                    "_goal : binary_constructor_sound shll Val.shll"
                ],
                "tactic_res": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shllimm e1 n\n   | None => Eexternal i64_shl sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shll"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shllimm e1 n\n   | None => Eexternal i64_shl sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shll"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shllimm a n\n        | None => Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shll x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shllimm a n\n        | None => Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shllimm a n\n        | None => Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shll x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_intconst _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_intconst _i ) as [ n| ] eqn : IC .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shllimm a n\n        | None => Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shll x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shll x y) v))",
                    "IC : eq (is_intconst b) (Some n)",
                    "n : Int.int",
                    "IC : eq (is_intconst b) None"
                ]
            },
            {
                "tactic_sig": "exploit is_intconst_sound .",
                "tactic_sig_no_out_arg": "exploit is_intconst_sound .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))",
                    "EQ : eq y (Vint n)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))",
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply eval_shllimm .",
                "tactic_sig_no_out_arg": "eapply eval_shllimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a n) v)\n     (Val.lessdef (Val.shll x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shll x y) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shll x y) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shll x y) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shll x y) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shl sig_li_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_shl ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shl ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shl\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shl\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shl) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shl) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef (Val.shll x y) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shll x y) (Val.shll x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shll x y) (Val.shll x y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shrluimm",
        "proof": [
            {
                "tactic_sig": "unfold shrluimm .",
                "tactic_sig_no_out_arg": "unfold shrluimm .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound (fun e : expr => shrluimm e n)\n  (fun v : val => Val.shrlu v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong (shruimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      makelong (Eop (Ointconst Int.zero) Enil)\n        (shruimm (highlong e) (Int.sub n Int.iwordsize))\n     else\n      Eexternal i64_shr sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shrlu v (Vint n))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong (shruimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      makelong (Eop (Ointconst Int.zero) Enil)\n        (shruimm (highlong e) (Int.sub n Int.iwordsize))\n     else\n      Eexternal i64_shr sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shrlu v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shruimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (Eop (Ointconst Int.zero) Enil)\n              (shruimm (highlong a) (Int.sub n Int.iwordsize))\n           else\n            Eexternal i64_shr sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shruimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (Eop (Ointconst Int.zero) Enil)\n              (shruimm (highlong a) (Int.sub n Int.iwordsize))\n           else\n            Eexternal i64_shr sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shruimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (Eop (Ointconst Int.zero) Enil)\n              (shruimm (highlong a) (Int.sub n Int.iwordsize))\n           else\n            Eexternal i64_shr sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "n : Int.int"
                ]
            },
            {
                "tactic_sig": "apply eval_shift_imm .",
                "tactic_sig_no_out_arg": "apply eval_shift_imm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shruimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            makelong (Eop (Ointconst Int.zero) Enil)\n              (shruimm (highlong a) (Int.sub n Int.iwordsize))\n           else\n            Eexternal i64_shr sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shruimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shr sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H0 : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shruimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shruimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true",
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true",
                    "H1 : eq (Int.ltu n Int.iwordsize) true",
                    "H0 : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "H0 : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint Int.zero)) v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrlu x (Vint Int.zero)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shrlu x (Vint Int.zero)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shrlu x (Vint Int.zero)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.shrlu x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint Int.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint Int.zero)) x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint Int.zero)) Vundef",
                    "_goal : Val.lessdef (Val.shrlu (Vint i) (Vint Int.zero)) (Vint i)",
                    "_goal : Val.lessdef (Val.shrlu (Vlong i) (Vint Int.zero)) (Vlong i)",
                    "_goal : Val.lessdef (Val.shrlu (Vfloat f) (Vint Int.zero)) (Vfloat f)",
                    "_goal : Val.lessdef (Val.shrlu (Vsingle f) (Vint Int.zero)) (Vsingle f)",
                    "_goal : Val.lessdef (Val.shrlu (Vptr b i) (Vint Int.zero)) (Vptr b i)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint Int.zero)) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vint i) (Vint Int.zero)) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vlong i) (Vint Int.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vfloat f) (Vint Int.zero)) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vsingle f) (Vint Int.zero)) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vptr b i) (Vint Int.zero)) (Vptr b i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change ( Int64.shru' _i Int.zero ) with ( Int64.shru _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "change ( Int64.shru' _i Int.zero ) with ( Int64.shru _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru' i Int.zero)\n   else Vundef) (Vlong i)",
                    "i : Int64.int",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru i Int64.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.shru_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.shru_zero .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shru i Int64.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply eval_splitlong with ( sem := fun _i => Val.shrlu _i ( Vint _i ) ) .",
                "tactic_sig_no_out_arg": "apply eval_splitlong with ( sem := fun _i => Val.shrlu _i ( Vint _i ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shruimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "x : val",
                    "x : val",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shrlu x (Vint n)) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shruimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y",
                    "H4 : eval_expr ge sp e m le0 a0 x0",
                    "x0 : val",
                    "y : val",
                    "a0 : expr",
                    "b : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_shruimm .",
                "tactic_sig_no_out_arg": "exploit eval_shruimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b n) v)\n           (Val.lessdef (Val.shru y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b n) v)\n           (Val.lessdef (Val.shru y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B1 : Val.lessdef (Val.shru y (Vint n)) v1",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shruimm .",
                "tactic_sig_no_out_arg": "exploit eval_shruimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H4 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shru x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shru x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm a0 n) v)\n           (Val.lessdef (Val.shru x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm a0 n) v)\n           (Val.lessdef (Val.shru x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B2 : Val.lessdef (Val.shru x0 (Vint n)) v2",
                    "A2 : eval_expr ge sp e m le0 (shruimm a0 n) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shlimm .",
                "tactic_sig_no_out_arg": "exploit eval_shlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H4 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shlimm a0 (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v3 [ A3 B3 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shlimm a0 (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) v1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shruimm b n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shruimm b n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v4 [ A4 B4 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B4 : Val.lessdef (Val.or v1 v3) v4",
                    "A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4",
                    "v4 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shruimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (shruimm a0 n)\n        (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n     ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (shruimm a0 n)\n        (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n     ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (shruimm a0 n)\n     (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n  ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (shruimm a0 n)\n     (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n  ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v2 v4)\n  (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v2 v4)\n  (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))",
                    "H7 : eq y (Vint q)",
                    "H6 : eq x0 (Vint p)",
                    "p : Int.int",
                    "q : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3",
                    "B2 : Val.lessdef (Val.shru (Vint p) (Vint n)) v2",
                    "B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1",
                    "H5 : eval_expr ge sp e m le0 b (Vint q)",
                    "H4 : eval_expr ge sp e m le0 a0 (Vint p)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (Val.shrlu (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.ofwords p q) n)\n   else Vundef)",
                    "B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3",
                    "B2 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru p n) else Vundef) v2",
                    "B1 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H1 : eq (Int.ltu n Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (Vint (Int.shru p n)) v2",
                    "B1 : Val.lessdef (Vint (Int.shru q n)) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' (Int64.ofwords p q) n)\n   else Vundef)",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4) (Vlong (Int64.shru' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int.shru q n)) v1"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef (Val.or (Vint (Int.shru q n)) v3) v4",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4) (Vlong (Int64.shru' (Int64.ofwords p q) n))",
                    "B2 : Val.lessdef (Vint (Int.shru p n)) v2"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.shru p n)) v4)\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))",
                    "A2 : eval_expr ge sp e m le0 (shruimm a0 n) (Vint (Int.shru p n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n))\n     (Vint (Int.shl p (Int.sub Int.iwordsize n)))) v4",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n))\n     (Vint (Int.shl p (Int.sub Int.iwordsize n)))) v4"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))\n  v4"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.shru p n)) v4)\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))",
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))\n  v4"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Val.longofwords (Vint (Int.shru p n))\n     (Vint\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))",
                    "A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (Val.longofwords (Vint (Int.shru p n))\n     (Vint\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_shru_1 .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_shru_1 .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shru' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))",
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong\n     (Int64.ofwords (Int.shru p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shrlu x (Vint n)) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.shrlu Vundef (Vint n)) Vundef",
                    "_goal : eq (Val.shrlu (Vint i) (Vint n)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.shrlu (Vfloat f) (Vint n)) Vundef",
                    "_goal : eq (Val.shrlu (Vsingle f) (Vint n)) Vundef",
                    "_goal : eq (Val.shrlu (Vptr b i) (Vint n)) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrlu Vundef (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrlu (Vint i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrlu (Vfloat f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrlu (Vsingle f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrlu (Vptr b i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_highlong .",
                "tactic_sig_no_out_arg": "exploit eval_highlong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "B1 : Val.lessdef (Val.hiword x) v1",
                    "A1 : eval_expr ge sp e m le (highlong a) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shruimm .",
                "tactic_sig_no_out_arg": "exploit eval_shruimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shruimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shru ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shruimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shru ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "A1 : eval_expr ge sp e m le (highlong a) v1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (shruimm (highlong a) ?Goal0) v)\n           (Val.lessdef (Val.shru v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (shruimm (highlong a) ?Goal0) v)\n           (Val.lessdef (Val.shru v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (shruimm (highlong a) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize)))\n              v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (shruimm (highlong a) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize)))\n              v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "B2 : Val.lessdef (Val.shru v1 (Vint (Int.sub n Int.iwordsize))) v2",
                    "A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (Eop (Ointconst Int.zero) Enil)\n           (shruimm (highlong a) (Int.sub n Int.iwordsize))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (makelong (Eop (Ointconst Int.zero) Enil)\n        (shruimm (highlong a) (Int.sub n Int.iwordsize))) \n     ?v) (Val.lessdef (Val.shrlu x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (makelong (Eop (Ointconst Int.zero) Enil)\n        (shruimm (highlong a) (Int.sub n Int.iwordsize))) \n     ?v) (Val.lessdef (Val.shrlu x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (makelong (Eop (Ointconst Int.zero) Enil)\n     (shruimm (highlong a) (Int.sub n Int.iwordsize))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (makelong (Eop (Ointconst Int.zero) Enil)\n     (shruimm (highlong a) (Int.sub n Int.iwordsize))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef (Val.shrlu (Vint i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef (Val.shrlu (Vlong i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef (Val.shrlu (Vfloat f) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef (Val.shrlu (Vsingle f) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef (Val.shrlu (Vptr b i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "B1 : Val.lessdef (Val.hiword Vundef) v1",
                    "H : eval_expr ge sp e m le a Vundef",
                    "B1 : Val.lessdef (Val.hiword (Vint i)) v1",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "B1 : Val.lessdef (Val.hiword (Vlong i)) v1",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "B1 : Val.lessdef (Val.hiword (Vfloat f)) v1",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "B1 : Val.lessdef (Val.hiword (Vsingle f)) v1",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "B1 : Val.lessdef (Val.hiword (Vptr b i)) v1",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vint i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vlong i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' i n)\n   else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' i n)\n   else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' i n)\n   else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vfloat f) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vsingle f) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu (Vptr b i) (Vint n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int64.iwordsize' ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int64.iwordsize' ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shru' i n)\n   else Vundef)\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.hiword (Vlong i)) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int64.hiword i)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int64.hiword i)) v1"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.shru (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize)))\n  v2",
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.shru (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize)))\n  v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))) v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  match v2 with\n  | Vint n2 => Vlong (Int64.ofwords Int.zero n2)\n  | _ => Vundef\n  end",
                    "B2 : Val.lessdef\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))) v2"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))",
                    "A2 : eval_expr ge sp e m le (shruimm (highlong a) (Int.sub n Int.iwordsize))\n  (Vint (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ]
            },
            {
                "tactic_sig": "erewrite <- Int64.decompose_shru_2 .",
                "tactic_sig_no_out_arg": "erewrite <- Int64.decompose_shru_2 .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.ofwords Int.zero\n        (Int.shru (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong (Int64.shru' (Int64.ofwords (Int64.hiword i) ?xl) n))",
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int64.loword _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int64.loword _i ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong (Int64.shru' (Int64.ofwords (Int64.hiword i) ?xl) n))",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.shru' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n))\n  (Vlong\n     (Int64.shru' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n)) (Vlong (Int64.shru' i n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shru' i n)) (Vlong (Int64.shru' i n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shr sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shr sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shrlu x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shr sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shrlu x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shr sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shr sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : helper_declared prog i64_shr ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shr\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shr\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shr)\n     (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shr)\n     (cons x (cons (Vint n) nil))) (Some ?v)",
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) (Val.shrlu x (Vint n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu x (Vint n)) (Val.shrlu x (Vint n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shrlu",
        "proof": [
            {
                "tactic_sig": "unfold shrlu .",
                "tactic_sig_no_out_arg": "unfold shrlu .",
                "tactic_args": [
                    "_goal : binary_constructor_sound shrlu Val.shrlu"
                ],
                "tactic_res": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shrluimm e1 n\n   | None => Eexternal i64_shr sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shrlu"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shrluimm e1 n\n   | None => Eexternal i64_shr sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shrlu"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrluimm a n\n        | None => Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrlu x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrluimm a n\n        | None => Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrluimm a n\n        | None => Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrlu x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_intconst _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_intconst _i ) as [ n| ] eqn : IC .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrluimm a n\n        | None => Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrlu x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shrlu x y) v))",
                    "IC : eq (is_intconst b) (Some n)",
                    "n : Int.int",
                    "IC : eq (is_intconst b) None"
                ]
            },
            {
                "tactic_sig": "exploit is_intconst_sound .",
                "tactic_sig_no_out_arg": "exploit is_intconst_sound .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))",
                    "EQ : eq y (Vint n)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))",
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply eval_shrluimm .",
                "tactic_sig_no_out_arg": "eapply eval_shrluimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrluimm a n) v)\n     (Val.lessdef (Val.shrlu x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shrlu x y) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shrlu x y) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shrlu x y) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrlu x y) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_shr sig_li_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_shr ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_shr ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shr\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_shr\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shr) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_shr) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef (Val.shrlu x y) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu x y) (Val.shrlu x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu x y) (Val.shrlu x y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shrlimm",
        "proof": [
            {
                "tactic_sig": "unfold shrlimm .",
                "tactic_sig_no_out_arg": "unfold shrlimm .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound (fun e : expr => shrlimm e n)\n  (fun v : val => Val.shrl v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong (shrimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      Elet (highlong e)\n        (makelong (shrimm (Eletvar 0) (Int.repr 31))\n           (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n     else\n      Eexternal i64_sar sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shrl v (Vint n))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall n : Int.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int.eq n Int.zero\n   then e\n   else\n    if Int.ltu n Int.iwordsize\n    then\n     splitlong e\n       (fun h l : expr =>\n        makelong (shrimm h n)\n          (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n    else\n     if Int.ltu n Int64.iwordsize'\n     then\n      Elet (highlong e)\n        (makelong (shrimm (Eletvar 0) (Int.repr 31))\n           (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n     else\n      Eexternal i64_sar sig_li_l\n        (Econs e (Econs (Eop (Ointconst n) Enil) Enil)))\n  (fun v : val => Val.shrl v (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shrimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            Elet (highlong a)\n              (makelong (shrimm (Eletvar 0) (Int.repr 31))\n                 (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n           else\n            Eexternal i64_sar sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : Int.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shrimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            Elet (highlong a)\n              (makelong (shrimm (Eletvar 0) (Int.repr 31))\n                 (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n           else\n            Eexternal i64_sar sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shrimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            Elet (highlong a)\n              (makelong (shrimm (Eletvar 0) (Int.repr 31))\n                 (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n           else\n            Eexternal i64_sar sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "n : Int.int"
                ]
            },
            {
                "tactic_sig": "apply eval_shift_imm .",
                "tactic_sig_no_out_arg": "apply eval_shift_imm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          if Int.ltu n Int.iwordsize\n          then\n           splitlong a\n             (fun h l : expr =>\n              makelong (shrimm h n)\n                (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n))))\n          else\n           if Int.ltu n Int64.iwordsize'\n           then\n            Elet (highlong a)\n              (makelong (shrimm (Eletvar 0) (Int.repr 31))\n                 (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))\n           else\n            Eexternal i64_sar sig_li_l\n              (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shrimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sar sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H0 : eq n Int.zero"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le 0 (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int.zwordsize))\n  (_ : eq (Int.ltu n Int.iwordsize) true)\n  (_ : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true)\n  (_ : eq (Int.ltu n Int64.iwordsize') true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shrimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shrimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true",
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true",
                    "H1 : eq (Int.ltu n Int.iwordsize) true",
                    "H0 : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n         (Z.lt (Int.unsigned n) Int64.zwordsize))\n  (_ : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "H0 : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint Int.zero)) v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.shrl x (Vint Int.zero)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shrl x (Vint Int.zero)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.shrl x (Vint Int.zero)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.shrl x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x (Vint Int.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl x (Vint Int.zero)) x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x (Vint Int.zero)) x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint Int.zero)) Vundef",
                    "_goal : Val.lessdef (Val.shrl (Vint i) (Vint Int.zero)) (Vint i)",
                    "_goal : Val.lessdef (Val.shrl (Vlong i) (Vint Int.zero)) (Vlong i)",
                    "_goal : Val.lessdef (Val.shrl (Vfloat f) (Vint Int.zero)) (Vfloat f)",
                    "_goal : Val.lessdef (Val.shrl (Vsingle f) (Vint Int.zero)) (Vsingle f)",
                    "_goal : Val.lessdef (Val.shrl (Vptr b i) (Vint Int.zero)) (Vptr b i)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint Int.zero)) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vint i) (Vint Int.zero)) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vlong i) (Vint Int.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vfloat f) (Vint Int.zero)) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vsingle f) (Vint Int.zero)) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vptr b i) (Vint Int.zero)) (Vptr b i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "change ( Int64.shr' _i Int.zero ) with ( Int64.shr _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "change ( Int64.shr' _i Int.zero ) with ( Int64.shr _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr' i Int.zero)\n   else Vundef) (Vlong i)",
                    "i : Int64.int",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr i Int64.zero)\n   else Vundef) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.shr_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.shr_zero .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize'\n   then Vlong (Int64.shr i Int64.zero)\n   else Vundef) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu Int.zero Int64.iwordsize' then Vlong i else Vundef)\n  (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply eval_splitlong with ( sem := fun _i => Val.shrl _i ( Vint _i ) ) .",
                "tactic_sig_no_out_arg": "apply eval_splitlong with ( sem := fun _i => Val.shrl _i ( Vint _i ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong a\n           (fun h l : expr =>\n            makelong (shrimm h n)\n              (or (shruimm l n) (shlimm h (Int.sub Int.iwordsize n)))))\n        v) (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "x : val",
                    "x : val",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shrl x (Vint n)) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (makelong (shrimm a n)\n           (or (shruimm b n) (shlimm a (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y",
                    "H4 : eval_expr ge sp e m le0 a0 x0",
                    "x0 : val",
                    "y : val",
                    "a0 : expr",
                    "b : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_shruimm .",
                "tactic_sig_no_out_arg": "exploit eval_shruimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shruimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shru ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H5 : eval_expr ge sp e m le0 b y"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b ?Goal2) v)\n           (Val.lessdef (Val.shru y (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b n) v)\n           (Val.lessdef (Val.shru y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shruimm b n) v)\n           (Val.lessdef (Val.shru y (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B1 : Val.lessdef (Val.shru y (Vint n)) v1",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shrimm .",
                "tactic_sig_no_out_arg": "exploit eval_shrimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shrimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shr ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shrimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shr ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H4 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shrimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shr x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shrimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shr x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shrimm a0 n) v)\n           (Val.lessdef (Val.shr x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shrimm a0 n) v)\n           (Val.lessdef (Val.shr x0 (Vint n)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B2 : Val.lessdef (Val.shr x0 (Vint n)) v2",
                    "A2 : eval_expr ge sp e m le0 (shrimm a0 n) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shlimm .",
                "tactic_sig_no_out_arg": "exploit eval_shlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal7 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal7 (shlimm ?Goal8 ?Goal6) v)\n           (Val.lessdef (Val.shl ?Goal9 (Vint ?Goal6)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "H4 : eval_expr ge sp e m le0 a0 x0"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub Int.iwordsize _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (shlimm a0 ?Goal2) v)\n           (Val.lessdef (Val.shl x0 (Vint ?Goal2)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shlimm a0 (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v3 [ A3 B3 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (shlimm a0 (Int.sub Int.iwordsize n)) v)\n           (Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B3 : Val.lessdef (Val.shl x0 (Vint (Int.sub Int.iwordsize n))) v3",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal7 ?Goal8",
                    "_goal : eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal9 ?Goal10",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal2 ?Goal3 ?Goal4 ?Goal5 \n              ?Goal6 (or ?Goal7 ?Goal9) v)\n           (Val.lessdef (Val.or ?Goal8 ?Goal10) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) v1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shruimm b n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (or (shruimm b n) ?Goal2) v)\n           (Val.lessdef (Val.or v1 ?Goal3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n)) v3"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v4 [ A4 B4 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n              v) (Val.lessdef (Val.or v1 v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))",
                    "B4 : Val.lessdef (Val.or v1 v3) v4",
                    "A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n))) v4",
                    "v4 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (makelong (shrimm a0 n)\n           (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) v)\n     (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n      eq v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (shrimm a0 n)\n        (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n     ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (makelong (shrimm a0 n)\n        (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n     ?v)\n  (forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\n   eq ?v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (shrimm a0 n)\n     (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n  ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (makelong (shrimm a0 n)\n     (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))) \n  ?v",
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq ?v (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v2 v4)\n  (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : Int.int) (_ : eq x0 (Vint p)) (_ : eq y (Vint q)),\neq (Val.longofwords v2 v4)\n  (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))",
                    "H7 : eq y (Vint q)",
                    "H6 : eq x0 (Vint p)",
                    "p : Int.int",
                    "q : Int.int"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "B3 : Val.lessdef (Val.shl (Vint p) (Vint (Int.sub Int.iwordsize n))) v3",
                    "B2 : Val.lessdef (Val.shr (Vint p) (Vint n)) v2",
                    "B1 : Val.lessdef (Val.shru (Vint q) (Vint n)) v1",
                    "H5 : eval_expr ge sp e m le0 b (Vint q)",
                    "H4 : eval_expr ge sp e m le0 a0 (Vint p)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (Val.shrl (Vlong (Int64.ofwords p q)) (Vint n))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.ofwords p q) n)\n   else Vundef)",
                    "B3 : Val.lessdef\n  (if Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize\n   then Vint (Int.shl p (Int.sub Int.iwordsize n))\n   else Vundef) v3",
                    "B2 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shr p n) else Vundef) v2",
                    "B1 : Val.lessdef\n  (if Int.ltu n Int.iwordsize then Vint (Int.shru q n) else Vundef) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H1 : eq (Int.ltu n Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (Vint (Int.shr p n)) v2",
                    "B1 : Val.lessdef (Vint (Int.shru q n)) v1"
                ]
            },
            {
                "tactic_sig": "rewrite _i in * .",
                "tactic_sig_no_out_arg": "rewrite _i in * .",
                "tactic_args": [
                    "H2 : eq (Int.ltu (Int.sub Int.iwordsize n) Int.iwordsize) true"
                ],
                "tactic_res": [
                    "B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4)\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' (Int64.ofwords p q) n)\n   else Vundef)",
                    "H3 : eq (Int.ltu n Int64.iwordsize') true"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v2 v4) (Vlong (Int64.shr' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int.shru q n)) v1"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef (Val.or (Vint (Int.shru q n)) v3) v4",
                    "A1 : eval_expr ge sp e m le0 (shruimm b n) (Vint (Int.shru q n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v2 v4) (Vlong (Int64.shr' (Int64.ofwords p q) n))",
                    "B2 : Val.lessdef (Vint (Int.shr p n)) v2"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords (Vint (Int.shr p n)) v4)\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))",
                    "A2 : eval_expr ge sp e m le0 (shrimm a0 n) (Vint (Int.shr p n))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B3 : Val.lessdef (Vint (Int.shl p (Int.sub Int.iwordsize n))) v3"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n))\n     (Vint (Int.shl p (Int.sub Int.iwordsize n)))) v4",
                    "A3 : eval_expr ge sp e m le0 (shlimm a0 (Int.sub Int.iwordsize n))\n  (Vint (Int.shl p (Int.sub Int.iwordsize n)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B4 : Val.lessdef\n  (Val.or (Vint (Int.shru q n))\n     (Vint (Int.shl p (Int.sub Int.iwordsize n)))) v4"
                ],
                "tactic_res": [
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))\n  v4"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords (Vint (Int.shr p n)) v4)\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))",
                    "B4 : Val.lessdef\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))\n  v4"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Val.longofwords (Vint (Int.shr p n))\n     (Vint\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))",
                    "A4 : eval_expr ge sp e m le0\n  (or (shruimm b n) (shlimm a0 (Int.sub Int.iwordsize n)))\n  (Vint (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (Val.longofwords (Vint (Int.shr p n))\n     (Vint\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_shr_1 .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_shr_1 .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong (Int64.shr' (Int64.ofwords p q) n))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))",
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))\n  (Vlong\n     (Int64.ofwords (Int.shr p n)\n        (Int.or (Int.shru q n) (Int.shl p (Int.sub Int.iwordsize n)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le 0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ => True\n| _ => eq (Val.shrl x (Vint n)) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.shrl Vundef (Vint n)) Vundef",
                    "_goal : eq (Val.shrl (Vint i) (Vint n)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.shrl (Vfloat f) (Vint n)) Vundef",
                    "_goal : eq (Val.shrl (Vsingle f) (Vint n)) Vundef",
                    "_goal : eq (Val.shrl (Vptr b i) (Vint n)) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrl Vundef (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrl (Vint i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrl (Vfloat f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrl (Vsingle f) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.shrl (Vptr b i) (Vint n)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_highlong .",
                "tactic_sig_no_out_arg": "exploit eval_highlong .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H : eval_expr ge sp e m le a x"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword x) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "B1 : Val.lessdef (Val.hiword x) v1",
                    "A1 : eval_expr ge sp e m le (highlong a) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "assert ( eval_expr _i _i _i _i ( _i : : _i ) ( Eletvar 0 ) _i ) by EvalOp .",
                "tactic_sig_no_out_arg": "assert ( eval_expr _i _i _i _i ( _i : : _i ) ( Eletvar 0 ) _i ) by EvalOp .",
                "tactic_args": [
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "v1 : val",
                    "le : letenv",
                    "v1 : val"
                ],
                "tactic_res": [
                    "H2 : eval_expr ge sp e m (cons v1 le) (Eletvar 0) v1"
                ]
            },
            {
                "tactic_sig": "exploit eval_shrimm .",
                "tactic_sig_no_out_arg": "exploit eval_shrimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shrimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shr ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shrimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shr ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H2 : eval_expr ge sp e m (cons v1 le) (Eletvar 0) v1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) ?Goal0) v)\n           (Val.lessdef (Val.shr v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.sub _i Int.iwordsize ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) ?Goal0) v)\n           (Val.lessdef (Val.shr v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v)\n           (Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "B2 : Val.lessdef (Val.shr v1 (Vint (Int.sub n Int.iwordsize))) v2",
                    "A2 : eval_expr ge sp e m (cons v1 le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_shrimm .",
                "tactic_sig_no_out_arg": "exploit eval_shrimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shrimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shr ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (shrimm ?Goal6 ?Goal4) v)\n           (Val.lessdef (Val.shr ?Goal7 (Vint ?Goal4)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H2 : eval_expr ge sp e m (cons v1 le) (Eletvar 0) v1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) ?Goal0) v)\n           (Val.lessdef (Val.shr v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int.repr 31 ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int.repr 31 ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) ?Goal0) v)\n           (Val.lessdef (Val.shr v1 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v3 [ A3 B3 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons v1 le)\n              (shrimm (Eletvar 0) (Int.repr 31)) v)\n           (Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "B3 : Val.lessdef (Val.shr v1 (Vint (Int.repr 31))) v3",
                    "A3 : eval_expr ge sp e m (cons v1 le) (shrimm (Eletvar 0) (Int.repr 31)) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet (highlong a)\n           (makelong (shrimm (Eletvar 0) (Int.repr 31))\n              (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet (highlong a)\n        (makelong (shrimm (Eletvar 0) (Int.repr 31))\n           (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) \n     ?v) (Val.lessdef (Val.shrl x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet (highlong a)\n        (makelong (shrimm (Eletvar 0) (Int.repr 31))\n           (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) \n     ?v) (Val.lessdef (Val.shrl x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet (highlong a)\n     (makelong (shrimm (Eletvar 0) (Int.repr 31))\n        (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet (highlong a)\n     (makelong (shrimm (Eletvar 0) (Int.repr 31))\n        (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) (Val.longofwords v3 v2)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef (Val.shrl (Vint i) (Vint n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef (Val.shrl (Vlong i) (Vint n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef (Val.shrl (Vfloat f) (Vint n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef (Val.shrl (Vsingle f) (Vint n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef (Val.shrl (Vptr b i) (Vint n)) (Val.longofwords v3 v2)",
                    "B1 : Val.lessdef (Val.hiword Vundef) v1",
                    "H : eval_expr ge sp e m le a Vundef",
                    "B1 : Val.lessdef (Val.hiword (Vint i)) v1",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "B1 : Val.lessdef (Val.hiword (Vlong i)) v1",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "B1 : Val.lessdef (Val.hiword (Vfloat f)) v1",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "B1 : Val.lessdef (Val.hiword (Vsingle f)) v1",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "B1 : Val.lessdef (Val.hiword (Vptr b i)) v1",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vint i) (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vlong i) (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' i n)\n   else Vundef) (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' i n)\n   else Vundef) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' i n)\n   else Vundef) (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vfloat f) (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vsingle f) (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl (Vptr b i) (Vint n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Int.ltu _i Int64.iwordsize' ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.ltu _i Int64.iwordsize' ) .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (if Int.ltu n Int64.iwordsize'\n   then Vlong (Int64.shr' i n)\n   else Vundef) (Val.longofwords v3 v2)",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)",
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Val.longofwords v3 v2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.hiword (Vlong i)) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int64.hiword i)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int64.hiword i)) v1"
                ],
                "tactic_res": [
                    "A3 : eval_expr ge sp e m (cons (Vint (Int64.hiword i)) le)\n  (shrimm (Eletvar 0) (Int.repr 31)) v3",
                    "B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3",
                    "A2 : eval_expr ge sp e m (cons (Vint (Int64.hiword i)) le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize)) v2",
                    "B2 : Val.lessdef\n  (Val.shr (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2",
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword i))",
                    "H2 : eval_expr ge sp e m (cons (Vint (Int64.hiword i)) le) \n  (Eletvar 0) (Vint (Int64.hiword i))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.shr (Vint (Int64.hiword i)) (Vint (Int.sub n Int.iwordsize))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "H1 : eq (Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize) true",
                    "B2 : Val.lessdef\n  (if Int.ltu (Int.sub n Int.iwordsize) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))\n   else Vundef) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))\n  v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Val.longofwords v3 v2)",
                    "B2 : Val.lessdef (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))\n  v2"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))",
                    "A2 : eval_expr ge sp e m (cons (Vint (Int64.hiword i)) le)\n  (shrimm (Eletvar 0) (Int.sub n Int.iwordsize))\n  (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B3 : Val.lessdef (Val.shr (Vint (Int64.hiword i)) (Vint (Int.repr 31))) v3"
                ],
                "tactic_res": [
                    "B3 : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef) v3"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords v3\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))",
                    "B3 : Val.lessdef\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef) v3"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))",
                    "A3 : eval_expr ge sp e m (cons (Vint (Int64.hiword i)) le)\n  (shrimm (Eletvar 0) (Int.repr 31))\n  (if Int.ltu (Int.repr 31) Int.iwordsize\n   then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n   else Vundef)"
                ]
            },
            {
                "tactic_sig": "change ( Int.ltu ( Int.repr 31 ) Int.iwordsize ) with true .",
                "tactic_sig_no_out_arg": "change ( Int.ltu ( Int.repr 31 ) Int.iwordsize ) with true .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if Int.ltu (Int.repr 31) Int.iwordsize\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if true\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Val.longofwords\n     (if true\n      then Vint (Int.shr (Int64.hiword i) (Int.repr 31))\n      else Vundef)\n     (Vint (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.ofwords (Int.shr (Int64.hiword i) (Int.repr 31))\n        (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ]
            },
            {
                "tactic_sig": "erewrite <- Int64.decompose_shr_2 .",
                "tactic_sig_no_out_arg": "erewrite <- Int64.decompose_shr_2 .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.ofwords (Int.shr (Int64.hiword i) (Int.repr 31))\n        (Int.shr (Int64.hiword i) (Int.sub n Int.iwordsize))))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong (Int64.shr' (Int64.ofwords (Int64.hiword i) ?xl) n))",
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Int64.loword _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Int64.loword _i ) .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong (Int64.shr' (Int64.ofwords (Int64.hiword i) ?xl) n))",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.shr' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n))\n  (Vlong\n     (Int64.shr' (Int64.ofwords (Int64.hiword i) (Int64.loword i)) n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Vlong (Int64.shr' i n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shr' i n)) (Vlong (Int64.shr' i n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned n))\n  (Z.lt (Int.unsigned n) Int64.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sar sig_li_l\n           (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sar sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shrl x (Vint n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sar sig_li_l\n        (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n     ?v) (Val.lessdef (Val.shrl x (Vint n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sar sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sar sig_li_l\n     (Econs a (Econs (Eop (Ointconst n) Enil) Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : helper_declared prog i64_sar ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst n) Enil) ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sar\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sar\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vint n) nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sar)\n     (cons x (cons (Vint n) nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sar)\n     (cons x (cons (Vint n) nil))) (Some ?v)",
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) (Val.shrl x (Vint n))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x (Vint n)) (Val.shrl x (Vint n))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shrl",
        "proof": [
            {
                "tactic_sig": "unfold shrl .",
                "tactic_sig_no_out_arg": "unfold shrl .",
                "tactic_args": [
                    "_goal : binary_constructor_sound shrl Val.shrl"
                ],
                "tactic_res": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shrlimm e1 n\n   | None => Eexternal i64_sar sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shrl"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_intconst e2 with\n   | Some n => shrlimm e1 n\n   | None => Eexternal i64_sar sig_li_l (Econs e1 (Econs e2 Enil))\n   end) Val.shrl"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrlimm a n\n        | None => Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrlimm a n\n        | None => Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrlimm a n\n        | None => Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrl x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_intconst _i ) as [ n| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_intconst _i ) as [ n| ] eqn : IC .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_intconst b with\n        | Some n => shrlimm a n\n        | None => Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))\n        end v) (Val.lessdef (Val.shrl x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shrl x y) v))",
                    "IC : eq (is_intconst b) (Some n)",
                    "n : Int.int",
                    "IC : eq (is_intconst b) None"
                ]
            },
            {
                "tactic_sig": "exploit is_intconst_sound .",
                "tactic_sig_no_out_arg": "exploit is_intconst_sound .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_intconst ?Goal1) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vint ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vint n),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))",
                    "EQ : eq y (Vint n)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))",
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H0 : eval_expr ge sp e m le b (Vint n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eapply eval_shrlimm .",
                "tactic_sig_no_out_arg": "eapply eval_shrlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrlimm a n) v)\n     (Val.lessdef (Val.shrl x (Vint n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef (Val.shrl x y) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shrl x y) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef (Val.shrl x y) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef (Val.shrl x y) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sar sig_li_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_sar ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H16 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H12 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H11 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H10 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H9 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H8 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H5 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H4 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H2 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H3 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H1 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sar ?name sig_li_l",
                    "_goal : eq (lookup_builtin_function ?name sig_li_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sar\" sig_li_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sar\" sig_li_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sar) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sar) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef (Val.shrl x y) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl x y) (Val.shrl x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x y) (Val.shrl x y)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_addl",
        "proof": [
            {
                "tactic_sig": "unfold addl .",
                "tactic_sig_no_out_arg": "unfold addl .",
                "tactic_args": [
                    "_goal : forall _ : eq Archi.ptr64 false, binary_constructor_sound addl Val.addl"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq Archi.ptr64 false,\nbinary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.add n1 n2)\n       | None =>\n           if Int64.eq n1 Int64.zero\n           then e2\n           else\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 =>\n           if Int64.eq n2 Int64.zero\n           then e1\n           else\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       | None =>\n           Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n             (Econs e1 (Econs e2 Enil))\n       end\n   end) Val.addl"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall _ : eq Archi.ptr64 false,\nbinary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.add n1 n2)\n       | None =>\n           if Int64.eq n1 Int64.zero\n           then e2\n           else\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 =>\n           if Int64.eq n2 Int64.zero\n           then e1\n           else\n            Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       | None =>\n           Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n             (Econs e1 (Econs e2 Enil))\n       end\n   end) Val.addl"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq Archi.ptr64 false) (le : letenv) (a : expr) \n  (x : val) (b : expr) (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq Archi.ptr64 false) (le : letenv) (a : expr) \n  (x : val) (b : expr) (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "H1 : eval_expr ge sp e m le b y",
                    "H0 : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "H : eq Archi.ptr64 false"
                ]
            },
            {
                "tactic_sig": "set ( default := Ebuiltin ( EF_builtin \"__builtin_addl\" sig_ll_l ) ( _i : : : _i : : : Enil ) ) .",
                "tactic_sig_no_out_arg": "set ( default := Ebuiltin ( EF_builtin \"__builtin_addl\" sig_ll_l ) ( _i : : : _i : : : Enil ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_addl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "a : expr",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None => if Int64.eq n1 Int64.zero then b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "default : expr"
                ]
            },
            {
                "tactic_sig": "assert ( DEFAULT : exists v , eval_expr _i _i _i _i _i _i v /\\ Val.lessdef ( Val.addl _i _i ) v ) .",
                "tactic_sig_no_out_arg": "assert ( DEFAULT : exists v , eval_expr _i _i _i _i _i _i v /\\ Val.lessdef ( Val.addl _i _i ) v ) .",
                "tactic_args": [
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "le : letenv",
                    "default : expr",
                    "x : val",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le default ?v)\n  (Val.lessdef (Val.addl x y) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le default ?v)\n  (Val.lessdef (Val.addl x y) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le default ?v",
                    "_goal : Val.lessdef (Val.addl x y) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_builtin_2 .",
                "tactic_sig_no_out_arg": "eapply eval_builtin_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le default ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_addl\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_addl) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_addl) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef (Val.addl x y) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.addl x y) (Val.addl x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl x y) (Val.addl x y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None => if Int64.eq n1 Int64.zero then b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None => if Int64.eq n1 Int64.zero then b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ p| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ p| ] eqn : LC1 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.add n1 n2)\n            | None => if Int64.eq n1 Int64.zero then b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add p n2)\n        | None => if Int64.eq p Int64.zero then b else default\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "LC1 : eq (is_longconst a) (Some p)",
                    "p : Int64.int",
                    "LC1 : eq (is_longconst a) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : LC2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.add p n2)\n        | None => if Int64.eq p Int64.zero then b else default\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then b else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "LC2 : eq (is_longconst b) (Some q)",
                    "q : Int64.int",
                    "LC2 : eq (is_longconst b) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end v) (Val.lessdef (Val.addl x y) v))",
                    "b : expr",
                    "LC2 : eq (is_longconst b) (Some q)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "EQ : eq x (Vlong p)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong p)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))",
                    "EQ : eq y (Vlong q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) (Vlong q)) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong p) (Vlong q)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong q)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) v)\n     (Val.lessdef (Val.addl (Vlong p) (Vlong q)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) ?v)\n  (Val.lessdef (Val.addl (Vlong p) (Vlong q)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.add p q)) ?v)\n  (Val.lessdef (Val.addl (Vlong p) (Vlong q)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.add p q)) ?v",
                    "_goal : Val.lessdef (Val.addl (Vlong p) (Vlong q)) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.add p q)) ?v",
                    "_goal : Val.lessdef (Val.addl (Vlong p) (Vlong q)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.addl (Vlong p) (Vlong q)) (Vlong (Int64.add p q))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl (Vlong p) (Vlong q)) (Vlong (Int64.add p q))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add p q)) (Vlong (Int64.add p q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add p q)) (Vlong (Int64.add p q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then b else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq p Int64.zero\n      then eq p Int64.zero\n      else not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then b else default) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq p Int64.zero\n      then eq p Int64.zero\n      else not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then b else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq p Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))",
                    "_goal : forall _ : not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq p Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))",
                    "H2 : eq p Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "H2 : not (eq p Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "LC1 : eq (is_longconst a) (Some Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal1 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))",
                    "EQ : eq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl x y) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) y) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) y) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le b v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le b y)\n  (Val.lessdef (Val.addl (Vlong Int64.zero) y) y)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le b y)\n  (Val.lessdef (Val.addl (Vlong Int64.zero) y) y)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le b y",
                    "_goal : Val.lessdef (Val.addl (Vlong Int64.zero) y) y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl (Vlong Int64.zero) y) y"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.addl (Vlong Int64.zero) y) y"
                ]
            },
            {
                "tactic_sig": "unfold Val.addl .",
                "tactic_sig_no_out_arg": "unfold Val.addl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl (Vlong Int64.zero) y) y"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match y with\n  | Vlong n2 => Vlong (Int64.add Int64.zero n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end y"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match y with\n  | Vlong n2 => Vlong (Int64.add Int64.zero n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end y",
                    "H : eq Archi.ptr64 false"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match y with\n  | Vlong n2 => Vlong (Int64.add Int64.zero n2)\n  | _ => Vundef\n  end y"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match y with\n  | Vlong n2 => Vlong (Int64.add Int64.zero n2)\n  | _ => Vundef\n  end y",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef (Vint i)",
                    "_goal : Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i)",
                    "_goal : Val.lessdef Vundef (Vfloat f)",
                    "_goal : Val.lessdef Vundef (Vsingle f)",
                    "_goal : Val.lessdef Vundef (Vptr b0 i)",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) Vundef) v))",
                    "H1 : eval_expr ge sp e m le b Vundef",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) (Vint i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vint i)",
                    "i : Int.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) (Vlong i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong i)",
                    "i : Int64.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) (Vfloat f)) v))",
                    "H1 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) (Vsingle f)) v))",
                    "H1 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong Int64.zero) (Vptr b0 i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b0 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.add_zero_l .",
                "tactic_sig_no_out_arg": "rewrite Int64.add_zero_l .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add Int64.zero i)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq q Int64.zero\n      then eq q Int64.zero\n      else not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq q Int64.zero\n      then eq q Int64.zero\n      else not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.addl x y) v))",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq q Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))",
                    "_goal : forall _ : not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq q Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))",
                    "H2 : eq q Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "H2 : not (eq q Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "LC2 : eq (is_longconst b) (Some Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal0 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))",
                    "EQ : eq y (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x (Vlong Int64.zero)) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x (Vlong Int64.zero)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.addl x (Vlong Int64.zero)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.addl x (Vlong Int64.zero)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.addl x (Vlong Int64.zero)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.addl x (Vlong Int64.zero)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl x (Vlong Int64.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.addl x (Vlong Int64.zero)) x"
                ]
            },
            {
                "tactic_sig": "unfold Val.addl .",
                "tactic_sig_no_out_arg": "unfold Val.addl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.addl x (Vlong Int64.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.add n1 Int64.zero)\n  | Vptr b1 ofs1 =>\n      if Archi.ptr64\n      then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.add n1 Int64.zero)\n  | Vptr b1 ofs1 =>\n      if Archi.ptr64\n      then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end x",
                    "H : eq Archi.ptr64 false"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.add n1 Int64.zero)\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.add n1 Int64.zero)\n  | _ => Vundef\n  end x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef (Vint i)",
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)",
                    "_goal : Val.lessdef Vundef (Vfloat f)",
                    "_goal : Val.lessdef Vundef (Vsingle f)",
                    "_goal : Val.lessdef Vundef (Vptr b0 i)",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl Vundef (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a Vundef",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vint i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vlong i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vfloat f) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vsingle f) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl (Vptr b0 i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b0 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.add_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.add_zero .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.add i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.addl x y) v))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_subl",
        "proof": [
            {
                "tactic_sig": "unfold subl .",
                "tactic_sig_no_out_arg": "unfold subl .",
                "tactic_args": [
                    "_goal : forall _ : eq Archi.ptr64 false, binary_constructor_sound subl Val.subl"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq Archi.ptr64 false,\nbinary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.sub n1 n2)\n       | None =>\n           if Int64.eq n1 Int64.zero\n           then negl e2\n           else\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 =>\n           if Int64.eq n2 Int64.zero\n           then e1\n           else\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       | None =>\n           Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n             (Econs e1 (Econs e2 Enil))\n       end\n   end) Val.subl"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall _ : eq Archi.ptr64 false,\nbinary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.sub n1 n2)\n       | None =>\n           if Int64.eq n1 Int64.zero\n           then negl e2\n           else\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 =>\n           if Int64.eq n2 Int64.zero\n           then e1\n           else\n            Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n              (Econs e1 (Econs e2 Enil))\n       | None =>\n           Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n             (Econs e1 (Econs e2 Enil))\n       end\n   end) Val.subl"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq Archi.ptr64 false) (le : letenv) (a : expr) \n  (x : val) (b : expr) (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then negl b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq Archi.ptr64 false) (le : letenv) (a : expr) \n  (x : val) (b : expr) (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then negl b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then negl b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "H1 : eval_expr ge sp e m le b y",
                    "H0 : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "H : eq Archi.ptr64 false"
                ]
            },
            {
                "tactic_sig": "set ( default := Ebuiltin ( EF_builtin \"__builtin_subl\" sig_ll_l ) ( _i : : : _i : : : Enil ) ) .",
                "tactic_sig_no_out_arg": "set ( default := Ebuiltin ( EF_builtin \"__builtin_subl\" sig_ll_l ) ( _i : : : _i : : : Enil ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero\n                then negl b\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 =>\n                if Int64.eq n2 Int64.zero\n                then a\n                else\n                 Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                   (Econs a (Econs b Enil))\n            | None =>\n                Ebuiltin (EF_builtin \"__builtin_subl\" sig_ll_l)\n                  (Econs a (Econs b Enil))\n            end\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "a : expr",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero then negl b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "default : expr"
                ]
            },
            {
                "tactic_sig": "assert ( DEFAULT : exists v , eval_expr _i _i _i _i _i _i v /\\ Val.lessdef ( Val.subl _i _i ) v ) .",
                "tactic_sig_no_out_arg": "assert ( DEFAULT : exists v , eval_expr _i _i _i _i _i _i v /\\ Val.lessdef ( Val.subl _i _i ) v ) .",
                "tactic_args": [
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "le : letenv",
                    "default : expr",
                    "x : val",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le default ?v)\n  (Val.lessdef (Val.subl x y) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le default ?v)\n  (Val.lessdef (Val.subl x y) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le default ?v",
                    "_goal : Val.lessdef (Val.subl x y) ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_builtin_2 .",
                "tactic_sig_no_out_arg": "eapply eval_builtin_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le default ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_subl\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_subl) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_subl) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef (Val.subl x y) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.subl x y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.subl x y) (Val.subl x y)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero then negl b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero then negl b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ p| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ p| ] eqn : LC1 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.sub n1 n2)\n            | None =>\n                if Int64.eq n1 Int64.zero then negl b else default\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => if Int64.eq n2 Int64.zero then a else default\n            | None => default\n            end\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub p n2)\n        | None => if Int64.eq p Int64.zero then negl b else default\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "LC1 : eq (is_longconst a) (Some p)",
                    "p : Int64.int",
                    "LC1 : eq (is_longconst a) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : LC2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.sub p n2)\n        | None => if Int64.eq p Int64.zero then negl b else default\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then negl b else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "LC2 : eq (is_longconst b) (Some q)",
                    "q : Int64.int",
                    "LC2 : eq (is_longconst b) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => if Int64.eq n2 Int64.zero then a else default\n        | None => default\n        end v) (Val.lessdef (Val.subl x y) v))",
                    "b : expr",
                    "LC2 : eq (is_longconst b) (Some q)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "EQ : eq x (Vlong p)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong p)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))",
                    "EQ : eq y (Vlong q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) (Vlong q)) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong p) (Vlong q)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong q)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) v)\n     (Val.lessdef (Val.subl (Vlong p) (Vlong q)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) ?v)\n  (Val.lessdef (Val.subl (Vlong p) (Vlong q)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.sub p q)) ?v)\n  (Val.lessdef (Val.subl (Vlong p) (Vlong q)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.sub p q)) ?v",
                    "_goal : Val.lessdef (Val.subl (Vlong p) (Vlong q)) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.sub p q)) ?v",
                    "_goal : Val.lessdef (Val.subl (Vlong p) (Vlong q)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.subl (Vlong p) (Vlong q)) (Vlong (Int64.sub p q))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.subl (Vlong p) (Vlong q)) (Vlong (Int64.sub p q))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub p q)) (Vlong (Int64.sub p q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub p q)) (Vlong (Int64.sub p q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then negl b else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq p Int64.zero\n      then eq p Int64.zero\n      else not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then negl b else default) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq p Int64.zero\n      then eq p Int64.zero\n      else not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq p Int64.zero then negl b else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq p Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "_goal : forall _ : not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq p Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "H2 : eq p Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq p Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "H2 : not (eq p Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "replace ( Val.subl _i _i ) with ( Val.negl _i ) .",
                "tactic_sig_no_out_arg": "replace ( Val.subl _i _i ) with ( Val.negl _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "x : val",
                    "y : val",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.negl y) v))",
                    "_goal : eq (Val.negl y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "eapply eval_negl .",
                "tactic_sig_no_out_arg": "eapply eval_negl .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (negl b) v)\n     (Val.lessdef (Val.negl y) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "LC1 : eq (is_longconst a) (Some Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : eq (Val.negl y) (Val.subl x y)",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2), eq (Val.negl y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2), eq (Val.negl y) (Val.subl x y)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal1 (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong Int64.zero), eq (Val.negl y) (Val.subl x y)"
                ],
                "tactic_res": [
                    "_goal : eq (Val.negl y) (Val.subl x y)",
                    "EQ : eq x (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : eq (Val.negl y) (Val.subl x y)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.negl y) (Val.subl (Vlong Int64.zero) y)",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) y) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (Val.negl y) (Val.subl (Vlong Int64.zero) y)",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.negl Vundef) (Val.subl (Vlong Int64.zero) Vundef)",
                    "_goal : eq (Val.negl (Vint i)) (Val.subl (Vlong Int64.zero) (Vint i))",
                    "_goal : eq (Val.negl (Vlong i)) (Val.subl (Vlong Int64.zero) (Vlong i))",
                    "_goal : eq (Val.negl (Vfloat f)) (Val.subl (Vlong Int64.zero) (Vfloat f))",
                    "_goal : eq (Val.negl (Vsingle f)) (Val.subl (Vlong Int64.zero) (Vsingle f))",
                    "_goal : eq (Val.negl (Vptr b0 i)) (Val.subl (Vlong Int64.zero) (Vptr b0 i))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) Vundef) v))",
                    "H1 : eval_expr ge sp e m le b Vundef",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) (Vint i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vint i)",
                    "i : Int.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) (Vlong i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong i)",
                    "i : Int64.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) (Vfloat f)) v))",
                    "H1 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) (Vsingle f)) v))",
                    "H1 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong Int64.zero) (Vptr b0 i)) v))",
                    "H1 : eval_expr ge sp e m le b (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl Vundef) (Val.subl (Vlong Int64.zero) Vundef)"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl (Vint i)) (Val.subl (Vlong Int64.zero) (Vint i))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl (Vlong i)) (Val.subl (Vlong Int64.zero) (Vlong i))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.neg i)) (Vlong (Int64.sub Int64.zero i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.neg i)) (Vlong (Int64.sub Int64.zero i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl (Vfloat f)) (Val.subl (Vlong Int64.zero) (Vfloat f))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl (Vsingle f)) (Val.subl (Vlong Int64.zero) (Vsingle f))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.negl (Vptr b0 i)) (Val.subl (Vlong Int64.zero) (Vptr b0 i))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq q Int64.zero\n      then eq q Int64.zero\n      else not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq q Int64.zero\n      then eq q Int64.zero\n      else not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq q Int64.zero then a else default) v)\n     (Val.lessdef (Val.subl x y) v))",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq q Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))",
                    "_goal : forall _ : not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq q Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))",
                    "H2 : eq q Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq q Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "H2 : not (eq q Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "LC2 : eq (is_longconst b) (Some Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal0 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong Int64.zero),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))",
                    "EQ : eq y (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x (Vlong Int64.zero)) v))",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x (Vlong Int64.zero)) v))",
                    "H1 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.subl x (Vlong Int64.zero)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.subl x (Vlong Int64.zero)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.subl x (Vlong Int64.zero)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.subl x (Vlong Int64.zero)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.subl x (Vlong Int64.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.subl x (Vlong Int64.zero)) x"
                ]
            },
            {
                "tactic_sig": "unfold Val.subl .",
                "tactic_sig_no_out_arg": "unfold Val.subl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.subl x (Vlong Int64.zero)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.sub n1 Int64.zero)\n  | Vptr b1 ofs1 =>\n      if Archi.ptr64\n      then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.sub n1 Int64.zero)\n  | Vptr b1 ofs1 =>\n      if Archi.ptr64\n      then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 Int64.zero))\n      else Vundef\n  | _ => Vundef\n  end x",
                    "H : eq Archi.ptr64 false"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.sub n1 Int64.zero)\n  | _ => Vundef\n  end x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  match x with\n  | Vlong n1 => Vlong (Int64.sub n1 Int64.zero)\n  | _ => Vundef\n  end x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef",
                    "_goal : Val.lessdef Vundef (Vint i)",
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)",
                    "_goal : Val.lessdef Vundef (Vfloat f)",
                    "_goal : Val.lessdef Vundef (Vsingle f)",
                    "_goal : Val.lessdef Vundef (Vptr b0 i)",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl Vundef (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a Vundef",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vint i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vlong i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vfloat f) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vsingle f) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "DEFAULT : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl (Vptr b0 i) (Vlong Int64.zero)) v))",
                    "H0 : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b0 i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.sub_zero_l .",
                "tactic_sig_no_out_arg": "rewrite Int64.sub_zero_l .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.sub i Int64.zero)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le default v)\n     (Val.lessdef (Val.subl x y) v))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_mull_base",
        "proof": [
            {
                "tactic_sig": "unfold mull_base .",
                "tactic_sig_no_out_arg": "unfold mull_base .",
                "tactic_args": [
                    "_goal : binary_constructor_sound mull_base Val.mull"
                ],
                "tactic_res": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   splitlong2 e1 e2\n     (fun h1 l1 h2 l2 : expr =>\n      Elet\n        (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n           (Econs l1 (Econs l2 Enil)))\n        (makelong\n           (add\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift l1) (lift h2))) (mul (lift h1) (lift l2)))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) Val.mull"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   splitlong2 e1 e2\n     (fun h1 l1 h2 l2 : expr =>\n      Elet\n        (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n           (Econs l1 (Econs l2 Enil)))\n        (makelong\n           (add\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift l1) (lift h2))) (mul (lift h1) (lift l2)))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))) Val.mull"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr =>\n            Elet\n              (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n                 (Econs l1 (Econs l2 Enil)))\n              (makelong\n                 (add\n                    (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                       (mul (lift l1) (lift h2)))\n                    (mul (lift h1) (lift l2)))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr =>\n            Elet\n              (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n                 (Econs l1 (Econs l2 Enil)))\n              (makelong\n                 (add\n                    (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                       (mul (lift l1) (lift h2)))\n                    (mul (lift h1) (lift l2)))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr =>\n            Elet\n              (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n                 (Econs l1 (Econs l2 Enil)))\n              (makelong\n                 (add\n                    (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                       (mul (lift l1) (lift h2)))\n                    (mul (lift h1) (lift l2)))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "apply eval_splitlong2 .",
                "tactic_sig_no_out_arg": "apply eval_splitlong2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (splitlong2 a b\n           (fun h1 l1 h2 l2 : expr =>\n            Elet\n              (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n                 (Econs l1 (Econs l2 Enil)))\n              (makelong\n                 (add\n                    (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                       (mul (lift l1) (lift h2)))\n                    (mul (lift h1) (lift l2)))\n                 (Eop Olowlong (Econs (Eletvar 0) Enil))))) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.mull x y) Vundef\n    end\n| _ => eq (Val.mull x y) Vundef\nend",
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr) (x1 x2 y1 y2 : val)\n  (_ : eval_expr ge sp e m le a1 x1) (_ : eval_expr ge sp e m le a2 x2)\n  (_ : eval_expr ge sp e m le b1 y1) (_ : eval_expr ge sp e m le b2 y2),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2",
                    "H3 : eval_expr ge sp e m le0 b1 y1",
                    "H2 : eval_expr ge sp e m le0 a2 x2",
                    "H1 : eval_expr ge sp e m le0 a1 x1",
                    "x1 : val",
                    "x2 : val",
                    "y1 : val",
                    "y2 : val",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "set ( p := Val.mull' _i _i ) .",
                "tactic_sig_no_out_arg": "set ( p := Val.mull' _i _i ) .",
                "tactic_args": [
                    "x2 : val",
                    "y2 : val"
                ],
                "tactic_res": [
                    "p : val"
                ]
            },
            {
                "tactic_sig": "set ( le1 := _i : : _i ) .",
                "tactic_sig_no_out_arg": "set ( le1 := _i : : _i ) .",
                "tactic_args": [
                    "p : val",
                    "le0 : letenv"
                ],
                "tactic_res": [
                    "le1 : list val"
                ]
            },
            {
                "tactic_sig": "assert ( E1 : eval_expr _i _i _i _i _i ( Eop Olowlong ( Eletvar O : : : Enil ) ) ( Val.loword _i ) ) by EvalOp .",
                "tactic_sig_no_out_arg": "assert ( E1 : eval_expr _i _i _i _i _i ( Eop Olowlong ( Eletvar O : : : Enil ) ) ( Val.loword _i ) ) by EvalOp .",
                "tactic_args": [
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "le1 : list val",
                    "p : val"
                ],
                "tactic_res": [
                    "E1 : eval_expr ge sp e m le1 (Eop Olowlong (Econs (Eletvar 0) Enil))\n  (Val.loword p)"
                ]
            },
            {
                "tactic_sig": "assert ( E2 : eval_expr _i _i _i _i _i ( Eop Ohighlong ( Eletvar O : : : Enil ) ) ( Val.hiword _i ) ) by EvalOp .",
                "tactic_sig_no_out_arg": "assert ( E2 : eval_expr _i _i _i _i _i ( Eop Ohighlong ( Eletvar O : : : Enil ) ) ( Val.hiword _i ) ) by EvalOp .",
                "tactic_args": [
                    "ge : Genv.t fundef unit",
                    "sp : val",
                    "e : env",
                    "m : Mem.mem",
                    "le1 : list val",
                    "p : val"
                ],
                "tactic_res": [
                    "E2 : eval_expr ge sp e m le1 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n  (Val.hiword p)"
                ]
            },
            {
                "tactic_sig": "exploit eval_mul .",
                "tactic_sig_no_out_arg": "exploit eval_mul .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (mul ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.mul ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "apply eval_lift .",
                "tactic_sig_no_out_arg": "apply eval_lift .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (mul ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.mul ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?ge ?sp ?e ?m ?le ?a ?v",
                    "_goal : eval_expr ?ge ?sp ?e ?m (cons ?w ?le) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?ge ?sp ?e ?m (cons ?w ?le)\n              (mul (lift ?a) ?Goal0) v)\n           (Val.lessdef (Val.mul ?v ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?ge ?sp ?e ?m ?le ?a ?v",
                    "_goal : eval_expr ?ge ?sp ?e ?m (cons ?w ?le) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?ge ?sp ?e ?m (cons ?w ?le)\n              (mul (lift ?a) ?Goal0) v)\n           (Val.lessdef (Val.mul ?v ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H2 : eval_expr ge sp e m le0 a2 x2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons ?w le0) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) ?Goal0) v)\n           (Val.lessdef (Val.mul x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "apply eval_lift .",
                "tactic_sig_no_out_arg": "apply eval_lift .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons ?w le0) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) ?Goal0) v)\n           (Val.lessdef (Val.mul x2 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?a ?v",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) (lift ?a))\n              v) (Val.lessdef (Val.mul x2 ?v) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?a ?v",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) (lift ?a))\n              v) (Val.lessdef (Val.mul x2 ?v) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H3 : eval_expr ge sp e m le0 b1 y1"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) (lift b1))\n              v) (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a2) (lift b1))\n              v) (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "p : val"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons p le0) (mul (lift a2) (lift b1))\n              v) (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "fold _i .",
                "tactic_sig_no_out_arg": "fold _i .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons p le0) (mul (lift a2) (lift b1))\n              v) (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "le1 : list val"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1 (mul (lift a2) (lift b1)) v)\n           (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v3 [ E3 L3 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1 (mul (lift a2) (lift b1)) v)\n           (Val.lessdef (Val.mul x2 y1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "L3 : Val.lessdef (Val.mul x2 y1) v3",
                    "E3 : eval_expr ge sp e m le1 (mul (lift a2) (lift b1)) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_mul .",
                "tactic_sig_no_out_arg": "exploit eval_mul .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (mul ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.mul ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "apply eval_lift .",
                "tactic_sig_no_out_arg": "apply eval_lift .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (mul ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.mul ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?ge ?sp ?e ?m ?le ?a ?v",
                    "_goal : eval_expr ?ge ?sp ?e ?m (cons ?w ?le) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?ge ?sp ?e ?m (cons ?w ?le)\n              (mul (lift ?a) ?Goal0) v)\n           (Val.lessdef (Val.mul ?v ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?ge ?sp ?e ?m ?le ?a ?v",
                    "_goal : eval_expr ?ge ?sp ?e ?m (cons ?w ?le) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?ge ?sp ?e ?m (cons ?w ?le)\n              (mul (lift ?a) ?Goal0) v)\n           (Val.lessdef (Val.mul ?v ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H1 : eval_expr ge sp e m le0 a1 x1"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons ?w le0) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) ?Goal0) v)\n           (Val.lessdef (Val.mul x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "apply eval_lift .",
                "tactic_sig_no_out_arg": "apply eval_lift .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons ?w le0) ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) ?Goal0) v)\n           (Val.lessdef (Val.mul x1 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?a ?v",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) (lift ?a))\n              v) (Val.lessdef (Val.mul x1 ?v) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?a ?v",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) (lift ?a))\n              v) (Val.lessdef (Val.mul x1 ?v) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "H4 : eval_expr ge sp e m le0 b2 y2"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) (lift b2))\n              v) (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons ?w le0) (mul (lift a1) (lift b2))\n              v) (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "p : val"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons p le0) (mul (lift a1) (lift b2))\n              v) (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "fold _i .",
                "tactic_sig_no_out_arg": "fold _i .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m (cons p le0) (mul (lift a1) (lift b2))\n              v) (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "le1 : list val"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1 (mul (lift a1) (lift b2)) v)\n           (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v4 [ E4 L4 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1 (mul (lift a1) (lift b2)) v)\n           (Val.lessdef (Val.mul x1 y2) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "L4 : Val.lessdef (Val.mul x1 y2) v4",
                    "E4 : eval_expr ge sp e m le1 (mul (lift a1) (lift b2)) v4",
                    "v4 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_add .",
                "tactic_sig_no_out_arg": "exploit eval_add .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (add ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.add ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (add ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.add ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "E2 : eval_expr ge sp e m le1 (Eop Ohighlong (Econs (Eletvar 0) Enil))\n  (Val.hiword p)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le1 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal0) v)\n           (Val.lessdef (Val.add (Val.hiword p) ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le1 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil)) ?Goal0) v)\n           (Val.lessdef (Val.add (Val.hiword p) ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "E3 : eval_expr ge sp e m le1 (mul (lift a2) (lift b1)) v3"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift a2) (lift b1))) v)\n           (Val.lessdef (Val.add (Val.hiword p) v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v5 [ E5 L5 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift a2) (lift b1))) v)\n           (Val.lessdef (Val.add (Val.hiword p) v3) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "L5 : Val.lessdef (Val.add (Val.hiword p) v3) v5",
                    "E5 : eval_expr ge sp e m le1\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1))) v5",
                    "v5 : val"
                ]
            },
            {
                "tactic_sig": "exploit eval_add .",
                "tactic_sig_no_out_arg": "exploit eval_add .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (add ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.add ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal4 (add ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.add ?Goal6 ?Goal8) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "E5 : eval_expr ge sp e m le1\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1))) v5"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le1 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1))) ?Goal0) v)\n           (Val.lessdef (Val.add v5 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le1 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1))) ?Goal0) v)\n           (Val.lessdef (Val.add v5 ?Goal1) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "E4 : eval_expr ge sp e m le1 (mul (lift a1) (lift b2)) v4"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2))) v)\n           (Val.lessdef (Val.add v5 v4) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v6 [ E6 L6 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le1\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2))) v)\n           (Val.lessdef (Val.add v5 v4) v)),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "L6 : Val.lessdef (Val.add v5 v4) v6",
                    "E6 : eval_expr ge sp e m le1\n  (add\n     (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2))) v6",
                    "v6 : val"
                ]
            },
            {
                "tactic_sig": "exists ( Val.longofwords _i ( Val.loword _i ) ) .",
                "tactic_sig_no_out_arg": "exists ( Val.longofwords _i ( Val.loword _i ) ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le0\n        (Elet\n           (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n              (Econs a2 (Econs b2 Enil)))\n           (makelong\n              (add\n                 (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                    (mul (lift a2) (lift b1)))\n                 (mul (lift a1) (lift b2)))\n              (Eop Olowlong (Econs (Eletvar 0) Enil)))) v)\n     (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n        (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1))\n        (_ : eq y2 (Vint q2)),\n      eq v\n        (Val.mull (Vlong (Int64.ofwords p1 p2))\n           (Vlong (Int64.ofwords q1 q2)))))",
                    "v6 : val",
                    "p : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (Elet\n        (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n           (Econs a2 (Econs b2 Enil)))\n        (makelong\n           (add\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))\n     (Val.longofwords v6 (Val.loword p)))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords v6 (Val.loword p))\n     (Val.mull (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le0\n     (Elet\n        (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n           (Econs a2 (Econs b2 Enil)))\n        (makelong\n           (add\n              (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n                 (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n           (Eop Olowlong (Econs (Eletvar 0) Enil))))\n     (Val.longofwords v6 (Val.loword p)))\n  (forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n     (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\n   eq (Val.longofwords v6 (Val.loword p))\n     (Val.mull (Vlong (Int64.ofwords p1 p2))\n        (Vlong (Int64.ofwords q1 q2))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Elet\n     (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n        (Econs a2 (Econs b2 Enil)))\n     (makelong\n        (add\n           (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n        (Eop Olowlong (Econs (Eletvar 0) Enil))))\n  (Val.longofwords v6 (Val.loword p))",
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords v6 (Val.loword p))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Elet\n     (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n        (Econs a2 (Econs b2 Enil)))\n     (makelong\n        (add\n           (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n              (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n        (Eop Olowlong (Econs (Eletvar 0) Enil))))\n  (Val.longofwords v6 (Val.loword p))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n     (Econs a2 (Econs b2 Enil))) p"
                ]
            },
            {
                "tactic_sig": "eapply eval_builtin_2 .",
                "tactic_sig_no_out_arg": "eapply eval_builtin_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Ebuiltin (EF_builtin \"__builtin_mull\" sig_ii_l)\n     (Econs a2 (Econs b2 Enil))) p"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 a2 ?varg1",
                    "_goal : eval_expr ge sp e m le0 b2 ?varg2",
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some p)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 a2 ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some p)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x2 (cons ?varg2 nil))) (Some p)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 b2 ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x2 (cons ?varg2 nil))) (Some p)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x2 (cons y2 nil))) (Some p)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__builtin_mull\" sig_ii_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x2 (cons y2 nil))) (Some p)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_mull) (cons x2 (cons y2 nil)))\n  (Some p)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (builtin_function_sem (BI_standard BI_mull) (cons x2 (cons y2 nil)))\n  (Some p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p1 p2 q1 q2 : Int.int) (_ : eq x1 (Vint p1))\n  (_ : eq x2 (Vint p2)) (_ : eq y1 (Vint q1)) (_ : eq y2 (Vint q2)),\neq (Val.longofwords v6 (Val.loword p))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v6 (Val.loword p))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "H8 : eq y2 (Vint q2)",
                    "H7 : eq y1 (Vint q1)",
                    "H6 : eq x2 (Vint p2)",
                    "H5 : eq x1 (Vint p1)",
                    "p1 : Int.int",
                    "p2 : Int.int",
                    "q1 : Int.int",
                    "q2 : Int.int"
                ]
            },
            {
                "tactic_sig": "unfold _i , _i in * .",
                "tactic_sig_no_out_arg": "unfold _i , _i in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v6 (Val.loword p))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "le1 : list val",
                    "p : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v6 (Val.loword (Val.mull' x2 y2)))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "E6 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (add\n     (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2))) v6",
                    "L5 : Val.lessdef (Val.add (Val.hiword (Val.mull' x2 y2)) v3) v5",
                    "E5 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1))) v5",
                    "E4 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (mul (lift a1) (lift b2)) v4",
                    "E3 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (mul (lift a2) (lift b1)) v3",
                    "E2 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil))\n  (Val.hiword (Val.mull' x2 y2))",
                    "E1 : eval_expr ge sp e m (cons (Val.mull' x2 y2) le0)\n  (Eop Olowlong (Econs (Eletvar 0) Enil))\n  (Val.loword (Val.mull' x2 y2))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v6 (Val.loword (Val.mull' x2 y2)))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v6 (Val.loword (Val.mull' (Vint p2) (Vint q2))))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))",
                    "E6 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (add\n     (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2))) v6",
                    "L5 : Val.lessdef (Val.add (Val.hiword (Val.mull' (Vint p2) (Vint q2))) v3)\n  v5",
                    "E5 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1))) v5",
                    "E4 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (mul (lift a1) (lift b2)) v4",
                    "L4 : Val.lessdef (Val.mul (Vint p1) (Vint q2)) v4",
                    "E3 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (mul (lift a2) (lift b1)) v3",
                    "L3 : Val.lessdef (Val.mul (Vint p2) (Vint q1)) v3",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint q2)",
                    "E2 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil))\n  (Val.hiword (Val.mull' (Vint p2) (Vint q2)))",
                    "E1 : eval_expr ge sp e m (cons (Val.mull' (Vint p2) (Vint q2)) le0)\n  (Eop Olowlong (Econs (Eletvar 0) Enil))\n  (Val.loword (Val.mull' (Vint p2) (Vint q2)))",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint q1)",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint p2)",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint p1)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v6 (Val.loword (Val.mull' (Vint p2) (Vint q2))))\n  (Val.mull (Vlong (Int64.ofwords p1 p2)) (Vlong (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))",
                    "E6 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (add\n     (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2))) v6",
                    "L5 : Val.lessdef\n  match v3 with\n  | Vint n2 => Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) n2)\n  | Vptr b2 ofs2 =>\n      if Archi.ptr64\n      then Vundef\n      else\n       Vptr b2\n         (Ptrofs.add ofs2\n            (Ptrofs.of_int (Int64.hiword (Int64.mul' p2 q2))))\n  | _ => Vundef\n  end v5",
                    "E5 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1))) v5",
                    "E4 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (mul (lift a1) (lift b2)) v4",
                    "L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4",
                    "E3 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (mul (lift a2) (lift b1)) v3",
                    "L3 : Val.lessdef (Vint (Int.mul p2 q1)) v3",
                    "E2 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (Eop Ohighlong (Econs (Eletvar 0) Enil))\n  (Vint (Int64.hiword (Int64.mul' p2 q2)))",
                    "E1 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (Eop Olowlong (Econs (Eletvar 0) Enil))\n  (Vint (Int64.loword (Int64.mul' p2 q2)))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "L3 : Val.lessdef (Vint (Int.mul p2 q1)) v3"
                ],
                "tactic_res": [
                    "L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5",
                    "E3 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (mul (lift a2) (lift b1)) (Vint (Int.mul p2 q1))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "L4 : Val.lessdef (Vint (Int.mul p1 q2)) v4"
                ],
                "tactic_res": [
                    "L6 : Val.lessdef (Val.add v5 (Vint (Int.mul p1 q2))) v6",
                    "E4 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (mul (lift a1) (lift b2)) (Vint (Int.mul p1 q2))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "L5 : Val.lessdef\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))) v5"
                ],
                "tactic_res": [
                    "L6 : Val.lessdef\n  (Val.add\n     (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))\n     (Vint (Int.mul p1 q2))) v6",
                    "E5 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n     (mul (lift a2) (lift b1)))\n  (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "L6 : Val.lessdef\n  (Val.add\n     (Vint (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1)))\n     (Vint (Int.mul p1 q2))) v6"
                ],
                "tactic_res": [
                    "L6 : Val.lessdef\n  (Vint\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) v6"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (Val.longofwords v6 (Vint (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))",
                    "L6 : Val.lessdef\n  (Vint\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2))) v6"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Val.longofwords\n     (Vint\n        (Int.add\n           (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n           (Int.mul p1 q2))) (Vint (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))",
                    "E6 : eval_expr ge sp e m (cons (Vlong (Int64.mul' p2 q2)) le0)\n  (add\n     (add (Eop Ohighlong (Econs (Eletvar 0) Enil))\n        (mul (lift a2) (lift b1))) (mul (lift a1) (lift b2)))\n  (Vint\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (Val.longofwords\n     (Vint\n        (Int.add\n           (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n           (Int.mul p1 q2))) (Vint (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.add\n           (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n           (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq\n  (Vlong\n     (Int64.ofwords\n        (Int.add\n           (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n           (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2))))\n  (Vlong (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Int64.ofwords\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)))\n  (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "_goal : eq\n  (Int64.ofwords\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)))\n  (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))\n  (Int64.ofwords\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)))"
                ]
            },
            {
                "tactic_sig": "apply Int64.decompose_mul .",
                "tactic_sig_no_out_arg": "apply Int64.decompose_mul .",
                "tactic_args": [
                    "_goal : eq (Int64.mul (Int64.ofwords p1 p2) (Int64.ofwords q1 q2))\n  (Int64.ofwords\n     (Int.add\n        (Int.add (Int64.hiword (Int64.mul' p2 q2)) (Int.mul p2 q1))\n        (Int.mul p1 q2)) (Int64.loword (Int64.mul' p2 q2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match x with\n| Vlong _ =>\n    match y with\n    | Vlong _ => True\n    | _ => eq (Val.mull x y) Vundef\n    end\n| _ => eq (Val.mull x y) Vundef\nend",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.mull Vundef y) Vundef",
                    "_goal : eq (Val.mull (Vint i) y) Vundef",
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.mull (Vlong i) y) Vundef\nend",
                    "_goal : eq (Val.mull (Vfloat f) y) Vundef",
                    "_goal : eq (Val.mull (Vsingle f) y) Vundef",
                    "_goal : eq (Val.mull (Vptr b0 i) y) Vundef",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull Vundef y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vint i) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.mull (Vlong i) y) Vundef\nend"
                ],
                "tactic_res": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.mull (Vlong i) y) Vundef\nend"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : match y with\n| Vlong _ => True\n| _ => eq (Val.mull (Vlong i) y) Vundef\nend",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.mull (Vlong i) Vundef) Vundef",
                    "_goal : eq (Val.mull (Vlong i) (Vint i0)) Vundef",
                    "_goal : True",
                    "_goal : eq (Val.mull (Vlong i) (Vfloat f)) Vundef",
                    "_goal : eq (Val.mull (Vlong i) (Vsingle f)) Vundef",
                    "_goal : eq (Val.mull (Vlong i) (Vptr b0 i0)) Vundef",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) Vundef) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) (Vint i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) (Vfloat f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) (Vsingle f)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) (Vptr b0 i0)) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vfloat f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vsingle f) y) Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vptr b0 i) y) Vundef"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_mullimm",
        "proof": [
            {
                "tactic_sig": "unfold mullimm .",
                "tactic_sig_no_out_arg": "unfold mullimm .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound (mullimm n)\n  (fun v : val => Val.mull v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int64.eq n Int64.zero\n   then longconst Int64.zero\n   else\n    if Int64.eq n Int64.one\n    then e\n    else\n     match Int64.is_power2' n with\n     | Some l => shllimm e l\n     | None => mull_base e (longconst n)\n     end) (fun v : val => Val.mull v (Vlong n))"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun e : expr =>\n   if Int64.eq n Int64.zero\n   then longconst Int64.zero\n   else\n    if Int64.eq n Int64.one\n    then e\n    else\n     match Int64.is_power2' n with\n     | Some l => shllimm e l\n     | None => mull_base e (longconst n)\n     end) (fun v : val => Val.mull v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall (n : Int64.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : Int64.int) (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "n : Int64.int"
                ]
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq n Int64.zero\n      then eq n Int64.zero\n      else not (eq n Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq n Int64.zero\n      then eq n Int64.zero\n      else not (eq n Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.zero\n         then longconst Int64.zero\n         else\n          if Int64.eq n Int64.one\n          then a\n          else\n           match Int64.is_power2' n with\n           | Some l => shllimm a l\n           | None => mull_base a (longconst n)\n           end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "_goal : forall _ : not (eq n Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int64.zero,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "H0 : eq n Int64.zero"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq n Int64.zero),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "H0 : not (eq n Int64.zero)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong Int64.zero)) v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst Int64.zero) v)\n     (Val.lessdef (Val.mull x (Vlong Int64.zero)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst Int64.zero) ?v)\n  (Val.lessdef (Val.mull x (Vlong Int64.zero)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst Int64.zero) ?v)\n  (Val.lessdef (Val.mull x (Vlong Int64.zero)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst Int64.zero) ?v",
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.zero)) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst Int64.zero) ?v",
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.zero)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.zero)) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong Int64.zero))\n  (Vlong Int64.zero)",
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong Int64.zero)) (Vlong Int64.zero)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong Int64.zero))\n  (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.mul_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.mul_zero .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.zero)) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong Int64.zero) (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i Int64.one ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i Int64.one ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq n Int64.one\n      then eq n Int64.one\n      else not (eq n Int64.one),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i Int64.one ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i Int64.one ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq n Int64.one\n      then eq n Int64.one\n      else not (eq n Int64.one),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int64.eq n Int64.one\n         then a\n         else\n          match Int64.is_power2' n with\n          | Some l => shllimm a l\n          | None => mull_base a (longconst n)\n          end) v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq n Int64.one,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "_goal : forall _ : not (eq n Int64.one),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match Int64.is_power2' n with\n        | Some l => shllimm a l\n        | None => mull_base a (longconst n)\n        end v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq n Int64.one,\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "H1 : eq n Int64.one"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq n Int64.one),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match Int64.is_power2' n with\n        | Some l => shllimm a l\n        | None => mull_base a (longconst n)\n        end v) (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match Int64.is_power2' n with\n        | Some l => shllimm a l\n        | None => mull_base a (longconst n)\n        end v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "H1 : not (eq n Int64.one)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong Int64.one)) v))",
                    "H0 : not (eq Int64.one Int64.zero)"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v)\n     (Val.lessdef (Val.mull x (Vlong Int64.one)) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.mull x (Vlong Int64.one)) x)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x)\n  (Val.lessdef (Val.mull x (Vlong Int64.one)) x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.one)) x"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.one)) x"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.one)) x"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull x (Vlong Int64.one)) x",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong Int64.one)) Vundef",
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong Int64.one)) (Vint i)",
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong Int64.one)) (Vlong i)",
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong Int64.one)) (Vfloat f)",
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong Int64.one)) (Vsingle f)",
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong Int64.one)) (Vptr b i)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong Int64.one)) Vundef"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong Int64.one)) (Vint i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vint i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong Int64.one)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong Int64.one)) (Vfloat f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vfloat f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong Int64.one)) (Vsingle f)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vsingle f)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong Int64.one)) (Vptr b i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef (Vptr b i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.mul_one .",
                "tactic_sig_no_out_arg": "rewrite Int64.mul_one .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i Int64.one)) (Vlong i)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong i) (Vlong i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( Int64.is_power2' _i ) as [ l| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Int64.is_power2' _i ) as [ l| ] eqn : P2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match Int64.is_power2' n with\n        | Some l => shllimm a l\n        | None => mull_base a (longconst n)\n        end v) (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "n : Int64.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mull_base a (longconst n)) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "P2 : eq (Int64.is_power2' n) (Some l)",
                    "l : Int.int",
                    "P2 : eq (Int64.is_power2' n) None"
                ]
            },
            {
                "tactic_sig": "exploit eval_shllimm .",
                "tactic_sig_no_out_arg": "exploit eval_shllimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m ?Goal1 (shllimm ?Goal2 ?Goal0) v)\n           (Val.lessdef (Val.shll ?Goal3 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal2 ?Goal3",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m ?Goal1 (shllimm ?Goal2 ?Goal0) v)\n           (Val.lessdef (Val.shll ?Goal3 (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (shllimm a ?Goal0) v)\n           (Val.lessdef (Val.shll x (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := _i ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := _i ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (shllimm a ?Goal0) v)\n           (Val.lessdef (Val.shll x (Vint ?Goal0)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n           (Val.lessdef (Val.shll x (Vint l)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n           (Val.lessdef (Val.shll x (Vint l)) v)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "B : Val.lessdef (Val.shll x (Vint l)) v",
                    "A : eval_expr ge sp e m le (shllimm a l) v",
                    "v : val"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))",
                    "v : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n  (Val.lessdef (Val.mull x (Vlong n)) v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (shllimm a l) v)\n  (Val.lessdef (Val.mull x (Vlong n)) v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (shllimm a l) v",
                    "_goal : Val.lessdef (Val.mull x (Vlong n)) v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (shllimm a l) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull x (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull x (Vlong n)) v"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull x (Vlong n)) v",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong n)) v",
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong n)) v",
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong n)) v",
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong n)) v",
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong n)) v",
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong n)) v",
                    "B : Val.lessdef (Val.shll Vundef (Vint l)) v",
                    "H : eval_expr ge sp e m le a Vundef",
                    "B : Val.lessdef (Val.shll (Vint i) (Vint l)) v",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "B : Val.lessdef (Val.shll (Vfloat f) (Vint l)) v",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "B : Val.lessdef (Val.shll (Vsingle f) (Vint l)) v",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "B : Val.lessdef (Val.shll (Vptr b i) (Vint l)) v",
                    "H : eval_expr ge sp e m le a (Vptr b i)",
                    "i : Ptrofs.int",
                    "b : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull Vundef (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vint i) (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vlong i) (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i n)) v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i n)) v"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vfloat f) (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vsingle f) (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vptr b i) (Vlong n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef Vundef v"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef Vundef v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "erewrite Int64.mul_pow2' by eauto .",
                "tactic_sig_no_out_arg": "erewrite Int64.mul_pow2' by eauto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul i n)) v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i l)) v"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.shll (Vlong i) (Vint l)) v"
                ],
                "tactic_res": [
                    "B : Val.lessdef\n  (if Int.ltu l Int64.iwordsize'\n   then Vlong (Int64.shl' i l)\n   else Vundef) v"
                ]
            },
            {
                "tactic_sig": "erewrite Int64.is_power2'_range in _i by eauto .",
                "tactic_sig_no_out_arg": "erewrite Int64.is_power2'_range in _i by eauto .",
                "tactic_args": [
                    "B : Val.lessdef\n  (if Int.ltu l Int64.iwordsize'\n   then Vlong (Int64.shl' i l)\n   else Vundef) v"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vlong (Int64.shl' i l)) v"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.shl' i l)) v",
                    "B : Val.lessdef (Vlong (Int64.shl' i l)) v"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply eval_mull_base .",
                "tactic_sig_no_out_arg": "apply eval_mull_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mull_base a (longconst n)) v)\n     (Val.lessdef (Val.mull x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) (Vlong n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_mull",
        "proof": [
            {
                "tactic_sig": "unfold mull .",
                "tactic_sig_no_out_arg": "unfold mull .",
                "tactic_args": [
                    "_goal : binary_constructor_sound mull Val.mull"
                ],
                "tactic_res": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.mul n1 n2)\n       | None => mullimm n1 e2\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 => mullimm n2 e1\n       | None => mull_base e1 e2\n       end\n   end) Val.mull"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : binary_constructor_sound\n  (fun e1 e2 : expr =>\n   match is_longconst e1 with\n   | Some n1 =>\n       match is_longconst e2 with\n       | Some n2 => longconst (Int64.mul n1 n2)\n       | None => mullimm n1 e2\n       end\n   | None =>\n       match is_longconst e2 with\n       | Some n2 => mullimm n2 e1\n       | None => mull_base e1 e2\n       end\n   end) Val.mull"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.mul n1 n2)\n            | None => mullimm n1 b\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => mullimm n2 a\n            | None => mull_base a b\n            end\n        end v) (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val) (b : expr) \n  (y : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.mul n1 n2)\n            | None => mullimm n1 b\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => mullimm n2 a\n            | None => mull_base a b\n            end\n        end v) (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.mul n1 n2)\n            | None => mullimm n1 b\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => mullimm n2 a\n            | None => mull_base a b\n            end\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ p| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ p| ] eqn : LC1 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst a with\n        | Some n1 =>\n            match is_longconst b with\n            | Some n2 => longconst (Int64.mul n1 n2)\n            | None => mullimm n1 b\n            end\n        | None =>\n            match is_longconst b with\n            | Some n2 => mullimm n2 a\n            | None => mull_base a b\n            end\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.mul p n2)\n        | None => mullimm p b\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => mullimm n2 a\n        | None => mull_base a b\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "LC1 : eq (is_longconst a) (Some p)",
                    "p : Int64.int",
                    "LC1 : eq (is_longconst a) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : LC2 .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => longconst (Int64.mul p n2)\n        | None => mullimm p b\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "LC2 : eq (is_longconst b) (Some q)",
                    "q : Int64.int",
                    "LC2 : eq (is_longconst b) None"
                ]
            },
            {
                "tactic_sig": "destruct ( is_longconst _i ) as [ q| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst _i ) as [ q| ] eqn : _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        match is_longconst b with\n        | Some n2 => mullimm n2 a\n        | None => mull_base a b\n        end v) (Val.lessdef (Val.mull x y) v))",
                    "b : expr",
                    "LC2 : eq (is_longconst b) (Some q)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mull_base a b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "EQ : eq x (Vlong p)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "H : eval_expr ge sp e m le a (Vlong p)"
                ]
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal3)",
                    "_goal : forall _ : eq ?Goal2 (Vlong ?Goal3),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "EQ : eq y (Vlong q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) (Vlong q)) v))",
                    "H0 : eval_expr ge sp e m le b (Vlong q)"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) v)\n     (Val.lessdef (Val.mull (Vlong p) (Vlong q)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) ?v)\n  (Val.lessdef (Val.mull (Vlong p) (Vlong q)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le (longconst (Int64.mul p q)) ?v)\n  (Val.lessdef (Val.mull (Vlong p) (Vlong q)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.mul p q)) ?v",
                    "_goal : Val.lessdef (Val.mull (Vlong p) (Vlong q)) ?v"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst (Int64.mul p q)) ?v",
                    "_goal : Val.lessdef (Val.mull (Vlong p) (Vlong q)) ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.mull (Vlong p) (Vlong q)) (Vlong (Int64.mul p q))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.mull (Vlong p) (Vlong q)) (Vlong (Int64.mul p q))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Vlong (Int64.mul p q)) (Vlong (Int64.mul p q))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Vlong (Int64.mul p q)) (Vlong (Int64.mul p q))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "le : letenv",
                    "a : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst a) (Some ?Goal2)",
                    "_goal : forall _ : eq ?Goal1 (Vlong ?Goal2),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal1 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?Goal1",
                    "_goal : forall _ : eq ?Goal1 (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq x (Vlong p),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "EQ : eq x (Vlong p)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "H : eval_expr ge sp e m le a (Vlong p)"
                ]
            },
            {
                "tactic_sig": "replace ( Val.mull ( Vlong _i ) _i ) with ( Val.mull _i ( Vlong _i ) ) in * .",
                "tactic_sig_no_out_arg": "replace ( Val.mull ( Vlong _i ) _i ) with ( Val.mull _i ( Vlong _i ) ) in * .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull (Vlong p) y) v))",
                    "p : Int64.int",
                    "y : val",
                    "y : val",
                    "p : Int64.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull y (Vlong p)) v))",
                    "_goal : eq (Val.mull y (Vlong p)) (Val.mull (Vlong p) y)"
                ]
            },
            {
                "tactic_sig": "eapply eval_mullimm .",
                "tactic_sig_no_out_arg": "eapply eval_mullimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm p b) v)\n     (Val.lessdef (Val.mull y (Vlong p)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o | _o _o | _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (Val.mull y (Vlong p)) (Val.mull (Vlong p) y)",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : eq (Val.mull Vundef (Vlong p)) (Val.mull (Vlong p) Vundef)",
                    "_goal : eq (Val.mull (Vint i) (Vlong p)) (Val.mull (Vlong p) (Vint i))",
                    "_goal : eq (Val.mull (Vlong i) (Vlong p)) (Val.mull (Vlong p) (Vlong i))",
                    "_goal : eq (Val.mull (Vfloat f) (Vlong p)) (Val.mull (Vlong p) (Vfloat f))",
                    "_goal : eq (Val.mull (Vsingle f) (Vlong p)) (Val.mull (Vlong p) (Vsingle f))",
                    "_goal : eq (Val.mull (Vptr b0 i) (Vlong p)) (Val.mull (Vlong p) (Vptr b0 i))",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i)",
                    "i : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vlong i)",
                    "i : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull Vundef (Vlong p)) (Val.mull (Vlong p) Vundef)"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vint i) (Vlong p)) (Val.mull (Vlong p) (Vint i))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vlong i) (Vlong p)) (Val.mull (Vlong p) (Vlong i))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.mul i p)) (Vlong (Int64.mul p i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.mul i p)) (Vlong (Int64.mul p i))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.mul i p)) (Vlong (Int64.mul p i))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vfloat f) (Vlong p)) (Val.mull (Vlong p) (Vfloat f))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vsingle f) (Vlong p)) (Val.mull (Vlong p) (Vsingle f))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (Val.mull (Vptr b0 i) (Vlong p)) (Val.mull (Vlong p) (Vptr b0 i))"
                ],
                "tactic_res": [
                    "_goal : eq Vundef Vundef"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Vundef Vundef"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Int64.mul_commut .",
                "tactic_sig_no_out_arg": "rewrite Int64.mul_commut .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.mul i p)) (Vlong (Int64.mul p i))"
                ],
                "tactic_res": [
                    "_goal : eq (Vlong (Int64.mul p i)) (Vlong (Int64.mul p i))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Vlong (Int64.mul p i)) (Vlong (Int64.mul p i))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_sig_no_out_arg": "exploit ( is_longconst_sound _i _i ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "le : letenv",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst b) (Some ?Goal1)",
                    "_goal : forall _ : eq ?Goal0 (Vlong ?Goal1),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq ?Goal0 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?Goal0",
                    "_goal : forall _ : eq ?Goal0 (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq y (Vlong q),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "EQ : eq y (Vlong q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x y) v))",
                    "y : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x (Vlong q)) v))",
                    "H0 : eval_expr ge sp e m le b (Vlong q)"
                ]
            },
            {
                "tactic_sig": "eapply eval_mullimm .",
                "tactic_sig_no_out_arg": "eapply eval_mullimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mullimm q a) v)\n     (Val.lessdef (Val.mull x (Vlong q)) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply eval_mull_base .",
                "tactic_sig_no_out_arg": "apply eval_mull_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (mull_base a b) v)\n     (Val.lessdef (Val.mull x y) v))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a x",
                    "_goal : eval_expr ge sp e m le b y"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b y"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_mullhu",
        "proof": [
            {
                "tactic_sig": "unfold mullhu .",
                "tactic_sig_no_out_arg": "unfold mullhu .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound (fun a : expr => mullhu a n)\n  (fun v : val => Val.mullhu v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhu v (Vlong n))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhu v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : unary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhu v (Vlong n))",
                    "n : Int64.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhu v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhu x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhu x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhu x (Vlong n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhu x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n     ?v) (Val.lessdef (Val.mullhu x (Vlong n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n     ?v) (Val.lessdef (Val.mullhu x (Vlong n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v",
                    "_goal : Val.lessdef (Val.mullhu x (Vlong n)) ?v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v",
                    "_goal : Val.lessdef (Val.mullhu x (Vlong n)) ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (Val.mullhu x (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (Val.mullhu x (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2",
                    "_goal : helper_declared prog i64_umulh ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vlong n) nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_umulh ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_umulh\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_umulh\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vlong n) nil)))\n  (Some (Val.mullhu x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_umulh)\n     (cons x (cons (Vlong n) nil))) (Some (Val.mullhu x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_umulh)\n     (cons x (cons (Vlong n) nil))) (Some (Val.mullhu x (Vlong n)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_mullhs",
        "proof": [
            {
                "tactic_sig": "unfold mullhs .",
                "tactic_sig_no_out_arg": "unfold mullhs .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound (fun a : expr => mullhs a n)\n  (fun v : val => Val.mullhs v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhs v (Vlong n))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall n : Int64.int,\nunary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhs v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : unary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhs v (Vlong n))",
                    "n : Int64.int"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : unary_constructor_sound\n  (fun a : expr =>\n   Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (fun v : val => Val.mullhs v (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhs x (Vlong n)) v))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : val)\n  (_ : eval_expr ge sp e m le a x),\nex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhs x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhs x (Vlong n)) v))",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smulh sig_ll_l\n           (Econs a (Econs (longconst n) Enil))) v)\n     (Val.lessdef (Val.mullhs x (Vlong n)) v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n     ?v) (Val.lessdef (Val.mullhs x (Vlong n)) ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n     ?v) (Val.lessdef (Val.mullhs x (Vlong n)) ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v",
                    "_goal : Val.lessdef (Val.mullhs x (Vlong n)) ?v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  ?v",
                    "_goal : Val.lessdef (Val.mullhs x (Vlong n)) ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (Val.mullhs x (Vlong n))"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smulh sig_ll_l (Econs a (Econs (longconst n) Enil)))\n  (Val.mullhs x (Vlong n))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2",
                    "_goal : helper_declared prog i64_smulh ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2"
                ]
            },
            {
                "tactic_sig": "apply eval_longconst .",
                "tactic_sig_no_out_arg": "apply eval_longconst .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (longconst n) ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vlong n) nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H15 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H13 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H12 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H11 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H10 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H9 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H8 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H7 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H6 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H5 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H4 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H3 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H1 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H2 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H0 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_smulh ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_smulh\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_smulh\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons (Vlong n) nil)))\n  (Some (Val.mullhs x (Vlong n)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_smulh)\n     (cons x (cons (Vlong n) nil))) (Some (Val.mullhs x (Vlong n)))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_smulh)\n     (cons x (cons (Vlong n) nil))) (Some (Val.mullhs x (Vlong n)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_shrxlimm",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (n : Int.int) (x z : val)\n  (_ : eq Archi.ptr64 false) (_ : eval_expr ge sp e m le a x)\n  (_ : eq (Val.shrxl x (Vint n)) (Some z)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrxlimm a n) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrxlimm a n) v)\n     (Val.lessdef z v))",
                    "H1 : eq (Val.shrxl x (Vint n)) (Some z)",
                    "H0 : eval_expr ge sp e m le a x",
                    "H : eq Archi.ptr64 false",
                    "x : val",
                    "z : val",
                    "n : Int.int",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "apply Val.shrxl_shrl_2 in _i .",
                "tactic_sig_no_out_arg": "apply Val.shrxl_shrl_2 in _i .",
                "tactic_args": [
                    "H1 : eq (Val.shrxl x (Vint n)) (Some z)"
                ],
                "tactic_res": [
                    "H1 : eq z\n  (if Int.eq n Int.zero\n   then x\n   else\n    Val.shrl\n      (Val.addl x\n         (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n            (Vint (Int.sub (Int.repr 64) n)))) (Vint n))"
                ]
            },
            {
                "tactic_sig": "unfold shrxlimm .",
                "tactic_sig_no_out_arg": "unfold shrxlimm .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (shrxlimm a n) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          Elet a\n            (shrlimm\n               (addl (Eletvar 0)\n                  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                     (Int.sub (Int.repr 64) n))) n)) v)\n     (Val.lessdef z v))"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.eq _i Int.zero ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.eq _i Int.zero ) .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (if Int.eq n Int.zero\n         then a\n         else\n          Elet a\n            (shrlimm\n               (addl (Eletvar 0)\n                  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                     (Int.sub (Int.repr 64) n))) n)) v)\n     (Val.lessdef z v))",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v) (Val.lessdef z v))",
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet a\n           (shrlimm\n              (addl (Eletvar 0)\n                 (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                    (Int.sub (Int.repr 64) n))) n)) v)\n     (Val.lessdef z v))",
                    "H1 : eq z x",
                    "H1 : eq z\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n))"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v) (Val.lessdef z v))",
                    "z : val"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v) (Val.lessdef x v))"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le a v) (Val.lessdef x v))",
                    "x : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x) (Val.lessdef x x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Logic.and (eval_expr ge sp e m le a x) (Val.lessdef x x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( le' := _i : : _i ) .",
                "tactic_sig_no_out_arg": "set ( le' := _i : : _i ) .",
                "tactic_args": [
                    "x : val",
                    "le : letenv"
                ],
                "tactic_res": [
                    "le' : list val"
                ]
            },
            {
                "tactic_sig": "edestruct ( eval_shrlimm ( Int.repr 63 ) _i ( Eletvar O ) ) as ( v1 & A1 & B1 ) as [| _o _o _o ] .",
                "tactic_sig_no_out_arg": "edestruct ( eval_shrlimm ( Int.repr 63 ) _i ( Eletvar O ) ) as ( v1 & A1 & B1 ) .",
                "tactic_args": [
                    "le' : list val"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le' (Eletvar 0) ?x",
                    "B1 : Val.lessdef (Val.shrl ?x (Vint (Int.repr 63))) v1",
                    "A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le' (Eletvar 0) ?x"
                ],
                "tactic_res": [
                    "_goal : eq (nth_error le' 0) (Some ?x)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (nth_error le' 0) (Some ?x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct ( eval_shrluimm ( Int.sub ( Int.repr 64 ) _i ) _i ) as ( v2 & A2 & B2 ) as [| _o _o _o ] .",
                "tactic_sig_no_out_arg": "edestruct ( eval_shrluimm ( Int.sub ( Int.repr 64 ) _i ) _i ) as ( v2 & A2 & B2 ) .",
                "tactic_args": [
                    "n : Int.int",
                    "le' : list val"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le' ?a ?x",
                    "B2 : Val.lessdef (Val.shrlu ?x (Vint (Int.sub (Int.repr 64) n))) v2",
                    "A2 : eval_expr ge sp e m le' (shrluimm ?a (Int.sub (Int.repr 64) n)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le' ?a ?x",
                    "A1 : eval_expr ge sp e m le' (shrlimm (Eletvar 0) (Int.repr 63)) v1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct ( eval_addl _i _i ( Eletvar 0 ) ) as ( v3 & A3 & B3 ) as [| | _o _o _o ] .",
                "tactic_sig_no_out_arg": "edestruct ( eval_addl _i _i ( Eletvar 0 ) ) as ( v3 & A3 & B3 ) .",
                "tactic_args": [
                    "H : eq Archi.ptr64 false",
                    "le' : list val"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le' (Eletvar 0) ?x",
                    "_goal : eval_expr ge sp e m le' ?b ?y",
                    "B3 : Val.lessdef (Val.addl ?x ?y) v3",
                    "A3 : eval_expr ge sp e m le' (addl (Eletvar 0) ?b) v3",
                    "v3 : val"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le' (Eletvar 0) ?x"
                ],
                "tactic_res": [
                    "_goal : eq (nth_error le' 0) (Some ?x)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (nth_error le' 0) (Some ?x)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le' ?b ?y",
                    "A2 : eval_expr ge sp e m le' (shrluimm ?a (Int.sub (Int.repr 64) n)) v2"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "edestruct ( eval_shrlimm _i _i ) as ( v4 & A4 & B4 ) as [| _o _o _o ] .",
                "tactic_sig_no_out_arg": "edestruct ( eval_shrlimm _i _i ) as ( v4 & A4 & B4 ) .",
                "tactic_args": [
                    "n : Int.int",
                    "le' : list val"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le' ?a ?x",
                    "B4 : Val.lessdef (Val.shrl ?x (Vint n)) v4",
                    "A4 : eval_expr ge sp e m le' (shrlimm ?a n) v4",
                    "v4 : val"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le' ?a ?x",
                    "A3 : eval_expr ge sp e m le' (addl (Eletvar 0) ?b) v3"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Elet a\n           (shrlimm\n              (addl (Eletvar 0)\n                 (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                    (Int.sub (Int.repr 64) n))) n)) v)\n     (Val.lessdef z v))",
                    "v4 : val"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet a\n        (shrlimm\n           (addl (Eletvar 0)\n              (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                 (Int.sub (Int.repr 64) n))) n)) v4) \n  (Val.lessdef z v4)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Elet a\n        (shrlimm\n           (addl (Eletvar 0)\n              (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n                 (Int.sub (Int.repr 64) n))) n)) v4) \n  (Val.lessdef z v4)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Elet a\n     (shrlimm\n        (addl (Eletvar 0)\n           (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n              (Int.sub (Int.repr 64) n))) n)) v4",
                    "_goal : Val.lessdef z v4"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Elet a\n     (shrlimm\n        (addl (Eletvar 0)\n           (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n              (Int.sub (Int.repr 64) n))) n)) v4"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?v1",
                    "_goal : eval_expr ge sp e m (cons ?v1 le)\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m (cons x le)\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m (cons x le)\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( X : forall _i _i _i , Val.lessdef _i _i -> Val.lessdef ( Val.shrl _i ( Vint _i ) ) ( Val.shrl _i ( Vint _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( X : forall _i _i _i , Val.lessdef _i _i -> Val.lessdef ( Val.shrl _i ( Vint _i ) ) ( Val.shrl _i ( Vint _i ) ) ) .",
                "tactic_args": [
                    "v1 : val",
                    "v2 : val",
                    "n : Int.int",
                    "v1 : val",
                    "v2 : val",
                    "v1 : val",
                    "n : Int.int",
                    "v2 : val",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))",
                    "X : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))",
                    "H2 : Val.lessdef v0 v5",
                    "n0 : Int.int",
                    "v0 : val",
                    "v5 : val"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl v0 (Vint n0)) (Val.shrl v5 (Vint n0))",
                    "H2 : Val.lessdef v0 v5"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl v5 (Vint n0)) (Val.shrl v5 (Vint n0))",
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint n0)) (Val.shrl v5 (Vint n0))",
                    "B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4",
                    "A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4",
                    "B3 : Val.lessdef (Val.addl x v2) v3",
                    "A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n        (Int.sub (Int.repr 64) n))) v3",
                    "B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2",
                    "A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n     (Int.sub (Int.repr 64) n)) v2",
                    "B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl v5 (Vint n0)) (Val.shrl v5 (Vint n0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl Vundef (Vint n0)) (Val.shrl v5 (Vint n0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Val.lessdef z v4"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z v4"
                ]
            },
            {
                "tactic_sig": "assert ( Y : forall _i _i _i , Val.lessdef _i _i -> Val.lessdef ( Val.shrlu _i ( Vint _i ) ) ( Val.shrlu _i ( Vint _i ) ) ) .",
                "tactic_sig_no_out_arg": "assert ( Y : forall _i _i _i , Val.lessdef _i _i -> Val.lessdef ( Val.shrlu _i ( Vint _i ) ) ( Val.shrlu _i ( Vint _i ) ) ) .",
                "tactic_args": [
                    "v1 : val",
                    "v2 : val",
                    "n : Int.int",
                    "v1 : val",
                    "v2 : val",
                    "v1 : val",
                    "n : Int.int",
                    "v2 : val",
                    "n : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))",
                    "Y : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))",
                    "H2 : Val.lessdef v0 v5",
                    "n0 : Int.int",
                    "v0 : val",
                    "v5 : val"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu v0 (Vint n0)) (Val.shrlu v5 (Vint n0))",
                    "H2 : Val.lessdef v0 v5"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrlu v5 (Vint n0)) (Val.shrlu v5 (Vint n0))",
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint n0)) (Val.shrlu v5 (Vint n0))",
                    "B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4",
                    "A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4",
                    "B3 : Val.lessdef (Val.addl x v2) v3",
                    "A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n        (Int.sub (Int.repr 64) n))) v3",
                    "B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2",
                    "A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n     (Int.sub (Int.repr 64) n)) v2",
                    "B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu v5 (Vint n0)) (Val.shrlu v5 (Vint n0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrlu Vundef (Vint n0)) (Val.shrlu v5 (Vint n0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Val.lessdef z v4"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z v4"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : Val.lessdef z v4",
                    "z : val"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) v4",
                    "B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4",
                    "A4 : eval_expr ge sp e m le'\n  (shrlimm\n     (addl (Eletvar 0)\n        (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n           (Int.sub (Int.repr 64) n))) n) v4",
                    "B3 : Val.lessdef (Val.addl x v2) v3",
                    "A3 : eval_expr ge sp e m le'\n  (addl (Eletvar 0)\n     (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n        (Int.sub (Int.repr 64) n))) v3",
                    "B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2",
                    "A2 : eval_expr ge sp e m le'\n  (shrluimm (shrlimm (Eletvar 0) (Int.repr 63))\n     (Int.sub (Int.repr 64) n)) v2",
                    "B1 : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1"
                ]
            },
            {
                "tactic_sig": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_sig_no_out_arg": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n)) v4",
                    "B4 : Val.lessdef (Val.shrl v3 (Vint n)) v4"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n))\n  (Val.shrl v3 (Vint n))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.shrl\n     (Val.addl x\n        (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n           (Vint (Int.sub (Int.repr 64) n)))) (Vint n))\n  (Val.shrl v3 (Vint n))",
                    "X : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrl v1 (Vint n)) (Val.shrl v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) v3"
                ]
            },
            {
                "tactic_sig": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_sig_no_out_arg": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) v3",
                    "B3 : Val.lessdef (Val.addl x v2) v3"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Val.addl x v2)"
                ]
            },
            {
                "tactic_sig": "apply Val.addl_lessdef .",
                "tactic_sig_no_out_arg": "apply Val.addl_lessdef .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.addl x\n     (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n        (Vint (Int.sub (Int.repr 64) n)))) (Val.addl x v2)"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef x x",
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef x x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2"
                ]
            },
            {
                "tactic_sig": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_sig_no_out_arg": "eapply Val.lessdef_trans;[ |eexact _i ] .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n))) v2",
                    "B2 : Val.lessdef (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n))) v2"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n)))\n  (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Val.lessdef\n  (Val.shrlu (Val.shrl x (Vint (Int.repr 63)))\n     (Vint (Int.sub (Int.repr 64) n)))\n  (Val.shrlu v1 (Vint (Int.sub (Int.repr 64) n)))",
                    "Y : forall (v1 v2 : val) (n : Int.int) (_ : Val.lessdef v1 v2),\nVal.lessdef (Val.shrlu v1 (Vint n)) (Val.shrlu v2 (Vint n))"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef (Val.shrl x (Vint (Int.repr 63))) v1"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_divlu_base",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y z : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y)\n  (_ : eq (Val.divlu x y) (Some z)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divlu_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divlu_base a b) v)\n     (Val.lessdef z v))",
                    "H1 : eq (Val.divlu x y) (Some z)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "z : val",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold divlu_base .",
                "tactic_sig_no_out_arg": "unfold divlu_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divlu_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef z ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_udiv sig_ll_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H17 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H15 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H13 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H12 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H11 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H10 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H9 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H8 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H6 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H5 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H3 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H4 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H2 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_udiv ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_udiv\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_udiv\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_udiv) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_udiv) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef z ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef z z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_modlu_base",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y z : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y)\n  (_ : eq (Val.modlu x y) (Some z)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modlu_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modlu_base a b) v)\n     (Val.lessdef z v))",
                    "H1 : eq (Val.modlu x y) (Some z)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "z : val",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold modlu_base .",
                "tactic_sig_no_out_arg": "unfold modlu_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modlu_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef z ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_umod sig_ll_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H17 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H15 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H13 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H12 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H11 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H10 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H9 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H8 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H6 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H5 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H3 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H4 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H2 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_umod ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_umod\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_umod\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_umod) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_umod) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef z ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef z z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_divls_base",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y z : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y)\n  (_ : eq (Val.divls x y) (Some z)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divls_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divls_base a b) v)\n     (Val.lessdef z v))",
                    "H1 : eq (Val.divls x y) (Some z)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "z : val",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold divls_base .",
                "tactic_sig_no_out_arg": "unfold divls_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (divls_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef z ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_sdiv sig_ll_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H17 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H15 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H13 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H12 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H11 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H10 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H9 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H8 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H6 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H5 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H3 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H4 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H2 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_sdiv ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sdiv\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_sdiv\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sdiv) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_sdiv) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef z ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef z z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_modls_base",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a b : expr) (x y z : val)\n  (_ : eval_expr ge sp e m le a x) (_ : eval_expr ge sp e m le b y)\n  (_ : eq (Val.modls x y) (Some z)),\nex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modls_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modls_base a b) v)\n     (Val.lessdef z v))",
                    "H1 : eq (Val.modls x y) (Some z)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "x : val",
                    "y : val",
                    "z : val",
                    "a : expr",
                    "b : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold modls_base .",
                "tactic_sig_no_out_arg": "unfold modls_base .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and (eval_expr ge sp e m le (modls_base a b) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : ex\n  (fun v : val =>\n   Logic.and\n     (eval_expr ge sp e m le\n        (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) v)\n     (Val.lessdef z v))"
                ],
                "tactic_res": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : Logic.and\n  (eval_expr ge sp e m le\n     (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) \n     ?v) (Val.lessdef z ?v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) \n  ?v",
                    "_goal : Val.lessdef z ?v"
                ]
            },
            {
                "tactic_sig": "eapply eval_helper_2 .",
                "tactic_sig_no_out_arg": "eapply eval_helper_2 .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (Eexternal i64_smod sig_ll_l (Econs a (Econs b Enil))) \n  ?v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a ?varg1",
                    "_goal : eq (builtin_function_sem ?bf (cons ?varg1 (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b ?varg2",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons ?varg2 nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ],
                "tactic_res": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l"
                ]
            },
            {
                "tactic_sig": "red in _i .",
                "tactic_sig_no_out_arg": "red in _i .",
                "tactic_args": [
                    "HELPERS : helper_functions_declared prog hf"
                ],
                "tactic_res": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ]
            },
            {
                "tactic_sig": "decompose [ Logic.and ] _i .",
                "tactic_sig_no_out_arg": "decompose [ Logic.and ] _i .",
                "tactic_args": [
                    "HELPERS : Logic.and (helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l)\n  (Logic.and\n     (helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l)\n     (Logic.and\n        (helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f)\n        (Logic.and\n           (helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f)\n           (Logic.and\n              (helper_declared prog i64_stof \"__compcert_i64_stof\"\n                 sig_l_s)\n              (Logic.and\n                 (helper_declared prog i64_utof \"__compcert_i64_utof\"\n                    sig_l_s)\n                 (Logic.and\n                    (helper_declared prog i64_sdiv\n                       \"__compcert_i64_sdiv\" sig_ll_l)\n                    (Logic.and\n                       (helper_declared prog i64_udiv\n                          \"__compcert_i64_udiv\" sig_ll_l)\n                       (Logic.and\n                          (helper_declared prog i64_smod\n                             \"__compcert_i64_smod\" sig_ll_l)\n                          (Logic.and\n                             (helper_declared prog i64_umod\n                                \"__compcert_i64_umod\" sig_ll_l)\n                             (Logic.and\n                                (helper_declared prog i64_shl\n                                   \"__compcert_i64_shl\" sig_li_l)\n                                (Logic.and\n                                   (helper_declared prog i64_shr\n                                      \"__compcert_i64_shr\" sig_li_l)\n                                   (Logic.and\n                                      (helper_declared prog i64_sar\n                                         \"__compcert_i64_sar\" sig_li_l)\n                                      (Logic.and\n                                         (helper_declared prog\n                                            i64_umulh\n                                            \"__compcert_i64_umulh\"\n                                            sig_ll_l)\n                                         (helper_declared prog\n                                            i64_smulh\n                                            \"__compcert_i64_smulh\"\n                                            sig_ll_l))))))))))))))"
                ],
                "tactic_res": [
                    "H17 : helper_declared prog i64_smulh \"__compcert_i64_smulh\" sig_ll_l",
                    "H15 : helper_declared prog i64_umulh \"__compcert_i64_umulh\" sig_ll_l",
                    "H14 : helper_declared prog i64_sar \"__compcert_i64_sar\" sig_li_l",
                    "H13 : helper_declared prog i64_shr \"__compcert_i64_shr\" sig_li_l",
                    "H12 : helper_declared prog i64_shl \"__compcert_i64_shl\" sig_li_l",
                    "H11 : helper_declared prog i64_umod \"__compcert_i64_umod\" sig_ll_l",
                    "H10 : helper_declared prog i64_smod \"__compcert_i64_smod\" sig_ll_l",
                    "H9 : helper_declared prog i64_udiv \"__compcert_i64_udiv\" sig_ll_l",
                    "H8 : helper_declared prog i64_sdiv \"__compcert_i64_sdiv\" sig_ll_l",
                    "H7 : helper_declared prog i64_utof \"__compcert_i64_utof\" sig_l_s",
                    "H6 : helper_declared prog i64_stof \"__compcert_i64_stof\" sig_l_s",
                    "H5 : helper_declared prog i64_utod \"__compcert_i64_utod\" sig_l_f",
                    "H3 : helper_declared prog i64_stod \"__compcert_i64_stod\" sig_l_f",
                    "H4 : helper_declared prog i64_dtou \"__compcert_i64_dtou\" sig_f_l",
                    "H2 : helper_declared prog i64_dtos \"__compcert_i64_dtos\" sig_f_l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : helper_declared prog i64_smod ?name sig_ll_l",
                    "_goal : eq (lookup_builtin_function ?name sig_ll_l) (Some ?bf)"
                ],
                "tactic_res": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_smod\" sig_ll_l) (Some ?bf)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (lookup_builtin_function \"__compcert_i64_smod\" sig_ll_l) (Some ?bf)",
                    "_goal : eq (builtin_function_sem ?bf (cons x (cons y nil))) (Some ?v)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_smod) (cons x (cons y nil)))\n  (Some ?v)"
                ]
            },
            {
                "tactic_sig": "eassumption .",
                "tactic_sig_no_out_arg": "eassumption .",
                "tactic_args": [
                    "_goal : eq\n  (builtin_function_sem (BI_standard BI_i64_smod) (cons x (cons y nil)))\n  (Some ?v)",
                    "_goal : Val.lessdef z ?v"
                ],
                "tactic_res": [
                    "_goal : Val.lessdef z z"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Val.lessdef z z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "decompose_cmpl_eq_zero",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall h l : Int.int,\neq (Int64.eq (Int64.ofwords h l) Int64.zero)\n  (Int.eq (Int.or h l) Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.eq (Int64.ofwords h l) Int64.zero)\n  (Int.eq (Int.or h l) Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ]
            },
            {
                "tactic_sig": "assert ( Int64.zwordsize = Int.zwordsize * 2 ) by reflexivity .",
                "tactic_sig_no_out_arg": "assert ( Int64.zwordsize = Int.zwordsize * 2 ) by reflexivity .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq Int64.zwordsize (Z.mul Int.zwordsize 2)"
                ]
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec ( Int64.ofwords _i _i ) Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec ( Int64.ofwords _i _i ) Int64.zero ) .",
                "tactic_args": [
                    "_goal : eq (Int64.eq (Int64.ofwords h l) Int64.zero)\n  (Int.eq (Int.or h l) Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq (Int64.ofwords h l) Int64.zero\n      then eq (Int64.ofwords h l) Int64.zero\n      else not (eq (Int64.ofwords h l) Int64.zero),\neq (Int64.eq (Int64.ofwords h l) Int64.zero)\n  (Int.eq (Int.or h l) Int.zero)"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq ( Int64.ofwords _i _i ) Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq ( Int64.ofwords _i _i ) Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq (Int64.ofwords h l) Int64.zero\n      then eq (Int64.ofwords h l) Int64.zero\n      else not (eq (Int64.ofwords h l) Int64.zero),\neq (Int64.eq (Int64.ofwords h l) Int64.zero)\n  (Int.eq (Int.or h l) Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.ofwords h l) Int64.zero,\neq true (Int.eq (Int.or h l) Int.zero)",
                    "_goal : forall _ : not (eq (Int64.ofwords h l) Int64.zero),\neq false (Int.eq (Int.or h l) Int.zero)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords h l) Int64.zero,\neq true (Int.eq (Int.or h l) Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq true (Int.eq (Int.or h l) Int.zero)",
                    "H0 : eq (Int64.ofwords h l) Int64.zero"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq (Int64.ofwords h l) Int64.zero),\neq false (Int.eq (Int.or h l) Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq false (Int.eq (Int.or h l) Int.zero)",
                    "H0 : not (eq (Int64.ofwords h l) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "replace ( Int.or _i _i ) with Int.zero .",
                "tactic_sig_no_out_arg": "replace ( Int.or _i _i ) with Int.zero .",
                "tactic_args": [
                    "_goal : eq true (Int.eq (Int.or h l) Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : eq true (Int.eq Int.zero Int.zero)",
                    "_goal : eq Int.zero (Int.or h l)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.eq_true .",
                "tactic_sig_no_out_arg": "rewrite Int.eq_true .",
                "tactic_args": [
                    "_goal : eq true (Int.eq Int.zero Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply Int.same_bits_eq .",
                "tactic_sig_no_out_arg": "apply Int.same_bits_eq .",
                "tactic_args": [
                    "_goal : eq Int.zero (Int.or h l)"
                ],
                "tactic_res": [
                    "_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit Int.zero i) (Int.testbit (Int.or h l) i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)),\neq (Int.testbit Int.zero i) (Int.testbit (Int.or h l) i)"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit Int.zero i) (Int.testbit (Int.or h l) i)",
                    "H1 : Logic.and (Z.le 0 i) (Z.lt i Int.zwordsize)",
                    "i : Z"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_zero .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_zero .",
                "tactic_args": [
                    "_goal : eq (Int.testbit Int.zero i) (Int.testbit (Int.or h l) i)"
                ],
                "tactic_res": [
                    "_goal : eq false (Int.testbit (Int.or h l) i)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_or by auto .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_or by auto .",
                "tactic_args": [
                    "_goal : eq false (Int.testbit (Int.or h l) i)"
                ],
                "tactic_res": [
                    "_goal : eq false (orb (Int.testbit h i) (Int.testbit l i))"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "_goal : eq false (orb (Int.testbit h i) (Int.testbit l i))"
                ],
                "tactic_res": [
                    "_goal : eq (orb (Int.testbit h i) (Int.testbit l i)) false"
                ]
            },
            {
                "tactic_sig": "apply orb_false_intro .",
                "tactic_sig_no_out_arg": "apply orb_false_intro .",
                "tactic_args": [
                    "_goal : eq (orb (Int.testbit h i) (Int.testbit l i)) false"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit h i) false",
                    "_goal : eq (Int.testbit l i) false"
                ]
            },
            {
                "tactic_sig": "transitivity ( Int64.testbit ( Int64.ofwords _i _i ) ( _i + Int.zwordsize ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( Int64.testbit ( Int64.ofwords _i _i ) ( _i + Int.zwordsize ) ) .",
                "tactic_args": [
                    "_goal : eq (Int.testbit h i) false",
                    "h : Int.int",
                    "l : Int.int",
                    "i : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit h i)\n  (Int64.testbit (Int64.ofwords h l) (Z.add i Int.zwordsize))",
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) (Z.add i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_ofwords by lia .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_ofwords by lia .",
                "tactic_args": [
                    "_goal : eq (Int.testbit h i)\n  (Int64.testbit (Int64.ofwords h l) (Z.add i Int.zwordsize))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit h i)\n  (if zlt (Z.add i Int.zwordsize) Int.zwordsize\n   then Int.testbit l (Z.add i Int.zwordsize)\n   else Int.testbit h (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))"
                ]
            },
            {
                "tactic_sig": "rewrite zlt_false by lia .",
                "tactic_sig_no_out_arg": "rewrite zlt_false by lia .",
                "tactic_args": [
                    "_goal : eq (Int.testbit h i)\n  (if zlt (Z.add i Int.zwordsize) Int.zwordsize\n   then Int.testbit l (Z.add i Int.zwordsize)\n   else Int.testbit h (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit h i)\n  (Int.testbit h (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (Int.testbit h i)\n  (Int.testbit h (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))"
                ],
                "tactic_res": [
                    "_goal : eq i (Z.sub (Z.add i Int.zwordsize) Int.zwordsize)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq i (Z.sub (Z.add i Int.zwordsize) Int.zwordsize)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) (Z.add i Int.zwordsize)) false",
                    "H0 : eq (Int64.ofwords h l) Int64.zero"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit Int64.zero (Z.add i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "apply Int64.bits_zero .",
                "tactic_sig_no_out_arg": "apply Int64.bits_zero .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit Int64.zero (Z.add i Int.zwordsize)) false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "transitivity ( Int64.testbit ( Int64.ofwords _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "transitivity ( Int64.testbit ( Int64.ofwords _i _i ) _i ) .",
                "tactic_args": [
                    "_goal : eq (Int.testbit l i) false",
                    "h : Int.int",
                    "l : Int.int",
                    "i : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit l i) (Int64.testbit (Int64.ofwords h l) i)",
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_ofwords by lia .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_ofwords by lia .",
                "tactic_args": [
                    "_goal : eq (Int.testbit l i) (Int64.testbit (Int64.ofwords h l) i)"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit l i)\n  (if zlt i Int.zwordsize\n   then Int.testbit l i\n   else Int.testbit h (Z.sub i Int.zwordsize))"
                ]
            },
            {
                "tactic_sig": "rewrite zlt_true by lia .",
                "tactic_sig_no_out_arg": "rewrite zlt_true by lia .",
                "tactic_args": [
                    "_goal : eq (Int.testbit l i)\n  (if zlt i Int.zwordsize\n   then Int.testbit l i\n   else Int.testbit h (Z.sub i Int.zwordsize))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit l i) (Int.testbit l i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int.testbit l i) (Int.testbit l i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) false",
                    "H0 : eq (Int64.ofwords h l) Int64.zero"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit Int64.zero i) false"
                ]
            },
            {
                "tactic_sig": "apply Int64.bits_zero .",
                "tactic_sig_no_out_arg": "apply Int64.bits_zero .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit Int64.zero i) false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "_goal : eq false (Int.eq (Int.or h l) Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (Int.eq (Int.or h l) Int.zero) false"
                ]
            },
            {
                "tactic_sig": "apply Int.eq_false .",
                "tactic_sig_no_out_arg": "apply Int.eq_false .",
                "tactic_args": [
                    "_goal : eq (Int.eq (Int.or h l) Int.zero) false"
                ],
                "tactic_res": [
                    "_goal : not (eq (Int.or h l) Int.zero)"
                ]
            },
            {
                "tactic_sig": "red .",
                "tactic_sig_no_out_arg": "red .",
                "tactic_args": [
                    "_goal : not (eq (Int.or h l) Int.zero)"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int.or h l) Int.zero, False"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int.or h l) Int.zero, False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H1 : eq (Int.or h l) Int.zero"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "_goal : False",
                    "H0 : not (eq (Int64.ofwords h l) Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.ofwords h l) Int64.zero"
                ]
            },
            {
                "tactic_sig": "apply Int64.same_bits_eq .",
                "tactic_sig_no_out_arg": "apply Int64.same_bits_eq .",
                "tactic_args": [
                    "_goal : eq (Int64.ofwords h l) Int64.zero"
                ],
                "tactic_res": [
                    "_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords h l) i) (Int64.testbit Int64.zero i)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i : Z) (_ : Logic.and (Z.le 0 i) (Z.lt i Int64.zwordsize)),\neq (Int64.testbit (Int64.ofwords h l) i) (Int64.testbit Int64.zero i)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) (Int64.testbit Int64.zero i)",
                    "H2 : Logic.and (Z.le 0 i) (Z.lt i Int64.zwordsize)",
                    "i : Z"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_zero .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_zero .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) (Int64.testbit Int64.zero i)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.bits_ofwords by auto .",
                "tactic_sig_no_out_arg": "rewrite Int64.bits_ofwords by auto .",
                "tactic_args": [
                    "_goal : eq (Int64.testbit (Int64.ofwords h l) i) false"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if zlt i Int.zwordsize\n   then Int.testbit l i\n   else Int.testbit h (Z.sub i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i Int.zwordsize ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i Int.zwordsize ) .",
                "tactic_args": [
                    "_goal : eq\n  (if zlt i Int.zwordsize\n   then Int.testbit l i\n   else Int.testbit h (Z.sub i Int.zwordsize)) false",
                    "i : Z"
                ],
                "tactic_res": [
                    "_goal : eq (Int.testbit l i) false",
                    "_goal : eq (Int.testbit h (Z.sub i Int.zwordsize)) false",
                    "l0 : Z.lt i Int.zwordsize",
                    "g : Z.ge i Int.zwordsize"
                ]
            },
            {
                "tactic_sig": "assert ( Int.testbit ( Int.or _i _i ) _i = false ) by ( rewrite _i ; apply Int.bits_zero ) .",
                "tactic_sig_no_out_arg": "assert ( Int.testbit ( Int.or _i _i ) _i = false ) by ( rewrite _i ; apply Int.bits_zero ) .",
                "tactic_args": [
                    "h : Int.int",
                    "l : Int.int",
                    "i : Z",
                    "H1 : eq (Int.or h l) Int.zero"
                ],
                "tactic_res": [
                    "H3 : eq (Int.testbit (Int.or h l) i) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_or in _i by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_or in _i by lia .",
                "tactic_args": [
                    "H3 : eq (Int.testbit (Int.or h l) i) false"
                ],
                "tactic_res": [
                    "H3 : eq (orb (Int.testbit h i) (Int.testbit l i)) false"
                ]
            },
            {
                "tactic_sig": "exploit orb_false_elim .",
                "tactic_sig_no_out_arg": "exploit orb_false_elim .",
                "tactic_args": [
                    "_goal : eq (Int.testbit l i) false"
                ],
                "tactic_res": [
                    "_goal : eq (orb ?Goal0 ?Goal1) false",
                    "_goal : forall _ : Logic.and (eq ?Goal0 false) (eq ?Goal1 false),\neq (Int.testbit l i) false"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (orb ?Goal0 ?Goal1) false",
                    "_goal : forall _ : Logic.and (eq ?Goal0 false) (eq ?Goal1 false),\neq (Int.testbit l i) false"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h i) false)\n        (eq (Int.testbit l i) false), eq (Int.testbit l i) false"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h i) false)\n        (eq (Int.testbit l i) false), eq (Int.testbit l i) false"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h i) false)\n        (eq (Int.testbit l i) false), eq (Int.testbit l i) false"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h i) false)\n        (eq (Int.testbit l i) false), eq (Int.testbit l i) false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( Int.testbit ( Int.or _i _i ) ( _i - Int.zwordsize ) = false ) by ( rewrite _i ; apply Int.bits_zero ) .",
                "tactic_sig_no_out_arg": "assert ( Int.testbit ( Int.or _i _i ) ( _i - Int.zwordsize ) = false ) by ( rewrite _i ; apply Int.bits_zero ) .",
                "tactic_args": [
                    "h : Int.int",
                    "l : Int.int",
                    "i : Z",
                    "H1 : eq (Int.or h l) Int.zero"
                ],
                "tactic_res": [
                    "H3 : eq (Int.testbit (Int.or h l) (Z.sub i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "rewrite Int.bits_or in _i by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.bits_or in _i by lia .",
                "tactic_args": [
                    "H3 : eq (Int.testbit (Int.or h l) (Z.sub i Int.zwordsize)) false"
                ],
                "tactic_res": [
                    "H3 : eq\n  (orb (Int.testbit h (Z.sub i Int.zwordsize))\n     (Int.testbit l (Z.sub i Int.zwordsize))) false"
                ]
            },
            {
                "tactic_sig": "exploit orb_false_elim .",
                "tactic_sig_no_out_arg": "exploit orb_false_elim .",
                "tactic_args": [
                    "_goal : eq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ],
                "tactic_res": [
                    "_goal : eq (orb ?Goal ?Goal0) false",
                    "_goal : forall _ : Logic.and (eq ?Goal false) (eq ?Goal0 false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (orb ?Goal ?Goal0) false",
                    "_goal : forall _ : Logic.and (eq ?Goal false) (eq ?Goal0 false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h (Z.sub i Int.zwordsize)) false)\n        (eq (Int.testbit l (Z.sub i Int.zwordsize)) false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h (Z.sub i Int.zwordsize)) false)\n        (eq (Int.testbit l (Z.sub i Int.zwordsize)) false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h (Z.sub i Int.zwordsize)) false)\n        (eq (Int.testbit l (Z.sub i Int.zwordsize)) false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : Logic.and (eq (Int.testbit h (Z.sub i Int.zwordsize)) false)\n        (eq (Int.testbit l (Z.sub i Int.zwordsize)) false),\neq (Int.testbit h (Z.sub i Int.zwordsize)) false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmpl_eq_zero",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : Int64.int)\n  (_ : eval_expr ge sp e m le a (Vlong x)),\neval_expr ge sp e m le (cmpl_eq_zero a)\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero a)\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold cmpl_eq_zero .",
                "tactic_sig_no_out_arg": "unfold cmpl_eq_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero a)\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr =>\n      comp Ceq (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eapply eval_splitlong_strict .",
                "tactic_sig_no_out_arg": "eapply eval_splitlong_strict .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr =>\n      comp Ceq (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va))),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va))),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))",
                    "H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))",
                    "a1 : expr",
                    "a2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (or ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.or ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (or ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.or ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal) v)\n           (Val.lessdef (Val.or (Vint (Int64.hiword x)) ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal) v)\n           (Val.lessdef (Val.or (Vint (Int64.hiword x)) ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 a2) v)\n           (Val.lessdef\n              (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x)))\n              v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 a2) v)\n           (Val.lessdef\n              (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x)))\n              v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1",
                    "A1 : eval_expr ge sp e m le0 (or a1 a2) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int.or (Int64.hiword x) (Int64.loword x))) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int.or (Int64.hiword x) (Int64.loword x))) v1"
                ],
                "tactic_res": [
                    "A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))"
                ]
            },
            {
                "tactic_sig": "exploit eval_comp .",
                "tactic_sig_no_out_arg": "exploit eval_comp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4\n              (comp ?Goal3 ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.cmp ?Goal3 ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4\n              (comp ?Goal3 ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.cmp ?Goal3 ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (comp ?Goal (or a1 a2) ?Goal0) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal1) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_sig_no_out_arg": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (comp ?Goal (or a1 a2) ?Goal0) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal1) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (Eop (Ointconst Int.zero) Enil) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (Eop (Ointconst Int.zero) Enil) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Ceq ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Ceq ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Ceq\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Ceq\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "B2 : Val.lessdef\n  (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2",
                    "A2 : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmp in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmp in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.cmp Ceq (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Ceq\n        (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero))) v2"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Ceq\n        (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero\n   then Vtrue\n   else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "rewrite <- decompose_cmpl_eq_zero in _i .",
                "tactic_sig_no_out_arg": "rewrite <- decompose_cmpl_eq_zero in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (if Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero\n   then Vtrue\n   else Vfalse) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if\n    Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n      Int64.zero\n   then Vtrue\n   else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose in _i .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (if\n    Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n      Int64.zero\n   then Vtrue\n   else Vfalse) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (if Int64.eq x Int64.zero then Vtrue else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "destruct ( Int64.eq _i Int64.zero ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int64.eq _i Int64.zero ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.eq x Int64.zero))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)",
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)",
                    "B2 : Val.lessdef Vtrue v2",
                    "B2 : Val.lessdef Vfalse v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vtrue v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) Vtrue"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vfalse v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil)) Vfalse"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Ceq (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmpl_ne_zero",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a : expr) (x : Int64.int)\n  (_ : eval_expr ge sp e m le a (Vlong x)),\neval_expr ge sp e m le (cmpl_ne_zero a)\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero a)\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int",
                    "a : expr",
                    "le : letenv"
                ]
            },
            {
                "tactic_sig": "unfold cmpl_ne_zero .",
                "tactic_sig_no_out_arg": "unfold cmpl_ne_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero a)\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr =>\n      comp Cne (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eapply eval_splitlong_strict .",
                "tactic_sig_no_out_arg": "eapply eval_splitlong_strict .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong a\n     (fun h l : expr =>\n      comp Cne (or h l) (Eop (Ointconst Int.zero) Enil)))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va))),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va))),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x))),\neval_expr ge sp e m le\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))",
                    "H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))",
                    "a1 : expr",
                    "a2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "exploit eval_or .",
                "tactic_sig_no_out_arg": "exploit eval_or .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (or ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.or ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3\n              (or ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.or ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "H0 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal) v)\n           (Val.lessdef (Val.or (Vint (Int64.hiword x)) ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 ?Goal) v)\n           (Val.lessdef (Val.or (Vint (Int64.hiword x)) ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "H1 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 a2) v)\n           (Val.lessdef\n              (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x)))\n              v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le0 (or a1 a2) v)\n           (Val.lessdef\n              (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x)))\n              v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1",
                    "A1 : eval_expr ge sp e m le0 (or a1 a2) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.or (Vint (Int64.hiword x)) (Vint (Int64.loword x))) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int.or (Int64.hiword x) (Int64.loword x))) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int.or (Int64.hiword x) (Int64.loword x))) v1"
                ],
                "tactic_res": [
                    "A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))"
                ]
            },
            {
                "tactic_sig": "exploit eval_comp .",
                "tactic_sig_no_out_arg": "exploit eval_comp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4\n              (comp ?Goal3 ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.cmp ?Goal3 ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal4\n              (comp ?Goal3 ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.cmp ?Goal3 ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "A1 : eval_expr ge sp e m le0 (or a1 a2)\n  (Vint (Int.or (Int64.hiword x) (Int64.loword x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (comp ?Goal (or a1 a2) ?Goal0) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal1) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_sig_no_out_arg": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 ?Goal0 ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0 (comp ?Goal (or a1 a2) ?Goal0) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal1) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0 (Eop (Ointconst Int.zero) Enil) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0 (Eop (Ointconst Int.zero) Enil) ?Goal0",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 ?Goal0) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Cne ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Cne ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp ?Goal (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp ?Goal\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Cne\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le0\n              (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Cne\n                 (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n                 (Vint Int.zero)) v)),\neval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "B2 : Val.lessdef\n  (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2",
                    "A2 : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmp in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmp in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.cmp Cne (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n     (Vint Int.zero)) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Cne\n        (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero))) v2"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Cne\n        (Vint (Int.or (Int64.hiword x) (Int64.loword x)))\n        (Vint Int.zero))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if negb (Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero)\n   then Vtrue\n   else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "rewrite <- decompose_cmpl_eq_zero in _i .",
                "tactic_sig_no_out_arg": "rewrite <- decompose_cmpl_eq_zero in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (if negb (Int.eq (Int.or (Int64.hiword x) (Int64.loword x)) Int.zero)\n   then Vtrue\n   else Vfalse) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if\n    negb\n      (Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n         Int64.zero)\n   then Vtrue\n   else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_recompose in _i .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_recompose in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (if\n    negb\n      (Int64.eq (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n         Int64.zero)\n   then Vtrue\n   else Vfalse) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef (if negb (Int64.eq x Int64.zero) then Vtrue else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "destruct ( negb ( Int64.eq _i Int64.zero ) ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( negb ( Int64.eq _i Int64.zero ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.eq x Int64.zero)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)",
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)",
                    "B2 : Val.lessdef Vtrue v2",
                    "B2 : Val.lessdef Vfalse v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vtrue v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) Vtrue"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vfalse v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil)) Vfalse"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (comp Cne (or a1 a2) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmplu_gen",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (ch cl : comparison) (a b : expr) (le : letenv)\n  (x y : Int64.int) (_ : eval_expr ge sp e m le a (Vlong x))\n  (_ : eval_expr ge sp e m le b (Vlong y)),\neval_expr ge sp e m le (cmplu_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int",
                    "y : Int64.int",
                    "le : letenv",
                    "a : expr",
                    "b : expr",
                    "ch : comparison",
                    "cl : comparison"
                ]
            },
            {
                "tactic_sig": "unfold cmplu_gen .",
                "tactic_sig_no_out_arg": "unfold cmplu_gen .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (Econs h1 (Econs h2 Enil)))\n        (Eop (Ocmp (Ccompu cl)) (Econs l1 (Econs l2 Enil)))\n        (Eop (Ocmp (Ccompu ch)) (Econs h1 (Econs h2 Enil)))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eapply eval_splitlong2_strict .",
                "tactic_sig_no_out_arg": "eapply eval_splitlong2_strict .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (Econs h1 (Econs h2 Enil)))\n        (Eop (Ocmp (Ccompu cl)) (Econs l1 (Econs l2 Enil)))\n        (Eop (Ocmp (Ccompu ch)) (Econs h1 (Econs h2 Enil)))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : eval_expr ge sp e m le b (Vlong ?vb)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b (Vlong ?vb)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y))",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_condexpr ge sp e m le0\n  (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil))) \n  ?va",
                    "_goal : eval_expr ge sp e m le0\n  (if ?va\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_condexpr ge sp e m le0\n  (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil))) \n  ?va"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le0 (Econs a1 (Econs b1 Enil)) ?vl",
                    "_goal : eq (eval_condition (Ccomp Ceq) ?vl m) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le0 (Econs a1 (Econs b1 Enil)) ?vl",
                    "_goal : eq (eval_condition (Ccomp Ceq) ?vl m) (Some ?va)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_condition (Ccomp Ceq)\n     (cons (Vint (Int64.hiword x)) (cons (Vint (Int64.hiword y)) nil))\n     m) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (eval_condition (Ccomp Ceq)\n     (cons (Vint (Int64.hiword x)) (cons (Vint (Int64.hiword y)) nil))\n     m) (Some ?va)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Int.eq (Int64.hiword x) (Int64.hiword y))) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Some (Int.eq (Int64.hiword x) (Int64.hiword y))) (Some ?va)",
                    "_goal : eval_expr ge sp e m le0\n  (if ?va\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (if Int.eq (Int64.hiword x) (Int64.hiword y)\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.eq ( Int64.hiword _i ) ( Int64.hiword _i ) ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.eq ( Int64.hiword _i ) ( Int64.hiword _i ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (if Int.eq (Int64.hiword x) (Int64.hiword y)\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))",
                    "x : Int64.int",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n  (Val.of_bool (Int.cmpu cl (Int64.loword x) (Int64.loword y)))",
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool (Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n  (Val.of_bool (Int.cmpu cl (Int64.loword x) (Int64.loword y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool (Int.cmpu ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "int64_eq_xor",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall p q : Int64.int,\neq (Int64.eq p q) (Int64.eq (Int64.xor p q) Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.eq p q) (Int64.eq (Int64.xor p q) Int64.zero)",
                    "p : Int64.int",
                    "q : Int64.int"
                ]
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec _i _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec _i _i ) .",
                "tactic_args": [
                    "_goal : eq (Int64.eq p q) (Int64.eq (Int64.xor p q) Int64.zero)",
                    "p : Int64.int",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : if Int64.eq p q then eq p q else not (eq p q),\neq (Int64.eq p q) (Int64.eq (Int64.xor p q) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq _i _i ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq _i _i ) .",
                "tactic_args": [
                    "_goal : forall _ : if Int64.eq p q then eq p q else not (eq p q),\neq (Int64.eq p q) (Int64.eq (Int64.xor p q) Int64.zero)",
                    "p : Int64.int",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq p q, eq true (Int64.eq (Int64.xor p q) Int64.zero)",
                    "_goal : forall _ : not (eq p q), eq false (Int64.eq (Int64.xor p q) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq p q, eq true (Int64.eq (Int64.xor p q) Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq true (Int64.eq (Int64.xor p q) Int64.zero)",
                    "H : eq p q"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq p q), eq false (Int64.eq (Int64.xor p q) Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq false (Int64.eq (Int64.xor p q) Int64.zero)",
                    "H : not (eq p q)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "_goal : eq true (Int64.eq (Int64.xor p q) Int64.zero)",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eq true (Int64.eq (Int64.xor p p) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.xor_idem .",
                "tactic_sig_no_out_arg": "rewrite Int64.xor_idem .",
                "tactic_args": [
                    "_goal : eq true (Int64.eq (Int64.xor p p) Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq true (Int64.eq Int64.zero Int64.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.eq_true .",
                "tactic_sig_no_out_arg": "rewrite Int64.eq_true .",
                "tactic_args": [
                    "_goal : eq true (Int64.eq Int64.zero Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "generalize ( Int64.eq_spec ( Int64.xor _i _i ) Int64.zero ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.eq_spec ( Int64.xor _i _i ) Int64.zero ) .",
                "tactic_args": [
                    "_goal : eq false (Int64.eq (Int64.xor p q) Int64.zero)",
                    "p : Int64.int",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : if Int64.eq (Int64.xor p q) Int64.zero\n      then eq (Int64.xor p q) Int64.zero\n      else not (eq (Int64.xor p q) Int64.zero),\neq false (Int64.eq (Int64.xor p q) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "case ( Int64.eq ( Int64.xor _i _i ) Int64.zero ) .",
                "tactic_sig_no_out_arg": "case ( Int64.eq ( Int64.xor _i _i ) Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : if Int64.eq (Int64.xor p q) Int64.zero\n      then eq (Int64.xor p q) Int64.zero\n      else not (eq (Int64.xor p q) Int64.zero),\neq false (Int64.eq (Int64.xor p q) Int64.zero)",
                    "p : Int64.int",
                    "q : Int64.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.xor p q) Int64.zero, eq false true",
                    "_goal : forall _ : not (eq (Int64.xor p q) Int64.zero), eq false false"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.xor p q) Int64.zero, eq false true"
                ],
                "tactic_res": [
                    "_goal : eq false true",
                    "H0 : eq (Int64.xor p q) Int64.zero"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall _ : not (eq (Int64.xor p q) Int64.zero), eq false false"
                ],
                "tactic_res": [
                    "_goal : eq false false",
                    "H0 : not (eq (Int64.xor p q) Int64.zero)"
                ]
            },
            {
                "tactic_sig": "elim _i .",
                "tactic_sig_no_out_arg": "elim _i .",
                "tactic_args": [
                    "_goal : eq false true",
                    "H : not (eq p q)"
                ],
                "tactic_res": [
                    "_goal : eq p q"
                ]
            },
            {
                "tactic_sig": "apply Int64.xor_zero_equal .",
                "tactic_sig_no_out_arg": "apply Int64.xor_zero_equal .",
                "tactic_args": [
                    "_goal : eq p q"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.xor p q) Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Int64.xor p q) Int64.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmplu",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : comparison) (le : letenv) (a : expr) (x : val) \n  (b : expr) (y v : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y)\n  (_ : eq (Val.cmplu (Mem.valid_pointer m) c x y) (Some v))\n  (_ : eq Archi.ptr64 false), eval_expr ge sp e m le (cmplu c a b) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v",
                    "H2 : eq Archi.ptr64 false",
                    "H1 : eq (Val.cmplu (Mem.valid_pointer m) c x y) (Some v)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "v : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "c : comparison"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmplu , Val.cmplu_bool in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmplu , Val.cmplu_bool in _i .",
                "tactic_args": [
                    "H1 : eq (Val.cmplu (Mem.valid_pointer m) c x y) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match x with\n     | Vlong n1 =>\n         match y with\n         | Vlong n2 => Some (Int64.cmpu c n1 n2)\n         | Vptr b2 ofs2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if\n               andb (Int64.eq n1 Int64.zero)\n                 (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                    (Mem.valid_pointer m b2\n                       (Z.sub (Ptrofs.unsigned ofs2) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | _ => None\n         end\n     | Vptr b1 ofs1 =>\n         match y with\n         | Vlong n2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if\n               andb (Int64.eq n2 Int64.zero)\n                 (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                    (Mem.valid_pointer m b1\n                       (Z.sub (Ptrofs.unsigned ofs1) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | Vptr b2 ofs2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if eq_block b1 b2\n              then\n               if\n                andb\n                  (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                     (Mem.valid_pointer m b1\n                        (Z.sub (Ptrofs.unsigned ofs1) 1)))\n                  (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                     (Mem.valid_pointer m b2\n                        (Z.sub (Ptrofs.unsigned ofs2) 1)))\n               then Some (Ptrofs.cmpu c ofs1 ofs2)\n               else None\n              else\n               if\n                andb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                  (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n               then Val.cmp_different_blocks c\n               else None\n         | _ => None\n         end\n     | _ => None\n     end) (Some v)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "H2 : eq Archi.ptr64 false",
                    "H1 : eq\n  (option_map Val.of_bool\n     match x with\n     | Vlong n1 =>\n         match y with\n         | Vlong n2 => Some (Int64.cmpu c n1 n2)\n         | Vptr b2 ofs2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if\n               andb (Int64.eq n1 Int64.zero)\n                 (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                    (Mem.valid_pointer m b2\n                       (Z.sub (Ptrofs.unsigned ofs2) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | _ => None\n         end\n     | Vptr b1 ofs1 =>\n         match y with\n         | Vlong n2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if\n               andb (Int64.eq n2 Int64.zero)\n                 (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                    (Mem.valid_pointer m b1\n                       (Z.sub (Ptrofs.unsigned ofs1) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | Vptr b2 ofs2 =>\n             if negb Archi.ptr64\n             then None\n             else\n              if eq_block b1 b2\n              then\n               if\n                andb\n                  (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                     (Mem.valid_pointer m b1\n                        (Z.sub (Ptrofs.unsigned ofs1) 1)))\n                  (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                     (Mem.valid_pointer m b2\n                        (Z.sub (Ptrofs.unsigned ofs2) 1)))\n               then Some (Ptrofs.cmpu c ofs1 ofs2)\n               else None\n              else\n               if\n                andb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                  (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n               then Val.cmp_different_blocks c\n               else None\n         | _ => None\n         end\n     | _ => None\n     end) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match x with\n     | Vlong n1 =>\n         match y with\n         | Vlong n2 => Some (Int64.cmpu c n1 n2)\n         | Vptr b2 ofs2 =>\n             if negb false\n             then None\n             else\n              if\n               andb (Int64.eq n1 Int64.zero)\n                 (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                    (Mem.valid_pointer m b2\n                       (Z.sub (Ptrofs.unsigned ofs2) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | _ => None\n         end\n     | Vptr b1 ofs1 =>\n         match y with\n         | Vlong n2 =>\n             if negb false\n             then None\n             else\n              if\n               andb (Int64.eq n2 Int64.zero)\n                 (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                    (Mem.valid_pointer m b1\n                       (Z.sub (Ptrofs.unsigned ofs1) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | Vptr b2 ofs2 =>\n             if negb false\n             then None\n             else\n              if eq_block b1 b2\n              then\n               if\n                andb\n                  (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                     (Mem.valid_pointer m b1\n                        (Z.sub (Ptrofs.unsigned ofs1) 1)))\n                  (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                     (Mem.valid_pointer m b2\n                        (Z.sub (Ptrofs.unsigned ofs2) 1)))\n               then Some (Ptrofs.cmpu c ofs1 ofs2)\n               else None\n              else\n               if\n                andb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                  (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n               then Val.cmp_different_blocks c\n               else None\n         | _ => None\n         end\n     | _ => None\n     end) (Some v)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match x with\n     | Vlong n1 =>\n         match y with\n         | Vlong n2 => Some (Int64.cmpu c n1 n2)\n         | Vptr b2 ofs2 =>\n             if negb false\n             then None\n             else\n              if\n               andb (Int64.eq n1 Int64.zero)\n                 (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                    (Mem.valid_pointer m b2\n                       (Z.sub (Ptrofs.unsigned ofs2) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | _ => None\n         end\n     | Vptr b1 ofs1 =>\n         match y with\n         | Vlong n2 =>\n             if negb false\n             then None\n             else\n              if\n               andb (Int64.eq n2 Int64.zero)\n                 (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                    (Mem.valid_pointer m b1\n                       (Z.sub (Ptrofs.unsigned ofs1) 1)))\n              then Val.cmp_different_blocks c\n              else None\n         | Vptr b2 ofs2 =>\n             if negb false\n             then None\n             else\n              if eq_block b1 b2\n              then\n               if\n                andb\n                  (orb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                     (Mem.valid_pointer m b1\n                        (Z.sub (Ptrofs.unsigned ofs1) 1)))\n                  (orb (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n                     (Mem.valid_pointer m b2\n                        (Z.sub (Ptrofs.unsigned ofs2) 1)))\n               then Some (Ptrofs.cmpu c ofs1 ofs2)\n               else None\n              else\n               if\n                andb (Mem.valid_pointer m b1 (Ptrofs.unsigned ofs1))\n                  (Mem.valid_pointer m b2 (Ptrofs.unsigned ofs2))\n               then Val.cmp_different_blocks c\n               else None\n         | _ => None\n         end\n     | _ => None\n     end) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match x with\n     | Vlong n1 =>\n         match y with\n         | Vlong n2 => Some (Int64.cmpu c n1 n2)\n         | _ => None\n         end\n     | Vptr _ _ => match y with\n                   | Vundef | _ => None\n                   end\n     | _ => None\n     end) (Some v)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "x : val"
                ],
                "tactic_res": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H1 : eq\n  (option_map Val.of_bool\n     match y with\n     | Vlong n2 => Some (Int64.cmpu c i n2)\n     | _ => None\n     end) (Some v)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H1 : eq (option_map Val.of_bool match y with\n                           | Vundef | _ => None\n                           end) (Some v)",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "H1 : eq None (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "H1 : eq None (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o _o | _o _o _o | _o | _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "y : val"
                ],
                "tactic_res": [
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H1 : eq (option_map Val.of_bool (Some (Int64.cmpu c i i0))) (Some v)",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool (Some (Int64.cmpu c i i0))) (Some v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "H1 : eq None (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "H1 : eq None (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))"
                ]
            },
            {
                "tactic_sig": "try discriminate _i .",
                "tactic_sig_no_out_arg": "try discriminate _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "y : val"
                ],
                "tactic_res": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b1 i0)",
                    "i0 : Ptrofs.int",
                    "b1 : block"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) v",
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rename _i into x .",
                "tactic_sig_no_out_arg": "rename _i into x .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c i i0))",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x i0))",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int"
                ]
            },
            {
                "tactic_sig": "rename _i into y .",
                "tactic_sig_no_out_arg": "rename _i into y .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x i0))",
                    "i0 : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)",
                    "y : Int64.int"
                ]
            },
            {
                "tactic_sig": "destruct _i as [| | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu c a b) (Val.of_bool (Int64.cmpu c x y))",
                    "c : comparison"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu Ceq a b)\n  (Val.of_bool (Int64.cmpu Ceq x y))",
                    "_goal : eval_expr ge sp e m le (cmplu Cne a b)\n  (Val.of_bool (Int64.cmpu Cne x y))",
                    "_goal : eval_expr ge sp e m le (cmplu Clt a b)\n  (Val.of_bool (Int64.cmpu Clt x y))",
                    "_goal : eval_expr ge sp e m le (cmplu Cle a b)\n  (Val.of_bool (Int64.cmpu Cle x y))",
                    "_goal : eval_expr ge sp e m le (cmplu Cgt a b)\n  (Val.of_bool (Int64.cmpu Cgt x y))",
                    "_goal : eval_expr ge sp e m le (cmplu Cge a b)\n  (Val.of_bool (Int64.cmpu Cge x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Ceq a b)\n  (Val.of_bool (Int64.cmpu Ceq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Cne a b)\n  (Val.of_bool (Int64.cmpu Cne x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Clt a b)\n  (Val.of_bool (Int64.cmpu Clt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Cle a b)\n  (Val.of_bool (Int64.cmpu Cle x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Cgt a b)\n  (Val.of_bool (Int64.cmpu Cgt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu Cge a b)\n  (Val.of_bool (Int64.cmpu Cge x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ]
            },
            {
                "tactic_sig": "exploit eval_xorl .",
                "tactic_sig_no_out_arg": "exploit eval_xorl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal4 (xorl ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xorl ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal4 (xorl ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xorl ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal4) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal5) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal4) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal5) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1",
                    "A : eval_expr ge sp e m le (xorl a b) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "rewrite int64_eq_xor .",
                "tactic_sig_no_out_arg": "rewrite int64_eq_xor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))"
                ]
            },
            {
                "tactic_sig": "apply eval_cmpl_eq_zero .",
                "tactic_sig_no_out_arg": "apply eval_cmpl_eq_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_xorl .",
                "tactic_sig_no_out_arg": "exploit eval_xorl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (xorl ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.xorl ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (xorl ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.xorl ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal3 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal3) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal4) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal3 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal3) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal4) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1",
                    "A : eval_expr ge sp e m le (xorl a b) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "rewrite int64_eq_xor .",
                "tactic_sig_no_out_arg": "rewrite int64_eq_xor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "apply eval_cmpl_ne_zero .",
                "tactic_sig_no_out_arg": "apply eval_cmpl_ne_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmplu_gen Clt Clt ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmplu_gen Clt Clt ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal2 (Vlong ?Goal5)",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal3 (Vlong ?Goal6)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal4 (cmplu_gen Clt Clt ?Goal2 ?Goal3)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal5) (Int64.hiword ?Goal6)\n            then\n             Int.cmpu Clt (Int64.loword ?Goal5) (Int64.loword ?Goal6)\n            else\n             Int.cmpu Clt (Int64.hiword ?Goal5) (Int64.hiword ?Goal6))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal2 (Vlong ?Goal5)",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal3 (Vlong ?Goal6)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal4 (cmplu_gen Clt Clt ?Goal2 ?Goal3)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal5) (Int64.hiword ?Goal6)\n            then\n             Int.cmpu Clt (Int64.loword ?Goal5) (Int64.loword ?Goal6)\n            else\n             Int.cmpu Clt (Int64.hiword ?Goal5) (Int64.hiword ?Goal6))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal2 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal3)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword ?Goal3)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal2 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal3)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword ?Goal3)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword x) (Int64.loword y)\n            else Int.ltu (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- Int64.decompose_ltu .",
                "tactic_sig_no_out_arg": "rewrite <- Int64.decompose_ltu .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword x) (Int64.loword y)\n            else Int.ltu (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n              (Int64.ofwords (Int64.hiword y) (Int64.loword y)))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite ! Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool\n           (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n              (Int64.ofwords (Int64.hiword y) (Int64.loword y)))),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool (Int64.ltu x y)),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n        (Val.of_bool (Int64.ltu x y)),\neval_expr ge sp e m le (cmplu_gen Clt Clt a b)\n  (Val.of_bool (Int64.ltu x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmplu_gen Clt Cle ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmplu_gen Clt Cle ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal1 (Vlong ?Goal4)",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal2 (Vlong ?Goal5)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal3 (cmplu_gen Clt Cle ?Goal1 ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal4) (Int64.hiword ?Goal5)\n            then\n             Int.cmpu Cle (Int64.loword ?Goal4) (Int64.loword ?Goal5)\n            else\n             Int.cmpu Clt (Int64.hiword ?Goal4) (Int64.hiword ?Goal5))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal1 (Vlong ?Goal4)",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal2 (Vlong ?Goal5)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal3 (cmplu_gen Clt Cle ?Goal1 ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal4) (Int64.hiword ?Goal5)\n            then\n             Int.cmpu Cle (Int64.loword ?Goal4) (Int64.loword ?Goal5)\n            else\n             Int.cmpu Clt (Int64.hiword ?Goal4) (Int64.hiword ?Goal5))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal1 (Vlong ?Goal2)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Cle a ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal2)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword ?Goal2)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword ?Goal2))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal1 (Vlong ?Goal2)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Cle a ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal2)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword ?Goal2)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword ?Goal2))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))",
                    "H1 : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Clt (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.ltu y x)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_leu .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_leu .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.ltu (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.ltu (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmplu_gen Cgt Cgt ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmplu_gen Cgt Cgt ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal0 (Vlong ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal1 (Vlong ?Goal4)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal2 (cmplu_gen Cgt Cgt ?Goal0 ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal3) (Int64.hiword ?Goal4)\n            then\n             Int.cmpu Cgt (Int64.loword ?Goal3) (Int64.loword ?Goal4)\n            else\n             Int.cmpu Cgt (Int64.hiword ?Goal3) (Int64.hiword ?Goal4))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal0 (Vlong ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal1 (Vlong ?Goal4)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal2 (cmplu_gen Cgt Cgt ?Goal0 ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal3) (Int64.hiword ?Goal4)\n            then\n             Int.cmpu Cgt (Int64.loword ?Goal3) (Int64.loword ?Goal4)\n            else\n             Int.cmpu Cgt (Int64.hiword ?Goal3) (Int64.hiword ?Goal4))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal0 (Vlong ?Goal1)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal1)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword ?Goal1)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword ?Goal1))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal0 (Vlong ?Goal1)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal1)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword ?Goal1)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword ?Goal1))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.ltu (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.eq_sym .",
                "tactic_sig_no_out_arg": "rewrite Int.eq_sym .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.ltu (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword y) (Int64.hiword x)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.ltu (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "rewrite <- Int64.decompose_ltu .",
                "tactic_sig_no_out_arg": "rewrite <- Int64.decompose_ltu .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword y) (Int64.hiword x)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.ltu (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n              (Int64.ofwords (Int64.hiword x) (Int64.loword x)))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite ! Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool\n           (Int64.ltu (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n              (Int64.ofwords (Int64.hiword x) (Int64.loword x)))),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool (Int64.ltu y x)),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n        (Val.of_bool (Int64.ltu y x)),\neval_expr ge sp e m le (cmplu_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.ltu y x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmplu_gen Cgt Cge ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmplu_gen Cgt Cge ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal (Vlong ?Goal2)",
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal0 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal1 (cmplu_gen Cgt Cge ?Goal ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal2) (Int64.hiword ?Goal3)\n            then\n             Int.cmpu Cge (Int64.loword ?Goal2) (Int64.loword ?Goal3)\n            else\n             Int.cmpu Cgt (Int64.hiword ?Goal2) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal (Vlong ?Goal2)",
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal0 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal1 (cmplu_gen Cgt Cge ?Goal ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal2) (Int64.hiword ?Goal3)\n            then\n             Int.cmpu Cge (Int64.loword ?Goal2) (Int64.loword ?Goal3)\n            else\n             Int.cmpu Cgt (Int64.hiword ?Goal2) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal (Vlong ?Goal0)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cge a ?Goal)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal0)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword ?Goal0)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword ?Goal0))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal (Vlong ?Goal0)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cge a ?Goal)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal0)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword ?Goal0)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword ?Goal0))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n            else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))",
                    "H1 : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmpu Cgt (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.ltu x y)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_leu .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_leu .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.ltu (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.eq_sym .",
                "tactic_sig_no_out_arg": "rewrite Int.eq_sym .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmplu_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.ltu (Int64.hiword y) (Int64.hiword x)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmpl_gen",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (ch cl : comparison) (a b : expr) (le : letenv)\n  (x y : Int64.int) (_ : eval_expr ge sp e m le a (Vlong x))\n  (_ : eval_expr ge sp e m le b (Vlong y)),\neval_expr ge sp e m le (cmpl_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int",
                    "y : Int64.int",
                    "le : letenv",
                    "a : expr",
                    "b : expr",
                    "ch : comparison",
                    "cl : comparison"
                ]
            },
            {
                "tactic_sig": "unfold cmpl_gen .",
                "tactic_sig_no_out_arg": "unfold cmpl_gen .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen ch cl a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (Econs h1 (Econs h2 Enil)))\n        (Eop (Ocmp (Ccompu cl)) (Econs l1 (Econs l2 Enil)))\n        (Eop (Ocmp (Ccomp ch)) (Econs h1 (Econs h2 Enil)))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eapply eval_splitlong2_strict .",
                "tactic_sig_no_out_arg": "eapply eval_splitlong2_strict .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (splitlong2 a b\n     (fun h1 l1 h2 l2 : expr =>\n      Econdition (CEcond (Ccomp Ceq) (Econs h1 (Econs h2 Enil)))\n        (Eop (Ocmp (Ccompu cl)) (Econs l1 (Econs l2 Enil)))\n        (Eop (Ocmp (Ccomp ch)) (Econs h1 (Econs h2 Enil)))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : eval_expr ge sp e m le b (Vlong ?vb)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le a (Vlong ?va)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword ?va)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword ?va)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le b (Vlong ?vb)",
                    "_goal : forall (le0 : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword ?vb)))\n  (_ : eval_expr ge sp e m le0 b2 (Vint (Int64.loword ?vb))),\neval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (le : letenv) (a1 a2 b1 b2 : expr)\n  (_ : eval_expr ge sp e m le a1 (Vint (Int64.hiword x)))\n  (_ : eval_expr ge sp e m le a2 (Vint (Int64.loword x)))\n  (_ : eval_expr ge sp e m le b1 (Vint (Int64.hiword y)))\n  (_ : eval_expr ge sp e m le b2 (Vint (Int64.loword y))),\neval_expr ge sp e m le\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))",
                    "H4 : eval_expr ge sp e m le0 b2 (Vint (Int64.loword y))",
                    "H3 : eval_expr ge sp e m le0 b1 (Vint (Int64.hiword y))",
                    "H2 : eval_expr ge sp e m le0 a2 (Vint (Int64.loword x))",
                    "H1 : eval_expr ge sp e m le0 a1 (Vint (Int64.hiword x))",
                    "a1 : expr",
                    "a2 : expr",
                    "b1 : expr",
                    "b2 : expr",
                    "le0 : letenv"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Econdition (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil)))\n     (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n     (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil))))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_condexpr ge sp e m le0\n  (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil))) \n  ?va",
                    "_goal : eval_expr ge sp e m le0\n  (if ?va\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : eval_condexpr ge sp e m le0\n  (CEcond (Ccomp Ceq) (Econs a1 (Econs b1 Enil))) \n  ?va"
                ],
                "tactic_res": [
                    "_goal : eval_exprlist ge sp e m le0 (Econs a1 (Econs b1 Enil)) ?vl",
                    "_goal : eq (eval_condition (Ccomp Ceq) ?vl m) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_exprlist ge sp e m le0 (Econs a1 (Econs b1 Enil)) ?vl",
                    "_goal : eq (eval_condition (Ccomp Ceq) ?vl m) (Some ?va)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_condition (Ccomp Ceq)\n     (cons (Vint (Int64.hiword x)) (cons (Vint (Int64.hiword y)) nil))\n     m) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (eval_condition (Ccomp Ceq)\n     (cons (Vint (Int64.hiword x)) (cons (Vint (Int64.hiword y)) nil))\n     m) (Some ?va)"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Int.eq (Int64.hiword x) (Int64.hiword y))) (Some ?va)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (Some (Int.eq (Int64.hiword x) (Int64.hiword y))) (Some ?va)",
                    "_goal : eval_expr ge sp e m le0\n  (if ?va\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (if Int.eq (Int64.hiword x) (Int64.hiword y)\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.eq ( Int64.hiword _i ) ( Int64.hiword _i ) ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.eq ( Int64.hiword _i ) ( Int64.hiword _i ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (if Int.eq (Int64.hiword x) (Int64.hiword y)\n   then Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil))\n   else Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu cl (Int64.loword x) (Int64.loword y)\n      else Int.cmp ch (Int64.hiword x) (Int64.hiword y)))",
                    "x : Int64.int",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n  (Val.of_bool (Int.cmpu cl (Int64.loword x) (Int64.loword y)))",
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool (Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccompu cl)) (Econs a2 (Econs b2 Enil)))\n  (Val.of_bool (Int.cmpu cl (Int64.loword x) (Int64.loword y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le0\n  (Eop (Ocmp (Ccomp ch)) (Econs a1 (Econs b1 Enil)))\n  (Val.of_bool (Int.cmp ch (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "decompose_cmpl_lt_zero",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall h l : Int.int,\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ]
            },
            {
                "tactic_sig": "generalize ( Int64.shru_lt_zero ( Int64.ofwords _i _i ) ) .",
                "tactic_sig_no_out_arg": "generalize ( Int64.shru_lt_zero ( Int64.ofwords _i _i ) ) .",
                "tactic_args": [
                    "_goal : eq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (Int64.shru (Int64.ofwords h l)\n           (Int64.repr (Z.sub Int64.zwordsize 1)))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ]
            },
            {
                "tactic_sig": "change ( Int64.shru ( Int64.ofwords _i _i ) ( Int64.repr ( Int64.zwordsize - 1 ) ) ) with ( Int64.shru' ( Int64.ofwords _i _i ) ( Int.repr 63 ) ) .",
                "tactic_sig_no_out_arg": "change ( Int64.shru ( Int64.ofwords _i _i ) ( Int64.repr ( Int64.zwordsize - 1 ) ) ) with ( Int64.shru' ( Int64.ofwords _i _i ) ( Int.repr 63 ) ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.shru (Int64.ofwords h l)\n           (Int64.repr (Z.sub Int64.zwordsize 1)))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)",
                    "h : Int.int",
                    "l : Int.int",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq (Int64.shru' (Int64.ofwords h l) (Int.repr 63))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_shru_2 .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_shru_2 .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq (Int64.shru' (Int64.ofwords h l) (Int.repr 63))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (Int.shru h (Int.sub (Int.repr 63) Int.iwordsize)))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)",
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned (Int.repr 63)))\n  (Z.lt (Int.unsigned (Int.repr 63)) Int64.zwordsize)"
                ]
            },
            {
                "tactic_sig": "change ( Int.sub ( Int.repr 63 ) Int.iwordsize ) with ( Int.repr ( Int.zwordsize - 1 ) ) .",
                "tactic_sig_no_out_arg": "change ( Int.sub ( Int.repr 63 ) Int.iwordsize ) with ( Int.repr ( Int.zwordsize - 1 ) ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (Int.shru h (Int.sub (Int.repr 63) Int.iwordsize)))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (Int.shru h (Int.repr (Z.sub Int.zwordsize 1))))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ]
            },
            {
                "tactic_sig": "rewrite Int.shru_lt_zero .",
                "tactic_sig_no_out_arg": "rewrite Int.shru_lt_zero .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (Int.shru h (Int.repr (Z.sub Int.zwordsize 1))))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)"
                ]
            },
            {
                "tactic_sig": "destruct ( Int64.lt ( Int64.ofwords _i _i ) Int64.zero ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int64.lt ( Int64.ofwords _i _i ) Int64.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero))\n        (if Int64.lt (Int64.ofwords h l) Int64.zero\n         then Int64.one\n         else Int64.zero),\neq (Int64.lt (Int64.ofwords h l) Int64.zero) (Int.lt h Int.zero)",
                    "h : Int.int",
                    "l : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero)) Int64.one,\neq true (Int.lt h Int.zero)",
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero))\n        Int64.zero, eq false (Int.lt h Int.zero)"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.lt _i Int.zero ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.lt _i Int.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero)) Int64.one,\neq true (Int.lt h Int.zero)",
                    "h : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.one) Int64.one, eq true true",
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.one,\neq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.one) Int64.one, eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.one,\neq true false"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.one,\neq true false"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.one,\neq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false",
                    "H : eq (Int64.ofwords Int.zero Int.zero) Int64.one"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.lt _i Int.zero ) as [| ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.lt _i Int.zero ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (Int64.ofwords Int.zero\n           (if Int.lt h Int.zero then Int.one else Int.zero))\n        Int64.zero, eq false (Int.lt h Int.zero)",
                    "h : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.one) Int64.zero,\neq false true",
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.zero,\neq false false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.one) Int64.zero,\neq false true"
                ],
                "tactic_res": [
                    "_goal : eq false true",
                    "H : eq (Int64.ofwords Int.zero Int.one) Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall _ : eq (Int64.ofwords Int.zero Int.zero) Int64.zero,\neq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim Int64.one_not_zero .",
                "tactic_sig_no_out_arg": "elim Int64.one_not_zero .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq Int64.one Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Int64.one Int64.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "elim Int64.one_not_zero .",
                "tactic_sig_no_out_arg": "elim Int64.one_not_zero .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": [
                    "_goal : eq Int64.one Int64.zero"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq Int64.one Int64.zero"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "vm_compute .",
                "tactic_sig_no_out_arg": "vm_compute .",
                "tactic_args": [
                    "_goal : Logic.and (Z.le Int.zwordsize (Int.unsigned (Int.repr 63)))\n  (Z.lt (Int.unsigned (Int.repr 63)) Int64.zwordsize)"
                ],
                "tactic_res": [
                    "_goal : Logic.and (forall _ : eq Lt Gt, False) (eq Lt Lt)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "_goal : Logic.and (forall _ : eq Lt Gt, False) (eq Lt Lt)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_cmpl",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : comparison) (le : letenv) (a : expr) (x : val) \n  (b : expr) (y v : val) (_ : eval_expr ge sp e m le a x)\n  (_ : eval_expr ge sp e m le b y) (_ : eq (Val.cmpl c x y) (Some v)),\neval_expr ge sp e m le (cmpl c a b) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) v",
                    "H1 : eq (Val.cmpl c x y) (Some v)",
                    "H0 : eval_expr ge sp e m le b y",
                    "H : eval_expr ge sp e m le a x",
                    "y : val",
                    "v : val",
                    "b : expr",
                    "x : val",
                    "a : expr",
                    "le : letenv",
                    "c : comparison"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmpl in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmpl in _i .",
                "tactic_args": [
                    "H1 : eq (Val.cmpl c x y) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c x y)) (Some v)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "x : val"
                ],
                "tactic_res": [
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c Vundef y)) (Some v)",
                    "H : eval_expr ge sp e m le a Vundef",
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vint i) y)) (Some v)",
                    "H : eval_expr ge sp e m le a (Vint i)",
                    "i : Int.int",
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vlong i) y)) (Some v)",
                    "H : eval_expr ge sp e m le a (Vlong i)",
                    "i : Int64.int",
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vfloat f) y)) (Some v)",
                    "H : eval_expr ge sp e m le a (Vfloat f)",
                    "f : float",
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vsingle f) y)) (Some v)",
                    "H : eval_expr ge sp e m le a (Vsingle f)",
                    "f : float32",
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vptr b0 i) y)) (Some v)",
                    "H : eval_expr ge sp e m le a (Vptr b0 i)",
                    "i : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c Vundef y)) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vint i) y)) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool (Val.cmpl_bool c (Vlong i) y)) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match y with\n     | Vlong n2 => Some (Int64.cmp c i n2)\n     | _ => None\n     end) (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) v"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) v"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match y with\n     | Vlong n2 => Some (Int64.cmp c i n2)\n     | _ => None\n     end) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match y with\n     | Vlong n2 => Some (Int64.cmp c i n2)\n     | _ => None\n     end) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H1 : eq\n  (option_map Val.of_bool\n     match y with\n     | Vlong n2 => Some (Int64.cmp c i n2)\n     | _ => None\n     end) (Some v)"
                ],
                "tactic_res": [
                    "H1 : eq None (Some v)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o | _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "y : val"
                ],
                "tactic_res": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)",
                    "H0 : eval_expr ge sp e m le b Vundef",
                    "H0 : eval_expr ge sp e m le b (Vint i0)",
                    "i0 : Int.int",
                    "H1 : eq (option_map Val.of_bool (Some (Int64.cmp c i i0))) (Some v)",
                    "H0 : eval_expr ge sp e m le b (Vlong i0)",
                    "i0 : Int64.int",
                    "H0 : eval_expr ge sp e m le b (Vfloat f)",
                    "f : float",
                    "H0 : eval_expr ge sp e m le b (Vsingle f)",
                    "f : float32",
                    "H0 : eval_expr ge sp e m le b (Vptr b0 i0)",
                    "i0 : Ptrofs.int",
                    "b0 : block"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool (Some (Int64.cmp c i i0))) (Some v)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c i i0))"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) v",
                    "H1 : eq (option_map Val.of_bool None) (Some v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rename _i into x .",
                "tactic_sig_no_out_arg": "rename _i into x .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c i i0))",
                    "i : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x i0))",
                    "H : eval_expr ge sp e m le a (Vlong x)",
                    "x : Int64.int"
                ]
            },
            {
                "tactic_sig": "rename _i into y .",
                "tactic_sig_no_out_arg": "rename _i into y .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x i0))",
                    "i0 : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)",
                    "y : Int64.int"
                ]
            },
            {
                "tactic_sig": "destruct _i as [| | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl c a b) (Val.of_bool (Int64.cmp c x y))",
                    "c : comparison"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl Ceq a b) (Val.of_bool (Int64.cmp Ceq x y))",
                    "_goal : eval_expr ge sp e m le (cmpl Cne a b) (Val.of_bool (Int64.cmp Cne x y))",
                    "_goal : eval_expr ge sp e m le (cmpl Clt a b) (Val.of_bool (Int64.cmp Clt x y))",
                    "_goal : eval_expr ge sp e m le (cmpl Cle a b) (Val.of_bool (Int64.cmp Cle x y))",
                    "_goal : eval_expr ge sp e m le (cmpl Cgt a b) (Val.of_bool (Int64.cmp Cgt x y))",
                    "_goal : eval_expr ge sp e m le (cmpl Cge a b) (Val.of_bool (Int64.cmp Cge x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Ceq a b) (Val.of_bool (Int64.cmp Ceq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Cne a b) (Val.of_bool (Int64.cmp Cne x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Clt a b) (Val.of_bool (Int64.cmp Clt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Cle a b) (Val.of_bool (Int64.cmp Cle x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Cgt a b) (Val.of_bool (Int64.cmp Cgt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl Cge a b) (Val.of_bool (Int64.cmp Cge x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Cgt Cge a b) (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "exploit eval_xorl .",
                "tactic_sig_no_out_arg": "exploit eval_xorl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal4 (xorl ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xorl ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal5 ?Goal6",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal7 ?Goal8",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal4 (xorl ?Goal5 ?Goal7) v)\n           (Val.lessdef (Val.xorl ?Goal6 ?Goal8) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal4) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal5) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal4) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal5) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))",
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1",
                    "A : eval_expr ge sp e m le (xorl a b) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "rewrite int64_eq_xor .",
                "tactic_sig_no_out_arg": "rewrite int64_eq_xor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))"
                ]
            },
            {
                "tactic_sig": "apply eval_cmpl_eq_zero .",
                "tactic_sig_no_out_arg": "apply eval_cmpl_eq_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_eq_zero (xorl a b))\n  (Val.of_bool (Int64.eq (Int64.xor x y) Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_xorl .",
                "tactic_sig_no_out_arg": "exploit eval_xorl .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (xorl ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.xorl ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal6 ?Goal7",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (xorl ?Goal4 ?Goal6) v)\n           (Val.lessdef (Val.xorl ?Goal5 ?Goal7) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal3 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal3) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal4) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal3 ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a ?Goal3) v)\n           (Val.lessdef (Val.xorl (Vlong x) ?Goal4) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (xorl a b) v)\n           (Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v)),\neval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))",
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1",
                    "A : eval_expr ge sp e m le (xorl a b) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B : Val.lessdef (Val.xorl (Vlong x) (Vlong y)) v1"
                ],
                "tactic_res": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B : Val.lessdef (Vlong (Int64.xor x y)) v1"
                ],
                "tactic_res": [
                    "A : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "rewrite int64_eq_xor .",
                "tactic_sig_no_out_arg": "rewrite int64_eq_xor .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "apply eval_cmpl_ne_zero .",
                "tactic_sig_no_out_arg": "apply eval_cmpl_ne_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_ne_zero (xorl a b))\n  (Val.of_bool (negb (Int64.eq (Int64.xor x y) Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (xorl a b) (Vlong (Int64.xor x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( is_longconst_zero _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst_zero _i ) eqn : LC .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Clt Clt a b) (Val.of_bool (Int64.lt x y))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))",
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))",
                    "LC : eq (is_longconst_zero b) true",
                    "LC : eq (is_longconst_zero b) false"
                ]
            },
            {
                "tactic_sig": "exploit is_longconst_zero_sound .",
                "tactic_sig_no_out_arg": "exploit is_longconst_zero_sound .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst_zero ?Goal4) true",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall _ : eq ?Goal5 (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst_zero ?Goal4) true",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 b ?Goal4"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 b ?Goal4",
                    "_goal : forall _ : eq ?Goal5 (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))",
                    "EQ : eq (Vlong y) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x y))",
                    "EQ : eq (Vlong y) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "H0 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H0 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_highlong .",
                "tactic_sig_no_out_arg": "exploit eval_highlong .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (highlong ?Goal4) v)\n           (Val.lessdef (Val.hiword ?Goal5) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal3 (highlong ?Goal4) v)\n           (Val.lessdef (Val.hiword ?Goal5) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword (Vlong x)) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword (Vlong x)) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "B1 : Val.lessdef (Val.hiword (Vlong x)) v1",
                    "A1 : eval_expr ge sp e m le (highlong a) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.hiword (Vlong x)) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int64.hiword x)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int64.hiword x)) v1"
                ],
                "tactic_res": [
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))"
                ]
            },
            {
                "tactic_sig": "exploit eval_comp .",
                "tactic_sig_no_out_arg": "exploit eval_comp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal8 ?Goal9 ?Goal10",
                    "_goal : eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal8 ?Goal11 ?Goal12",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 \n              ?Goal8 (comp ?Goal7 ?Goal9 ?Goal11) v)\n           (Val.lessdef (Val.cmp ?Goal7 ?Goal10 ?Goal12) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal8 ?Goal9 ?Goal10",
                    "_goal : eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 ?Goal8 ?Goal11 ?Goal12",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal3 ?Goal4 ?Goal5 ?Goal6 \n              ?Goal8 (comp ?Goal7 ?Goal9 ?Goal11) v)\n           (Val.lessdef (Val.cmp ?Goal7 ?Goal10 ?Goal12) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (comp ?Goal3 (highlong a) ?Goal4) v)\n           (Val.lessdef (Val.cmp ?Goal3 (Vint (Int64.hiword x)) ?Goal5)\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_sig_no_out_arg": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal4 ?Goal5",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (comp ?Goal3 (highlong a) ?Goal4) v)\n           (Val.lessdef (Val.cmp ?Goal3 (Vint (Int64.hiword x)) ?Goal5)\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal3 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef (Val.cmp ?Goal3 (Vint (Int64.hiword x)) ?Goal4)\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) ?Goal4",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal3 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef (Val.cmp ?Goal3 (Vint (Int64.hiword x)) ?Goal4)\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal3 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef\n              (Val.cmp ?Goal3 (Vint (Int64.hiword x)) (Vint Int.zero))\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Clt ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Clt ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal3 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef\n              (Val.cmp ?Goal3 (Vint (Int64.hiword x)) (Vint Int.zero))\n              v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v)),\neval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "B2 : Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v2",
                    "A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmp in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmp in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef (Val.cmp Clt (Vint (Int64.hiword x)) (Vint Int.zero)) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Clt (Vint (Int64.hiword x)) (Vint Int.zero))) v2"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Clt (Vint (Int64.hiword x)) (Vint Int.zero))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if Int.lt (Int64.hiword x) Int.zero then Vtrue else Vfalse) v2"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int64.lt x Int64.zero))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        Int64.zero))"
                ]
            },
            {
                "tactic_sig": "rewrite decompose_cmpl_lt_zero .",
                "tactic_sig_no_out_arg": "rewrite decompose_cmpl_lt_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n        Int64.zero))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int.lt (Int64.hiword x) Int.zero))"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.lt ( Int64.hiword _i ) Int.zero ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Int.lt ( Int64.hiword _i ) Int.zero ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (Int.lt (Int64.hiword x) Int.zero))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)",
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)",
                    "B2 : Val.lessdef Vtrue v2",
                    "B2 : Val.lessdef Vfalse v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vtrue v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) Vtrue"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vfalse v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil)) Vfalse"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Clt (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmpl_gen Clt Clt ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmpl_gen Clt Clt ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal2 (Vlong ?Goal5)",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal3 (Vlong ?Goal6)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal4 (cmpl_gen Clt Clt ?Goal2 ?Goal3)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal5) (Int64.hiword ?Goal6)\n            then\n             Int.cmpu Clt (Int64.loword ?Goal5) (Int64.loword ?Goal6)\n            else\n             Int.cmp Clt (Int64.hiword ?Goal5) (Int64.hiword ?Goal6))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal2 (Vlong ?Goal5)",
                    "_goal : eval_expr ge sp e m ?Goal4 ?Goal3 (Vlong ?Goal6)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal4 (cmpl_gen Clt Clt ?Goal2 ?Goal3)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal5) (Int64.hiword ?Goal6)\n            then\n             Int.cmpu Clt (Int64.loword ?Goal5) (Int64.loword ?Goal6)\n            else\n             Int.cmp Clt (Int64.hiword ?Goal5) (Int64.hiword ?Goal6))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal2 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal3)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword ?Goal3)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal2 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal3)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword ?Goal3)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword y)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Clt (Int64.loword x) (Int64.loword y)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword x) (Int64.loword y)\n            else Int.lt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "rewrite <- Int64.decompose_lt .",
                "tactic_sig_no_out_arg": "rewrite <- Int64.decompose_lt .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword x) (Int64.loword y)\n            else Int.lt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n              (Int64.ofwords (Int64.hiword y) (Int64.loword y)))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite ! Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool\n           (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n              (Int64.ofwords (Int64.hiword y) (Int64.loword y)))),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool (Int64.lt x y)),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n        (Val.of_bool (Int64.lt x y)),\neval_expr ge sp e m le (cmpl_gen Clt Clt a b)\n  (Val.of_bool (Int64.lt x y))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmpl_gen Clt Cle ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmpl_gen Clt Cle ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal1 (Vlong ?Goal4)",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal2 (Vlong ?Goal5)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal3 (cmpl_gen Clt Cle ?Goal1 ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal4) (Int64.hiword ?Goal5)\n            then\n             Int.cmpu Cle (Int64.loword ?Goal4) (Int64.loword ?Goal5)\n            else\n             Int.cmp Clt (Int64.hiword ?Goal4) (Int64.hiword ?Goal5))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal1 (Vlong ?Goal4)",
                    "_goal : eval_expr ge sp e m ?Goal3 ?Goal2 (Vlong ?Goal5)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal3 (cmpl_gen Clt Cle ?Goal1 ?Goal2)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal4) (Int64.hiword ?Goal5)\n            then\n             Int.cmpu Cle (Int64.loword ?Goal4) (Int64.loword ?Goal5)\n            else\n             Int.cmp Clt (Int64.hiword ?Goal4) (Int64.hiword ?Goal5))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal1 (Vlong ?Goal2)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Cle a ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal2)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword ?Goal2)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword ?Goal2))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal1 (Vlong ?Goal2)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Cle a ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal2)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword ?Goal2)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword ?Goal2))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n            else Int.cmp Clt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))",
                    "H1 : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cle (Int64.loword x) (Int64.loword y)\n      else Int.cmp Clt (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool (negb (Int64.lt y x)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt y (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_le .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_le .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n           (Int64.ofwords (Int64.hiword x) (Int64.loword x)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.lt (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Clt Cle a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword y) (Int64.loword x))\n      else Int.lt (Int64.hiword x) (Int64.hiword y)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmpl_gen Cgt Cgt ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmpl_gen Cgt Cgt ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal0 (Vlong ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal1 (Vlong ?Goal4)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal2 (cmpl_gen Cgt Cgt ?Goal0 ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal3) (Int64.hiword ?Goal4)\n            then\n             Int.cmpu Cgt (Int64.loword ?Goal3) (Int64.loword ?Goal4)\n            else\n             Int.cmp Cgt (Int64.hiword ?Goal3) (Int64.hiword ?Goal4))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal0 (Vlong ?Goal3)",
                    "_goal : eval_expr ge sp e m ?Goal2 ?Goal1 (Vlong ?Goal4)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal2 (cmpl_gen Cgt Cgt ?Goal0 ?Goal1)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal3) (Int64.hiword ?Goal4)\n            then\n             Int.cmpu Cgt (Int64.loword ?Goal3) (Int64.loword ?Goal4)\n            else\n             Int.cmp Cgt (Int64.hiword ?Goal3) (Int64.hiword ?Goal4))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal0 (Vlong ?Goal1)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal1)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword ?Goal1)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword ?Goal1))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal0 (Vlong ?Goal1)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal1)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword ?Goal1)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword ?Goal1))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword y)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cgt (Int64.loword x) (Int64.loword y)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.lt (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.eq_sym .",
                "tactic_sig_no_out_arg": "rewrite Int.eq_sym .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.lt (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword y) (Int64.hiword x)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.lt (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "rewrite <- Int64.decompose_lt .",
                "tactic_sig_no_out_arg": "rewrite <- Int64.decompose_lt .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword y) (Int64.hiword x)\n            then Int.ltu (Int64.loword y) (Int64.loword x)\n            else Int.lt (Int64.hiword y) (Int64.hiword x))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n              (Int64.ofwords (Int64.hiword x) (Int64.loword x)))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "rewrite ! Int64.ofwords_recompose .",
                "tactic_sig_no_out_arg": "rewrite ! Int64.ofwords_recompose .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool\n           (Int64.lt (Int64.ofwords (Int64.hiword y) (Int64.loword y))\n              (Int64.ofwords (Int64.hiword x) (Int64.loword x)))),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool (Int64.lt y x)),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n        (Val.of_bool (Int64.lt y x)),\neval_expr ge sp e m le (cmpl_gen Cgt Cgt a b)\n  (Val.of_bool (Int64.lt y x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( is_longconst_zero _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_longconst_zero _i ) eqn : LC .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (if is_longconst_zero b\n   then comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)\n   else cmpl_gen Cgt Cge a b) (Val.of_bool (negb (Int64.lt x y)))",
                    "b : expr"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "LC : eq (is_longconst_zero b) true",
                    "LC : eq (is_longconst_zero b) false"
                ]
            },
            {
                "tactic_sig": "exploit is_longconst_zero_sound .",
                "tactic_sig_no_out_arg": "exploit is_longconst_zero_sound .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : eq (is_longconst_zero ?Goal1) true",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall _ : eq ?Goal2 (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (is_longconst_zero ?Goal1) true",
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 b ?Goal1",
                    "_goal : forall _ : eq ?Goal2 (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros EQ .",
                "tactic_args": [
                    "_goal : forall _ : eq (Vlong y) (Vlong Int64.zero),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "EQ : eq (Vlong y) (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "EQ : eq (Vlong y) (Vlong Int64.zero)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "H0 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H0 : eval_expr ge sp e m le b (Vlong Int64.zero)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit eval_highlong .",
                "tactic_sig_no_out_arg": "exploit eval_highlong .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal0 ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m ?Goal0 (highlong ?Goal1) v)\n           (Val.lessdef (Val.hiword ?Goal2) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword (Vlong x)) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v1 [ A1 B1 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and (eval_expr ge sp e m le (highlong a) v)\n           (Val.lessdef (Val.hiword (Vlong x)) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "B1 : Val.lessdef (Val.hiword (Vlong x)) v1",
                    "A1 : eval_expr ge sp e m le (highlong a) v1",
                    "v1 : val"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Val.hiword (Vlong x)) v1"
                ],
                "tactic_res": [
                    "B1 : Val.lessdef (Vint (Int64.hiword x)) v1"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B1 : Val.lessdef (Vint (Int64.hiword x)) v1"
                ],
                "tactic_res": [
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))"
                ]
            },
            {
                "tactic_sig": "exploit eval_comp .",
                "tactic_sig_no_out_arg": "exploit eval_comp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (comp ?Goal4 ?Goal6 ?Goal8) v)\n           (Val.lessdef (Val.cmp ?Goal4 ?Goal7 ?Goal9) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal6 ?Goal7",
                    "_goal : eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal5 ?Goal8 ?Goal9",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ?Goal0 ?Goal1 ?Goal2 ?Goal3 \n              ?Goal5 (comp ?Goal4 ?Goal6 ?Goal8) v)\n           (Val.lessdef (Val.cmp ?Goal4 ?Goal7 ?Goal9) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "A1 : eval_expr ge sp e m le (highlong a) (Vint (Int64.hiword x))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (comp ?Goal0 (highlong a) ?Goal1) v)\n           (Val.lessdef (Val.cmp ?Goal0 (Vint (Int64.hiword x)) ?Goal2)\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_sig_no_out_arg": "instantiate ( 2 := Eop ( Ointconst Int.zero ) Enil ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal1 ?Goal2",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le (comp ?Goal0 (highlong a) ?Goal1) v)\n           (Val.lessdef (Val.cmp ?Goal0 (Vint (Int64.hiword x)) ?Goal2)\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal0 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef (Val.cmp ?Goal0 (Vint (Int64.hiword x)) ?Goal1)\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "EvalOp .",
                "tactic_sig_no_out_arg": "EvalOp .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (Eop (Ointconst Int.zero) Enil) ?Goal1",
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal0 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef (Val.cmp ?Goal0 (Vint (Int64.hiword x)) ?Goal1)\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal0 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef\n              (Val.cmp ?Goal0 (Vint (Int64.hiword x)) (Vint Int.zero))\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "instantiate ( 1 := Cge ) .",
                "tactic_sig_no_out_arg": "instantiate ( 1 := Cge ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp ?Goal0 (highlong a) (Eop (Ointconst Int.zero) Enil))\n              v)\n           (Val.lessdef\n              (Val.cmp ?Goal0 (Vint (Int64.hiword x)) (Vint Int.zero))\n              v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ v2 [ A2 B2 ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : ex\n        (fun v : val =>\n         Logic.and\n           (eval_expr ge sp e m le\n              (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v)\n           (Val.lessdef\n              (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v)),\neval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "B2 : Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v2",
                    "A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) v2",
                    "v2 : val"
                ]
            },
            {
                "tactic_sig": "unfold Val.cmp in _i .",
                "tactic_sig_no_out_arg": "unfold Val.cmp in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef (Val.cmp Cge (Vint (Int64.hiword x)) (Vint Int.zero)) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Cge (Vint (Int64.hiword x)) (Vint Int.zero))) v2"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "B2 : Val.lessdef\n  (Val.of_optbool\n     (Val.cmp_bool Cge (Vint (Int64.hiword x)) (Vint Int.zero))) v2"
                ],
                "tactic_res": [
                    "B2 : Val.lessdef\n  (if negb (Int.lt (Int64.hiword x) Int.zero) then Vtrue else Vfalse)\n  v2"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int64.lt x Int64.zero)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           Int64.zero)))"
                ]
            },
            {
                "tactic_sig": "rewrite decompose_cmpl_lt_zero .",
                "tactic_sig_no_out_arg": "rewrite decompose_cmpl_lt_zero .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           Int64.zero)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int.lt (Int64.hiword x) Int.zero)))"
                ]
            },
            {
                "tactic_sig": "destruct ( negb ( Int.lt ( Int64.hiword _i ) Int.zero ) ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( negb ( Int.lt ( Int64.hiword _i ) Int.zero ) ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool (negb (Int.lt (Int64.hiword x) Int.zero)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)",
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)",
                    "B2 : Val.lessdef Vtrue v2",
                    "B2 : Val.lessdef Vfalse v2"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vtrue v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) Vtrue"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool true)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "B2 : Val.lessdef Vfalse v2"
                ],
                "tactic_res": [
                    "A2 : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil)) Vfalse"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le\n  (comp Cge (highlong a) (Eop (Ointconst Int.zero) Enil))\n  (Val.of_bool false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ( eval_cmpl_gen Cgt Cge ) .",
                "tactic_sig_no_out_arg": "exploit ( eval_cmpl_gen Cgt Cge ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal (Vlong ?Goal2)",
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal0 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal1 (cmpl_gen Cgt Cge ?Goal ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal2) (Int64.hiword ?Goal3)\n            then\n             Int.cmpu Cge (Int64.loword ?Goal2) (Int64.loword ?Goal3)\n            else\n             Int.cmp Cgt (Int64.hiword ?Goal2) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal (Vlong ?Goal2)",
                    "_goal : eval_expr ge sp e m ?Goal1 ?Goal0 (Vlong ?Goal3)",
                    "_goal : forall\n  _ : eval_expr ge sp e m ?Goal1 (cmpl_gen Cgt Cge ?Goal ?Goal0)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword ?Goal2) (Int64.hiword ?Goal3)\n            then\n             Int.cmpu Cge (Int64.loword ?Goal2) (Int64.loword ?Goal3)\n            else\n             Int.cmp Cgt (Int64.hiword ?Goal2) (Int64.hiword ?Goal3))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "H : eval_expr ge sp e m le a (Vlong x)"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le ?Goal (Vlong ?Goal0)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cge a ?Goal)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal0)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword ?Goal0)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword ?Goal0))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "eexact _i .",
                "tactic_sig_no_out_arg": "eexact _i .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le ?Goal (Vlong ?Goal0)",
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cge a ?Goal)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword ?Goal0)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword ?Goal0)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword ?Goal0))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "H0 : eval_expr ge sp e m le b (Vlong y)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  _ : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n        (Val.of_bool\n           (if Int.eq (Int64.hiword x) (Int64.hiword y)\n            then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n            else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y))),\neval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "H1 : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then Int.cmpu Cge (Int64.loword x) (Int64.loword y)\n      else Int.cmp Cgt (Int64.hiword x) (Int64.hiword y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool (negb (Int64.lt x y)))",
                    "x : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_sig_no_out_arg": "rewrite <- ( Int64.ofwords_recompose _i ) .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x)) y)))",
                    "y : Int64.int"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.decompose_le .",
                "tactic_sig_no_out_arg": "rewrite Int64.decompose_le .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (negb\n        (Int64.lt (Int64.ofwords (Int64.hiword x) (Int64.loword x))\n           (Int64.ofwords (Int64.hiword y) (Int64.loword y)))))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.eq_sym .",
                "tactic_sig_no_out_arg": "rewrite Int.eq_sym .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword y) (Int64.hiword x)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))"
                ],
                "tactic_res": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eval_expr ge sp e m le (cmpl_gen Cgt Cge a b)\n  (Val.of_bool\n     (if Int.eq (Int64.hiword x) (Int64.hiword y)\n      then negb (Int.ltu (Int64.loword x) (Int64.loword y))\n      else Int.lt (Int64.hiword y) (Int64.hiword x)))"
                ],
                "tactic_res": []
            }
        ]
    }
]