[
    {
        "lemma_name": "Name_eq_dec",
        "proof": [
            {
                "tactic_sig": "decide equality .",
                "tactic_sig_no_out_arg": "decide equality .",
                "tactic_args": [
                    "_goal : forall a b : Name, sumbool (eq a b) (not (eq a b))"
                ],
                "tactic_res": [
                    "_goal : sumbool (eq c c0) (not (eq c c0))",
                    "c : Client_index",
                    "c0 : Client_index",
                    "a : Name",
                    "b : Name"
                ]
            },
            {
                "tactic_sig": "apply fin_eq_dec .",
                "tactic_sig_no_out_arg": "apply fin_eq_dec .",
                "tactic_args": [
                    "_goal : sumbool (eq c c0) (not (eq c c0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Msg_eq_dec",
        "proof": [
            {
                "tactic_sig": "decide equality .",
                "tactic_sig_no_out_arg": "decide equality .",
                "tactic_args": [
                    "_goal : forall a b : Msg, sumbool (eq a b) (not (eq a b))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_n_Nodes",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall n : Name, In n Nodes"
                ],
                "tactic_res": [
                    "_goal : forall n : Name, In n Nodes"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall n : Name, In n Nodes"
                ],
                "tactic_res": [
                    "_goal : In n Nodes",
                    "n : Name"
                ]
            },
            {
                "tactic_sig": "unfold Nodes , list_Clients .",
                "tactic_sig_no_out_arg": "unfold Nodes , list_Clients .",
                "tactic_args": [
                    "_goal : In n Nodes"
                ],
                "tactic_res": [
                    "_goal : In n (cons Server (map Client (all_fin num_Clients)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : In n (cons Server (map Client (all_fin num_Clients)))"
                ],
                "tactic_res": [
                    "_goal : or (eq Server n) (In n (map Client (all_fin num_Clients)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : or (eq Server n) (In n (map Client (all_fin num_Clients)))",
                    "n : Name"
                ],
                "tactic_res": [
                    "_goal : or (eq Server (Client c))\n  (In (Client c) (map Client (all_fin num_Clients)))",
                    "_goal : or (eq Server Server) (In Server (map Client (all_fin num_Clients)))",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "_goal : or (eq Server (Client c))\n  (In (Client c) (map Client (all_fin num_Clients)))"
                ],
                "tactic_res": [
                    "_goal : In (Client c) (map Client (all_fin num_Clients))"
                ]
            },
            {
                "tactic_sig": "apply in_map .",
                "tactic_sig_no_out_arg": "apply in_map .",
                "tactic_args": [
                    "_goal : In (Client c) (map Client (all_fin num_Clients))"
                ],
                "tactic_res": [
                    "_goal : In c (all_fin num_Clients)"
                ]
            },
            {
                "tactic_sig": "apply all_fin_all .",
                "tactic_sig_no_out_arg": "apply all_fin_all .",
                "tactic_args": [
                    "_goal : In c (all_fin num_Clients)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or (eq Server Server) (In Server (map Client (all_fin num_Clients)))"
                ],
                "tactic_res": [
                    "_goal : eq Server Server"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq Server Server"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nodup",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : NoDup Nodes"
                ],
                "tactic_res": [
                    "_goal : NoDup Nodes"
                ]
            },
            {
                "tactic_sig": "unfold Nodes , list_Clients .",
                "tactic_sig_no_out_arg": "unfold Nodes , list_Clients .",
                "tactic_args": [
                    "_goal : NoDup Nodes"
                ],
                "tactic_res": [
                    "_goal : NoDup (cons Server (map Client (all_fin num_Clients)))"
                ]
            },
            {
                "tactic_sig": "apply NoDup_cons .",
                "tactic_sig_no_out_arg": "apply NoDup_cons .",
                "tactic_args": [
                    "_goal : NoDup (cons Server (map Client (all_fin num_Clients)))"
                ],
                "tactic_res": [
                    "_goal : not (In Server (map Client (all_fin num_Clients)))",
                    "_goal : NoDup (map Client (all_fin num_Clients))"
                ]
            },
            {
                "tactic_sig": "in_crush_tac ( intuition auto ) .",
                "tactic_sig_no_out_arg": "in_crush_tac ( intuition auto ) .",
                "tactic_args": [
                    "_goal : not (In Server (map Client (all_fin num_Clients)))"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : In x (all_fin num_Clients)",
                    "H : eq (Client x) Server",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply NoDup_map_injective .",
                "tactic_sig_no_out_arg": "apply NoDup_map_injective .",
                "tactic_args": [
                    "_goal : NoDup (map Client (all_fin num_Clients))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : Client_index) (_ : In x (all_fin num_Clients))\n  (_ : In y (all_fin num_Clients)) (_ : eq (Client x) (Client y)),\neq x y",
                    "_goal : NoDup (all_fin num_Clients)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : Client_index) (_ : In x (all_fin num_Clients))\n  (_ : In y (all_fin num_Clients)) (_ : eq (Client x) (Client y)),\neq x y"
                ],
                "tactic_res": [
                    "_goal : eq x y",
                    "H1 : eq (Client x) (Client y)",
                    "H0 : In y (all_fin num_Clients)",
                    "H : In x (all_fin num_Clients)",
                    "x : Client_index",
                    "y : Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq x y"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply all_fin_NoDup .",
                "tactic_sig_no_out_arg": "apply all_fin_NoDup .",
                "tactic_args": [
                    "_goal : NoDup (all_fin num_Clients)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_implies_mutex",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma),\nmutual_exclusion sigma"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma),\nmutual_exclusion sigma"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct , mutual_exclusion .",
                "tactic_sig_no_out_arg": "unfold locks_correct , mutual_exclusion .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma),\nmutual_exclusion sigma"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t))) (m n : Client_index)\n  (_ : eq (held (sigma (Client m))) true)\n  (_ : eq (held (sigma (Client n))) true), eq m n"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t))) (m n : Client_index)\n  (_ : eq (held (sigma (Client m))) true)\n  (_ : eq (held (sigma (Client n))) true), eq m n"
                ],
                "tactic_res": [
                    "_goal : eq m n",
                    "H1 : eq (held (sigma (Client n))) true",
                    "H0 : eq (held (sigma (Client m))) true",
                    "m : Client_index",
                    "n : Client_index",
                    "H : forall (n : Client_index) (_ : eq (held (sigma (Client n))) true),\nex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "repeat find_apply_hyp_hyp .",
                "tactic_sig_no_out_arg": "repeat find_apply_hyp_hyp .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H0 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons m t))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (queue (sigma Server)) (cons n x)",
                    "x : list Client_index",
                    "H0 : eq (queue (sigma Server)) (cons m x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "find_rewrite .",
                "tactic_sig_no_out_arg": "find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (cons m x0) (cons n x)"
                ]
            },
            {
                "tactic_sig": "find_inversion .",
                "tactic_sig_no_out_arg": "find_inversion .",
                "tactic_args": [
                    "_goal : eq m n"
                ],
                "tactic_res": [
                    "_goal : eq n n",
                    "H0 : eq (queue (sigma Server)) (cons n x)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq n n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nwnw_sym",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q),\nLockServ_network_network_invariant q p"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q),\nLockServ_network_network_invariant q p"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_network_invariant .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_network_invariant .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q),\nLockServ_network_network_invariant q p"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False)))),\nand (forall (_ : eq (pBody q) Unlock) (_ : eq (pBody p) Unlock), False)\n  (and\n     (forall (_ : eq (pBody q) Locked) (_ : eq (pBody p) Unlock), False)\n     (and\n        (forall (_ : eq (pBody q) Unlock) (_ : eq (pBody p) Locked),\n         False)\n        (forall (_ : eq (pBody q) Locked) (_ : eq (pBody p) Locked),\n         False)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False)))),\nand (forall (_ : eq (pBody q) Unlock) (_ : eq (pBody p) Unlock), False)\n  (and\n     (forall (_ : eq (pBody q) Locked) (_ : eq (pBody p) Unlock), False)\n     (and\n        (forall (_ : eq (pBody q) Unlock) (_ : eq (pBody p) Locked),\n         False)\n        (forall (_ : eq (pBody q) Locked) (_ : eq (pBody p) Locked),\n         False)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_init",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : locks_correct init_handlers"
                ],
                "tactic_res": [
                    "_goal : locks_correct init_handlers"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct .",
                "tactic_sig_no_out_arg": "unfold locks_correct .",
                "tactic_args": [
                    "_goal : locks_correct init_handlers"
                ],
                "tactic_res": [
                    "_goal : forall (n : Client_index)\n  (_ : eq (held (init_handlers (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (init_handlers Server)) (cons n t))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (n : Client_index)\n  (_ : eq (held (init_handlers (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (init_handlers Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : forall (n : Client_index) (_ : eq false true),\nex (fun t : list Client_index => eq nil (cons n t))"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : forall (n : Client_index) (_ : eq false true),\nex (fun t : list Client_index => eq nil (cons n t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputHandler_cases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (u : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair u out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (u : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair u out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (u : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair u out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (u : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match h with\n          | Client c =>\n              match i with\n              | Lock =>\n                  fun s : Data =>\n                  pair (pair (pair (InputLock c) (app nil nil)) s)\n                    (app (cons (pair Server Lock) nil) nil)\n              | Unlock =>\n                  fun s : Data =>\n                  let\n                  'pair (pair (pair b os2) s'') ws2 :=\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    (if held s\n                     then\n                      fun _ : Data =>\n                      pair\n                        (pair (pair tt (app (app nil nil) nil))\n                           {| queue := nil; held := false |})\n                        (app (app nil (cons (pair Server Unlock) nil))\n                           nil)\n                     else\n                      fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                      s in\n                    pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                      (app ws1 nil) in\n                   pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n              | Locked =>\n                  fun s : Data => pair (pair (pair Nop nil) s) nil\n              end\n          | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair u out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (u : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match h with\n          | Client c =>\n              match i with\n              | Lock =>\n                  fun s : Data =>\n                  pair (pair (pair (InputLock c) (app nil nil)) s)\n                    (app (cons (pair Server Lock) nil) nil)\n              | Unlock =>\n                  fun s : Data =>\n                  let\n                  'pair (pair (pair b os2) s'') ws2 :=\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    (if held s\n                     then\n                      fun _ : Data =>\n                      pair\n                        (pair (pair tt (app (app nil nil) nil))\n                           {| queue := nil; held := false |})\n                        (app (app nil (cons (pair Server Unlock) nil))\n                           nil)\n                     else\n                      fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                      s in\n                    pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                      (app ws1 nil) in\n                   pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n              | Locked =>\n                  fun s : Data => pair (pair (pair Nop nil) s) nil\n              end\n          | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair u out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "H : eq\n  (match h with\n   | Client c =>\n       match i with\n       | Lock =>\n           fun s : Data =>\n           pair (pair (pair (InputLock c) (app nil nil)) s)\n             (app (cons (pair Server Lock) nil) nil)\n       | Unlock =>\n           fun s : Data =>\n           let\n           'pair (pair (pair b os2) s'') ws2 :=\n            let\n            'pair (pair (pair _ os1) s') ws1 :=\n             (if held s\n              then\n               fun _ : Data =>\n               pair\n                 (pair (pair tt (app (app nil nil) nil))\n                    {| queue := nil; held := false |})\n                 (app (app nil (cons (pair Server Unlock) nil)) nil)\n              else fun s0 : Data => pair (pair (pair tt nil) s0) nil) s\n             in\n             pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n               (app ws1 nil) in\n            pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n       | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n       end\n   | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n   end st) (pair (pair (pair u out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "u : Label",
                    "st : Data",
                    "i : Msg",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq true true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Locked Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))",
                    "H : eq\n  (pair (pair (pair (InputLock c) (app nil nil)) st)\n     (app (cons (pair Server Lock) nil) nil))\n  (pair (pair (pair u out) st') ms)",
                    "Heqm : eq i Lock",
                    "Heqn : eq h (Client c)",
                    "c : Client_index",
                    "H : eq (pair (pair (pair l0 (app nil l1)) d) (app nil l))\n  (pair (pair (pair u out) st') ms)",
                    "Heqp : eq (pair (pair (pair (InputUnlock c) (app l3 nil)) d0) (app l2 nil))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app (app nil nil) nil))\n        {| queue := nil; held := false |})\n     (app (app nil (cons (pair Server Unlock) nil)) nil))\n  (pair (pair (pair u0 l3) d0) l2)",
                    "Heqb : eq (held st) true",
                    "Heqp3 : eq p1 (pair (pair u0 l3) d0)",
                    "Heqp4 : eq p2 (pair u0 l3)",
                    "l3 : list Output",
                    "u0 : unit",
                    "d0 : Data",
                    "p2 : prod unit (list Output)",
                    "l2 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp0 : eq p (pair (pair l0 l1) d)",
                    "Heqp1 : eq p0 (pair l0 l1)",
                    "l1 : list Output",
                    "l0 : Label",
                    "d : Data",
                    "p0 : prod Label (list Output)",
                    "l : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqm : eq i Unlock",
                    "Heqp2 : eq (pair (pair (pair tt nil) st) nil) (pair (pair (pair u0 l3) d0) l2)",
                    "Heqb : eq (held st) false",
                    "H : eq (pair (pair (pair Nop nil) st) nil)\n  (pair (pair (pair u out) st') ms)",
                    "Heqm : eq i Locked",
                    "Heqn : eq h Server"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq true true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (app (cons (pair Server Unlock) nil) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq (app nil nil) nil)\n                 (and\n                    (eq (held {| queue := nil; held := false |}) false)\n                    (or\n                       (and (eq true true)\n                          (eq (app (cons (pair Server Unlock) nil) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (app (cons (pair Server Unlock) nil) nil)\n                             nil)))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (eq (app (cons (pair Server Unlock) nil) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (app (cons (pair Server Unlock) nil) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq (app nil nil) nil)\n                 (and\n                    (eq (held {| queue := nil; held := false |}) false)\n                    (or\n                       (and (eq true true)\n                          (eq (app (cons (pair Server Unlock) nil) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (app (cons (pair Server Unlock) nil) nil)\n                             nil)))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (eq (app (cons (pair Server Unlock) nil) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq false false)\n                    (or\n                       (and (eq true true)\n                          (eq (cons (pair Server Unlock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (cons (pair Server Unlock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (eq (cons (pair Server Unlock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq st' st')\n                    (eq (app nil nil) (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq (app nil nil) nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq (app nil nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq (app nil nil) nil)))))))))\n  (and (eq (app nil nil) nil) (and (eq st' st') (eq (app nil nil) nil)))",
                    "Heqb : eq (held st') false"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq st' st')\n                    (eq (app nil nil) (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq (app nil nil) nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq (app nil nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq (app nil nil) nil)))))))))\n  (and (eq (app nil nil) nil) (and (eq st' st') (eq (app nil nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq Locked Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq Locked Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st) (eq ms (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq out nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st) true)\n                          (eq ms (cons (pair Server Unlock) nil)))\n                       (and (eq st' st) (eq ms nil)))))))))\n  (and (eq out nil) (and (eq st' st) (eq ms nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (eq (cons (pair Server Lock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Lock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (eq (cons (pair Server Lock) nil)\n                    (cons (pair Server Lock) nil)))))\n        (and (eq Lock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq (held st') true)\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq st' st')\n                       (eq (cons (pair Server Lock) nil) nil))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Lock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (eq (cons (pair Server Lock) nil)\n                    (cons (pair Server Lock) nil)))))\n        (and (eq Lock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq (held st') true)\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq st' st')\n                       (eq (cons (pair Server Lock) nil) nil))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Lock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (eq (cons (pair Server Lock) nil)\n                 (cons (pair Server Lock) nil)))))\n     (and (eq Lock Unlock)\n        (and (eq nil nil)\n           (and (eq (held st') false)\n              (or\n                 (and (eq (held st') true)\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Unlock) nil)))\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil) nil)))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Lock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (eq (cons (pair Server Lock) nil)\n                 (cons (pair Server Lock) nil)))))\n     (and (eq Lock Unlock)\n        (and (eq nil nil)\n           (and (eq (held st') false)\n              (or\n                 (and (eq (held st') true)\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Unlock) nil)))\n                 (and (eq st' st')\n                    (eq (cons (pair Server Lock) nil) nil)))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq false false)\n                    (or\n                       (and (eq true true)\n                          (eq (cons (pair Server Unlock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (cons (pair Server Unlock) nil) nil)))))))))\n  (and (eq nil nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (eq (cons (pair Server Unlock) nil) nil)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq {| queue := nil; held := false |} st)\n                 (eq (cons (pair Server Unlock) nil)\n                    (cons (pair Server Lock) nil)))))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq false false)\n                 (or\n                    (and (eq true true)\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq {| queue := nil; held := false |} st)\n                       (eq (cons (pair Server Unlock) nil) nil))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq {| queue := nil; held := false |} st)\n                 (eq (cons (pair Server Unlock) nil)\n                    (cons (pair Server Lock) nil)))))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq false false)\n                 (or\n                    (and (eq true true)\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq {| queue := nil; held := false |} st)\n                       (eq (cons (pair Server Unlock) nil) nil))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := false |} st)\n              (eq (cons (pair Server Unlock) nil)\n                 (cons (pair Server Lock) nil)))))\n     (and (eq Unlock Unlock)\n        (and (eq nil nil)\n           (and (eq false false)\n              (or\n                 (and (eq true true)\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Unlock) nil)))\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (cons (pair Server Unlock) nil) nil)))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := false |} st)\n              (eq (cons (pair Server Unlock) nil)\n                 (cons (pair Server Lock) nil)))))\n     (and (eq Unlock Unlock)\n        (and (eq nil nil)\n           (and (eq false false)\n              (or\n                 (and (eq true true)\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Unlock) nil)))\n                 (and (eq {| queue := nil; held := false |} st)\n                    (eq (cons (pair Server Unlock) nil) nil)))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq st' st') (eq nil (cons (pair Server Lock) nil)))))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq false true)\n                       (eq nil (cons (pair Server Unlock) nil)))\n                    (and (eq st' st') (eq nil nil))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq st' st') (eq nil (cons (pair Server Lock) nil)))))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq false true)\n                       (eq nil (cons (pair Server Unlock) nil)))\n                    (and (eq st' st') (eq nil nil))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq st' st') (eq nil (cons (pair Server Lock) nil)))))\n     (and (eq Unlock Unlock)\n        (and (eq nil nil)\n           (and (eq (held st') false)\n              (or\n                 (and (eq false true)\n                    (eq nil (cons (pair Server Unlock) nil)))\n                 (and (eq st' st') (eq nil nil)))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq st' st') (eq nil (cons (pair Server Lock) nil)))))\n     (and (eq Unlock Unlock)\n        (and (eq nil nil)\n           (and (eq (held st') false)\n              (or\n                 (and (eq false true)\n                    (eq nil (cons (pair Server Unlock) nil)))\n                 (and (eq st' st') (eq nil nil)))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq Locked Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (eq nil (cons (pair Server Lock) nil)))))\n           (and (eq i Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))\n  (and (eq nil nil) (and (eq st' st') (eq nil nil)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_update_false",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : Data) \n  (x : Client_index) (_ : locks_correct sigma)\n  (_ : eq (held st') false),\nlocks_correct (update name_eq_dec sigma (Client x) st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : Data) \n  (x : Client_index) (_ : locks_correct sigma)\n  (_ : eq (held st') false),\nlocks_correct (update name_eq_dec sigma (Client x) st')"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct .",
                "tactic_sig_no_out_arg": "unfold locks_correct .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : Data) \n  (x : Client_index) (_ : locks_correct sigma)\n  (_ : eq (held st') false),\nlocks_correct (update name_eq_dec sigma (Client x) st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : Data) \n  (x : Client_index)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : eq (held st') false) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma (Client x) st' (Client n)))\n         true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons n t))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : Data) \n  (x : Client_index)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : eq (held st') false) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma (Client x) st' (Client n)))\n         true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons n t))",
                    "H1 : eq (held (update name_eq_dec sigma (Client x) st' (Client n))) true",
                    "n : Client_index",
                    "H0 : eq (held st') false",
                    "H : forall (n : Client_index) (_ : eq (held (sigma (Client n))) true),\nex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "x : Client_index",
                    "st' : Data",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "destruct ( Name_eq_dec ( Client _i ) ( Client _i ) ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Name_eq_dec ( Client _i ) ( Client _i ) ) .",
                "tactic_args": [
                    "x : Client_index",
                    "n : Client_index"
                ],
                "tactic_res": [
                    "e : eq (Client x) (Client n)",
                    "n0 : not (eq (Client x) (Client n))"
                ]
            },
            {
                "tactic_sig": "find_inversion .",
                "tactic_sig_no_out_arg": "find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client n) st' Server))\n     (cons n t))",
                    "H1 : eq (held (update name_eq_dec sigma (Client n) st' (Client n))) true"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client n) st' Server))\n     (cons n t))"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (held st') true"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H1 : eq (held (sigma (Client n))) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_input_handlers",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma h st')"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma h st')"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma h st')"
                ],
                "tactic_res": [
                    "_goal : locks_correct (update Name_eq_dec sigma (Client x) st')",
                    "H5 : eq (held (sigma (Client x))) true",
                    "H3 : eq (held st') false",
                    "x : Client_index",
                    "H0 : locks_correct sigma",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_update_false .",
                "tactic_sig_no_out_arg": "auto using locks_correct_update_false .",
                "tactic_args": [
                    "_goal : locks_correct (update Name_eq_dec sigma (Client x) st')"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ClientNetHandler_cases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair u out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair u out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair u out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match m with\n          | Locked =>\n              fun _ : Data =>\n              pair\n                (pair\n                   (pair (MsgLocked c)\n                      (app nil (app (cons Locked nil) nil)))\n                   {| queue := nil; held := true |})\n                (app nil (app nil nil))\n          | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair u out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match m with\n          | Locked =>\n              fun _ : Data =>\n              pair\n                (pair\n                   (pair (MsgLocked c)\n                      (app nil (app (cons Locked nil) nil)))\n                   {| queue := nil; held := true |})\n                (app nil (app nil nil))\n          | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair u out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))",
                    "H : eq\n  (match m with\n   | Locked =>\n       fun _ : Data =>\n       pair\n         (pair\n            (pair (MsgLocked c) (app nil (app (cons Locked nil) nil)))\n            {| queue := nil; held := true |}) (app nil (app nil nil))\n   | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n   end st) (pair (pair (pair u out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "u : Label",
                    "st : Data",
                    "m : Msg",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq m Locked))))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))",
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))",
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))",
                    "H : eq (pair (pair (pair Nop nil) st) nil)\n  (pair (pair (pair u out) st') ms)",
                    "Heqm0 : eq m Lock",
                    "Heqm0 : eq m Unlock",
                    "H : eq\n  (pair\n     (pair (pair (MsgLocked c) (app nil (app (cons Locked nil) nil)))\n        {| queue := nil; held := true |}) (app nil (app nil nil)))\n  (pair (pair (pair u out) st') ms)",
                    "Heqm0 : eq m Locked"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Lock Locked))))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (not (eq Unlock Locked))))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq out (cons Locked nil)) (eq (held st') true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (eq (held {| queue := nil; held := true |}) true))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (eq (held {| queue := nil; held := true |}) true))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (eq (held {| queue := nil; held := true |}) true))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (not (eq Locked Locked))))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (eq (held {| queue := nil; held := true |}) true))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ServerNetHandler_cases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair u out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair u out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair u out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (let\n          'pair (pair (pair b os2) s'') ws2 :=\n           match m with\n           | Lock =>\n               match src with\n               | Client c =>\n                   fun s : Data =>\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    let\n                    'pair (pair (pair _ os1) _) ws1 :=\n                     (if null (queue st)\n                      then\n                       fun s0 : Data =>\n                       pair (pair (pair tt (app nil nil)) s0)\n                         (app (cons (pair src Locked) nil) nil)\n                      else\n                       fun s0 : Data =>\n                       pair (pair (pair tt nil) s0) nil) s in\n                     pair\n                       (pair (pair tt (app os1 nil))\n                          {|\n                            queue := app (queue st) (cons c nil);\n                            held := held st\n                          |}) (app ws1 nil) in\n                    pair (pair (pair (MsgLock c) (app os1 nil)) s')\n                      (app ws1 nil)\n               | Server =>\n                   fun s : Data => pair (pair (pair Nop nil) s) nil\n               end\n           | Unlock =>\n               fun s : Data =>\n               let\n               'pair (pair (pair _ os1) s') ws1 :=\n                match queue st with\n                | cons _ (cons x xs) =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt (app nil nil))\n                         {| queue := cons x xs; held := held st |})\n                      (app nil (cons (pair (Client x) Locked) nil))\n                | _ =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt nil)\n                         {| queue := nil; held := held st |}) nil\n                end s in\n                pair (pair (pair MsgUnlock (app os1 nil)) s')\n                  (app ws1 nil)\n           | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n           end st in\n           pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n         (pair (pair (pair u out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (u : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (let\n          'pair (pair (pair b os2) s'') ws2 :=\n           match m with\n           | Lock =>\n               match src with\n               | Client c =>\n                   fun s : Data =>\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    let\n                    'pair (pair (pair _ os1) _) ws1 :=\n                     (if null (queue st)\n                      then\n                       fun s0 : Data =>\n                       pair (pair (pair tt (app nil nil)) s0)\n                         (app (cons (pair src Locked) nil) nil)\n                      else\n                       fun s0 : Data =>\n                       pair (pair (pair tt nil) s0) nil) s in\n                     pair\n                       (pair (pair tt (app os1 nil))\n                          {|\n                            queue := app (queue st) (cons c nil);\n                            held := held st\n                          |}) (app ws1 nil) in\n                    pair (pair (pair (MsgLock c) (app os1 nil)) s')\n                      (app ws1 nil)\n               | Server =>\n                   fun s : Data => pair (pair (pair Nop nil) s) nil\n               end\n           | Unlock =>\n               fun s : Data =>\n               let\n               'pair (pair (pair _ os1) s') ws1 :=\n                match queue st with\n                | cons _ (cons x xs) =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt (app nil nil))\n                         {| queue := cons x xs; held := held st |})\n                      (app nil (cons (pair (Client x) Locked) nil))\n                | _ =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt nil)\n                         {| queue := nil; held := held st |}) nil\n                end s in\n                pair (pair (pair MsgUnlock (app os1 nil)) s')\n                  (app ws1 nil)\n           | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n           end st in\n           pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n         (pair (pair (pair u out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))",
                    "H : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    match m with\n    | Lock =>\n        match src with\n        | Client c =>\n            fun s : Data =>\n            let\n            'pair (pair (pair _ os1) s') ws1 :=\n             let\n             'pair (pair (pair _ os1) _) ws1 :=\n              (if null (queue st)\n               then\n                fun s0 : Data =>\n                pair (pair (pair tt (app nil nil)) s0)\n                  (app (cons (pair src Locked) nil) nil)\n               else fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                s in\n              pair\n                (pair (pair tt (app os1 nil))\n                   {|\n                     queue := app (queue st) (cons c nil);\n                     held := held st\n                   |}) (app ws1 nil) in\n             pair (pair (pair (MsgLock c) (app os1 nil)) s')\n               (app ws1 nil)\n        | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n        end\n    | Unlock =>\n        fun s : Data =>\n        let\n        'pair (pair (pair _ os1) s') ws1 :=\n         match queue st with\n         | cons _ (cons x xs) =>\n             fun _ : Data =>\n             pair\n               (pair (pair tt (app nil nil))\n                  {| queue := cons x xs; held := held st |})\n               (app nil (cons (pair (Client x) Locked) nil))\n         | _ =>\n             fun _ : Data =>\n             pair\n               (pair (pair tt nil) {| queue := nil; held := held st |})\n               nil\n         end s in\n         pair (pair (pair MsgUnlock (app os1 nil)) s') (app ws1 nil)\n    | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n    end st in pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair u out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "u : Label",
                    "st : Data",
                    "m : Msg",
                    "src : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq m Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Lock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Lock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Lock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq (queue st') (app nil (cons c nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl nil))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq (queue st') (app (cons c nil) (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq ms (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl (cons c nil)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue st')\n                    (app (cons c (cons c0 l5)) (cons c1 nil)))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq ms (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl (cons c (cons c0 l5))))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Locked Unlock))))))",
                    "H : eq (pair (pair (pair l0 (app nil l1)) d) (app nil l))\n  (pair (pair (pair u out) st') ms)",
                    "Heqp : eq (pair (pair (pair (MsgLock c) (app l3 nil)) d0) (app l2 nil))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app l5 nil))\n        {| queue := app (queue st) (cons c nil); held := held st |})\n     (app l4 nil)) (pair (pair (pair u0 l3) d0) l2)",
                    "Heqp5 : eq\n  (pair (pair (pair tt (app nil nil)) st)\n     (app (cons (pair (Client c) Locked) nil) nil))\n  (pair (pair (pair u1 l5) d1) l4)",
                    "Heqb : eq (null (queue st)) true",
                    "Heqp6 : eq p3 (pair (pair u1 l5) d1)",
                    "Heqp7 : eq p4 (pair u1 l5)",
                    "l5 : list Output",
                    "u1 : unit",
                    "d1 : Data",
                    "p4 : prod unit (list Output)",
                    "l4 : list (prod Name Msg)",
                    "p3 : prod (prod unit (list Output)) Data",
                    "Heqp3 : eq p1 (pair (pair u0 l3) d0)",
                    "Heqp4 : eq p2 (pair u0 l3)",
                    "l3 : list Output",
                    "u0 : unit",
                    "d0 : Data",
                    "p2 : prod unit (list Output)",
                    "l2 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqn : eq src (Client c)",
                    "c : Client_index",
                    "Heqm0 : eq m Lock",
                    "Heqp0 : eq p (pair (pair l0 l1) d)",
                    "Heqp1 : eq p0 (pair l0 l1)",
                    "l1 : list Output",
                    "l0 : Label",
                    "d : Data",
                    "p0 : prod Label (list Output)",
                    "l : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqp5 : eq (pair (pair (pair tt nil) st) nil) (pair (pair (pair u1 l5) d1) l4)",
                    "Heqb : eq (null (queue st)) false",
                    "Heqp : eq (pair (pair (pair Nop nil) st) nil) (pair (pair (pair l0 l1) d) l)",
                    "Heqn : eq src Server",
                    "Heqp : eq (pair (pair (pair MsgUnlock (app l3 nil)) d0) (app l2 nil))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp2 : eq (pair (pair (pair tt nil) {| queue := nil; held := held st |}) nil)\n  (pair (pair (pair u0 l3) d0) l2)",
                    "Heql4 : eq (queue st) nil",
                    "Heqm0 : eq m Unlock",
                    "Heql4 : eq (queue st) (cons c nil)",
                    "Heql5 : eq l4 nil",
                    "l4 : list Client_index",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app nil nil))\n        {| queue := cons c0 l5; held := held st |})\n     (app nil (cons (pair (Client c0) Locked) nil)))\n  (pair (pair (pair u0 l3) d0) l2)",
                    "Heql4 : eq (queue st) (cons c (cons c0 l5))",
                    "Heql5 : eq l4 (cons c0 l5)",
                    "l5 : list Client_index",
                    "c0 : Client_index",
                    "Heqm0 : eq m Locked"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))",
                    "Heqb : eq (null (queue d1)) true"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq (app (app nil nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq (app (app nil nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil) (eq (app (app nil nil) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq (app (app nil nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app (app nil nil) nil) nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))",
                    "Heqb : eq (null (queue d1)) false"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq (queue st') (app nil (cons c nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl nil))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (app nil (cons c nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq (app nil nil)\n                          (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq (app nil nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := nil; held := held st |})\n                 (List.tl nil))\n              (or\n                 (and\n                    (eq (queue {| queue := nil; held := held st |}) nil)\n                    (eq (app nil nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue {| queue := nil; held := held st |})\n                             (cons next t))\n                          (eq (app nil nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq (queue st') (app (cons c nil) (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq ms (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl (cons c nil)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (app (cons c nil) (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq (app nil nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil))\n                       (eq (app nil nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := nil; held := held st |})\n                 (List.tl (cons c nil)))\n              (or\n                 (and\n                    (eq (queue {| queue := nil; held := held st |}) nil)\n                    (eq (app nil nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue {| queue := nil; held := held st |})\n                             (cons next t))\n                          (eq (app nil nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue st')\n                    (app (cons c (cons c0 l5)) (cons c1 nil)))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq ms (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq ms nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (queue st') (List.tl (cons c (cons c0 l5))))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := cons c0 l5; held := held st |})\n                    (app (cons c (cons c0 l5)) (cons c1 nil)))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := cons c0 l5; held := held st |})\n                 (List.tl (cons c (cons c0 l5))))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {| queue := cons c0 l5; held := held st |})\n                       nil)\n                    (eq (app (cons (pair (Client c0) Locked) nil) nil)\n                       nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := cons c0 l5; held := held st\n                                |}) (cons next t))\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app (cons (pair (Client c0) Locked) nil) nil) nil)\n           (and (eq {| queue := cons c0 l5; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st) (cons c nil)))\n                 (or\n                    (and (eq (queue st) nil)\n                       (eq ms (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st) nil)) (eq ms nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st)))\n              (or (and (eq (queue st') nil) (eq ms nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq ms (cons (pair (Client next) Locked) nil))))))))\n        (and (eq ms nil) (and (eq st' st) (not (eq Locked Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Locked Unlock))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp null_sound .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp null_sound .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqb : eq (queue d1) nil"
                ]
            },
            {
                "tactic_sig": "find_rewrite .",
                "tactic_sig_no_out_arg": "find_rewrite .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app nil (cons c nil); held := held d1\n                       |}) (app nil (cons c0 nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq nil nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app nil (cons c nil); held := held d1\n                    |}) (List.tl nil))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app nil (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app nil (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq {| queue := app nil (cons c nil); held := held d1 |}\n                 d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app nil (cons c nil); held := held d1\n                       |}) (app nil (cons c0 nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq nil nil))\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app nil (cons c nil); held := held d1\n                    |}) (List.tl nil))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app nil (cons c nil);\n                            held := held d1\n                          |}) nil)\n                    (eq\n                       (app\n                          (app (cons (pair (Client c) Locked) nil) nil)\n                          nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app nil (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq {| queue := app nil (cons c nil); held := held d1 |}\n                 d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (cons c nil) (cons c0 nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq nil nil))\n                       (eq (cons (pair (Client c) Locked) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (cons c nil) nil)\n              (or\n                 (and (eq (cons c nil) nil)\n                    (eq (cons (pair (Client c) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c nil) (cons next t))\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (cons (pair (Client c) Locked) nil) nil)\n           (and (eq {| queue := cons c nil; held := held d1 |} d1)\n              (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (cons c nil) (cons c0 nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq nil nil))\n                       (eq (cons (pair (Client c) Locked) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (cons c nil) nil)\n              (or\n                 (and (eq (cons c nil) nil)\n                    (eq (cons (pair (Client c) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c nil) (cons next t))\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (cons (pair (Client c) Locked) nil) nil)\n           (and (eq {| queue := cons c nil; held := held d1 |} d1)\n              (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (cons c nil) (cons c0 nil))\n              (or\n                 (and (eq nil nil)\n                    (eq (cons (pair (Client c) Locked) nil)\n                       (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq nil nil, False)\n                    (eq (cons (pair (Client c) Locked) nil) nil)))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (cons c nil) nil)\n           (or\n              (and (eq (cons c nil) nil)\n                 (eq (cons (pair (Client c) Locked) nil) nil))\n              (ex\n                 (fun next : Client_index =>\n                  ex\n                    (fun t : list Client_index =>\n                     and (eq (cons c nil) (cons next t))\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client next) Locked) nil))))))))\n     (and (eq (cons (pair (Client c) Locked) nil) nil)\n        (and (eq {| queue := cons c nil; held := held d1 |} d1)\n           (forall _ : eq Lock Unlock, False))))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (cons c nil) (cons c0 nil))\n              (or\n                 (and (eq nil nil)\n                    (eq (cons (pair (Client c) Locked) nil)\n                       (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq nil nil, False)\n                    (eq (cons (pair (Client c) Locked) nil) nil)))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (cons c nil) nil)\n           (or\n              (and (eq (cons c nil) nil)\n                 (eq (cons (pair (Client c) Locked) nil) nil))\n              (ex\n                 (fun next : Client_index =>\n                  ex\n                    (fun t : list Client_index =>\n                     and (eq (cons c nil) (cons next t))\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client next) Locked) nil))))))))\n     (and (eq (cons (pair (Client c) Locked) nil) nil)\n        (and (eq {| queue := cons c nil; held := held d1 |} d1)\n           (forall _ : eq Lock Unlock, False))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (cons c nil) (cons c0 nil))\n           (or\n              (and (eq nil nil)\n                 (eq (cons (pair (Client c) Locked) nil)\n                    (cons (pair (Client c0) Locked) nil)))\n              (and (forall _ : eq nil nil, False)\n                 (eq (cons (pair (Client c) Locked) nil) nil))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (cons c nil) (cons c0 nil))\n           (or\n              (and (eq nil nil)\n                 (eq (cons (pair (Client c) Locked) nil)\n                    (cons (pair (Client c0) Locked) nil)))\n              (and (forall _ : eq nil nil, False)\n                 (eq (cons (pair (Client c) Locked) nil) nil))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (cons c nil) (cons ?c nil))\n        (or\n           (and (eq nil nil)\n              (eq (cons (pair (Client c) Locked) nil)\n                 (cons (pair (Client ?c) Locked) nil)))\n           (and (forall _ : eq nil nil, False)\n              (eq (cons (pair (Client c) Locked) nil) nil)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (cons c nil) (cons ?c nil))\n        (or\n           (and (eq nil nil)\n              (eq (cons (pair (Client c) Locked) nil)\n                 (cons (pair (Client ?c) Locked) nil)))\n           (and (forall _ : eq nil nil, False)\n              (eq (cons (pair (Client c) Locked) nil) nil)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq (app (app nil nil) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil))\n                       (eq (app (app nil nil) nil) nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and\n              (eq\n                 (queue\n                    {|\n                      queue := app (queue d1) (cons c nil);\n                      held := held d1\n                    |}) (List.tl (queue d1)))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) nil) (eq (app (app nil nil) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := app (queue d1) (cons c nil);\n                                  held := held d1\n                                |}) (cons next t))\n                          (eq (app (app nil nil) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app (app nil nil) nil) nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq (app (queue d1) (cons c nil))\n                    (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n              (or\n                 (and (eq (app (queue d1) (cons c nil)) nil)\n                    (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq (app (queue d1) (cons c nil))\n                             (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp null_false_neq_nil .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp null_false_neq_nil .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqb : not (eq (queue d1) nil)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and\n                 (eq (app (queue d1) (cons c nil))\n                    (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (queue d1) nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n              (or\n                 (and (eq (app (queue d1) (cons c nil)) nil)\n                    (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq (app (queue d1) (cons c nil))\n                             (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and\n              (eq (app (queue d1) (cons c nil))\n                 (app (queue d1) (cons c0 nil)))\n              (or\n                 (and (eq (queue d1) nil)\n                    (eq nil (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq (queue d1) nil, False)\n                    (eq nil nil)))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n           (or\n              (and (eq (app (queue d1) (cons c nil)) nil) (eq nil nil))\n              (ex\n                 (fun next : Client_index =>\n                  ex\n                    (fun t : list Client_index =>\n                     and\n                       (eq (app (queue d1) (cons c nil)) (cons next t))\n                       (eq nil (cons (pair (Client next) Locked) nil))))))))\n     (and (eq nil nil)\n        (and\n           (eq\n              {|\n                queue := app (queue d1) (cons c nil); held := held d1\n              |} d1) (forall _ : eq Lock Unlock, False))))",
                    "Heqb : forall _ : eq (queue d1) nil, False"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and\n              (eq (app (queue d1) (cons c nil))\n                 (app (queue d1) (cons c0 nil)))\n              (or\n                 (and (eq (queue d1) nil)\n                    (eq nil (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq (queue d1) nil, False)\n                    (eq nil nil)))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n           (or\n              (and (eq (app (queue d1) (cons c nil)) nil) (eq nil nil))\n              (ex\n                 (fun next : Client_index =>\n                  ex\n                    (fun t : list Client_index =>\n                     and\n                       (eq (app (queue d1) (cons c nil)) (cons next t))\n                       (eq nil (cons (pair (Client next) Locked) nil))))))))\n     (and (eq nil nil)\n        (and\n           (eq\n              {|\n                queue := app (queue d1) (cons c nil); held := held d1\n              |} d1) (forall _ : eq Lock Unlock, False))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and\n           (eq (app (queue d1) (cons c nil))\n              (app (queue d1) (cons c0 nil)))\n           (or\n              (and (eq (queue d1) nil)\n                 (eq nil (cons (pair (Client c0) Locked) nil)))\n              (and (forall _ : eq (queue d1) nil, False) (eq nil nil))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and\n           (eq (app (queue d1) (cons c nil))\n              (app (queue d1) (cons c0 nil)))\n           (or\n              (and (eq (queue d1) nil)\n                 (eq nil (cons (pair (Client c0) Locked) nil)))\n              (and (forall _ : eq (queue d1) nil, False) (eq nil nil))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and\n        (eq (app (queue d1) (cons c nil))\n           (app (queue d1) (cons ?c nil)))\n        (or\n           (and (eq (queue d1) nil)\n              (eq nil (cons (pair (Client ?c) Locked) nil)))\n           (and (forall _ : eq (queue d1) nil, False) (eq nil nil)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and\n        (eq (app (queue d1) (cons c nil))\n           (app (queue d1) (cons ?c nil)))\n        (or\n           (and (eq (queue d1) nil)\n              (eq nil (cons (pair (Client ?c) Locked) nil)))\n           (and (forall _ : eq (queue d1) nil, False) (eq nil nil)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Lock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Lock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Lock Unlock))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (app nil (cons c nil)))\n                 (or\n                    (and (eq nil nil)\n                       (eq (app nil nil)\n                          (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq (app nil nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := nil; held := held st |})\n                 (List.tl nil))\n              (or\n                 (and\n                    (eq (queue {| queue := nil; held := held st |}) nil)\n                    (eq (app nil nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue {| queue := nil; held := held st |})\n                             (cons next t))\n                          (eq (app nil nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))",
                    "st : Data"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := nil;\n                   held := held {| queue := queue0; held := held0 |}\n                 |} {| queue := queue0; held := held0 |})\n              (not (eq Unlock Unlock))))))",
                    "Heql4 : eq (queue {| queue := queue0; held := held0 |}) nil",
                    "held0 : bool",
                    "queue0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := nil;\n                   held := held {| queue := queue0; held := held0 |}\n                 |} {| queue := queue0; held := held0 |})\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := queue0; held := held0 |})\n              (not (eq Unlock Unlock))))))",
                    "Heql4 : eq queue0 nil"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := queue0; held := held0 |})\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := nil; held := held0 |})\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq nil nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := nil; held := held0 |})\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (app (cons c nil) (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq (app nil nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil))\n                       (eq (app nil nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := nil; held := held st |})\n                 (List.tl (cons c nil)))\n              (or\n                 (and\n                    (eq (queue {| queue := nil; held := held st |}) nil)\n                    (eq (app nil nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue {| queue := nil; held := held st |})\n                             (cons next t))\n                          (eq (app nil nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq nil (cons c (cons c0 nil)))\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (not (eq (cons c nil) nil)) (eq nil nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (or (and (eq nil nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq nil (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (queue {| queue := cons c0 l5; held := held st |})\n                    (app (cons c (cons c0 l5)) (cons c1 nil)))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and\n              (eq (queue {| queue := cons c0 l5; held := held st |})\n                 (List.tl (cons c (cons c0 l5))))\n              (or\n                 (and\n                    (eq\n                       (queue\n                          {| queue := cons c0 l5; held := held st |})\n                       nil)\n                    (eq (app (cons (pair (Client c0) Locked) nil) nil)\n                       nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq\n                             (queue\n                                {|\n                                  queue := cons c0 l5; held := held st\n                                |}) (cons next t))\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (app (cons (pair (Client c0) Locked) nil) nil) nil)\n           (and (eq {| queue := cons c0 l5; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (cons c0 l5)\n                    (cons c (cons c0 (app l5 (cons c1 nil)))))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq (cons (pair (Client c0) Locked) nil)\n                          (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq (cons (pair (Client c0) Locked) nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (cons c0 l5) (cons c0 l5))\n              (or\n                 (and (eq (cons c0 l5) nil)\n                    (eq (cons (pair (Client c0) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c0 l5) (cons next t))\n                          (eq (cons (pair (Client c0) Locked) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (cons (pair (Client c0) Locked) nil) nil)\n           (and (eq {| queue := cons c0 l5; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition eauto .",
                "tactic_sig_no_out_arg": "intuition eauto .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and\n                 (eq (cons c0 l5)\n                    (cons c (cons c0 (app l5 (cons c1 nil)))))\n                 (or\n                    (and (eq (cons c (cons c0 l5)) nil)\n                       (eq (cons (pair (Client c0) Locked) nil)\n                          (cons (pair (Client c1) Locked) nil)))\n                    (and (not (eq (cons c (cons c0 l5)) nil))\n                       (eq (cons (pair (Client c0) Locked) nil) nil)))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq (cons c0 l5) (cons c0 l5))\n              (or\n                 (and (eq (cons c0 l5) nil)\n                    (eq (cons (pair (Client c0) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c0 l5) (cons next t))\n                          (eq (cons (pair (Client c0) Locked) nil)\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq (cons (pair (Client c0) Locked) nil) nil)\n           (and (eq {| queue := cons c0 l5; held := held st |} st)\n              (not (eq Unlock Unlock))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Locked Unlock))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Locked Unlock))))))"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; congruence ) .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq (queue st') (app (queue st') (cons c nil)))\n                 (or\n                    (and (eq (queue st') nil)\n                       (eq nil (cons (pair (Client c) Locked) nil)))\n                    (and (not (eq (queue st') nil)) (eq nil nil)))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq (queue st') (List.tl (queue st')))\n              (or (and (eq (queue st') nil) (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue st') (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil))))))))\n        (and (eq nil nil) (and (eq st' st') (not (eq Locked Unlock))))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "at_head_of_queue_intro",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (t : list Client_index) (_ : eq (queue (sigma Server)) (cons c t)),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (t : list Client_index) (_ : eq (queue (sigma Server)) (cons c t)),\nat_head_of_queue sigma c"
                ]
            },
            {
                "tactic_sig": "unfold at_head_of_queue .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (t : list Client_index) (_ : eq (queue (sigma Server)) (cons c t)),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (t : list Client_index) (_ : eq (queue (sigma Server)) (cons c t)),\nex\n  (fun t0 : list Client_index => eq (queue (sigma Server)) (cons c t0))"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (t : list Client_index) (_ : eq (queue (sigma Server)) (cons c t)),\nex\n  (fun t0 : list Client_index => eq (queue (sigma Server)) (cons c t0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_update_true",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index) \n  (st' : Data) (_ : eq (held st') true) (_ : at_head_of_queue sigma c)\n  (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma (Client c) st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index) \n  (st' : Data) (_ : eq (held st') true) (_ : at_head_of_queue sigma c)\n  (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma (Client c) st')"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct .",
                "tactic_sig_no_out_arg": "unfold locks_correct .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index) \n  (st' : Data) (_ : eq (held st') true) (_ : at_head_of_queue sigma c)\n  (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma (Client c) st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index) \n  (st' : Data) (_ : eq (held st') true) (_ : at_head_of_queue sigma c)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t))) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma (Client c) st' (Client n)))\n         true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client c) st' Server))\n     (cons n t))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index) \n  (st' : Data) (_ : eq (held st') true) (_ : at_head_of_queue sigma c)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t))) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma (Client c) st' (Client n)))\n         true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client c) st' Server))\n     (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client c) st' Server))\n     (cons n t))",
                    "H2 : eq (held (update name_eq_dec sigma (Client c) st' (Client n))) true",
                    "n : Client_index",
                    "H1 : forall (n : Client_index) (_ : eq (held (sigma (Client n))) true),\nex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H0 : at_head_of_queue sigma c",
                    "H : eq (held st') true",
                    "st' : Data",
                    "c : Client_index",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "destruct ( Name_eq_dec ( Client _i ) ( Client _i ) ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( Name_eq_dec ( Client _i ) ( Client _i ) ) .",
                "tactic_args": [
                    "c : Client_index",
                    "n : Client_index"
                ],
                "tactic_res": [
                    "e : eq (Client c) (Client n)",
                    "n0 : not (eq (Client c) (Client n))"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H2 : eq (held st') true"
                ]
            },
            {
                "tactic_sig": "try find_inversion .",
                "tactic_sig_no_out_arg": "try find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : at_head_of_queue sigma n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client c) st' Server))\n     (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H2 : eq (held (sigma (Client n))) true"
                ]
            },
            {
                "tactic_sig": "try find_inversion .",
                "tactic_sig_no_out_arg": "try find_inversion .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_at_head",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pDst p) (Client c))\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pDst p) (Client c))\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p),\nat_head_of_queue sigma c"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_locked .",
                "tactic_sig_no_out_arg": "unfold locks_correct_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pDst p) (Client c))\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pDst p) (Client c))\n  (_ : eq (pBody p) Locked)\n  (_ : forall _ : eq (pBody p) Locked,\n       ex\n         (fun c0 : Client_index =>\n          valid_locked (queue (sigma Server))\n            (held (sigma (Client c0))) c0 p)), at_head_of_queue sigma c"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pDst p) (Client c))\n  (_ : eq (pBody p) Locked)\n  (_ : forall _ : eq (pBody p) Locked,\n       ex\n         (fun c0 : Client_index =>\n          valid_locked (queue (sigma Server))\n            (held (sigma (Client c0))) c0 p)), at_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : at_head_of_queue sigma c",
                    "H2 : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index",
                    "H3 : eq (held (sigma (Client x))) false",
                    "H1 : eq (pDst p) (Client x)",
                    "x : Client_index",
                    "H0 : eq (pBody p) Locked",
                    "H : eq (pDst p) (Client c)",
                    "c : Client_index",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (Client c) (Client x)",
                    "H : eq (pDst p) (Client x)"
                ]
            },
            {
                "tactic_sig": "find_inversion .",
                "tactic_sig_no_out_arg": "find_inversion .",
                "tactic_args": [
                    "_goal : at_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : at_head_of_queue sigma x"
                ]
            },
            {
                "tactic_sig": "eauto using at_head_of_queue_intro .",
                "tactic_sig_no_out_arg": "eauto using at_head_of_queue_intro .",
                "tactic_args": [
                    "_goal : at_head_of_queue sigma x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "all_clients_false_locks_correct_server_update",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st : Data)\n  (_ : forall c : Client_index, eq (held (sigma (Client c))) false),\nlocks_correct (update name_eq_dec sigma Server st)"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st : Data)\n  (_ : forall c : Client_index, eq (held (sigma (Client c))) false),\nlocks_correct (update name_eq_dec sigma Server st)"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct .",
                "tactic_sig_no_out_arg": "unfold locks_correct .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st : Data)\n  (_ : forall c : Client_index, eq (held (sigma (Client c))) false),\nlocks_correct (update name_eq_dec sigma Server st)"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st : Data)\n  (_ : forall c : Client_index, eq (held (sigma (Client c))) false)\n  (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma Server st (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st Server)) (cons n t))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st : Data)\n  (_ : forall c : Client_index, eq (held (sigma (Client c))) false)\n  (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma Server st (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st Server)) (cons n t))",
                    "H0 : eq (held (update name_eq_dec sigma Server st (Client n))) true",
                    "n : Client_index",
                    "H : forall c : Client_index, eq (held (sigma (Client c))) false",
                    "st : Data",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "H0 : eq (held (sigma (Client n))) true"
                ]
            },
            {
                "tactic_sig": "now find_higher_order_rewrite .",
                "tactic_sig_no_out_arg": "now find_higher_order_rewrite .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_true_at_head_of_queue",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (x : Client_index)\n  (_ : locks_correct sigma) (_ : eq (held (sigma (Client x))) true),\nat_head_of_queue sigma x"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (x : Client_index)\n  (_ : locks_correct sigma) (_ : eq (held (sigma (Client x))) true),\nat_head_of_queue sigma x"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct .",
                "tactic_sig_no_out_arg": "unfold locks_correct .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (x : Client_index)\n  (_ : locks_correct sigma) (_ : eq (held (sigma (Client x))) true),\nat_head_of_queue sigma x"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (x : Client_index)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : eq (held (sigma (Client x))) true), at_head_of_queue sigma x"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (x : Client_index)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : eq (held (sigma (Client x))) true), at_head_of_queue sigma x"
                ],
                "tactic_res": [
                    "_goal : at_head_of_queue sigma x",
                    "H0 : eq (held (sigma (Client x))) true",
                    "H : forall (n : Client_index) (_ : eq (held (sigma (Client n))) true),\nex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "x : Client_index",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "find_apply_hyp_hyp .",
                "tactic_sig_no_out_arg": "find_apply_hyp_hyp .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "eauto using at_head_of_queue_intro .",
                "tactic_sig_no_out_arg": "eauto using at_head_of_queue_intro .",
                "tactic_args": [
                    "_goal : at_head_of_queue sigma x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "at_head_of_nil",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (_ : at_head_of_queue sigma c) (_ : eq (queue (sigma Server)) nil),\nFalse"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (_ : at_head_of_queue sigma c) (_ : eq (queue (sigma Server)) nil),\nFalse"
                ]
            },
            {
                "tactic_sig": "unfold at_head_of_queue .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (_ : at_head_of_queue sigma c) (_ : eq (queue (sigma Server)) nil),\nFalse"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t)))\n  (_ : eq (queue (sigma Server)) nil), False"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t)))\n  (_ : eq (queue (sigma Server)) nil), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq (queue (sigma Server)) (cons c x)",
                    "x : list Client_index",
                    "H0 : eq (queue (sigma Server)) nil",
                    "c : Client_index",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "empty_queue_all_clients_false",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma)\n  (_ : eq (queue (sigma Server)) nil) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma)\n  (_ : eq (queue (sigma Server)) nil) (c : Client_index),\neq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (_ : locks_correct sigma)\n  (_ : eq (queue (sigma Server)) nil) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "c : Client_index",
                    "H0 : eq (queue (sigma Server)) nil",
                    "H : locks_correct sigma",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "destruct ( held ( _i ( Client _i ) ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( held ( _i ( Client _i ) ) ) eqn : ? .",
                "tactic_args": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "sigma : forall _ : name, data",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "_goal : eq true false",
                    "_goal : eq false false",
                    "Heqb : eq (held (sigma (Client c))) true",
                    "Heqb : eq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "eauto using at_head_of_nil , locks_correct_true_at_head_of_queue .",
                "tactic_sig_no_out_arg": "eauto using at_head_of_nil , locks_correct_true_at_head_of_queue .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "unlock_in_flight_all_clients_false",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "c : Client_index",
                    "H1 : locks_correct sigma",
                    "H0 : locks_correct_unlock sigma p",
                    "H : eq (pBody p) Unlock",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "destruct ( held ( _i ( Client _i ) ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( held ( _i ( Client _i ) ) ) eqn : ? .",
                "tactic_args": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "sigma : forall _ : name, data",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "_goal : eq true false",
                    "_goal : eq false false",
                    "Heqb : eq (held (sigma (Client c))) true",
                    "Heqb : eq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index",
                    "H3 : eq (held (sigma (Client x))) false",
                    "H0 : eq (pSrc p) (Client x)",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "find_copy_apply_lem_hyp locks_correct_true_at_head_of_queue .",
                "tactic_sig_no_out_arg": "find_copy_apply_lem_hyp locks_correct_true_at_head_of_queue .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : locks_correct sigma",
                    "H4 : at_head_of_queue sigma c",
                    "H4 : eq (held (sigma (Client c))) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : locks_correct sigma"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold at_head_of_queue in * .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons c t))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (queue (sigma Server)) (cons c x1)",
                    "x1 : list Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_at_head_preserved",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data)\n  (_ : locks_correct sigma)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct (update name_eq_dec sigma Server st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data)\n  (_ : locks_correct sigma)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct (update name_eq_dec sigma Server st')"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct , at_head_of_queue .",
                "tactic_sig_no_out_arg": "unfold locks_correct , at_head_of_queue .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data)\n  (_ : locks_correct sigma)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct (update name_eq_dec sigma Server st')"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : forall (c : Client_index)\n         (_ : ex\n                (fun t : list Client_index =>\n                 eq (queue (sigma Server)) (cons c t))),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (update name_eq_dec sigma Server st' Server))\n            (cons c t))) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma Server st' (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons n t))"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data)\n  (_ : forall (n : Client_index)\n         (_ : eq (held (sigma (Client n))) true),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons n t)))\n  (_ : forall (c : Client_index)\n         (_ : ex\n                (fun t : list Client_index =>\n                 eq (queue (sigma Server)) (cons c t))),\n       ex\n         (fun t : list Client_index =>\n          eq (queue (update name_eq_dec sigma Server st' Server))\n            (cons c t))) (n : Client_index)\n  (_ : eq (held (update name_eq_dec sigma Server st' (Client n))) true),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons n t))",
                    "H1 : eq (held (update name_eq_dec sigma Server st' (Client n))) true",
                    "n : Client_index",
                    "H0 : forall (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))",
                    "H : forall (n : Client_index) (_ : eq (held (sigma (Client n))) true),\nex (fun t : list Client_index => eq (queue (sigma Server)) (cons n t))",
                    "st' : data",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons n t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue st') (cons n t))",
                    "H1 : eq (held (sigma (Client n))) true",
                    "H0 : forall (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex (fun t : list Client_index => eq (queue st') (cons c t))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue st') (cons n t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "snoc_at_head_of_queue_preserved",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (x : Client_index)\n  (_ : eq (queue st') (app (queue (sigma Server)) (cons x nil)))\n  (c : Client_index) (_ : at_head_of_queue sigma c),\nat_head_of_queue (update name_eq_dec sigma Server st') c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (x : Client_index)\n  (_ : eq (queue st') (app (queue (sigma Server)) (cons x nil)))\n  (c : Client_index) (_ : at_head_of_queue sigma c),\nat_head_of_queue (update name_eq_dec sigma Server st') c"
                ]
            },
            {
                "tactic_sig": "unfold at_head_of_queue .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (x : Client_index)\n  (_ : eq (queue st') (app (queue (sigma Server)) (cons x nil)))\n  (c : Client_index) (_ : at_head_of_queue sigma c),\nat_head_of_queue (update name_eq_dec sigma Server st') c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (x : Client_index)\n  (_ : eq (queue st') (app (queue (sigma Server)) (cons x nil)))\n  (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (x : Client_index)\n  (_ : eq (queue st') (app (queue (sigma Server)) (cons x nil)))\n  (c : Client_index)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))",
                    "H0 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons c t))",
                    "c : Client_index",
                    "H : eq (queue st') (app (queue (sigma Server)) (cons x nil))",
                    "x : Client_index",
                    "st' : Data",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (queue (sigma Server)) (cons c x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue st') (cons c t))"
                ]
            },
            {
                "tactic_sig": "find_rewrite .",
                "tactic_sig_no_out_arg": "find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (queue st') (app (cons c x0) (cons x nil))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue st') (cons c t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_net_handlers",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p) (_ : locks_correct_locked sigma p),\nlocks_correct (update name_eq_dec sigma (pDst p) st')"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p) (_ : locks_correct_locked sigma p),\nlocks_correct (update name_eq_dec sigma (pDst p) st')"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p) (_ : locks_correct_locked sigma p),\nlocks_correct (update name_eq_dec sigma (pDst p) st')"
                ],
                "tactic_res": [
                    "_goal : locks_correct (update Name_eq_dec sigma (Client c) st')",
                    "_goal : locks_correct (update Name_eq_dec sigma Server st')",
                    "_goal : locks_correct (update Name_eq_dec sigma Server st')",
                    "_goal : locks_correct (update Name_eq_dec sigma Server st')",
                    "_goal : locks_correct (update Name_eq_dec sigma Server st')",
                    "H6 : eq (held st') true",
                    "H4 : eq (pBody p) Locked",
                    "H2 : locks_correct_locked sigma p",
                    "H1 : locks_correct_unlock sigma p",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) (Client c)",
                    "c : Client_index",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H7 : eq (queue (sigma Server)) nil",
                    "H5 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H4 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "Heqn : eq (pDst p) Server",
                    "H7 : forall _ : eq (queue (sigma Server)) nil, False",
                    "H5 : eq (queue st') (app (queue (sigma Server)) (cons x nil))",
                    "H6 : eq (List.tl (queue (sigma Server))) nil",
                    "H4 : eq (queue st') nil",
                    "H : eq (pBody p) Unlock",
                    "H6 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H4 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_args": [
                    "_goal : locks_correct (update Name_eq_dec sigma (Client c) st')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_update_true , locks_correct_locked_at_head , all_clients_false_locks_correct_server_update , empty_queue_all_clients_false , locks_correct_at_head_preserved , snoc_at_head_of_queue_preserved , all_clients_false_locks_correct_server_update , unlock_in_flight_all_clients_false .",
                "tactic_args": [
                    "_goal : locks_correct (update Name_eq_dec sigma Server st')"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_sent_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_unlock sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_unlock sigma p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_unlock .",
                "tactic_sig_no_out_arg": "unfold locks_correct_unlock .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_unlock sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock) (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock) (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)",
                    "H0 : eq (pBody p) Unlock",
                    "H : eq (pBody p) Lock",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_sent_locked",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked), locks_correct_unlock sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked), locks_correct_unlock sigma p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_unlock .",
                "tactic_sig_no_out_arg": "unfold locks_correct_unlock .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked), locks_correct_unlock sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked) (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked) (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)",
                    "H0 : eq (pBody p) Unlock",
                    "H : eq (pBody p) Locked",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_input_handlers_old",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client x) st') p",
                    "H6 : eq (held (sigma (Client x))) true",
                    "H4 : eq (held st') false",
                    "x : Client_index",
                    "H1 : locks_correct_unlock sigma p",
                    "H0 : locks_correct sigma",
                    "p : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "destruct ( pBody _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) eqn : ? .",
                "tactic_args": [
                    "p : packet"
                ],
                "tactic_res": [
                    "Heqm : eq (pBody p) Lock",
                    "Heqm : eq (pBody p) Unlock",
                    "Heqm : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_lock .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_lock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "now erewrite unlock_in_flight_all_clients_false in * by eauto .",
                "tactic_sig_no_out_arg": "now erewrite unlock_in_flight_all_clients_false in * by eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_locked .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_locked .",
                "tactic_args": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locked_in_flight_all_clients_false",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Locked) (_ : locks_correct_locked sigma p)\n  (_ : locks_correct sigma) (c : Client_index),\neq (held (sigma (Client c))) false"
                ],
                "tactic_res": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "c : Client_index",
                    "H1 : locks_correct sigma",
                    "H0 : locks_correct_locked sigma p",
                    "H : eq (pBody p) Locked",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "destruct ( held ( _i ( Client _i ) ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( held ( _i ( Client _i ) ) ) eqn : ? .",
                "tactic_args": [
                    "_goal : eq (held (sigma (Client c))) false",
                    "sigma : forall _ : name, data",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "_goal : eq true false",
                    "_goal : eq false false",
                    "Heqb : eq (held (sigma (Client c))) true",
                    "Heqb : eq (held (sigma (Client c))) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index",
                    "H3 : eq (held (sigma (Client x))) false",
                    "H0 : eq (pDst p) (Client x)",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "find_copy_apply_lem_hyp locks_correct_true_at_head_of_queue .",
                "tactic_sig_no_out_arg": "find_copy_apply_lem_hyp locks_correct_true_at_head_of_queue .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : locks_correct sigma",
                    "H4 : at_head_of_queue sigma c",
                    "H4 : eq (held (sigma (Client c))) true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": [
                    "_goal : eq true false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : locks_correct sigma"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold at_head_of_queue in * .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons c t))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (queue (sigma Server)) (cons c x1)",
                    "x1 : list Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq true false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_sent_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_locked sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_locked sigma p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_locked .",
                "tactic_sig_no_out_arg": "unfold locks_correct_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock), locks_correct_locked sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock) (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Lock) (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)",
                    "H0 : eq (pBody p) Locked",
                    "H : eq (pBody p) Lock",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_sent_unlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock), locks_correct_locked sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock), locks_correct_locked sigma p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_locked .",
                "tactic_sig_no_out_arg": "unfold locks_correct_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock), locks_correct_locked sigma p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock) (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : eq (pBody p) Unlock) (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)",
                    "H0 : eq (pBody p) Locked",
                    "H : eq (pBody p) Unlock",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   valid_locked (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_input_handlers_old",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma p),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma p),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma p),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client x) st') p",
                    "H6 : eq (held (sigma (Client x))) true",
                    "H4 : eq (held st') false",
                    "x : Client_index",
                    "H1 : locks_correct_locked sigma p",
                    "H0 : locks_correct sigma",
                    "p : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "destruct ( pBody _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) eqn : ? .",
                "tactic_args": [
                    "p : packet"
                ],
                "tactic_res": [
                    "Heqm : eq (pBody p) Lock",
                    "Heqm : eq (pBody p) Unlock",
                    "Heqm : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_locked_sent_lock .",
                "tactic_sig_no_out_arg": "auto using locks_correct_locked_sent_lock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_locked_sent_unlock .",
                "tactic_sig_no_out_arg": "auto using locks_correct_locked_sent_unlock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "now erewrite locked_in_flight_all_clients_false in * by eauto .",
                "tactic_sig_no_out_arg": "now erewrite locked_in_flight_all_clients_false in * by eauto .",
                "tactic_args": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_true_to_false",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (x : Client_index) (st' : Data) (_ : at_head_of_queue sigma x)\n  (_ : eq (held st') false) (_ : eq (pSrc p) (Client x)),\nlocks_correct_unlock (update name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (x : Client_index) (st' : Data) (_ : at_head_of_queue sigma x)\n  (_ : eq (held st') false) (_ : eq (pSrc p) (Client x)),\nlocks_correct_unlock (update name_eq_dec sigma (Client x) st') p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_unlock , valid_unlock .",
                "tactic_sig_no_out_arg": "unfold locks_correct_unlock , valid_unlock .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (x : Client_index) (st' : Data) (_ : at_head_of_queue sigma x)\n  (_ : eq (held st') false) (_ : eq (pSrc p) (Client x)),\nlocks_correct_unlock (update name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (x : Client_index) (st' : Data) (_ : at_head_of_queue sigma x)\n  (_ : eq (held st') false) (_ : eq (pSrc p) (Client x))\n  (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma (Client x) st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma (Client x) st' (Client c)))\n           false)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (x : Client_index) (st' : Data) (_ : at_head_of_queue sigma x)\n  (_ : eq (held st') false) (_ : eq (pSrc p) (Client x))\n  (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma (Client x) st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma (Client x) st' (Client c)))\n           false)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma (Client x) st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma (Client x) st' (Client c)))\n           false)))",
                    "H2 : eq (pBody p) Unlock",
                    "H1 : eq (pSrc p) (Client x)",
                    "H0 : eq (held st') false",
                    "H : at_head_of_queue sigma x",
                    "st' : Data",
                    "x : Client_index",
                    "p : packet",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma (Client x) st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma (Client x) st' (Client c)))\n           false)))",
                    "x : Client_index"
                ],
                "tactic_res": [
                    "_goal : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma (Client x) st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma (Client x) st' (Client x)))\n        false))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma (Client x) st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma (Client x) st' (Client x)))\n        false))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons x t))",
                    "_goal : eq (held (update name_eq_dec sigma (Client x) st' (Client x))) false"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma (Client x) st' Server))\n     (cons x t))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq (held (update name_eq_dec sigma (Client x) st' (Client x))) false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_input_handlers_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst p) (pBody p)) ms) (_ : eq (pSrc p) h),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst p) (pBody p)) ms) (_ : eq (pSrc p) h),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst p) (pBody p)) ms) (_ : eq (pSrc p) h),\nlocks_correct_unlock (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : locks_correct_unlock\n  (update Name_eq_dec sigma (Client x) (sigma (Client x))) p",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client x) st') p",
                    "H4 : eq Lock (pBody p)",
                    "H2 : eq Server (pDst p)",
                    "H3 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "H0 : locks_correct sigma",
                    "p : packet",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "H4 : eq Unlock (pBody p)",
                    "H7 : eq (held (sigma (Client x))) true",
                    "H5 : eq (held st') false",
                    "st' : Data"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_lock , locks_correct_unlock_true_to_false , locks_correct_true_at_head_of_queue .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_lock , locks_correct_unlock_true_to_false , locks_correct_true_at_head_of_queue .",
                "tactic_args": [
                    "_goal : locks_correct_unlock\n  (update Name_eq_dec sigma (Client x) (sigma (Client x))) p"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_lock , locks_correct_unlock_true_to_false , locks_correct_true_at_head_of_queue .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_lock , locks_correct_unlock_true_to_false , locks_correct_true_at_head_of_queue .",
                "tactic_args": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_input_handlers_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms))\n  (_ : In (pair (pDst p) (pBody p)) ms),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms))\n  (_ : In (pair (pDst p) (pBody p)) ms),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms))\n  (_ : In (pair (pDst p) (pBody p)) ms),\nlocks_correct_locked (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : locks_correct_locked\n  (update Name_eq_dec sigma (Client x) (sigma (Client x))) p",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client x) st') p",
                    "H2 : eq Lock (pBody p)",
                    "H1 : eq Server (pDst p)",
                    "x : Client_index",
                    "p : packet",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "H2 : eq Unlock (pBody p)",
                    "H5 : eq (held (sigma (Client x))) true",
                    "H3 : eq (held st') false",
                    "st' : Data"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_locked_sent_lock , locks_correct_locked_sent_unlock .",
                "tactic_sig_no_out_arg": "auto using locks_correct_locked_sent_lock , locks_correct_locked_sent_unlock .",
                "tactic_args": [
                    "_goal : locks_correct_locked\n  (update Name_eq_dec sigma (Client x) (sigma (Client x))) p"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_locked_sent_lock , locks_correct_locked_sent_unlock .",
                "tactic_sig_no_out_arg": "auto using locks_correct_locked_sent_lock , locks_correct_locked_sent_unlock .",
                "tactic_args": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client x) st') p"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nwnw_locked_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Locked), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Locked), eq (pBody q) Lock"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_network_invariant .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_network_invariant .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Locked), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False))))\n  (_ : eq (pBody p) Locked), eq (pBody q) Lock"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False))))\n  (_ : eq (pBody p) Locked), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : eq (pBody q) Lock",
                    "H0 : eq (pBody p) Locked",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock), False)\n  (and\n     (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Locked),\n         False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Locked),\n         False)))",
                    "p : packet",
                    "q : packet"
                ]
            },
            {
                "tactic_sig": "destruct ( pBody _i ) as [_o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) .",
                "tactic_args": [
                    "_goal : eq (pBody q) Lock",
                    "q : packet"
                ],
                "tactic_res": [
                    "_goal : eq Lock Lock",
                    "_goal : eq Unlock Lock",
                    "_goal : eq Locked Lock",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Lock Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Lock Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Lock Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Lock Locked), False)))",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Unlock Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Unlock Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Unlock Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Unlock Locked), False)))",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Locked Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Locked Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Locked Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Locked Locked), False)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Lock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Unlock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Locked Lock"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nwnw_unlock_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Unlock), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Unlock), eq (pBody q) Lock"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_network_invariant .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_network_invariant .",
                "tactic_args": [
                    "_goal : forall (p q : packet) (_ : LockServ_network_network_invariant p q)\n  (_ : eq (pBody p) Unlock), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False))))\n  (_ : eq (pBody p) Unlock), eq (pBody q) Lock"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p q : packet)\n  (_ : and\n         (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock),\n          False)\n         (and\n            (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock),\n             False)\n            (and\n               (forall (_ : eq (pBody p) Unlock)\n                  (_ : eq (pBody q) Locked), False)\n               (forall (_ : eq (pBody p) Locked)\n                  (_ : eq (pBody q) Locked), False))))\n  (_ : eq (pBody p) Unlock), eq (pBody q) Lock"
                ],
                "tactic_res": [
                    "_goal : eq (pBody q) Lock",
                    "H0 : eq (pBody p) Unlock",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Unlock), False)\n  (and\n     (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody q) Locked),\n         False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq (pBody q) Locked),\n         False)))",
                    "p : packet",
                    "q : packet"
                ]
            },
            {
                "tactic_sig": "destruct ( pBody _i ) as [_o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) .",
                "tactic_args": [
                    "_goal : eq (pBody q) Lock",
                    "q : packet"
                ],
                "tactic_res": [
                    "_goal : eq Lock Lock",
                    "_goal : eq Unlock Lock",
                    "_goal : eq Locked Lock",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Lock Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Lock Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Lock Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Lock Locked), False)))",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Unlock Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Unlock Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Unlock Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Unlock Locked), False)))",
                    "H : and (forall (_ : eq (pBody p) Unlock) (_ : eq Locked Unlock), False)\n  (and (forall (_ : eq (pBody p) Locked) (_ : eq Locked Unlock), False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq Locked Locked), False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq Locked Locked), False)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Lock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Unlock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Locked Lock"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_at_head",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pSrc p) (Client c))\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pSrc p) (Client c))\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p),\nat_head_of_queue sigma c"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_unlock .",
                "tactic_sig_no_out_arg": "unfold locks_correct_unlock .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pSrc p) (Client c))\n  (_ : eq (pBody p) Unlock) (_ : locks_correct_unlock sigma p),\nat_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pSrc p) (Client c))\n  (_ : eq (pBody p) Unlock)\n  (_ : forall _ : eq (pBody p) Unlock,\n       ex\n         (fun c0 : Client_index =>\n          valid_unlock (queue (sigma Server))\n            (held (sigma (Client c0))) c0 p)), at_head_of_queue sigma c"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet) \n  (c : Client_index) (_ : eq (pSrc p) (Client c))\n  (_ : eq (pBody p) Unlock)\n  (_ : forall _ : eq (pBody p) Unlock,\n       ex\n         (fun c0 : Client_index =>\n          valid_unlock (queue (sigma Server))\n            (held (sigma (Client c0))) c0 p)), at_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : at_head_of_queue sigma c",
                    "H1 : forall _ : eq (pBody p) Unlock,\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)",
                    "H0 : eq (pBody p) Unlock",
                    "H : eq (pSrc p) (Client c)",
                    "c : Client_index",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "find_apply_hyp_hyp .",
                "tactic_sig_no_out_arg": "find_apply_hyp_hyp .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : ex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H1 : forall _ : eq (pBody p) Unlock,\nex\n  (fun c : Client_index =>\n   valid_unlock (queue (sigma Server)) (held (sigma (Client c))) c p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : valid_unlock (queue (sigma Server)) (held (sigma (Client x))) x p",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "unfold valid_unlock in * .",
                "tactic_sig_no_out_arg": "unfold valid_unlock in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (sigma Server)) (cons x t)))\n     (eq (held (sigma (Client x))) false))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq (held (sigma (Client x))) false",
                    "H0 : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))",
                    "H1 : eq (pSrc p) (Client x)"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (Client c) (Client x)",
                    "H : eq (pSrc p) (Client x)"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [
                    "_goal : at_head_of_queue sigma c"
                ],
                "tactic_res": [
                    "_goal : at_head_of_queue sigma x"
                ]
            },
            {
                "tactic_sig": "eauto using at_head_of_queue_intro .",
                "tactic_sig_no_out_arg": "eauto using at_head_of_queue_intro .",
                "tactic_args": [
                    "_goal : at_head_of_queue sigma x"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_at_head_preserved",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_unlock sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_unlock (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_unlock sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_unlock (update name_eq_dec sigma Server st') p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_unlock , valid_unlock .",
                "tactic_sig_no_out_arg": "unfold locks_correct_unlock , valid_unlock .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_unlock sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_unlock (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet)\n  (_ : forall _ : eq (pBody p) Unlock,\n       ex\n         (fun c : Client_index =>\n          and (eq (pSrc p) (Client c))\n            (and\n               (ex\n                  (fun t : list Client_index =>\n                   eq (queue (sigma Server)) (cons c t)))\n               (eq (held (sigma (Client c))) false))))\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c)\n  (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet)\n  (_ : forall _ : eq (pBody p) Unlock,\n       ex\n         (fun c : Client_index =>\n          and (eq (pSrc p) (Client c))\n            (and\n               (ex\n                  (fun t : list Client_index =>\n                   eq (queue (sigma Server)) (cons c t)))\n               (eq (held (sigma (Client c))) false))))\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c)\n  (_ : eq (pBody p) Unlock),\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "H2 : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : eq (pBody p) Unlock",
                    "H0 : forall (c : Client_index) (_ : at_head_of_queue sigma c),\nat_head_of_queue (update name_eq_dec sigma Server st') c",
                    "p : packet",
                    "st' : data",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (sigma Server)) (cons x t)))\n     (eq (held (sigma (Client x))) false))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "x : Client_index"
                ],
                "tactic_res": [
                    "_goal : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client x))) false))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client x))) false))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons x t))",
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client x))) false",
                    "H4 : eq (held (sigma (Client x))) false",
                    "H : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))",
                    "H2 : eq (pSrc p) (Client x)"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons x t))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client x))) false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nil_at_head_of_queue_preserved",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (sigma sigma' : forall _ : Name, Data)\n  (_ : eq (queue (sigma Server)) nil) (_ : at_head_of_queue sigma c),\nat_head_of_queue sigma' c"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (sigma sigma' : forall _ : Name, Data)\n  (_ : eq (queue (sigma Server)) nil) (_ : at_head_of_queue sigma c),\nat_head_of_queue sigma' c"
                ]
            },
            {
                "tactic_sig": "unfold at_head_of_queue .",
                "tactic_sig_no_out_arg": "unfold at_head_of_queue .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (sigma sigma' : forall _ : Name, Data)\n  (_ : eq (queue (sigma Server)) nil) (_ : at_head_of_queue sigma c),\nat_head_of_queue sigma' c"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (sigma sigma' : forall _ : Name, Data)\n  (_ : eq (queue (sigma Server)) nil)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex (fun t : list Client_index => eq (queue (sigma' Server)) (cons c t))"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (sigma sigma' : forall _ : Name, Data)\n  (_ : eq (queue (sigma Server)) nil)\n  (_ : ex\n         (fun t : list Client_index =>\n          eq (queue (sigma Server)) (cons c t))),\nex (fun t : list Client_index => eq (queue (sigma' Server)) (cons c t))"
                ],
                "tactic_res": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma' Server)) (cons c t))",
                    "H0 : eq (queue (sigma Server)) (cons c x)",
                    "x : list Client_index",
                    "H : eq (queue (sigma Server)) nil",
                    "sigma : forall _ : Name, Data",
                    "sigma' : forall _ : Name, Data",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : ex (fun t : list Client_index => eq (queue (sigma' Server)) (cons c t))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_net_handlers_old",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client c) st') q",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "H6 : eq (held st') true",
                    "H4 : eq (pBody p) Locked",
                    "H2 : LockServ_network_network_invariant p q",
                    "H1 : locks_correct_unlock sigma q",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) (Client c)",
                    "c : Client_index",
                    "q : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H7 : eq (queue (sigma Server)) nil",
                    "H5 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H4 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "Heqn : eq (pDst p) Server",
                    "H7 : forall _ : eq (queue (sigma Server)) nil, False",
                    "H5 : eq (queue st') (app (queue (sigma Server)) (cons x nil))",
                    "H6 : eq (List.tl (queue (sigma Server))) nil",
                    "H4 : eq (queue st') nil",
                    "H : eq (pBody p) Unlock",
                    "H6 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H4 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma (Client c) st') q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_unlock_sent_lock , nwnw_locked_lock , locks_correct_unlock_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_at_head_preserved",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_locked sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_locked sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_locked , valid_locked .",
                "tactic_sig_no_out_arg": "unfold locks_correct_locked , valid_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet) (_ : locks_correct_locked sigma p)\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet)\n  (_ : forall _ : eq (pBody p) Locked,\n       ex\n         (fun c : Client_index =>\n          and (eq (pDst p) (Client c))\n            (and\n               (ex\n                  (fun t : list Client_index =>\n                   eq (queue (sigma Server)) (cons c t)))\n               (eq (held (sigma (Client c))) false))))\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c)\n  (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (p : packet)\n  (_ : forall _ : eq (pBody p) Locked,\n       ex\n         (fun c : Client_index =>\n          and (eq (pDst p) (Client c))\n            (and\n               (ex\n                  (fun t : list Client_index =>\n                   eq (queue (sigma Server)) (cons c t)))\n               (eq (held (sigma (Client c))) false))))\n  (_ : forall (c : Client_index) (_ : at_head_of_queue sigma c),\n       at_head_of_queue (update name_eq_dec sigma Server st') c)\n  (_ : eq (pBody p) Locked),\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "H2 : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : eq (pBody p) Locked",
                    "H0 : forall (c : Client_index) (_ : at_head_of_queue sigma c),\nat_head_of_queue (update name_eq_dec sigma Server st') c",
                    "p : packet",
                    "st' : data",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq (pDst p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (sigma Server)) (cons x t)))\n     (eq (held (sigma (Client x))) false))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "x : Client_index"
                ],
                "tactic_res": [
                    "_goal : and (eq (pDst p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client x))) false))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (pDst p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons x t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client x))) false))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons x t))",
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client x))) false",
                    "H4 : eq (held (sigma (Client x))) false",
                    "H : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))",
                    "H2 : eq (pDst p) (Client x)"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons x t))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client x))) false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_net_handlers_old",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_locked sigma q)\n  (_ : LockServ_network_network_invariant p q),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client c) st') q",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "H6 : eq (held st') true",
                    "H4 : eq (pBody p) Locked",
                    "H2 : LockServ_network_network_invariant p q",
                    "H1 : locks_correct_locked sigma q",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) (Client c)",
                    "c : Client_index",
                    "q : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H7 : eq (queue (sigma Server)) nil",
                    "H5 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H4 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "Heqn : eq (pDst p) Server",
                    "H7 : forall _ : eq (queue (sigma Server)) nil, False",
                    "H5 : eq (queue st') (app (queue (sigma Server)) (cons x nil))",
                    "H6 : eq (List.tl (queue (sigma Server))) nil",
                    "H4 : eq (queue st') nil",
                    "H : eq (pBody p) Unlock",
                    "H6 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H4 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma (Client c) st') q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_sent_lock , nwnw_locked_lock , locks_correct_locked_at_head_preserved , snoc_at_head_of_queue_preserved , nwnw_unlock_lock , nil_at_head_of_queue_preserved .",
                "tactic_args": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_unlock_net_handlers_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_unlock (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q",
                    "H7 : eq Locked (pBody q)",
                    "H5 : eq (Client x) (pDst q)",
                    "H6 : eq (queue (sigma Server)) nil",
                    "H4 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H3 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) Server",
                    "q : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H6 : eq Locked (pBody q)",
                    "H4 : eq (Client x) (pDst q)",
                    "H5 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H3 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index",
                    "H : eq (pBody p) Unlock"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_locked .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_locked .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_unlock_sent_locked .",
                "tactic_sig_no_out_arg": "auto using locks_correct_unlock_sent_locked .",
                "tactic_args": [
                    "_goal : locks_correct_unlock (update Name_eq_dec sigma Server st') q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_intro",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (c : Client_index) (t : list Client_index) (st' : Data)\n  (_ : eq (pDst p) (Client c)) (_ : eq (held (sigma (Client c))) false)\n  (_ : eq (queue st') (cons c t)),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (c : Client_index) (t : list Client_index) (st' : Data)\n  (_ : eq (pDst p) (Client c)) (_ : eq (held (sigma (Client c))) false)\n  (_ : eq (queue st') (cons c t)),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ]
            },
            {
                "tactic_sig": "unfold locks_correct_locked , valid_locked .",
                "tactic_sig_no_out_arg": "unfold locks_correct_locked , valid_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (c : Client_index) (t : list Client_index) (st' : Data)\n  (_ : eq (pDst p) (Client c)) (_ : eq (held (sigma (Client c))) false)\n  (_ : eq (queue st') (cons c t)),\nlocks_correct_locked (update name_eq_dec sigma Server st') p"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (c : Client_index) (t : list Client_index) (st' : Data)\n  (_ : eq (pDst p) (Client c)) (_ : eq (held (sigma (Client c))) false)\n  (_ : eq (queue st') (cons c t)) (_ : eq (pBody p) Locked),\nex\n  (fun c0 : Client_index =>\n   and (eq (pDst p) (Client c0))\n     (and\n        (ex\n           (fun t0 : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c0 t0)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c0)))\n           false)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (p : packet) \n  (c : Client_index) (t : list Client_index) (st' : Data)\n  (_ : eq (pDst p) (Client c)) (_ : eq (held (sigma (Client c))) false)\n  (_ : eq (queue st') (cons c t)) (_ : eq (pBody p) Locked),\nex\n  (fun c0 : Client_index =>\n   and (eq (pDst p) (Client c0))\n     (and\n        (ex\n           (fun t0 : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c0 t0)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c0)))\n           false)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "H2 : eq (pBody p) Locked",
                    "H1 : eq (queue st') (cons c t)",
                    "H0 : eq (held (sigma (Client c))) false",
                    "H : eq (pDst p) (Client c)",
                    "st' : Data",
                    "t : list Client_index",
                    "c : Client_index",
                    "p : packet",
                    "sigma : forall _ : Name, Data"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (update name_eq_dec sigma Server st' Server))\n              (cons c t)))\n        (eq (held (update name_eq_dec sigma Server st' (Client c)))\n           false)))",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "_goal : and (eq (pDst p) (Client c))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons c t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client c))) false))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (pDst p) (Client c))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (update name_eq_dec sigma Server st' Server))\n           (cons c t)))\n     (eq (held (update name_eq_dec sigma Server st' (Client c))) false))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))",
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client c))) false"
                ]
            },
            {
                "tactic_sig": "exists _i .",
                "tactic_sig_no_out_arg": "exists _i .",
                "tactic_args": [
                    "_goal : ex\n  (fun t : list Client_index =>\n   eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t))",
                    "t : list Client_index"
                ],
                "tactic_res": [
                    "_goal : eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t)"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq (queue (update name_eq_dec sigma Server st' Server)) (cons c t)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq (held (update name_eq_dec sigma Server st' (Client c))) false"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_net_handlers_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : locks_correct_unlock sigma p)\n  (_ : In (pair (pDst q) (pBody q)) ms),\nlocks_correct_locked (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q",
                    "H8 : eq Locked (pBody q)",
                    "H6 : eq (Client x) (pDst q)",
                    "H7 : eq (queue (sigma Server)) nil",
                    "H5 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H4 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "H1 : locks_correct_unlock sigma p",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) Server",
                    "q : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H7 : eq Locked (pBody q)",
                    "H5 : eq (Client x) (pDst q)",
                    "H6 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H4 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index",
                    "H : eq (pBody p) Unlock"
                ]
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_intro , empty_queue_all_clients_false , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_intro , empty_queue_all_clients_false , unlock_in_flight_all_clients_false .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_locked_intro , empty_queue_all_clients_false , unlock_in_flight_all_clients_false .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_locked_intro , empty_queue_all_clients_false , unlock_in_flight_all_clients_false .",
                "tactic_args": [
                    "_goal : locks_correct_locked (update Name_eq_dec sigma Server st') q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nwnw_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p p' : packet) (_ : eq (pBody p) Lock),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : forall (p p' : packet) (_ : eq (pBody p) Lock),\nLockServ_network_network_invariant p p'"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_network_invariant .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_network_invariant .",
                "tactic_args": [
                    "_goal : forall (p p' : packet) (_ : eq (pBody p) Lock),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : forall (p p' : packet) (_ : eq (pBody p) Lock),\nand\n  (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody p') Unlock), False)\n  (and\n     (forall (_ : eq (pBody p) Locked) (_ : eq (pBody p') Unlock),\n      False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody p') Locked),\n         False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq (pBody p') Locked),\n         False)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (p p' : packet) (_ : eq (pBody p) Lock),\nand\n  (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody p') Unlock), False)\n  (and\n     (forall (_ : eq (pBody p) Locked) (_ : eq (pBody p') Unlock),\n      False)\n     (and\n        (forall (_ : eq (pBody p) Unlock) (_ : eq (pBody p') Locked),\n         False)\n        (forall (_ : eq (pBody p) Locked) (_ : eq (pBody p') Locked),\n         False)))"
                ],
                "tactic_res": [
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "H1 : eq (pBody p') Unlock",
                    "H0 : eq (pBody p) Unlock",
                    "H : eq (pBody p) Lock",
                    "p : packet",
                    "p' : packet",
                    "H0 : eq (pBody p) Locked",
                    "H1 : eq (pBody p') Locked"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "LockServ_nwnw_input_handlers_old_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p p' : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ms) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p p' : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ms) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p p' : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ms) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p p' : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : and (locks_correct_unlock sigma p)\n         (locks_correct_locked sigma p))\n  (_ : In (pair (pDst p') (pBody p')) ms) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (p p' : packet)\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : and (locks_correct_unlock sigma p)\n         (locks_correct_locked sigma p))\n  (_ : In (pair (pDst p') (pBody p')) ms) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p p'",
                    "_goal : LockServ_network_network_invariant p p'",
                    "H6 : eq Lock (pBody p')",
                    "H3 : eq Server (pDst p')",
                    "H1 : eq (pSrc p') (Client x)",
                    "x : Client_index",
                    "H5 : locks_correct_locked sigma p",
                    "H4 : locks_correct_unlock sigma p",
                    "H0 : locks_correct sigma",
                    "p : packet",
                    "p' : packet",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "H6 : eq Unlock (pBody p')",
                    "H9 : eq (held (sigma (Client x))) true",
                    "H7 : eq (held st') false",
                    "st' : Data"
                ]
            },
            {
                "tactic_sig": "auto using nwnw_sym , nwnw_lock .",
                "tactic_sig_no_out_arg": "auto using nwnw_sym , nwnw_lock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( pBody _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) eqn : ? .",
                "tactic_args": [
                    "p : packet"
                ],
                "tactic_res": [
                    "Heqm : eq (pBody p) Lock",
                    "Heqm : eq (pBody p) Unlock",
                    "Heqm : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "auto using nwnw_lock .",
                "tactic_sig_no_out_arg": "auto using nwnw_lock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "now erewrite unlock_in_flight_all_clients_false in * by eauto .",
                "tactic_sig_no_out_arg": "now erewrite unlock_in_flight_all_clients_false in * by eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "now erewrite locked_in_flight_all_clients_false in * by eauto .",
                "tactic_sig_no_out_arg": "now erewrite locked_in_flight_all_clients_false in * by eauto .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p p'"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "LockServ_nwnw_input_handlers_new_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)"
                ]
            },
            {
                "tactic_sig": "set_up_input_handlers .",
                "tactic_sig_no_out_arg": "set_up_input_handlers .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (sigma : forall _ : Name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i (sigma h))\n         (pair (pair (pair u out) st') ms)),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ms)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "nw_empty_queue_lock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : eq (queue (sigma Server)) nil), eq (pBody p) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : eq (queue (sigma Server)) nil), eq (pBody p) Lock"
                ]
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant , locks_correct_unlock , locks_correct_locked , valid_unlock , valid_locked .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant , locks_correct_unlock , locks_correct_locked , valid_unlock , valid_locked .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : eq (queue (sigma Server)) nil), eq (pBody p) Lock"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : and\n         (forall _ : eq (pBody p) Unlock,\n          ex\n            (fun c : Client_index =>\n             and (eq (pSrc p) (Client c))\n               (and\n                  (ex\n                     (fun t : list Client_index =>\n                      eq (queue (sigma Server)) (cons c t)))\n                  (eq (held (sigma (Client c))) false))))\n         (forall _ : eq (pBody p) Locked,\n          ex\n            (fun c : Client_index =>\n             and (eq (pDst p) (Client c))\n               (and\n                  (ex\n                     (fun t : list Client_index =>\n                      eq (queue (sigma Server)) (cons c t)))\n                  (eq (held (sigma (Client c))) false)))))\n  (_ : eq (queue (sigma Server)) nil), eq (pBody p) Lock"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (p : packet)\n  (_ : and\n         (forall _ : eq (pBody p) Unlock,\n          ex\n            (fun c : Client_index =>\n             and (eq (pSrc p) (Client c))\n               (and\n                  (ex\n                     (fun t : list Client_index =>\n                      eq (queue (sigma Server)) (cons c t)))\n                  (eq (held (sigma (Client c))) false))))\n         (forall _ : eq (pBody p) Locked,\n          ex\n            (fun c : Client_index =>\n             and (eq (pDst p) (Client c))\n               (and\n                  (ex\n                     (fun t : list Client_index =>\n                      eq (queue (sigma Server)) (cons c t)))\n                  (eq (held (sigma (Client c))) false)))))\n  (_ : eq (queue (sigma Server)) nil), eq (pBody p) Lock"
                ],
                "tactic_res": [
                    "_goal : eq (pBody p) Lock",
                    "H2 : forall _ : eq (pBody p) Locked,\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : forall _ : eq (pBody p) Unlock,\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H0 : eq (queue (sigma Server)) nil",
                    "p : packet",
                    "sigma : forall _ : name, data"
                ]
            },
            {
                "tactic_sig": "destruct ( pBody _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( pBody _i ) eqn : ? .",
                "tactic_args": [
                    "_goal : eq (pBody p) Lock",
                    "p : packet"
                ],
                "tactic_res": [
                    "_goal : eq Lock Lock",
                    "_goal : eq Unlock Lock",
                    "_goal : eq Locked Lock",
                    "H2 : forall _ : eq Lock Locked,\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : forall _ : eq Lock Unlock,\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "Heqm : eq (pBody p) Lock",
                    "H2 : forall _ : eq Unlock Locked,\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : forall _ : eq Unlock Unlock,\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "Heqm : eq (pBody p) Unlock",
                    "H2 : forall _ : eq Locked Locked,\nex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "H1 : forall _ : eq Locked Unlock,\nex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))",
                    "Heqm : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq Lock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq (pSrc p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (sigma Server)) (cons x t)))\n     (eq (held (sigma (Client x))) false))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (held (sigma (Client x))) false",
                    "H : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))",
                    "H1 : eq (pSrc p) (Client x)"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq Unlock Lock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun c : Client_index =>\n   and (eq (pDst p) (Client c))\n     (and\n        (ex\n           (fun t : list Client_index =>\n            eq (queue (sigma Server)) (cons c t)))\n        (eq (held (sigma (Client c))) false)))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq (pDst p) (Client x))\n  (and\n     (ex\n        (fun t : list Client_index =>\n         eq (queue (sigma Server)) (cons x t)))\n     (eq (held (sigma (Client x))) false))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (held (sigma (Client x))) false",
                    "H : ex (fun t : list Client_index => eq (queue (sigma Server)) (cons x t))",
                    "H2 : eq (pDst p) (Client x)"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (queue (sigma Server)) (cons x x0)",
                    "x0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq Locked Lock"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "LockServ_nwnw_net_handlers_old_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q p' : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ms),\nLockServ_network_network_invariant p' q"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q p' : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ms),\nLockServ_network_network_invariant p' q"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg)) (q p' : packet)\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ms),\nLockServ_network_network_invariant p' q"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p' q",
                    "_goal : LockServ_network_network_invariant p' q",
                    "H10 : eq Locked (pBody p')",
                    "H8 : eq (Client x) (pDst p')",
                    "H9 : eq (queue (sigma Server)) nil",
                    "H7 : eq (queue st') (cons x nil)",
                    "H : eq (pBody p) Lock",
                    "H6 : eq (pSrc p) (Client x)",
                    "x : Client_index",
                    "H3 : LockServ_network_network_invariant p q",
                    "H2 : LockServ_network_invariant sigma q",
                    "H1 : LockServ_network_invariant sigma p",
                    "H0 : locks_correct sigma",
                    "Heqn : eq (pDst p) Server",
                    "q : packet",
                    "p' : packet",
                    "st' : Data",
                    "u : Label",
                    "sigma : forall _ : Name, Data",
                    "p : packet",
                    "H9 : eq Locked (pBody p')",
                    "H7 : eq (Client x) (pDst p')",
                    "H8 : eq (List.tl (queue (sigma Server))) (cons x x0)",
                    "H6 : eq (queue st') (cons x x0)",
                    "x0 : list Client_index",
                    "H : eq (pBody p) Unlock"
                ]
            },
            {
                "tactic_sig": "eauto using nwnw_sym , nwnw_lock , nw_empty_queue_lock , nwnw_unlock_lock .",
                "tactic_sig_no_out_arg": "eauto using nwnw_sym , nwnw_lock , nw_empty_queue_lock , nwnw_unlock_lock .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using nwnw_sym , nwnw_lock , nw_empty_queue_lock , nwnw_unlock_lock .",
                "tactic_sig_no_out_arg": "eauto using nwnw_sym , nwnw_lock , nw_empty_queue_lock , nwnw_unlock_lock .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p' q"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "LockServ_nwnw_net_handlers_new_new",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ms)"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ms)"
                ]
            },
            {
                "tactic_sig": "set_up_net_handlers .",
                "tactic_sig_no_out_arg": "set_up_net_handlers .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, Data) \n  (u : Label) (st' : Data) (out : list Output)\n  (ms : list (prod Name Msg))\n  (_ : eq (NetHandler (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair (pair u out) st') ms)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ms)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "LockServ_Decompositition",
        "proof": [
            {
                "tactic_sig": "apply Build_Decomposition with ( state_invariant := locks_correct ) ( network_invariant := LockServ_network_invariant ) ( network_network_invariant := LockServ_network_network_invariant ) .",
                "tactic_sig_no_out_arg": "apply Build_Decomposition with ( state_invariant := locks_correct ) ( network_invariant := LockServ_network_invariant ) ( network_network_invariant := LockServ_network_network_invariant ) .",
                "tactic_args": [
                    "_goal : Decomposition LockServ_BaseParams LockServ_MultiParams"
                ],
                "tactic_res": [
                    "_goal : forall (p1 p2 : packet) (_ : LockServ_network_network_invariant p1 p2),\nLockServ_network_network_invariant p2 p1",
                    "_goal : locks_correct init_handlers",
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma h st')",
                    "_goal : forall (p : packet) (sigma : forall _ : name, data) \n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\nlocks_correct (update name_eq_dec sigma (pDst p) st')",
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\nLockServ_network_invariant (update name_eq_dec sigma h st') p",
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : In (pair (pDst p) (pBody p)) ps)\n  (_ : eq (pSrc p) h),\nLockServ_network_invariant (update name_eq_dec sigma h st') p",
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p q : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q),\nLockServ_network_invariant (update name_eq_dec sigma (pDst p) st') q",
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p p' : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_invariant (update name_eq_dec sigma (pDst p) st') p'",
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p p' : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'",
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)",
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p p' q : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_network_invariant p' q",
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (p1 p2 : packet) (_ : LockServ_network_network_invariant p1 p2),\nLockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : forall (p1 p2 : packet) (_ : LockServ_network_network_invariant p1 p2),\nLockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p1 p2 : packet) (_ : LockServ_network_network_invariant p1 p2),\nLockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1",
                    "H : LockServ_network_network_invariant p1 p2",
                    "p1 : packet",
                    "p2 : packet"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : locks_correct init_handlers"
                ],
                "tactic_res": [
                    "_goal : locks_correct init_data"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma),\nlocks_correct (update name_eq_dec sigma h st')"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma),\nlocks_correct (update Name_eq_dec sigma h st')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma),\nlocks_correct (update Name_eq_dec sigma h st')"
                ],
                "tactic_res": [
                    "_goal : locks_correct (update Name_eq_dec sigma h st')",
                    "H0 : locks_correct sigma",
                    "H : eq (unlabeled_input_handlers h inp (sigma h)) (pair (pair out st') ps)",
                    "ps : list (prod Name Msg)",
                    "out : list Output",
                    "st' : Data",
                    "sigma : forall _ : Name, Data",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_input_handlers h inp (sigma h) in pair (pair out st') ps)\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp : eq (lb_input_handlers h inp (sigma h)) (pair (pair (pair l0 l1) d) l)",
                    "Heqp0 : eq p (pair (pair l0 l1) d)",
                    "Heqp1 : eq p0 (pair l0 l1)",
                    "l1 : list output",
                    "l0 : label",
                    "d : data",
                    "p0 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq (lb_input_handlers h inp (sigma h))\n  (pair (pair (pair l0 out) st') ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : name, data) \n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\nlocks_correct (update name_eq_dec sigma (pDst p) st')"
                ],
                "tactic_res": [
                    "_goal : forall (p : packet) (sigma : forall _ : Name, Data) \n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\nlocks_correct (update Name_eq_dec sigma (pDst p) st')"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p : packet) (sigma : forall _ : Name, Data) \n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\nlocks_correct (update Name_eq_dec sigma (pDst p) st')"
                ],
                "tactic_res": [
                    "_goal : locks_correct (update Name_eq_dec sigma (pDst p) st')",
                    "H1 : LockServ_network_invariant sigma p",
                    "H : eq\n  (unlabeled_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair out st') ps)",
                    "p : packet"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) in\n    pair (pair out st') ps) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 out) st') ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\nLockServ_network_invariant (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\nLockServ_network_invariant (update Name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\nLockServ_network_invariant (update Name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma h st') p",
                    "H : eq (unlabeled_input_handlers h inp (sigma h)) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_input_handlers h inp (sigma h) in pair (pair out st') ps)\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_input_handlers h inp (sigma h)) (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp0 : eq (lb_input_handlers h inp (sigma h))\n  (pair (pair (pair l0 out) st') ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : In (pair (pDst p) (pBody p)) ps)\n  (_ : eq (pSrc p) h),\nLockServ_network_invariant (update name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst p) (pBody p)) ps) (_ : eq (pSrc p) h),\nLockServ_network_invariant (update Name_eq_dec sigma h st') p"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : In (pair (pDst p) (pBody p)) ps) (_ : eq (pSrc p) h),\nLockServ_network_invariant (update Name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "H2 : eq (pSrc p) h",
                    "H1 : In (pair (pDst p) (pBody p)) ps",
                    "H : eq (unlabeled_input_handlers h inp (sigma h)) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_input_handlers h inp (sigma h) in pair (pair out st') ps)\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_input_handlers h inp (sigma h)) (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pSrc p) st') p",
                    "Heqp0 : eq (lb_input_handlers (pSrc p) inp (sigma (pSrc p)))\n  (pair (pair (pair l0 out) st') ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p q : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q),\nLockServ_network_invariant (update name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p q : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q),\nLockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p q : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q),\nLockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') q",
                    "H3 : LockServ_network_network_invariant p q",
                    "H2 : LockServ_network_invariant sigma q",
                    "H : eq\n  (unlabeled_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair out st') ps)",
                    "q : packet"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) in\n    pair (pair out st') ps) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p p' : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_invariant (update name_eq_dec sigma (pDst p) st') p'"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p p' : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') p'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p p' : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') p'"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') p'",
                    "H3 : eq (pSrc p') (pDst p)",
                    "H2 : In (pair (pDst p') (pBody p')) ps",
                    "H : eq\n  (unlabeled_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair out st') ps)",
                    "p' : packet"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) in\n    pair (pair out st') ps) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (p p' : packet)\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p p' : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (p p' : packet)\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') h),\nLockServ_network_network_invariant p p'"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p p'",
                    "H3 : eq (pSrc p') h",
                    "H : eq (unlabeled_input_handlers h inp (sigma h)) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_input_handlers h inp (sigma h) in pair (pair out st') ps)\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_input_handlers h inp (sigma h)) (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp0 : eq (lb_input_handlers (pSrc p') inp (sigma (pSrc p')))\n  (pair (pair (pair l0 out) st') ps)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (h : name) (inp : input) (sigma : forall _ : name, data)\n  (st' : data) (out : list output) (ps : list (prod name msg))\n  (_ : eq (input_handlers h inp (sigma h)) (pair (pair out st') ps))\n  (_ : locks_correct sigma),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (inp : Input) (sigma : forall _ : Name, Data)\n  (st' : Data) (out : list Output) (ps : list (prod Name Msg))\n  (_ : eq (unlabeled_input_handlers h inp (sigma h))\n         (pair (pair out st') ps)) (_ : locks_correct sigma),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": [
                    "_goal : distinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)",
                    "H : eq (unlabeled_input_handlers h inp (sigma h)) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_input_handlers h inp (sigma h) in pair (pair out st') ps)\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp : eq (lb_input_handlers h inp (sigma h)) (pair (pair (pair l0 l1) d) l)",
                    "Heqp0 : eq p (pair (pair l0 l1) d)",
                    "Heqp1 : eq p0 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p0 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p p' q : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_network_invariant p' q"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p p' q : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_network_invariant p' q"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p p' q : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p)\n  (_ : LockServ_network_invariant sigma q)\n  (_ : LockServ_network_network_invariant p q)\n  (_ : In (pair (pDst p') (pBody p')) ps) (_ : eq (pSrc p') (pDst p)),\nLockServ_network_network_invariant p' q"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p' q",
                    "H5 : eq (pSrc p') (pDst p)",
                    "H4 : In (pair (pDst p') (pBody p')) ps",
                    "H : eq\n  (unlabeled_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) in\n    pair (pair out st') ps) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : name, data) (st' : data) \n  (out : list output) (ps : list (prod name msg)) \n  (p : packet)\n  (_ : eq (net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n         (pair (pair out st') ps)) (_ : locks_correct sigma)\n  (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod name msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (sigma : forall _ : Name, Data) (st' : Data) \n  (out : list Output) (ps : list (prod Name Msg)) \n  (p : packet)\n  (_ : eq\n         (unlabeled_net_handlers (pDst p) (pSrc p) \n            (pBody p) (sigma (pDst p))) (pair (pair out st') ps))\n  (_ : locks_correct sigma) (_ : LockServ_network_invariant sigma p),\ndistinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": [
                    "_goal : distinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)",
                    "H : eq\n  (unlabeled_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ]
            },
            {
                "tactic_sig": "unlabeled_unfold .",
                "tactic_sig_no_out_arg": "unlabeled_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let\n   'pair (pair (pair _ out) st') ps :=\n    lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)) in\n    pair (pair out st') ps) (pair (pair out st') ps)"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (pair (pair l1 d) l) (pair (pair out st') ps)",
                    "Heqp0 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (sigma (pDst p)))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp1 : eq p0 (pair (pair l0 l1) d)",
                    "Heqp2 : eq p1 (pair l0 l1)",
                    "l1 : list output",
                    "d : data",
                    "p1 : prod label (list output)",
                    "l : list (prod lb_name lb_msg)",
                    "p0 : prod (prod label (list output)) data"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using nwnw_sym .",
                "tactic_sig_no_out_arg": "auto using nwnw_sym .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p2 p1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto using locks_correct_init .",
                "tactic_sig_no_out_arg": "auto using locks_correct_init .",
                "tactic_args": [
                    "_goal : locks_correct init_data"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using locks_correct_input_handlers .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_input_handlers .",
                "tactic_args": [
                    "_goal : locks_correct (update Name_eq_dec sigma h st')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant in * .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (locks_correct_unlock sigma p) (locks_correct_locked sigma p)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : locks_correct_locked sigma p",
                    "H : locks_correct_unlock sigma p"
                ]
            },
            {
                "tactic_sig": "eauto using locks_correct_net_handlers .",
                "tactic_sig_no_out_arg": "eauto using locks_correct_net_handlers .",
                "tactic_args": [
                    "_goal : locks_correct (update Name_eq_dec sigma (pDst p) st')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant in * .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant in * .",
                "tactic_args": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma h st') p"
                ],
                "tactic_res": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma h st') p)\n  (locks_correct_locked (update Name_eq_dec sigma h st') p)",
                    "H1 : and (locks_correct_unlock sigma p) (locks_correct_locked sigma p)"
                ]
            },
            {
                "tactic_sig": "intuition eauto using locks_correct_unlock_input_handlers_old , locks_correct_locked_input_handlers_old .",
                "tactic_sig_no_out_arg": "intuition eauto using locks_correct_unlock_input_handlers_old , locks_correct_locked_input_handlers_old .",
                "tactic_args": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma h st') p)\n  (locks_correct_locked (update Name_eq_dec sigma h st') p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant in * .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant in * .",
                "tactic_args": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pSrc p) st') p"
                ],
                "tactic_res": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pSrc p) st') p)\n  (locks_correct_locked (update Name_eq_dec sigma (pSrc p) st') p)"
                ]
            },
            {
                "tactic_sig": "intuition eauto using locks_correct_unlock_input_handlers_new , locks_correct_locked_input_handlers_new .",
                "tactic_sig_no_out_arg": "intuition eauto using locks_correct_unlock_input_handlers_new , locks_correct_locked_input_handlers_new .",
                "tactic_args": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pSrc p) st') p)\n  (locks_correct_locked (update Name_eq_dec sigma (pSrc p) st') p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant in * .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant in * .",
                "tactic_args": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') q"
                ],
                "tactic_res": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pDst p) st') q)\n  (locks_correct_locked (update Name_eq_dec sigma (pDst p) st') q)",
                    "H2 : and (locks_correct_unlock sigma q) (locks_correct_locked sigma q)",
                    "H1 : and (locks_correct_unlock sigma p) (locks_correct_locked sigma p)"
                ]
            },
            {
                "tactic_sig": "intuition eauto using locks_correct_unlock_net_handlers_old , locks_correct_locked_net_handlers_old .",
                "tactic_sig_no_out_arg": "intuition eauto using locks_correct_unlock_net_handlers_old , locks_correct_locked_net_handlers_old .",
                "tactic_args": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pDst p) st') q)\n  (locks_correct_locked (update Name_eq_dec sigma (pDst p) st') q)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold LockServ_network_invariant in * .",
                "tactic_sig_no_out_arg": "unfold LockServ_network_invariant in * .",
                "tactic_args": [
                    "_goal : LockServ_network_invariant (update Name_eq_dec sigma (pDst p) st') p'"
                ],
                "tactic_res": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pDst p) st') p')\n  (locks_correct_locked (update Name_eq_dec sigma (pDst p) st') p')",
                    "H1 : and (locks_correct_unlock sigma p) (locks_correct_locked sigma p)"
                ]
            },
            {
                "tactic_sig": "intuition eauto using locks_correct_unlock_net_handlers_new , locks_correct_locked_net_handlers_new .",
                "tactic_sig_no_out_arg": "intuition eauto using locks_correct_unlock_net_handlers_new , locks_correct_locked_net_handlers_new .",
                "tactic_args": [
                    "_goal : and (locks_correct_unlock (update Name_eq_dec sigma (pDst p) st') p')\n  (locks_correct_locked (update Name_eq_dec sigma (pDst p) st') p')"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using LockServ_nwnw_input_handlers_old_new .",
                "tactic_sig_no_out_arg": "eauto using LockServ_nwnw_input_handlers_old_new .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p p'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using LockServ_nwnw_input_handlers_new_new .",
                "tactic_sig_no_out_arg": "eauto using LockServ_nwnw_input_handlers_new_new .",
                "tactic_args": [
                    "_goal : distinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := h; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using LockServ_nwnw_net_handlers_old_new .",
                "tactic_sig_no_out_arg": "eauto using LockServ_nwnw_net_handlers_old_new .",
                "tactic_args": [
                    "_goal : LockServ_network_network_invariant p' q"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using LockServ_nwnw_net_handlers_new_new .",
                "tactic_sig_no_out_arg": "eauto using LockServ_nwnw_net_handlers_new_new .",
                "tactic_args": [
                    "_goal : distinct_pairs_and LockServ_network_network_invariant\n  (map\n     (fun m : prod Name Msg =>\n      {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) ps)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "true_in_reachable_mutual_exclusion",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : true_in_reachable step_async step_async_init\n  (fun net : network => mutual_exclusion (nwState net))"
                ],
                "tactic_res": [
                    "_goal : true_in_reachable step_async step_async_init\n  (fun net : network => mutual_exclusion (nwState net))"
                ]
            },
            {
                "tactic_sig": "pose proof decomposition_invariant .",
                "tactic_sig_no_out_arg": "pose proof decomposition_invariant .",
                "tactic_args": [],
                "tactic_res": [
                    "H : inductive_invariant step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_args": [],
                "tactic_res": [
                    "H : true_in_reachable step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "unfold true_in_reachable in * .",
                "tactic_sig_no_out_arg": "unfold true_in_reachable in * .",
                "tactic_args": [
                    "_goal : true_in_reachable step_async step_async_init\n  (fun net : network => mutual_exclusion (nwState net))"
                ],
                "tactic_res": [
                    "_goal : forall (a : network) (_ : reachable step_async step_async_init a),\nmutual_exclusion (nwState a)",
                    "H : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (a : network) (_ : reachable step_async step_async_init a),\nmutual_exclusion (nwState a)"
                ],
                "tactic_res": [
                    "_goal : mutual_exclusion (nwState a)",
                    "H0 : reachable step_async step_async_init a",
                    "a : network"
                ]
            },
            {
                "tactic_sig": "apply locks_correct_implies_mutex .",
                "tactic_sig_no_out_arg": "apply locks_correct_implies_mutex .",
                "tactic_args": [
                    "_goal : mutual_exclusion (nwState a)"
                ],
                "tactic_res": [
                    "_goal : locks_correct (nwState a)"
                ]
            },
            {
                "tactic_sig": "match goal with | [ _i : _ | - _ ] => apply _i end .",
                "tactic_sig_no_out_arg": "match goal with | [ _i : _ | - _ ] => apply _i end .",
                "tactic_args": [
                    "_goal : locks_correct (nwState a)",
                    "H : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a",
                    "H : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ],
                "tactic_res": [
                    "_goal : reachable step_async step_async_init a"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : reachable step_async step_async_init a"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cross_relation",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P step_async_init nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star step_async_init st tr) \n         (_ : P st tr) (_ : step_async st st' ev), \n       P st' (app tr ev)) (st : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr), P st tr"
                ],
                "tactic_res": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P step_async_init nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star step_async_init st tr) \n         (_ : P st tr) (_ : step_async st st' ev), \n       P st' (app tr ev)) (st : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr), P st tr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P step_async_init nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star step_async_init st tr) \n         (_ : P st tr) (_ : step_async st st' ev), \n       P st' (app tr ev)) (st : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr), P st tr"
                ],
                "tactic_res": [
                    "_goal : P st tr",
                    "H1 : step_async_star step_async_init st tr",
                    "tr : list (prod name (sum input (list output)))",
                    "st : network",
                    "H0 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)",
                    "H : P step_async_init nil",
                    "P : forall (_ : network) (_ : list (prod name (sum input (list output)))),\nProp"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp refl_trans_1n_n1_trace .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp refl_trans_1n_n1_trace .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : refl_trans_n1_trace step_async step_async_init st tr"
                ]
            },
            {
                "tactic_sig": "prep_induction _i .",
                "tactic_sig_no_out_arg": "prep_induction _i .",
                "tactic_args": [
                    "_goal : P st tr",
                    "H1 : refl_trans_n1_trace step_async step_async_init st tr"
                ],
                "tactic_res": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P H3 nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star H3 st tr) (_ : P st tr)\n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq H3 step_async_init) (_ : eq H2 step_async), \nP st tr",
                    "H1 : refl_trans_n1_trace H2 H3 st tr",
                    "H2 : step_relation network (prod name (sum input (list output)))",
                    "H3 : network"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P H3 nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star H3 st tr) (_ : P st tr)\n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq H3 step_async_init) (_ : eq H2 step_async), \nP st tr",
                    "H1 : refl_trans_n1_trace H2 H3 st tr"
                ],
                "tactic_res": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P x nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star x st tr) (_ : P st tr) \n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq x step_async_init) (_ : eq H2 step_async), \nP x nil",
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P x nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star x st tr) (_ : P st tr) \n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq x step_async_init) (_ : eq H2 step_async), \nP x'' (app cs cs')",
                    "x : network",
                    "IHrefl_trans_n1_trace : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P x nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star x st tr) (_ : P st tr) \n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq x step_async_init) (_ : eq H2 step_async), \nP x' cs",
                    "H : H2 x' x'' cs'",
                    "H1 : refl_trans_n1_trace H2 x x' cs",
                    "cs : list (prod name (sum input (list output)))",
                    "cs' : list (prod name (sum input (list output)))",
                    "x' : network",
                    "x'' : network"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P x nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star x st tr) (_ : P st tr) \n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq x step_async_init) (_ : eq H2 step_async), \nP x nil"
                ],
                "tactic_res": [
                    "_goal : P x nil",
                    "H3 : eq H2 step_async",
                    "H4 : eq x step_async_init",
                    "H0 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star x st tr) (_ : P st tr) (_ : H2 st st' ev),\nP st' (app tr ev)",
                    "H : P x nil",
                    "P : forall (_ : network) (_ : list (prod name (sum input (list output)))),\nProp"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : P x nil"
                ],
                "tactic_res": [
                    "_goal : P step_async_init nil",
                    "H : P step_async_init nil",
                    "H0 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : P step_async_init nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P x nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star x st tr) (_ : P st tr) \n         (_ : H2 st st' ev), P st' (app tr ev))\n  (_ : eq x step_async_init) (_ : eq H2 step_async), \nP x'' (app cs cs')"
                ],
                "tactic_res": [
                    "_goal : P x'' (app cs cs')",
                    "H5 : eq H2 step_async",
                    "H4 : eq x step_async_init",
                    "H3 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star x st tr) (_ : P st tr) (_ : H2 st st' ev),\nP st' (app tr ev)",
                    "H0 : P x nil",
                    "P : forall (_ : network) (_ : list (prod name (sum input (list output)))),\nProp"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : P step_async_init nil",
                    "H3 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)",
                    "H1 : refl_trans_n1_trace step_async step_async_init x' cs",
                    "H : step_async x' x'' cs'",
                    "IHrefl_trans_n1_trace : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P step_async_init nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star step_async_init st tr) \n         (_ : P st tr) (_ : step_async st st' ev), \n       P st' (app tr ev)) (_ : eq step_async_init step_async_init)\n  (_ : eq step_async step_async), P x' cs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : P x'' (app cs cs')"
                ],
                "tactic_res": [
                    "_goal : P x'' (app cs cs')"
                ]
            },
            {
                "tactic_sig": "eapply _i .",
                "tactic_sig_no_out_arg": "eapply _i .",
                "tactic_args": [
                    "_goal : P x'' (app cs cs')",
                    "H3 : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)"
                ],
                "tactic_res": [
                    "_goal : step_async_star step_async_init ?st cs",
                    "_goal : P ?st cs",
                    "_goal : step_async ?st x'' cs'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : step_async_star step_async_init ?st cs"
                ],
                "tactic_res": [
                    "_goal : step_async_star step_async_init ?st cs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : step_async_star step_async_init ?st cs"
                ],
                "tactic_res": [
                    "_goal : step_async_star step_async_init ?st cs"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : step_async_star step_async_init ?st cs",
                    "_goal : P ?st cs",
                    "_goal : step_async ?st x'' cs'"
                ],
                "tactic_res": [
                    "_goal : step_async_star step_async_init x' cs",
                    "_goal : P x' cs"
                ]
            },
            {
                "tactic_sig": "apply refl_trans_n1_1n_trace .",
                "tactic_sig_no_out_arg": "apply refl_trans_n1_1n_trace .",
                "tactic_args": [
                    "_goal : step_async_star step_async_init x' cs"
                ],
                "tactic_res": [
                    "_goal : refl_trans_n1_trace step_async step_async_init x' cs"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : refl_trans_n1_trace step_async step_async_init x' cs"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : P x' cs",
                    "IHrefl_trans_n1_trace : forall\n  (P : forall (_ : network)\n         (_ : list (prod name (sum input (list output)))), Prop)\n  (_ : P step_async_init nil)\n  (_ : forall (st st' : network)\n         (tr ev : list (prod name (sum input (list output))))\n         (_ : step_async_star step_async_init st tr) \n         (_ : P st tr) (_ : step_async st st' ev), \n       P st' (app tr ev)) (_ : eq step_async_init step_async_init)\n  (_ : eq step_async step_async), P x' cs"
                ],
                "tactic_res": [
                    "_goal : P step_async_init nil",
                    "_goal : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)",
                    "_goal : eq step_async_init step_async_init",
                    "_goal : eq step_async step_async"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : P step_async_init nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (st st' : network)\n  (tr ev : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init st tr) (_ : P st tr)\n  (_ : step_async st st' ev), P st' (app tr ev)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq step_async_init step_async_init"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq step_async step_async"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "trace_mutex'_no_out_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output)))) \n  (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output)))) \n  (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output)))) \n  (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))",
                    "_goal : forall (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair n (inr nil)) nil))",
                    "IHtr : forall (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))",
                    "H : trace_mutual_exclusion' h nil",
                    "h : option Client_index",
                    "n : name"
                ]
            },
            {
                "tactic_sig": "unfold trace_mutual_exclusion in * .",
                "tactic_sig_no_out_arg": "unfold trace_mutual_exclusion in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : match n with\n| Client _ | _ => True\nend",
                    "H : True",
                    "n : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : match n with\n| Client _ | _ => True\nend"
                ],
                "tactic_res": [
                    "_goal : True",
                    "_goal : True",
                    "Heqn0 : eq n (Client c)",
                    "c : Client_index",
                    "Heqn0 : eq n Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (n : name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inl a)) tr) (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inr b0)) tr) (cons (pair n (inr nil)) nil))",
                    "H : trace_mutual_exclusion' h (cons (pair a0 (inl a)) tr)",
                    "h : option Client_index",
                    "n : name",
                    "a : input",
                    "a0 : name",
                    "H : trace_mutual_exclusion' h (cons (pair a0 (inr b0)) tr)",
                    "b0 : list output"
                ]
            },
            {
                "tactic_sig": "unfold trace_mutual_exclusion in * .",
                "tactic_sig_no_out_arg": "unfold trace_mutual_exclusion in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inl a)) tr) (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inl a)) tr) (cons (pair n (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inl a)) tr) (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : match a0 with\n| Client n0 =>\n    match a with\n    | Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair n (inr nil)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair n (inr nil)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair n (inr nil)) nil))\n        end\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    end\n| Server =>\n    trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))\nend",
                    "H : match a0 with\n| Client n =>\n    match a with\n    | Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then trace_mutual_exclusion' None tr\n            else trace_mutual_exclusion' h tr\n        | None => trace_mutual_exclusion' h tr\n        end\n    | _ => trace_mutual_exclusion' h tr\n    end\n| Server => trace_mutual_exclusion' h tr\nend",
                    "n : Name",
                    "a : Input",
                    "a0 : Name",
                    "IHtr : forall (n : Name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "tr : list (prod Name (sum Input (list Output)))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : match a0 with\n| Client n0 =>\n    match a with\n    | Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair n (inr nil)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair n (inr nil)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair n (inr nil)) nil))\n        end\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    end\n| Server =>\n    trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "H : trace_mutual_exclusion' h tr",
                    "Heqi : eq a Lock",
                    "Heqn0 : eq a0 (Client c)",
                    "c : Client_index",
                    "H : trace_mutual_exclusion' None tr",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqi : eq a Unlock",
                    "H : trace_mutual_exclusion' (Some c0) tr",
                    "n0 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqi : eq a Locked",
                    "Heqn0 : eq a0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold trace_mutual_exclusion in * .",
                "tactic_sig_no_out_arg": "unfold trace_mutual_exclusion in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inr b0)) tr) (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inr b0)) tr) (cons (pair n (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons (pair a0 (inr b0)) tr) (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": [
                    "_goal : match a0 with\n| Client n0 =>\n    match b0 with\n    | nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    | cons Locked nil =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr (cons (pair n (inr nil)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match b0 with\n    | nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    | cons _ _ => False\n    end\nend",
                    "H : match a0 with\n| Client n =>\n    match b0 with\n    | nil => trace_mutual_exclusion' h tr\n    | cons Locked nil =>\n        match h with\n        | Some _ => False\n        | None => trace_mutual_exclusion' (Some n) tr\n        end\n    | _ => False\n    end\n| Server =>\n    match b0 with\n    | nil => trace_mutual_exclusion' h tr\n    | cons _ _ => False\n    end\nend",
                    "n : Name",
                    "b0 : list Output",
                    "a0 : Name",
                    "IHtr : forall (n : Name) (h : option Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "tr : list (prod Name (sum Input (list Output)))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : match a0 with\n| Client n0 =>\n    match b0 with\n    | nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    | cons Locked nil =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr (cons (pair n (inr nil)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match b0 with\n    | nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair n (inr nil)) nil))\n    | cons _ _ => False\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' (Some c) (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))",
                    "_goal : False",
                    "H : trace_mutual_exclusion' h tr",
                    "Heql : eq b0 nil",
                    "Heqn0 : eq a0 (Client c)",
                    "c : Client_index",
                    "H : False",
                    "Heql : eq b0 (cons Lock l)",
                    "Heqo0 : eq o Lock",
                    "l : list Output",
                    "o : Output",
                    "Heql : eq b0 (cons Unlock l)",
                    "Heqo0 : eq o Unlock",
                    "Heqo1 : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heql : eq b0 (cons Locked nil)",
                    "Heql0 : eq l nil",
                    "Heqo0 : eq o Locked",
                    "H : trace_mutual_exclusion' (Some c) tr",
                    "Heqo1 : eq h None",
                    "Heql : eq b0 (cons Locked (cons o0 l0))",
                    "Heql0 : eq l (cons o0 l0)",
                    "l0 : list Output",
                    "o0 : Output",
                    "Heqn0 : eq a0 Server",
                    "Heql : eq b0 (cons o l)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c) (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair n (inr nil)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_no_out_inv",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app nil (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)",
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair c (inr nil)) nil))) \n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)",
                    "IHtr : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (app nil (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h nil) (Some n)",
                    "H : eq (last_holder' h (app nil (cons (pair c (inr nil)) nil))) (Some n)",
                    "n : Client_index",
                    "c : name",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "H : eq match c with\n   | Client _ | _ => h\n   end (Some n)",
                    "c : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq h (Some n)",
                    "Heqn0 : eq c (Client c0)",
                    "c0 : Client_index",
                    "Heqn0 : eq c Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair c (inr nil)) nil))) \n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)",
                    "H : eq (last_holder' h (app (cons a tr) (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "n : Client_index",
                    "c : name",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair c (inr nil)) nil))\n               else\n                last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n) (app tr (cons (pair c (inr nil)) nil))\n       | _ => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n   end) (Some n)",
                    "c : Name",
                    "IHtr : forall (h : option Client_index) (c : Name) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "H : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H : eq (last_holder' None (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : eq (last_holder' (Some c1) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq (last_holder' (Some c0) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "n1 : forall _ : eq c0 c1, False"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "a : Input",
                    "b : list Output"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_no_out_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h nil) (Some n)),\neq (last_holder' h (app nil (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some n)),\neq (last_holder' h (app (cons a tr) (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "IHtr : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h nil) (Some n)),\neq (last_holder' h (app nil (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app nil (cons (pair c (inr nil)) nil))) (Some n)",
                    "H : eq (last_holder' h nil) (Some n)",
                    "n : Client_index",
                    "c : name",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app nil (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq match c with\n   | Client _ | _ => h\n   end (Some n)",
                    "H : eq h (Some n)",
                    "c : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq match c with\n   | Client _ | _ => h\n   end (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "_goal : eq h (Some n)",
                    "Heqn0 : eq c (Client c0)",
                    "c0 : Client_index",
                    "Heqn0 : eq c Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : name) (n : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some n)),\neq (last_holder' h (app (cons a tr) (cons (pair c (inr nil)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app (cons a tr) (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "H : eq (last_holder' h (cons a tr)) (Some n)",
                    "n : Client_index",
                    "c : name",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app (cons a tr) (cons (pair c (inr nil)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair c (inr nil)) nil))\n               else\n                last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n) (app tr (cons (pair c (inr nil)) nil))\n       | _ => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n   end) (Some n)",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "c : Name",
                    "IHtr : forall (h : option Client_index) (c : Name) (n : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair c (inr nil)) nil))\n               else\n                last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair c (inr nil)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n) (app tr (cons (pair c (inr nil)) nil))\n       | _ => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair c (inr nil)) nil))\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' None (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' (Some c1) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' None (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' (Some c0) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)",
                    "H : eq (last_holder' h tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H : eq (last_holder' None tr) (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : eq (last_holder' (Some c1) tr) (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq (last_holder' (Some c0) tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' None (app tr (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) (app tr (cons (pair c (inr nil)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair c (inr nil)) nil))) (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "decomposition_reachable_nw_invariant",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (st : network) (tr : list (prod name (sum input (list output))))\n  (p : packet) (_ : step_async_star step_async_init st tr)\n  (_ : In p (nwPackets st)), network_invariant (nwState st) p"
                ],
                "tactic_res": [
                    "_goal : forall (st : network) (tr : list (prod name (sum input (list output))))\n  (p : packet) (_ : step_async_star step_async_init st tr)\n  (_ : In p (nwPackets st)), network_invariant (nwState st) p"
                ]
            },
            {
                "tactic_sig": "pose proof decomposition_invariant .",
                "tactic_sig_no_out_arg": "pose proof decomposition_invariant .",
                "tactic_args": [],
                "tactic_res": [
                    "H : inductive_invariant step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_args": [],
                "tactic_res": [
                    "H : true_in_reachable step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "unfold true_in_reachable , reachable in * .",
                "tactic_sig_no_out_arg": "unfold true_in_reachable , reachable in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : forall (a : network)\n  (_ : ex\n         (fun out : list (prod name (sum input (list output))) =>\n          refl_trans_1n_trace step_async step_async_init a out)),\ncomposed_invariant a"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : forall (st : network) (tr : list (prod name (sum input (list output))))\n  (p : packet) (_ : step_async_star step_async_init st tr)\n  (_ : In p (nwPackets st)), network_invariant (nwState st) p"
                ],
                "tactic_res": [
                    "_goal : network_invariant (nwState st) p",
                    "H1 : In p (nwPackets st)",
                    "H0 : step_async_star step_async_init st tr",
                    "p : packet",
                    "tr : list (prod name (sum input (list output)))",
                    "st : network"
                ]
            },
            {
                "tactic_sig": "unfold composed_invariant in * .",
                "tactic_sig_no_out_arg": "unfold composed_invariant in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : forall (a : network)\n  (_ : ex\n         (fun out : list (prod name (sum input (list output))) =>\n          refl_trans_1n_trace step_async step_async_init a out)),\nand (state_invariant (nwState a))\n  (and\n     (forall (p : packet) (_ : In p (nwPackets a)),\n      network_invariant (nwState a) p)\n     (distinct_pairs_and network_network_invariant (nwPackets a)))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : network_invariant (nwState st) p",
                    "H : forall (a : network)\n  (_ : ex\n         (fun out : list (prod name (sum input (list output))) =>\n          refl_trans_1n_trace step_async step_async_init a out)),\nand (state_invariant (nwState a))\n  (and\n     (forall (p : packet) (_ : In p (nwPackets a)),\n      network_invariant (nwState a) p)\n     (distinct_pairs_and network_network_invariant (nwPackets a)))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init st out)",
                    "_goal : In p (nwPackets st)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : ex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init st out)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : In p (nwPackets st)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "trace_mutex'_locked_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h tr) (_ : eq (last_holder' h tr) None),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h tr) (_ : eq (last_holder' h tr) None),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h tr) (_ : eq (last_holder' h tr) None),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h nil)\n  (_ : eq (last_holder' h nil) None),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : forall (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr))\n  (_ : eq (last_holder' h (cons a tr)) None),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "IHtr : forall (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h tr) (_ : eq (last_holder' h tr) None),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h nil)\n  (_ : eq (last_holder' h nil) None),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "H0 : eq (last_holder' h nil) None",
                    "H : trace_mutual_exclusion' h nil",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : match h with\n| Some _ => False\n| None => True\nend",
                    "H0 : eq h None",
                    "H : True"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n : Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr))\n  (_ : eq (last_holder' h (cons a tr)) None),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "H0 : eq (last_holder' h (cons a tr)) None",
                    "H : trace_mutual_exclusion' h (cons a tr)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n0 =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    end\nend",
                    "H0 : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) None",
                    "H : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then trace_mutual_exclusion' None tr\n            else trace_mutual_exclusion' h tr\n        | None => trace_mutual_exclusion' h tr\n        end\n    | inl Lock | inl Locked | inr nil => trace_mutual_exclusion' h tr\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None => trace_mutual_exclusion' (Some n) tr\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ => trace_mutual_exclusion' h tr\n    end\nend",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : match h with\n| Some _ => False\n| None => True\nend"
                ],
                "tactic_res": [
                    "_goal : True"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n0 =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n0 =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    end\nend"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n0 =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n0 m\n            then\n             trace_mutual_exclusion' None\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr\n                  (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n0)\n              (app tr\n                 (cons (pair (Client n) (inr (cons Locked nil))) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' (Some c)\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))",
                    "_goal : False",
                    "H0 : eq (last_holder' h tr) None",
                    "H : trace_mutual_exclusion' h tr",
                    "Heqp : eq a (pair (Client c) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c)",
                    "c : Client_index",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H0 : eq (last_holder' None tr) None",
                    "H : trace_mutual_exclusion' None tr",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqp : eq a (pair (Client c) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H0 : eq (last_holder' (Some c0) tr) None",
                    "H : trace_mutual_exclusion' (Some c0) tr",
                    "n1 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "H : False",
                    "Heqp : eq a (pair (Client c) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H0 : eq (last_holder' (Some c) tr) None",
                    "Heqo1 : eq h (Some c0)",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "H : trace_mutual_exclusion' (Some c) tr",
                    "Heqo1 : eq h None",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server (inl i))",
                    "Heqs0 : eq s (inl i)",
                    "Heqn1 : eq n0 Server",
                    "Heqp : eq a (pair Server (inr nil))",
                    "Heqp : eq a (pair Server (inr (cons o l0)))",
                    "Heqs0 : eq s (inr (cons o l0))",
                    "Heql0 : eq l (cons o l0)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c)\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "reachable_intro",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (a : network) (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init a tr),\nreachable step_async step_async_init a"
                ],
                "tactic_res": [
                    "_goal : forall (a : network) (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init a tr),\nreachable step_async step_async_init a"
                ]
            },
            {
                "tactic_sig": "unfold reachable .",
                "tactic_sig_no_out_arg": "unfold reachable .",
                "tactic_args": [
                    "_goal : forall (a : network) (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init a tr),\nreachable step_async step_async_init a"
                ],
                "tactic_res": [
                    "_goal : forall (a : network) (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init a tr),\nex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init a out)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (a : network) (tr : list (prod name (sum input (list output))))\n  (_ : step_async_star step_async_init a tr),\nex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init a out)"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init a out)",
                    "H : step_async_star step_async_init a tr",
                    "tr : list (prod name (sum input (list output)))",
                    "a : network"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : ex\n  (fun out : list (prod name (sum input (list output))) =>\n   refl_trans_1n_trace step_async step_async_init a out)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_locked_invariant",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (st : network) (p : packet)\n  (_ : reachable step_async step_async_init st)\n  (_ : In p (nwPackets st)), locks_correct_locked (nwState st) p"
                ],
                "tactic_res": [
                    "_goal : forall (st : network) (p : packet)\n  (_ : reachable step_async step_async_init st)\n  (_ : In p (nwPackets st)), locks_correct_locked (nwState st) p"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (st : network) (p : packet)\n  (_ : reachable step_async step_async_init st)\n  (_ : In p (nwPackets st)), locks_correct_locked (nwState st) p"
                ],
                "tactic_res": [
                    "_goal : locks_correct_locked (nwState st) p",
                    "H0 : In p (nwPackets st)",
                    "H : reachable step_async step_async_init st",
                    "p : packet",
                    "st : network"
                ]
            },
            {
                "tactic_sig": "pose proof decomposition_invariant .",
                "tactic_sig_no_out_arg": "pose proof decomposition_invariant .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : inductive_invariant step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : true_in_reachable step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "unfold true_in_reachable in * .",
                "tactic_sig_no_out_arg": "unfold true_in_reachable in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : locks_correct_locked (nwState st) p",
                    "H1 : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ],
                "tactic_res": [
                    "_goal : reachable step_async step_async_init st",
                    "_goal : In p (nwPackets st)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : reachable step_async step_async_init st"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : In p (nwPackets st)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "locks_correct_invariant",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nlocks_correct (nwState st)"
                ],
                "tactic_res": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nlocks_correct (nwState st)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nlocks_correct (nwState st)"
                ],
                "tactic_res": [
                    "_goal : locks_correct (nwState st)",
                    "H : reachable step_async step_async_init st",
                    "st : network"
                ]
            },
            {
                "tactic_sig": "pose proof decomposition_invariant .",
                "tactic_sig_no_out_arg": "pose proof decomposition_invariant .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : inductive_invariant step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp inductive_invariant_true_in_reachable .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : true_in_reachable step_async step_async_init composed_invariant"
                ]
            },
            {
                "tactic_sig": "unfold true_in_reachable in * .",
                "tactic_sig_no_out_arg": "unfold true_in_reachable in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : locks_correct (nwState st)",
                    "H0 : forall (a : network) (_ : reachable step_async step_async_init a),\ncomposed_invariant a"
                ],
                "tactic_res": [
                    "_goal : reachable step_async step_async_init st"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : reachable step_async step_async_init st"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mutual_exclusion_invariant",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nmutual_exclusion (nwState st)"
                ],
                "tactic_res": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nmutual_exclusion (nwState st)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (st : network) (_ : reachable step_async step_async_init st),\nmutual_exclusion (nwState st)"
                ],
                "tactic_res": [
                    "_goal : mutual_exclusion (nwState st)",
                    "H : reachable step_async step_async_init st",
                    "st : network"
                ]
            },
            {
                "tactic_sig": "apply locks_correct_implies_mutex .",
                "tactic_sig_no_out_arg": "apply locks_correct_implies_mutex .",
                "tactic_args": [
                    "_goal : mutual_exclusion (nwState st)"
                ],
                "tactic_res": [
                    "_goal : locks_correct (nwState st)"
                ]
            },
            {
                "tactic_sig": "auto using locks_correct_invariant .",
                "tactic_sig_no_out_arg": "auto using locks_correct_invariant .",
                "tactic_args": [
                    "_goal : locks_correct (nwState st)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_locked_some_eq",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app nil\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n",
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr)\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n",
                    "IHtr : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n",
                    "tr : list (prod Name (sum input (list Msg)))",
                    "a : prod Name (sum input (list Msg))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app nil\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n"
                ],
                "tactic_res": [
                    "_goal : eq c n",
                    "H : eq\n  (last_holder' h\n     (app nil (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "c : Client_index",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (Some c) (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq c n"
                ],
                "tactic_res": [
                    "_goal : eq c n"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : eq c n"
                ],
                "tactic_res": [
                    "_goal : eq c n"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq c n"
                ],
                "tactic_res": [
                    "_goal : eq c n"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr)\n               (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n         (Some n)), eq c n"
                ],
                "tactic_res": [
                    "H : eq\n  (last_holder' h\n     (app (cons a tr)\n        (cons (pair (Client c) (inr (cons Locked nil))) nil))) \n  (Some n)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr\n                     (cons (pair (Client c) (inr (cons Locked nil)))\n                        nil))\n               else\n                last_holder' h\n                  (app tr\n                     (cons (pair (Client c) (inr (cons Locked nil)))\n                        nil))\n           | None =>\n               last_holder' h\n                 (app tr\n                    (cons (pair (Client c) (inr (cons Locked nil))) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr\n                (cons (pair (Client c) (inr (cons Locked nil))) nil))\n       | _ =>\n           last_holder' h\n             (app tr\n                (cons (pair (Client c) (inr (cons Locked nil))) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inr (cons Locked nil))) nil))\n   end) (Some n)",
                    "tr : list (prod Name (sum Input (list Msg)))",
                    "a : prod Name (sum Input (list Msg))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq\n  (last_holder' h\n     (app tr (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Msg)",
                    "n0 : Name",
                    "H : eq\n  (last_holder' None\n     (app tr (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Msg",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqm0 : eq m Lock",
                    "l0 : list Msg",
                    "m : Msg",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqm0 : eq m Unlock",
                    "H : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqm0 : eq m Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons m0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons m0 l1)))",
                    "Heql0 : eq l (cons Locked (cons m0 l1))",
                    "Heql1 : eq l0 (cons m0 l1)",
                    "l1 : list Msg",
                    "m0 : Msg",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq c n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_server_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input),\neq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input),\neq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input),\neq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (i : input),\neq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n  (last_holder' h nil)",
                    "_goal : forall (h : option Client_index) (i : input),\neq (last_holder' h (app (cons a tr) (cons (pair Server (inl i)) nil)))\n  (last_holder' h (cons a tr))",
                    "IHtr : forall (h : option Client_index) (i : input),\neq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "tr : list (prod Name (sum input (list output)))",
                    "a : prod Name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input),\neq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n  (last_holder' h nil)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n  (last_holder' h nil)",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n  (last_holder' h nil)"
                ],
                "tactic_res": [
                    "_goal : eq h h",
                    "i : Input"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq h h"
                ],
                "tactic_res": [
                    "_goal : eq h h"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq h h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input),\neq (last_holder' h (app (cons a tr) (cons (pair Server (inl i)) nil)))\n  (last_holder' h (cons a tr))"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app (cons a tr) (cons (pair Server (inl i)) nil)))\n  (last_holder' h (cons a tr))",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app (cons a tr) (cons (pair Server (inl i)) nil)))\n  (last_holder' h (cons a tr))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair Server (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair Server (inl i)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair Server (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair Server (inl i)) nil))\n       | _ => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n   end)\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end)",
                    "i : Input",
                    "IHtr : forall (h : option Client_index) (i : Input),\neq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair Server (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair Server (inl i)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair Server (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair Server (inl i)) nil))\n       | _ => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n   end)\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' None (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' None tr)",
                    "_goal : eq (last_holder' (Some c0) (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' (Some c0) tr)",
                    "_goal : eq (last_holder' None (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' None tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' (Some c) (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' (Some c) tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)",
                    "Heqp : eq a (pair (Client c) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi1 : eq i0 Lock",
                    "i0 : Input",
                    "Heqn0 : eq n (Client c)",
                    "c : Client_index",
                    "s : sum Input (list Output)",
                    "n : Name",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqp : eq a (pair (Client c) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi1 : eq i0 Unlock",
                    "n0 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi1 : eq i0 Locked",
                    "Heqp : eq a (pair (Client c) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn0 : eq n Server"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' (Some c0) tr)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' None tr)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c) (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' (Some c) tr)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n  (last_holder' h tr)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_locked_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list Msg))))\n  (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : forall (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app (cons a tr)\n        (cons (pair (Client n) (inr (cons Locked nil))) nil))) \n  (Some n)",
                    "IHtr : forall (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "tr : list (prod Name (sum input (list Msg)))",
                    "a : prod Name (sum input (list Msg))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app nil (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some n) (Some n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some n) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n : Client_index),\neq\n  (last_holder' h\n     (app (cons a tr)\n        (cons (pair (Client n) (inr (cons Locked nil))) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr)\n        (cons (pair (Client n) (inr (cons Locked nil))) nil))) \n  (Some n)",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr)\n        (cons (pair (Client n) (inr (cons Locked nil))) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n0 =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n0 m\n               then\n                last_holder' None\n                  (app tr\n                     (cons (pair (Client n) (inr (cons Locked nil)))\n                        nil))\n               else\n                last_holder' h\n                  (app tr\n                     (cons (pair (Client n) (inr (cons Locked nil)))\n                        nil))\n           | None =>\n               last_holder' h\n                 (app tr\n                    (cons (pair (Client n) (inr (cons Locked nil))) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n0)\n             (app tr\n                (cons (pair (Client n) (inr (cons Locked nil))) nil))\n       | _ =>\n           last_holder' h\n             (app tr\n                (cons (pair (Client n) (inr (cons Locked nil))) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n   end) (Some n)",
                    "tr : list (prod Name (sum Input (list Msg)))",
                    "a : prod Name (sum Input (list Msg))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n0 =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n0 m\n               then\n                last_holder' None\n                  (app tr\n                     (cons (pair (Client n) (inr (cons Locked nil)))\n                        nil))\n               else\n                last_holder' h\n                  (app tr\n                     (cons (pair (Client n) (inr (cons Locked nil)))\n                        nil))\n           | None =>\n               last_holder' h\n                 (app tr\n                    (cons (pair (Client n) (inr (cons Locked nil))) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n0)\n             (app tr\n                (cons (pair (Client n) (inr (cons Locked nil))) nil))\n       | _ =>\n           last_holder' h\n             (app tr\n                (cons (pair (Client n) (inr (cons Locked nil))) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil))\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' None\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' None\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c)\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c)",
                    "c : Client_index",
                    "s : sum Input (list Msg)",
                    "n0 : Name",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqp : eq a (pair (Client c) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "n1 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Msg",
                    "Heqp : eq a (pair (Client c) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqm0 : eq m Lock",
                    "l0 : list Msg",
                    "m : Msg",
                    "Heqp : eq a (pair (Client c) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqm0 : eq m Unlock",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqm0 : eq m Locked",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked (cons m0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons m0 l1)))",
                    "Heql0 : eq l (cons Locked (cons m0 l1))",
                    "Heql1 : eq l0 (cons m0 l1)",
                    "l1 : list Msg",
                    "m0 : Msg",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' None\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c)\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app tr (cons (pair (Client n) (inr (cons Locked nil))) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "trace_mutual_exclusion'_extend_input",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl i)) nil))",
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (_ : not (eq i Unlock))\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl i)) nil))",
                    "IHtr : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (_ : not (eq i Unlock)) (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl i)) nil))",
                    "H0 : trace_mutual_exclusion' h nil",
                    "H : not (eq i Unlock)",
                    "i : Msg",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : match i with\n| Unlock =>\n    match h with\n    | Some m => if fin_eq_dec num_Clients c m then True else True\n    | None => True\n    end\n| _ => True\nend",
                    "H0 : True"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : match i with\n| Unlock =>\n    match h with\n    | Some m => if fin_eq_dec num_Clients c m then True else True\n    | None => True\n    end\n| _ => True\nend"
                ],
                "tactic_res": [
                    "_goal : True",
                    "_goal : True",
                    "_goal : True",
                    "_goal : True",
                    "_goal : True",
                    "H : not (eq Lock Unlock)",
                    "Heqm : eq i Lock",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "H : not (eq Unlock Unlock)",
                    "Heqm : eq i Unlock",
                    "n : not (eq c c0)",
                    "Heqo : eq h None",
                    "H : not (eq Locked Unlock)",
                    "Heqm : eq i Locked"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (_ : not (eq i Unlock))\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl i)) nil))",
                    "H0 : trace_mutual_exclusion' h (cons a tr)",
                    "H : not (eq i Unlock)",
                    "i : Msg",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair (Client c) (inl i)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair (Client c) (inl i)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair (Client c) (inl i)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl i)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair (Client c) (inl i)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl i)) nil))\n    end\nend",
                    "H0 : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then trace_mutual_exclusion' None tr\n            else trace_mutual_exclusion' h tr\n        | None => trace_mutual_exclusion' h tr\n        end\n    | inl Lock | inl Locked | inr nil => trace_mutual_exclusion' h tr\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None => trace_mutual_exclusion' (Some n) tr\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ => trace_mutual_exclusion' h tr\n    end\nend",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair (Client c) (inl i)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair (Client c) (inl i)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair (Client c) (inl i)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl i)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair (Client c) (inl i)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl i)) nil))\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' (Some c1)\n  (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))",
                    "_goal : False",
                    "H0 : trace_mutual_exclusion' h tr",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi1 : eq i0 Lock",
                    "i0 : Input",
                    "Heqn0 : eq n (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Output)",
                    "n : Name",
                    "H0 : trace_mutual_exclusion' None tr",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi1 : eq i0 Unlock",
                    "H0 : trace_mutual_exclusion' (Some c1) tr",
                    "n0 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi1 : eq i0 Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "H0 : False",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "Heqo1 : eq h (Some c1)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "H0 : trace_mutual_exclusion' (Some c0) tr",
                    "Heqo1 : eq h None",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server (inl i0))",
                    "Heqs0 : eq s (inl i0)",
                    "Heqn0 : eq n Server",
                    "Heqp : eq a (pair Server (inr nil))",
                    "Heqp : eq a (pair Server (inr (cons o l0)))",
                    "Heqs0 : eq s (inr (cons o l0))",
                    "Heql0 : eq l (cons o l0)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c1)\n  (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair (Client c) (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "trace_mutual_exclusion'_extend_input_server",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h (app nil (cons (pair Server (inl i)) nil))",
                    "_goal : forall (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair Server (inl i)) nil))",
                    "IHtr : forall (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h (app nil (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair Server (inl i)) nil))",
                    "H : trace_mutual_exclusion' h nil",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app nil (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : True",
                    "H : True",
                    "i : Input"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": [
                    "_goal : True"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair Server (inl i)) nil))",
                    "H : trace_mutual_exclusion' h (cons a tr)",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair Server (inl i)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair Server (inl i)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair Server (inl i)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair Server (inl i)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair Server (inl i)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair Server (inl i)) nil))\n    end\nend",
                    "H : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then trace_mutual_exclusion' None tr\n            else trace_mutual_exclusion' h tr\n        | None => trace_mutual_exclusion' h tr\n        end\n    | inl Lock | inl Locked | inr nil => trace_mutual_exclusion' h tr\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None => trace_mutual_exclusion' (Some n) tr\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ => trace_mutual_exclusion' h tr\n    end\nend",
                    "i : Input",
                    "IHtr : forall (h : option Client_index) (i : Input)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair Server (inl i)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair Server (inl i)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair Server (inl i)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair Server (inl i)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair Server (inl i)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair Server (inl i)) nil))\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' (Some c)\n  (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))",
                    "_goal : False",
                    "H : trace_mutual_exclusion' h tr",
                    "Heqp : eq a (pair (Client c) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi1 : eq i0 Lock",
                    "i0 : Input",
                    "Heqn0 : eq n (Client c)",
                    "c : Client_index",
                    "s : sum Input (list Output)",
                    "n : Name",
                    "H : trace_mutual_exclusion' None tr",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqp : eq a (pair (Client c) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi1 : eq i0 Unlock",
                    "H : trace_mutual_exclusion' (Some c0) tr",
                    "n0 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi1 : eq i0 Locked",
                    "Heqp : eq a (pair (Client c) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "H : False",
                    "Heqp : eq a (pair (Client c) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "Heqo1 : eq h (Some c0)",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "H : trace_mutual_exclusion' (Some c) tr",
                    "Heqo1 : eq h None",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server (inl i0))",
                    "Heqs0 : eq s (inl i0)",
                    "Heqn0 : eq n Server",
                    "Heqp : eq a (pair Server (inr nil))",
                    "Heqp : eq a (pair Server (inr (cons o l0)))",
                    "Heqs0 : eq s (inr (cons o l0))",
                    "Heql0 : eq l (cons o l0)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' None (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c)\n  (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h (app tr (cons (pair Server (inl i)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_input_inv",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)",
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)",
                    "IHtr : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod Name (sum Msg (list output)))",
                    "a : prod Name (sum Msg (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h nil) (Some n)",
                    "H0 : eq (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "H : not (eq i Unlock)",
                    "n : Client_index",
                    "i : Msg",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "H0 : eq\n  match i with\n  | Unlock =>\n      match h with\n      | Some m => if fin_eq_dec num_Clients c m then None else h\n      | None => h\n      end\n  | _ => h\n  end (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq None (Some n)",
                    "H0 : eq h (Some n)",
                    "H : not (eq Lock Unlock)",
                    "Heqm : eq i Lock",
                    "H0 : eq None (Some n)",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "H : not (eq Unlock Unlock)",
                    "Heqm : eq i Unlock",
                    "H0 : eq (Some c0) (Some n)",
                    "n0 : not (eq c c0)",
                    "Heqo : eq h None",
                    "H : not (eq Locked Unlock)",
                    "Heqm : eq i Locked"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some c0) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq None (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair (Client c) (inl i)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)",
                    "H0 : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl i)) nil))) \n  (Some n)",
                    "H : not (eq i Unlock)",
                    "n : Client_index",
                    "i : Msg",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "H0 : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl i)) nil))\n       | _ =>\n           last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n       end\n   | Server =>\n       last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n   end) (Some n)",
                    "tr : list (prod Name (sum Msg (list Output)))",
                    "a : prod Name (sum Msg (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "H0 : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqm0 : eq m Lock",
                    "m : Msg",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Msg (list Output)",
                    "n0 : Name",
                    "H0 : eq (last_holder' None (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqm0 : eq m Unlock",
                    "H0 : eq\n  (last_holder' (Some c1) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqm0 : eq m Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H0 : eq\n  (last_holder' (Some c0) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_input_inv_server",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum input (list output))))\n  (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)",
                    "_goal : forall (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)",
                    "IHtr : forall (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod Name (sum input (list output)))",
                    "a : prod Name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq (last_holder' h (app nil (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h nil) (Some n)",
                    "H : eq (last_holder' h (app nil (cons (pair Server (inl i)) nil))) (Some n)",
                    "n : Client_index",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "H : eq h (Some n)",
                    "i : Input"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (i : input) (n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)",
                    "H : eq (last_holder' h (app (cons a tr) (cons (pair Server (inl i)) nil)))\n  (Some n)",
                    "n : Client_index",
                    "i : input",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair Server (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair Server (inl i)) nil))\n           | None =>\n               last_holder' h (app tr (cons (pair Server (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair Server (inl i)) nil))\n       | _ => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n       end\n   | Server => last_holder' h (app tr (cons (pair Server (inl i)) nil))\n   end) (Some n)",
                    "i : Input",
                    "IHtr : forall (h : option Client_index) (i : Input) (n : Client_index)\n  (_ : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' (Some c) tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "H : eq (last_holder' h (app tr (cons (pair Server (inl i)) nil))) (Some n)",
                    "Heqp : eq a (pair (Client c) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi1 : eq i0 Lock",
                    "i0 : Input",
                    "Heqn1 : eq n0 (Client c)",
                    "c : Client_index",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H : eq (last_holder' None (app tr (cons (pair Server (inl i)) nil)))\n  (Some n)",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "Heqp : eq a (pair (Client c) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi1 : eq i0 Unlock",
                    "H : eq (last_holder' (Some c0) (app tr (cons (pair Server (inl i)) nil)))\n  (Some n)",
                    "n1 : not (eq c c0)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi1 : eq i0 Locked",
                    "Heqp : eq a (pair (Client c) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq (last_holder' (Some c) (app tr (cons (pair Server (inl i)) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_input_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index) (i : Msg)\n  (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h nil) (Some n)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h (cons a tr)) (Some n)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl i)) nil))) \n  (Some n)",
                    "IHtr : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h tr) (Some n)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h nil) (Some n)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "H0 : eq (last_holder' h nil) (Some n)",
                    "H : not (eq i Unlock)",
                    "n : Client_index",
                    "i : Msg",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  match i with\n  | Unlock =>\n      match h with\n      | Some m => if fin_eq_dec num_Clients c m then None else h\n      | None => h\n      end\n  | _ => h\n  end (Some n)",
                    "H0 : eq h (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  match i with\n  | Unlock =>\n      match h with\n      | Some m => if fin_eq_dec num_Clients c m then None else h\n      | None => h\n      end\n  | _ => h\n  end (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "_goal : eq None (Some n)",
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq None (Some n)",
                    "_goal : eq h (Some n)",
                    "H : not (eq Lock Unlock)",
                    "Heqm : eq i Lock",
                    "e : eq c c0",
                    "H0 : eq (Some c0) (Some n)",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "H : not (eq Unlock Unlock)",
                    "Heqm : eq i Unlock",
                    "n0 : not (eq c c0)",
                    "H0 : eq None (Some n)",
                    "Heqo : eq h None",
                    "H : not (eq Locked Unlock)",
                    "Heqm : eq i Locked"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq None (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq None (Some n)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index) \n  (i : Msg) (n : Client_index) (_ : not (eq i Unlock))\n  (_ : eq (last_holder' h (cons a tr)) (Some n)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl i)) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl i)) nil))) \n  (Some n)",
                    "H0 : eq (last_holder' h (cons a tr)) (Some n)",
                    "H : not (eq i Unlock)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl i)) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl i)) nil))\n       | _ =>\n           last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n       end\n   | Server =>\n       last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n   end) (Some n)",
                    "H0 : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl i)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl i)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl i)) nil))\n       | _ =>\n           last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n       end\n   | Server =>\n       last_holder' h (app tr (cons (pair (Client c) (inl i)) nil))\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' None (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c1) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' None (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c0) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)",
                    "H0 : eq (last_holder' h tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi1 : eq i0 Lock",
                    "i0 : Input",
                    "Heqn1 : eq n0 (Client c0)",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H0 : eq (last_holder' None tr) (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi1 : eq i0 Unlock",
                    "H0 : eq (last_holder' (Some c1) tr) (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi1 : eq i0 Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H0 : eq (last_holder' (Some c0) tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c1) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c0) (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl i)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq None (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "trace_mutex'_unlock_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))",
                    "IHtr : forall (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h tr),\ntrace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h nil),\ntrace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl Unlock)) nil))",
                    "H : trace_mutual_exclusion' h nil",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app nil (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : match h with\n| Some m => if fin_eq_dec num_Clients c m then True else True\n| None => True\nend",
                    "H : True"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : match h with\n| Some m => if fin_eq_dec num_Clients c m then True else True\n| None => True\nend"
                ],
                "tactic_res": [
                    "_goal : True",
                    "_goal : True",
                    "_goal : True",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "n : not (eq c c0)",
                    "Heqo : eq h None"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : trace_mutual_exclusion' h (cons a tr)),\ntrace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))",
                    "H : trace_mutual_exclusion' h (cons a tr)",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair (Client c) (inl Unlock)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl Unlock)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl Unlock)) nil))\n    end\nend",
                    "H : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then trace_mutual_exclusion' None tr\n            else trace_mutual_exclusion' h tr\n        | None => trace_mutual_exclusion' h tr\n        end\n    | inl Lock | inl Locked | inr nil => trace_mutual_exclusion' h tr\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None => trace_mutual_exclusion' (Some n) tr\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ => trace_mutual_exclusion' h tr\n    end\nend",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : let (_n, s) := a in\nmatch _n with\n| Client n =>\n    match s with\n    | inl Unlock =>\n        match h with\n        | Some m =>\n            if fin_eq_dec num_Clients n m\n            then\n             trace_mutual_exclusion' None\n               (app tr (cons (pair (Client c) (inl Unlock)) nil))\n            else\n             trace_mutual_exclusion' h\n               (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        | None =>\n            trace_mutual_exclusion' h\n              (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        end\n    | inl Lock | inl Locked | inr nil =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl Unlock)) nil))\n    | inr (cons Locked nil) =>\n        match h with\n        | Some _ => False\n        | None =>\n            trace_mutual_exclusion' (Some n)\n              (app tr (cons (pair (Client c) (inl Unlock)) nil))\n        end\n    | _ => False\n    end\n| Server =>\n    match s with\n    | inr (cons _ _) => False\n    | _ =>\n        trace_mutual_exclusion' h\n          (app tr (cons (pair (Client c) (inl Unlock)) nil))\n    end\nend"
                ],
                "tactic_res": [
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' (Some c1)\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : False",
                    "_goal : False",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : False",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))",
                    "_goal : False",
                    "H : trace_mutual_exclusion' h tr",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn0 : eq n (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Output)",
                    "n : Name",
                    "H : trace_mutual_exclusion' None tr",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : trace_mutual_exclusion' (Some c1) tr",
                    "n0 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "H : False",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "Heqo1 : eq h (Some c1)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "H : trace_mutual_exclusion' (Some c0) tr",
                    "Heqo1 : eq h None",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server (inl i))",
                    "Heqs0 : eq s (inl i)",
                    "Heqn0 : eq n Server",
                    "Heqp : eq a (pair Server (inr nil))",
                    "Heqp : eq a (pair Server (inr (cons o l0)))",
                    "Heqs0 : eq s (inr (cons o l0))",
                    "Heql0 : eq l (cons o l0)"
                ]
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c1)\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' None\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' (Some c0)\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : trace_mutual_exclusion' h\n  (app tr (cons (pair (Client c) (inl Unlock)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition ( auto ; try congruence ) .",
                "tactic_sig_no_out_arg": "intuition ( auto ; try congruence ) .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_unlock_none",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h tr) (Some c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h tr) (Some c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h tr) (Some c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h nil) (Some c)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some c)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))) None",
                    "IHtr : forall (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h tr) (Some c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h nil) (Some c)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "H : eq (last_holder' h nil) (Some c)",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : eq\n  match h with\n  | Some m => if fin_eq_dec num_Clients c m then None else h\n  | None => h\n  end None",
                    "H : eq h (Some c)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  match h with\n  | Some m => if fin_eq_dec num_Clients c m then None else h\n  | None => h\n  end None"
                ],
                "tactic_res": [
                    "_goal : eq None None",
                    "_goal : eq (Some c0) None",
                    "_goal : eq None None",
                    "e : eq c c0",
                    "H : eq (Some c0) (Some c)",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "n : not (eq c c0)",
                    "H : eq None (Some c)",
                    "Heqo : eq h None"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "n : forall _ : eq c c0, False"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq None None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some c)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))) None"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))) None",
                    "H : eq (last_holder' h (cons a tr)) (Some c)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil))) None"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       | _ =>\n           last_holder' h\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inl Unlock)) nil))\n   end) None",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some c)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       | _ =>\n           last_holder' h\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inl Unlock)) nil))\n   end) None"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) None",
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "H : eq (last_holder' h tr) (Some c)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn0 : eq n (Client c0)",
                    "s : sum Input (list Output)",
                    "n : Name",
                    "H : eq (last_holder' None tr) (Some c)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : eq (last_holder' (Some c1) tr) (Some c)",
                    "n0 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq (last_holder' (Some c0) tr) (Some c)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn0 : eq n Server"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq (Some c0) None"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder_unlock_none",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (c : Client_index) (_ : eq (last_holder tr) (Some c)),\neq (last_holder (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (c : Client_index) (_ : eq (last_holder tr) (Some c)),\neq (last_holder (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (c : Client_index) (_ : eq (last_holder tr) (Some c)),\neq (last_holder (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None",
                    "H : eq (last_holder tr) (Some c)",
                    "c : Client_index",
                    "tr : list (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "apply last_holder'_unlock_none .",
                "tactic_sig_no_out_arg": "apply last_holder'_unlock_none .",
                "tactic_args": [
                    "_goal : eq (last_holder (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  None"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some c)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder_some_unlock_inv",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod Name (sum Msg (list output))))\n  (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)",
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)",
                    "IHtr : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h tr) (Some n)",
                    "tr : list (prod Name (sum Msg (list output)))",
                    "a : prod Name (sum Msg (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h nil) (Some n)",
                    "H : eq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "c : Client_index",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h nil) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq h (Some n)",
                    "H : eq\n  match h with\n  | Some m => if fin_eq_dec num_Clients c m then None else h\n  | None => h\n  end (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq h (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq None (Some n)",
                    "H : eq None (Some n)",
                    "e : eq c c0",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "H : eq (Some c0) (Some n)",
                    "n0 : not (eq c c0)",
                    "Heqo : eq h None"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (Some c0) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq None (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (c n : Client_index)\n  (_ : eq\n         (last_holder' h\n            (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n         (Some n)), eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)",
                    "H : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "c : Client_index",
                    "n : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (cons a tr)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       | _ =>\n           last_holder' h\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inl Unlock)) nil))\n   end) (Some n)",
                    "tr : list (prod Name (sum Msg (list Output)))",
                    "a : prod Name (sum Msg (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)",
                    "_goal : eq (last_holder' None tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "_goal : eq (last_holder' h tr) (Some n)",
                    "H : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqm0 : eq m Lock",
                    "m : Msg",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Msg (list Output)",
                    "n0 : Name",
                    "H : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqm0 : eq m Unlock",
                    "H : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqm0 : eq m Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "n1 : forall _ : eq c0 c1, False"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c1) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' None tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' (Some c0) tr) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "a : Msg",
                    "b : list Output"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (last_holder' h tr) (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "last_holder'_neq_unlock_extend",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "induction tr .",
                "tactic_sig_no_out_arg": "induction tr .",
                "tactic_args": [
                    "_goal : forall (tr : list (prod name (sum input (list output))))\n  (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : forall (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h nil) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : forall (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some n)) (_ : not (eq n c)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "IHtr : forall (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h tr) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "tr : list (prod name (sum input (list output)))",
                    "a : prod name (sum input (list output))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h nil) (Some n)) (_ : not (eq n c)),\neq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "H0 : not (eq n c)",
                    "H : eq (last_holder' h nil) (Some n)",
                    "n : Client_index",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app nil (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  match h with\n  | Some m => if fin_eq_dec num_Clients c m then None else h\n  | None => h\n  end (Some n)",
                    "H : eq h (Some n)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  match h with\n  | Some m => if fin_eq_dec num_Clients c m then None else h\n  | None => h\n  end (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq None (Some n)",
                    "_goal : eq (Some c0) (Some n)",
                    "_goal : eq None (Some n)",
                    "e : eq c c0",
                    "H : eq (Some c0) (Some n)",
                    "Heqo : eq h (Some c0)",
                    "c0 : Client_index",
                    "n0 : not (eq c c0)",
                    "H : eq None (Some n)",
                    "Heqo : eq h None"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : not (eq n c0)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (Some c0) (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq None (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : option Client_index) (n c : Client_index)\n  (_ : eq (last_holder' h (cons a tr)) (Some n)) (_ : not (eq n c)),\neq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "H0 : not (eq n c)",
                    "H : eq (last_holder' h (cons a tr)) (Some n)",
                    "n : Client_index",
                    "c : Client_index",
                    "h : option Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' h\n     (app (cons a tr) (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       | _ =>\n           last_holder' h\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inl Unlock)) nil))\n   end) (Some n)",
                    "H : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then last_holder' None tr\n               else last_holder' h tr\n           | None => last_holder' h tr\n           end\n       | inr (cons Locked nil) => last_holder' (Some n) tr\n       | _ => last_holder' h tr\n       end\n   | Server => last_holder' h tr\n   end) (Some n)",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "a : prod Name (sum Input (list Output))"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : eq\n  (let (_n, s) := a in\n   match _n with\n   | Client n =>\n       match s with\n       | inl Unlock =>\n           match h with\n           | Some m =>\n               if fin_eq_dec num_Clients n m\n               then\n                last_holder' None\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n               else\n                last_holder' h\n                  (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           | None =>\n               last_holder' h\n                 (app tr (cons (pair (Client c) (inl Unlock)) nil))\n           end\n       | inr (cons Locked nil) =>\n           last_holder' (Some n)\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       | _ =>\n           last_holder' h\n             (app tr (cons (pair (Client c) (inl Unlock)) nil))\n       end\n   | Server =>\n       last_holder' h\n         (app tr (cons (pair (Client c) (inl Unlock)) nil))\n   end) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)",
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)",
                    "H : eq (last_holder' h tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inl Lock))",
                    "Heqs0 : eq s (inl Lock)",
                    "Heqi0 : eq i Lock",
                    "i : Input",
                    "Heqn1 : eq n0 (Client c0)",
                    "c0 : Client_index",
                    "s : sum Input (list Output)",
                    "n0 : Name",
                    "H : eq (last_holder' None tr) (Some n)",
                    "e : eq c0 c1",
                    "Heqo : eq h (Some c1)",
                    "c1 : Client_index",
                    "Heqp : eq a (pair (Client c0) (inl Unlock))",
                    "Heqs0 : eq s (inl Unlock)",
                    "Heqi0 : eq i Unlock",
                    "H : eq (last_holder' (Some c1) tr) (Some n)",
                    "n1 : not (eq c0 c1)",
                    "Heqo : eq h None",
                    "Heqp : eq a (pair (Client c0) (inl Locked))",
                    "Heqs0 : eq s (inl Locked)",
                    "Heqi0 : eq i Locked",
                    "Heqp : eq a (pair (Client c0) (inr nil))",
                    "Heqs0 : eq s (inr nil)",
                    "Heql0 : eq l nil",
                    "l : list Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Lock l0)))",
                    "Heqs0 : eq s (inr (cons Lock l0))",
                    "Heql0 : eq l (cons Lock l0)",
                    "Heqo0 : eq o Lock",
                    "l0 : list Output",
                    "o : Output",
                    "Heqp : eq a (pair (Client c0) (inr (cons Unlock l0)))",
                    "Heqs0 : eq s (inr (cons Unlock l0))",
                    "Heql0 : eq l (cons Unlock l0)",
                    "Heqo0 : eq o Unlock",
                    "H : eq (last_holder' (Some c0) tr) (Some n)",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked nil)))",
                    "Heqs0 : eq s (inr (cons Locked nil))",
                    "Heql0 : eq l (cons Locked nil)",
                    "Heql1 : eq l0 nil",
                    "Heqo0 : eq o Locked",
                    "Heqp : eq a (pair (Client c0) (inr (cons Locked (cons o0 l1))))",
                    "Heqs0 : eq s (inr (cons Locked (cons o0 l1)))",
                    "Heql0 : eq l (cons Locked (cons o0 l1))",
                    "Heql1 : eq l0 (cons o0 l1)",
                    "l1 : list Output",
                    "o0 : Output",
                    "Heqp : eq a (pair Server s)",
                    "Heqn1 : eq n0 Server"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c1)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' None (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq\n  (last_holder' (Some c0)\n     (app tr (cons (pair (Client c) (inl Unlock)) nil))) \n  (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (last_holder' h (app tr (cons (pair (Client c) (inl Unlock)) nil)))\n  (Some n)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputHandler_lbcases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (l : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair l out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (l : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair l out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (l : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (InputHandler h i st) (pair (pair (pair l out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (l : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match h with\n          | Client c =>\n              match i with\n              | Lock =>\n                  fun s : Data =>\n                  pair (pair (pair (InputLock c) (app nil nil)) s)\n                    (app (cons (pair Server Lock) nil) nil)\n              | Unlock =>\n                  fun s : Data =>\n                  let\n                  'pair (pair (pair b os2) s'') ws2 :=\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    (if held s\n                     then\n                      fun _ : Data =>\n                      pair\n                        (pair (pair tt (app (app nil nil) nil))\n                           {| queue := nil; held := false |})\n                        (app (app nil (cons (pair Server Unlock) nil))\n                           nil)\n                     else\n                      fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                      s in\n                    pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                      (app ws1 nil) in\n                   pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n              | Locked =>\n                  fun s : Data => pair (pair (pair Nop nil) s) nil\n              end\n          | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair l out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (h : Name) (i : Msg) (st : Data) (l : Label) \n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match h with\n          | Client c =>\n              match i with\n              | Lock =>\n                  fun s : Data =>\n                  pair (pair (pair (InputLock c) (app nil nil)) s)\n                    (app (cons (pair Server Lock) nil) nil)\n              | Unlock =>\n                  fun s : Data =>\n                  let\n                  'pair (pair (pair b os2) s'') ws2 :=\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    (if held s\n                     then\n                      fun _ : Data =>\n                      pair\n                        (pair (pair tt (app (app nil nil) nil))\n                           {| queue := nil; held := false |})\n                        (app (app nil (cons (pair Server Unlock) nil))\n                           nil)\n                     else\n                      fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                      s in\n                    pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                      (app ws1 nil) in\n                   pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n              | Locked =>\n                  fun s : Data => pair (pair (pair Nop nil) s) nil\n              end\n          | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair l out) st') ms)),\nor\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "H : eq\n  (match h with\n   | Client c =>\n       match i with\n       | Lock =>\n           fun s : Data =>\n           pair (pair (pair (InputLock c) (app nil nil)) s)\n             (app (cons (pair Server Lock) nil) nil)\n       | Unlock =>\n           fun s : Data =>\n           let\n           'pair (pair (pair b os2) s'') ws2 :=\n            let\n            'pair (pair (pair _ os1) s') ws1 :=\n             (if held s\n              then\n               fun _ : Data =>\n               pair\n                 (pair (pair tt (app (app nil nil) nil))\n                    {| queue := nil; held := false |})\n                 (app (app nil (cons (pair Server Unlock) nil)) nil)\n              else fun s0 : Data => pair (pair (pair tt nil) s0) nil) s\n             in\n             pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n               (app ws1 nil) in\n            pair (pair (pair b (app nil os2)) s'') (app nil ws2)\n       | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n       end\n   | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n   end st) (pair (pair (pair l out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "l : Label",
                    "st : Data",
                    "i : Msg",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq true true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Locked Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))",
                    "H : eq\n  (pair (pair (pair (InputLock c) (app nil nil)) st)\n     (app (cons (pair Server Lock) nil) nil))\n  (pair (pair (pair l out) st') ms)",
                    "Heqm : eq i Lock",
                    "Heqn : eq h (Client c)",
                    "c : Client_index",
                    "H : eq (pair (pair (pair l1 (app nil l2)) d) (app nil l0))\n  (pair (pair (pair l out) st') ms)",
                    "Heqp : eq (pair (pair (pair (InputUnlock c) (app l4 nil)) d0) (app l3 nil))\n  (pair (pair (pair l1 l2) d) l0)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app (app nil nil) nil))\n        {| queue := nil; held := false |})\n     (app (app nil (cons (pair Server Unlock) nil)) nil))\n  (pair (pair (pair u l4) d0) l3)",
                    "Heqb : eq (held st) true",
                    "Heqp3 : eq p1 (pair (pair u l4) d0)",
                    "Heqp4 : eq p2 (pair u l4)",
                    "l4 : list Output",
                    "u : unit",
                    "d0 : Data",
                    "p2 : prod unit (list Output)",
                    "l3 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp0 : eq p (pair (pair l1 l2) d)",
                    "Heqp1 : eq p0 (pair l1 l2)",
                    "l2 : list Output",
                    "l1 : Label",
                    "d : Data",
                    "p0 : prod Label (list Output)",
                    "l0 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqm : eq i Unlock",
                    "Heqp2 : eq (pair (pair (pair tt nil) st) nil) (pair (pair (pair u l4) d0) l3)",
                    "Heqb : eq (held st) false",
                    "H : eq (pair (pair (pair Nop nil) st) nil)\n  (pair (pair (pair l out) st') ms)",
                    "Heqm : eq i Locked",
                    "Heqn : eq h Server"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq true true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (and\n                       (eq (app (cons (pair Server Unlock) nil) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq (app nil nil) nil)\n                    (and\n                       (eq (held {| queue := nil; held := false |})\n                          false)\n                       (or\n                          (and (eq true true)\n                             (eq\n                                (app (cons (pair Server Unlock) nil)\n                                   nil) (cons (pair Server Unlock) nil)))\n                          (and\n                             (eq {| queue := nil; held := false |} st)\n                             (eq\n                                (app (cons (pair Server Unlock) nil)\n                                   nil) nil))))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (and (eq (app (cons (pair Server Unlock) nil) nil) nil)\n           (eq (InputUnlock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (and\n                       (eq (app (cons (pair Server Unlock) nil) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq (app nil nil) nil)\n                    (and\n                       (eq (held {| queue := nil; held := false |})\n                          false)\n                       (or\n                          (and (eq true true)\n                             (eq\n                                (app (cons (pair Server Unlock) nil)\n                                   nil) (cons (pair Server Unlock) nil)))\n                          (and\n                             (eq {| queue := nil; held := false |} st)\n                             (eq\n                                (app (cons (pair Server Unlock) nil)\n                                   nil) nil))))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (and (eq (app (cons (pair Server Unlock) nil) nil) nil)\n           (eq (InputUnlock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (and\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq nil nil)\n                    (and (eq false false)\n                       (or\n                          (and (eq true true)\n                             (eq (cons (pair Server Unlock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and\n                             (eq {| queue := nil; held := false |} st)\n                             (eq (cons (pair Server Unlock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (and (eq (cons (pair Server Unlock) nil) nil)\n           (eq (InputUnlock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (app nil nil) (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq (app nil nil) nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq (app nil nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq (app nil nil) nil))))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq st' st')\n        (and (eq (app nil nil) nil) (eq (InputUnlock c) Nop))))",
                    "Heqb : eq (held st') false"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq (app nil nil) nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (app nil nil) (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq (app nil nil) nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq (app nil nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq (app nil nil) nil))))))))))\n  (and (eq (app nil nil) nil)\n     (and (eq st' st')\n        (and (eq (app nil nil) nil) (eq (InputUnlock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (and (eq nil nil) (eq (InputUnlock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c0))))))\n           (and (eq l (InputUnlock c0))\n              (and (eq Locked Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq Nop (InputLock c0))))))\n           (and (eq Nop (InputUnlock c0))\n              (and (eq Locked Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil) (and (eq st' st') (and (eq nil nil) (eq Nop Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq out nil)\n                 (and (eq st' st)\n                    (and (eq ms (cons (pair Server Lock) nil))\n                       (eq l (InputLock c))))))\n           (and (eq l (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq out nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st) true)\n                             (eq ms (cons (pair Server Unlock) nil)))\n                          (and (eq st' st) (eq ms nil))))))))))\n  (and (eq out nil) (and (eq st' st) (and (eq ms nil) (eq l Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq Nop (InputLock c))))))\n           (and (eq Nop (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil) (and (eq st' st') (and (eq nil nil) (eq Nop Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Lock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputLock c) (InputLock c0))))))\n           (and (eq (InputLock c) (InputUnlock c0))\n              (and (eq Lock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq (cons (pair Server Lock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and (eq st' st')\n                             (eq (cons (pair Server Lock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st')\n        (and (eq (cons (pair Server Lock) nil) nil)\n           (eq (InputLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Lock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (and\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil))\n                    (eq (InputLock c) (InputLock c0))))))\n        (and (eq (InputLock c) (InputUnlock c0))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Lock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (and\n                    (eq (cons (pair Server Lock) nil)\n                       (cons (pair Server Lock) nil))\n                    (eq (InputLock c) (InputLock c0))))))\n        (and (eq (InputLock c) (InputUnlock c0))\n           (and (eq Lock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq (held st') true)\n                          (eq (cons (pair Server Lock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq st' st')\n                          (eq (cons (pair Server Lock) nil) nil)))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Lock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (and\n                 (eq (cons (pair Server Lock) nil)\n                    (cons (pair Server Lock) nil))\n                 (eq (InputLock c) (InputLock ?c))))))\n     (and (eq (InputLock c) (InputUnlock ?c))\n        (and (eq Lock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq (held st') true)\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq st' st')\n                       (eq (cons (pair Server Lock) nil) nil))))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Lock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (and\n                 (eq (cons (pair Server Lock) nil)\n                    (cons (pair Server Lock) nil))\n                 (eq (InputLock c) (InputLock ?c))))))\n     (and (eq (InputLock c) (InputUnlock ?c))\n        (and (eq Lock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq (held st') true)\n                       (eq (cons (pair Server Lock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq st' st')\n                       (eq (cons (pair Server Lock) nil) nil))))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq {| queue := nil; held := false |} st)\n                    (and\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq nil nil)\n                    (and (eq false false)\n                       (or\n                          (and (eq true true)\n                             (eq (cons (pair Server Unlock) nil)\n                                (cons (pair Server Unlock) nil)))\n                          (and\n                             (eq {| queue := nil; held := false |} st)\n                             (eq (cons (pair Server Unlock) nil) nil))))))))))\n  (and (eq nil nil)\n     (and (eq {| queue := nil; held := false |} st)\n        (and (eq (cons (pair Server Unlock) nil) nil)\n           (eq (InputUnlock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq {| queue := nil; held := false |} st)\n                 (and\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Lock) nil))\n                    (eq (InputUnlock c) (InputLock c0))))))\n        (and (eq (InputUnlock c) (InputUnlock c0))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq false false)\n                    (or\n                       (and (eq true true)\n                          (eq (cons (pair Server Unlock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (cons (pair Server Unlock) nil) nil)))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq {| queue := nil; held := false |} st)\n                 (and\n                    (eq (cons (pair Server Unlock) nil)\n                       (cons (pair Server Lock) nil))\n                    (eq (InputUnlock c) (InputLock c0))))))\n        (and (eq (InputUnlock c) (InputUnlock c0))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq false false)\n                    (or\n                       (and (eq true true)\n                          (eq (cons (pair Server Unlock) nil)\n                             (cons (pair Server Unlock) nil)))\n                       (and (eq {| queue := nil; held := false |} st)\n                          (eq (cons (pair Server Unlock) nil) nil)))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := false |} st)\n              (and\n                 (eq (cons (pair Server Unlock) nil)\n                    (cons (pair Server Lock) nil))\n                 (eq (InputUnlock c) (InputLock ?c))))))\n     (and (eq (InputUnlock c) (InputUnlock ?c))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq false false)\n                 (or\n                    (and (eq true true)\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq {| queue := nil; held := false |} st)\n                       (eq (cons (pair Server Unlock) nil) nil))))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := false |} st)\n              (and\n                 (eq (cons (pair Server Unlock) nil)\n                    (cons (pair Server Lock) nil))\n                 (eq (InputUnlock c) (InputLock ?c))))))\n     (and (eq (InputUnlock c) (InputUnlock ?c))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq false false)\n                 (or\n                    (and (eq true true)\n                       (eq (cons (pair Server Unlock) nil)\n                          (cons (pair Server Unlock) nil)))\n                    (and (eq {| queue := nil; held := false |} st)\n                       (eq (cons (pair Server Unlock) nil) nil))))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Unlock Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq (InputUnlock c) (InputLock c0))))))\n           (and (eq (InputUnlock c) (InputUnlock c0))\n              (and (eq Unlock Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq false true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil)\n     (and (eq st' st') (and (eq nil nil) (eq (InputUnlock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (and (eq nil (cons (pair Server Lock) nil))\n                    (eq (InputUnlock c) (InputLock c0))))))\n        (and (eq (InputUnlock c) (InputUnlock c0))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (or\n        (and (eq Unlock Lock)\n           (and (eq nil nil)\n              (and (eq st' st')\n                 (and (eq nil (cons (pair Server Lock) nil))\n                    (eq (InputUnlock c) (InputLock c0))))))\n        (and (eq (InputUnlock c) (InputUnlock c0))\n           (and (eq Unlock Unlock)\n              (and (eq nil nil)\n                 (and (eq (held st') false)\n                    (or\n                       (and (eq false true)\n                          (eq nil (cons (pair Server Unlock) nil)))\n                       (and (eq st' st') (eq nil nil)))))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (and (eq nil (cons (pair Server Lock) nil))\n                 (eq (InputUnlock c) (InputLock ?c))))))\n     (and (eq (InputUnlock c) (InputUnlock ?c))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq false true)\n                       (eq nil (cons (pair Server Unlock) nil)))\n                    (and (eq st' st') (eq nil nil))))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (or\n     (and (eq Unlock Lock)\n        (and (eq nil nil)\n           (and (eq st' st')\n              (and (eq nil (cons (pair Server Lock) nil))\n                 (eq (InputUnlock c) (InputLock ?c))))))\n     (and (eq (InputUnlock c) (InputUnlock ?c))\n        (and (eq Unlock Unlock)\n           (and (eq nil nil)\n              (and (eq (held st') false)\n                 (or\n                    (and (eq false true)\n                       (eq nil (cons (pair Server Unlock) nil)))\n                    (and (eq st' st') (eq nil nil))))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (or\n           (and (eq Locked Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq Nop (InputLock c0))))))\n           (and (eq Nop (InputUnlock c0))\n              (and (eq Locked Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil) (and (eq st' st') (and (eq nil nil) (eq Nop Nop))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c : Client_index =>\n      and (eq Server (Client c))\n        (or\n           (and (eq i Lock)\n              (and (eq nil nil)\n                 (and (eq st' st')\n                    (and (eq nil (cons (pair Server Lock) nil))\n                       (eq Nop (InputLock c))))))\n           (and (eq Nop (InputUnlock c))\n              (and (eq i Unlock)\n                 (and (eq nil nil)\n                    (and (eq (held st') false)\n                       (or\n                          (and (eq (held st') true)\n                             (eq nil (cons (pair Server Unlock) nil)))\n                          (and (eq st' st') (eq nil nil))))))))))\n  (and (eq nil nil) (and (eq st' st') (and (eq nil nil) (eq Nop Nop))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ClientNetHandler_lbcases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair l out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair l out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ClientNetHandler c m st) (pair (pair (pair l out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match m with\n          | Locked =>\n              fun _ : Data =>\n              pair\n                (pair\n                   (pair (MsgLocked c)\n                      (app nil (app (cons Locked nil) nil)))\n                   {| queue := nil; held := true |})\n                (app nil (app nil nil))\n          | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair l out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (match m with\n          | Locked =>\n              fun _ : Data =>\n              pair\n                (pair\n                   (pair (MsgLocked c)\n                      (app nil (app (cons Locked nil) nil)))\n                   {| queue := nil; held := true |})\n                (app nil (app nil nil))\n          | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n          end st) (pair (pair (pair l out) st') ms)),\nand (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))",
                    "H : eq\n  (match m with\n   | Locked =>\n       fun _ : Data =>\n       pair\n         (pair\n            (pair (MsgLocked c) (app nil (app (cons Locked nil) nil)))\n            {| queue := nil; held := true |}) (app nil (app nil nil))\n   | _ => fun s : Data => pair (pair (pair Nop nil) s) nil\n   end st) (pair (pair (pair l out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "l : Label",
                    "st : Data",
                    "m : Msg",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq m Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Lock Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))",
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Unlock Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))",
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Locked Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))",
                    "H : eq (pair (pair (pair Nop nil) st) nil)\n  (pair (pair (pair l out) st') ms)",
                    "Heqm0 : eq m Lock",
                    "Heqm0 : eq m Unlock",
                    "H : eq\n  (pair\n     (pair (pair (MsgLocked c) (app nil (app (cons Locked nil) nil)))\n        {| queue := nil; held := true |}) (app nil (app nil nil)))\n  (pair (pair (pair l out) st') ms)",
                    "Heqm0 : eq m Locked"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Lock Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Lock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Unlock Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or (and (eq st' st') (and (eq nil nil) (eq Nop Nop)))\n     (and (eq Unlock Locked)\n        (and (eq nil (cons Locked nil))\n           (and (eq (held st') true) (eq Nop (MsgLocked c))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq ms nil)\n  (or (and (eq st' st) (and (eq out nil) (eq l Nop)))\n     (and (eq Locked Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held st') true) (eq l (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (eq (MsgLocked c) Nop)))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (and (eq (held {| queue := nil; held := true |}) true)\n              (eq (MsgLocked c) (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (eq (MsgLocked c) Nop)))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (and (eq (held {| queue := nil; held := true |}) true)\n              (eq (MsgLocked c) (MsgLocked c))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (eq (MsgLocked c) Nop)))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (and (eq (held {| queue := nil; held := true |}) true)\n              (eq (MsgLocked c) (MsgLocked c))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (and (eq {| queue := nil; held := true |} st)\n        (and (eq (cons Locked nil) nil) (eq (MsgLocked c) Nop)))\n     (and (eq Locked Locked)\n        (and (eq (cons Locked nil) (cons Locked nil))\n           (and (eq (held {| queue := nil; held := true |}) true)\n              (eq (MsgLocked c) (MsgLocked c))))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "ServerNetHandler_lbcases",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair l out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair l out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq (ServerNetHandler src m st) (pair (pair (pair l out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (let\n          'pair (pair (pair b os2) s'') ws2 :=\n           match m with\n           | Lock =>\n               match src with\n               | Client c =>\n                   fun s : Data =>\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    let\n                    'pair (pair (pair _ os1) _) ws1 :=\n                     (if null (queue st)\n                      then\n                       fun s0 : Data =>\n                       pair (pair (pair tt (app nil nil)) s0)\n                         (app (cons (pair src Locked) nil) nil)\n                      else\n                       fun s0 : Data =>\n                       pair (pair (pair tt nil) s0) nil) s in\n                     pair\n                       (pair (pair tt (app os1 nil))\n                          {|\n                            queue := app (queue st) (cons c nil);\n                            held := held st\n                          |}) (app ws1 nil) in\n                    pair (pair (pair (MsgLock c) (app os1 nil)) s')\n                      (app ws1 nil)\n               | Server =>\n                   fun s : Data => pair (pair (pair Nop nil) s) nil\n               end\n           | Unlock =>\n               fun s : Data =>\n               let\n               'pair (pair (pair _ os1) s') ws1 :=\n                match queue st with\n                | cons _ (cons x xs) =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt (app nil nil))\n                         {| queue := cons x xs; held := held st |})\n                      (app nil (cons (pair (Client x) Locked) nil))\n                | _ =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt nil)\n                         {| queue := nil; held := held st |}) nil\n                end s in\n                pair (pair (pair MsgUnlock (app os1 nil)) s')\n                  (app ws1 nil)\n           | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n           end st in\n           pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n         (pair (pair (pair l out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (src : Name) (m : Msg) (st : Data) (l : Label)\n  (out : list Output) (st' : Data) (ms : list (prod Name Msg))\n  (_ : eq\n         (let\n          'pair (pair (pair b os2) s'') ws2 :=\n           match m with\n           | Lock =>\n               match src with\n               | Client c =>\n                   fun s : Data =>\n                   let\n                   'pair (pair (pair _ os1) s') ws1 :=\n                    let\n                    'pair (pair (pair _ os1) _) ws1 :=\n                     (if null (queue st)\n                      then\n                       fun s0 : Data =>\n                       pair (pair (pair tt (app nil nil)) s0)\n                         (app (cons (pair src Locked) nil) nil)\n                      else\n                       fun s0 : Data =>\n                       pair (pair (pair tt nil) s0) nil) s in\n                     pair\n                       (pair (pair tt (app os1 nil))\n                          {|\n                            queue := app (queue st) (cons c nil);\n                            held := held st\n                          |}) (app ws1 nil) in\n                    pair (pair (pair (MsgLock c) (app os1 nil)) s')\n                      (app ws1 nil)\n               | Server =>\n                   fun s : Data => pair (pair (pair Nop nil) s) nil\n               end\n           | Unlock =>\n               fun s : Data =>\n               let\n               'pair (pair (pair _ os1) s') ws1 :=\n                match queue st with\n                | cons _ (cons x xs) =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt (app nil nil))\n                         {| queue := cons x xs; held := held st |})\n                      (app nil (cons (pair (Client x) Locked) nil))\n                | _ =>\n                    fun _ : Data =>\n                    pair\n                      (pair (pair tt nil)\n                         {| queue := nil; held := held st |}) nil\n                end s in\n                pair (pair (pair MsgUnlock (app os1 nil)) s')\n                  (app ws1 nil)\n           | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n           end st in\n           pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n         (pair (pair (pair l out) st') ms)),\nand (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "H : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    match m with\n    | Lock =>\n        match src with\n        | Client c =>\n            fun s : Data =>\n            let\n            'pair (pair (pair _ os1) s') ws1 :=\n             let\n             'pair (pair (pair _ os1) _) ws1 :=\n              (if null (queue st)\n               then\n                fun s0 : Data =>\n                pair (pair (pair tt (app nil nil)) s0)\n                  (app (cons (pair src Locked) nil) nil)\n               else fun s0 : Data => pair (pair (pair tt nil) s0) nil)\n                s in\n              pair\n                (pair (pair tt (app os1 nil))\n                   {|\n                     queue := app (queue st) (cons c nil);\n                     held := held st\n                   |}) (app ws1 nil) in\n             pair (pair (pair (MsgLock c) (app os1 nil)) s')\n               (app ws1 nil)\n        | Server => fun s : Data => pair (pair (pair Nop nil) s) nil\n        end\n    | Unlock =>\n        fun s : Data =>\n        let\n        'pair (pair (pair _ os1) s') ws1 :=\n         match queue st with\n         | cons _ (cons x xs) =>\n             fun _ : Data =>\n             pair\n               (pair (pair tt (app nil nil))\n                  {| queue := cons x xs; held := held st |})\n               (app nil (cons (pair (Client x) Locked) nil))\n         | _ =>\n             fun _ : Data =>\n             pair\n               (pair (pair tt nil) {| queue := nil; held := held st |})\n               nil\n         end s in\n         pair (pair (pair MsgUnlock (app os1 nil)) s') (app ws1 nil)\n    | Locked => fun s : Data => pair (pair (pair Nop nil) s) nil\n    end st in pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair l out) st') ms)",
                    "ms : list (prod Name Msg)",
                    "st' : Data",
                    "out : list Output",
                    "l : Label",
                    "st : Data",
                    "m : Msg",
                    "src : Name"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq m Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq m Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq l (MsgLock c0))\n                 (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq l (MsgLock c0))\n                 (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app nil (cons c nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl nil))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c0))\n                 (and (eq (queue st') (app (cons c nil) (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq ms (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (cons c nil)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c1))\n                 (and\n                    (eq (queue st')\n                       (app (cons c (cons c0 l6)) (cons c1 nil)))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq ms (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (cons c (cons c0 l6))))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))",
                    "H : eq (pair (pair (pair l1 (app nil l2)) d) (app nil l0))\n  (pair (pair (pair l out) st') ms)",
                    "Heqp : eq (pair (pair (pair (MsgLock c) (app l4 nil)) d0) (app l3 nil))\n  (pair (pair (pair l1 l2) d) l0)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app l6 nil))\n        {| queue := app (queue st) (cons c nil); held := held st |})\n     (app l5 nil)) (pair (pair (pair u l4) d0) l3)",
                    "Heqp5 : eq\n  (pair (pair (pair tt (app nil nil)) st)\n     (app (cons (pair (Client c) Locked) nil) nil))\n  (pair (pair (pair u0 l6) d1) l5)",
                    "Heqb : eq (null (queue st)) true",
                    "Heqp6 : eq p3 (pair (pair u0 l6) d1)",
                    "Heqp7 : eq p4 (pair u0 l6)",
                    "l6 : list Output",
                    "u0 : unit",
                    "d1 : Data",
                    "p4 : prod unit (list Output)",
                    "l5 : list (prod Name Msg)",
                    "p3 : prod (prod unit (list Output)) Data",
                    "Heqp3 : eq p1 (pair (pair u l4) d0)",
                    "Heqp4 : eq p2 (pair u l4)",
                    "l4 : list Output",
                    "u : unit",
                    "d0 : Data",
                    "p2 : prod unit (list Output)",
                    "l3 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqn : eq src (Client c)",
                    "c : Client_index",
                    "Heqm0 : eq m Lock",
                    "Heqp0 : eq p (pair (pair l1 l2) d)",
                    "Heqp1 : eq p0 (pair l1 l2)",
                    "l2 : list Output",
                    "l1 : Label",
                    "d : Data",
                    "p0 : prod Label (list Output)",
                    "l0 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqp5 : eq (pair (pair (pair tt nil) st) nil) (pair (pair (pair u0 l6) d1) l5)",
                    "Heqb : eq (null (queue st)) false",
                    "Heqp : eq (pair (pair (pair Nop nil) st) nil) (pair (pair (pair l1 l2) d) l0)",
                    "Heqn : eq src Server",
                    "Heqp : eq (pair (pair (pair MsgUnlock (app l4 nil)) d0) (app l3 nil))\n  (pair (pair (pair l1 l2) d) l0)",
                    "Heqp2 : eq (pair (pair (pair tt nil) {| queue := nil; held := held st |}) nil)\n  (pair (pair (pair u l4) d0) l3)",
                    "Heql5 : eq (queue st) nil",
                    "Heqm0 : eq m Unlock",
                    "Heql5 : eq (queue st) (cons c nil)",
                    "Heql6 : eq l5 nil",
                    "l5 : list Client_index",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app nil nil))\n        {| queue := cons c0 l6; held := held st |})\n     (app nil (cons (pair (Client c0) Locked) nil)))\n  (pair (pair (pair u l4) d0) l3)",
                    "Heql5 : eq (queue st) (cons c (cons c0 l6))",
                    "Heql6 : eq l5 (cons c0 l6)",
                    "l6 : list Client_index",
                    "c0 : Client_index",
                    "Heqm0 : eq m Locked"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))",
                    "Heqb : eq (null (queue d1)) true"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq l (MsgLock c0))\n                 (and (eq (queue st') (app (queue st) (cons c0 nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq (app (app nil nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq (app (app nil nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil) (eq (app (app nil nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq (app (app nil nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app (app nil nil) nil) nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))",
                    "Heqb : eq (null (queue d1)) false"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app nil (cons c nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl nil))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and\n                    (eq (queue {| queue := nil; held := held st |})\n                       (app nil (cons c nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq (app nil nil)\n                             (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq (app nil nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (List.tl nil))\n                 (or\n                    (and\n                       (eq (queue {| queue := nil; held := held st |})\n                          nil) (eq (app nil nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {| queue := nil; held := held st |})\n                                (cons next t))\n                             (eq (app nil nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c0))\n                 (and (eq (queue st') (app (cons c nil) (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq ms (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (cons c nil)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c0))\n                 (and\n                    (eq (queue {| queue := nil; held := held st |})\n                       (app (cons c nil) (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq (app nil nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil))\n                          (eq (app nil nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (List.tl (cons c nil)))\n                 (or\n                    (and\n                       (eq (queue {| queue := nil; held := held st |})\n                          nil) (eq (app nil nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {| queue := nil; held := held st |})\n                                (cons next t))\n                             (eq (app nil nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq l (MsgLock c1))\n                 (and\n                    (eq (queue st')\n                       (app (cons c (cons c0 l6)) (cons c1 nil)))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq ms (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq ms nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (cons c (cons c0 l6))))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c1))\n                 (and\n                    (eq\n                       (queue\n                          {| queue := cons c0 l6; held := held st |})\n                       (app (cons c (cons c0 l6)) (cons c1 nil)))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil)\n                             (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := cons c0 l6; held := held st |})\n                    (List.tl (cons c (cons c0 l6))))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {| queue := cons c0 l6; held := held st |})\n                          nil)\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue := cons c0 l6;\n                                     held := held st\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (cons (pair (Client c0) Locked) nil)\n                                   nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app (cons (pair (Client c0) Locked) nil) nil) nil)\n           (and (eq {| queue := cons c0 l6; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "repeat tuple_inversion .",
                "tactic_sig_no_out_arg": "repeat tuple_inversion .",
                "tactic_args": [
                    "_goal : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq l (MsgLock c))\n                 (and (eq (queue st') (app (queue st) (cons c nil)))\n                    (or\n                       (and (eq (queue st) nil)\n                          (eq ms (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st) nil)) (eq ms nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq l MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st)))\n                 (or (and (eq (queue st') nil) (eq ms nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq ms\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq ms nil) (and (eq st' st) (eq l Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp null_sound .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp null_sound .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqb : eq (queue d1) nil"
                ]
            },
            {
                "tactic_sig": "find_rewrite .",
                "tactic_sig_no_out_arg": "find_rewrite .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app nil (cons c nil);\n                            held := held d1\n                          |}) (app nil (cons c0 nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq nil nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app nil (cons c nil); held := held d1\n                       |}) (List.tl nil))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app nil (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue := app nil (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq {| queue := app nil (cons c nil); held := held d1 |}\n                 d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app nil (cons c nil);\n                            held := held d1\n                          |}) (app nil (cons c0 nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq nil nil))\n                          (eq\n                             (app\n                                (app\n                                   (cons (pair (Client c) Locked) nil)\n                                   nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app nil (cons c nil); held := held d1\n                       |}) (List.tl nil))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app nil (cons c nil);\n                               held := held d1\n                             |}) nil)\n                       (eq\n                          (app\n                             (app (cons (pair (Client c) Locked) nil)\n                                nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue := app nil (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (app\n                                      (cons (pair (Client c) Locked)\n                                         nil) nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and\n           (eq (app (app (cons (pair (Client c) Locked) nil) nil) nil)\n              nil)\n           (and\n              (eq {| queue := app nil (cons c nil); held := held d1 |}\n                 d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and (eq (cons c nil) (cons c0 nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq nil nil))\n                          (eq (cons (pair (Client c) Locked) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and (eq (cons c nil) nil)\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq (cons (pair (Client c) Locked) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (cons c nil) (cons next t))\n                             (eq (cons (pair (Client c) Locked) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (cons (pair (Client c) Locked) nil) nil)\n           (and (eq {| queue := cons c nil; held := held d1 |} d1)\n              (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and (eq (cons c nil) (cons c0 nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq nil nil))\n                          (eq (cons (pair (Client c) Locked) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and (eq (cons c nil) nil)\n                 (or\n                    (and (eq (cons c nil) nil)\n                       (eq (cons (pair (Client c) Locked) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (cons c nil) (cons next t))\n                             (eq (cons (pair (Client c) Locked) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (cons (pair (Client c) Locked) nil) nil)\n           (and (eq {| queue := cons c nil; held := held d1 |} d1)\n              (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (MsgLock c) (MsgLock c0))\n              (and (eq (cons c nil) (cons c0 nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (forall _ : eq nil nil, False)\n                       (eq (cons (pair (Client c) Locked) nil) nil))))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (MsgLock c) MsgUnlock)\n           (and (eq (cons c nil) nil)\n              (or\n                 (and (eq (cons c nil) nil)\n                    (eq (cons (pair (Client c) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c nil) (cons next t))\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client next) Locked) nil)))))))))\n     (and (eq (cons (pair (Client c) Locked) nil) nil)\n        (and (eq {| queue := cons c nil; held := held d1 |} d1)\n           (eq (MsgLock c) Nop))))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (MsgLock c) (MsgLock c0))\n              (and (eq (cons c nil) (cons c0 nil))\n                 (or\n                    (and (eq nil nil)\n                       (eq (cons (pair (Client c) Locked) nil)\n                          (cons (pair (Client c0) Locked) nil)))\n                    (and (forall _ : eq nil nil, False)\n                       (eq (cons (pair (Client c) Locked) nil) nil))))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (MsgLock c) MsgUnlock)\n           (and (eq (cons c nil) nil)\n              (or\n                 (and (eq (cons c nil) nil)\n                    (eq (cons (pair (Client c) Locked) nil) nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (cons c nil) (cons next t))\n                          (eq (cons (pair (Client c) Locked) nil)\n                             (cons (pair (Client next) Locked) nil)))))))))\n     (and (eq (cons (pair (Client c) Locked) nil) nil)\n        (and (eq {| queue := cons c nil; held := held d1 |} d1)\n           (eq (MsgLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (MsgLock c) (MsgLock c0))\n           (and (eq (cons c nil) (cons c0 nil))\n              (or\n                 (and (eq nil nil)\n                    (eq (cons (pair (Client c) Locked) nil)\n                       (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq nil nil, False)\n                    (eq (cons (pair (Client c) Locked) nil) nil)))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (MsgLock c) (MsgLock c0))\n           (and (eq (cons c nil) (cons c0 nil))\n              (or\n                 (and (eq nil nil)\n                    (eq (cons (pair (Client c) Locked) nil)\n                       (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq nil nil, False)\n                    (eq (cons (pair (Client c) Locked) nil) nil)))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (MsgLock c) (MsgLock ?c))\n        (and (eq (cons c nil) (cons ?c nil))\n           (or\n              (and (eq nil nil)\n                 (eq (cons (pair (Client c) Locked) nil)\n                    (cons (pair (Client ?c) Locked) nil)))\n              (and (forall _ : eq nil nil, False)\n                 (eq (cons (pair (Client c) Locked) nil) nil))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (MsgLock c) (MsgLock ?c))\n        (and (eq (cons c nil) (cons ?c nil))\n           (or\n              (and (eq nil nil)\n                 (eq (cons (pair (Client c) Locked) nil)\n                    (cons (pair (Client ?c) Locked) nil)))\n              (and (forall _ : eq nil nil, False)\n                 (eq (cons (pair (Client c) Locked) nil) nil))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app (app nil nil) nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq\n                       (queue\n                          {|\n                            queue := app (queue d1) (cons c nil);\n                            held := held d1\n                          |}) (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq (app (app nil nil) nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil))\n                          (eq (app (app nil nil) nil) nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq\n                    (queue\n                       {|\n                         queue := app (queue d1) (cons c nil);\n                         held := held d1\n                       |}) (List.tl (queue d1)))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {|\n                               queue := app (queue d1) (cons c nil);\n                               held := held d1\n                             |}) nil) (eq (app (app nil nil) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue :=\n                                       app (queue d1) (cons c nil);\n                                     held := held d1\n                                   |}) (cons next t))\n                             (eq (app (app nil nil) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app (app nil nil) nil) nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq (app (queue d1) (cons c nil))\n                       (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq nil (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n                 (or\n                    (and (eq (app (queue d1) (cons c nil)) nil)\n                       (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq (app (queue d1) (cons c nil))\n                                (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp null_false_neq_nil .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp null_false_neq_nil .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqb : not (eq (queue d1) nil)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq (Client c) (Client c0))\n           (and (eq Lock Lock)\n              (and (eq (MsgLock c) (MsgLock c0))\n                 (and\n                    (eq (app (queue d1) (cons c nil))\n                       (app (queue d1) (cons c0 nil)))\n                    (or\n                       (and (eq (queue d1) nil)\n                          (eq nil (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (queue d1) nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq (MsgLock c) MsgUnlock)\n              (and\n                 (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n                 (or\n                    (and (eq (app (queue d1) (cons c nil)) nil)\n                       (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq (app (queue d1) (cons c nil))\n                                (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := app (queue d1) (cons c nil);\n                   held := held d1\n                 |} d1) (eq (MsgLock c) Nop)))))"
                ],
                "tactic_res": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (MsgLock c) (MsgLock c0))\n              (and\n                 (eq (app (queue d1) (cons c nil))\n                    (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (forall _ : eq (queue d1) nil, False)\n                       (eq nil nil))))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (MsgLock c) MsgUnlock)\n           (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n              (or\n                 (and (eq (app (queue d1) (cons c nil)) nil)\n                    (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq (app (queue d1) (cons c nil))\n                             (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil)))))))))\n     (and (eq nil nil)\n        (and\n           (eq\n              {|\n                queue := app (queue d1) (cons c nil); held := held d1\n              |} d1) (eq (MsgLock c) Nop))))",
                    "Heqb : forall _ : eq (queue d1) nil, False"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (ex\n     (fun c0 : Client_index =>\n      and (eq (Client c) (Client c0))\n        (and (eq Lock Lock)\n           (and (eq (MsgLock c) (MsgLock c0))\n              (and\n                 (eq (app (queue d1) (cons c nil))\n                    (app (queue d1) (cons c0 nil)))\n                 (or\n                    (and (eq (queue d1) nil)\n                       (eq nil (cons (pair (Client c0) Locked) nil)))\n                    (and (forall _ : eq (queue d1) nil, False)\n                       (eq nil nil))))))))\n  (or\n     (and (eq Lock Unlock)\n        (and (eq (MsgLock c) MsgUnlock)\n           (and (eq (app (queue d1) (cons c nil)) (List.tl (queue d1)))\n              (or\n                 (and (eq (app (queue d1) (cons c nil)) nil)\n                    (eq nil nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and\n                          (eq (app (queue d1) (cons c nil))\n                             (cons next t))\n                          (eq nil\n                             (cons (pair (Client next) Locked) nil)))))))))\n     (and (eq nil nil)\n        (and\n           (eq\n              {|\n                queue := app (queue d1) (cons c nil); held := held d1\n              |} d1) (eq (MsgLock c) Nop))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (MsgLock c) (MsgLock c0))\n           (and\n              (eq (app (queue d1) (cons c nil))\n                 (app (queue d1) (cons c0 nil)))\n              (or\n                 (and (eq (queue d1) nil)\n                    (eq nil (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq (queue d1) nil, False)\n                    (eq nil nil)))))))"
                ]
            },
            {
                "tactic_sig": "eexists .",
                "tactic_sig_no_out_arg": "eexists .",
                "tactic_args": [
                    "_goal : ex\n  (fun c0 : Client_index =>\n   and (eq (Client c) (Client c0))\n     (and (eq Lock Lock)\n        (and (eq (MsgLock c) (MsgLock c0))\n           (and\n              (eq (app (queue d1) (cons c nil))\n                 (app (queue d1) (cons c0 nil)))\n              (or\n                 (and (eq (queue d1) nil)\n                    (eq nil (cons (pair (Client c0) Locked) nil)))\n                 (and (forall _ : eq (queue d1) nil, False)\n                    (eq nil nil)))))))"
                ],
                "tactic_res": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (MsgLock c) (MsgLock ?c))\n        (and\n           (eq (app (queue d1) (cons c nil))\n              (app (queue d1) (cons ?c nil)))\n           (or\n              (and (eq (queue d1) nil)\n                 (eq nil (cons (pair (Client ?c) Locked) nil)))\n              (and (forall _ : eq (queue d1) nil, False) (eq nil nil))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq (Client c) (Client ?c))\n  (and (eq Lock Lock)\n     (and (eq (MsgLock c) (MsgLock ?c))\n        (and\n           (eq (app (queue d1) (cons c nil))\n              (app (queue d1) (cons ?c nil)))\n           (or\n              (and (eq (queue d1) nil)\n                 (eq nil (cons (pair (Client ?c) Locked) nil)))\n              (and (forall _ : eq (queue d1) nil, False) (eq nil nil))))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq Server (Client c))\n           (and (eq Lock Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Lock Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and\n                    (eq (queue {| queue := nil; held := held st |})\n                       (app nil (cons c nil)))\n                    (or\n                       (and (eq nil nil)\n                          (eq (app nil nil)\n                             (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq (app nil nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (List.tl nil))\n                 (or\n                    (and\n                       (eq (queue {| queue := nil; held := held st |})\n                          nil) (eq (app nil nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {| queue := nil; held := held st |})\n                                (cons next t))\n                             (eq (app nil nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))",
                    "st : Data"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := nil;\n                   held := held {| queue := queue0; held := held0 |}\n                 |} {| queue := queue0; held := held0 |})\n              (eq MsgUnlock Nop)))))",
                    "Heql5 : eq (queue {| queue := queue0; held := held0 |}) nil",
                    "held0 : bool",
                    "queue0 : list Client_index"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq\n                 {|\n                   queue := nil;\n                   held := held {| queue := queue0; held := held0 |}\n                 |} {| queue := queue0; held := held0 |})\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := queue0; held := held0 |})\n              (eq MsgUnlock Nop)))))",
                    "Heql5 : eq queue0 nil"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := queue0; held := held0 |})\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := nil; held := held0 |}) \n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c))\n                 (and (eq nil (cons c nil))\n                    (or\n                       (and (eq nil nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq nil nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and\n              (eq {| queue := nil; held := held0 |}\n                 {| queue := nil; held := held0 |}) \n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c0))\n                 (and\n                    (eq (queue {| queue := nil; held := held st |})\n                       (app (cons c nil) (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq (app nil nil)\n                             (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil))\n                          (eq (app nil nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := nil; held := held st |})\n                    (List.tl (cons c nil)))\n                 (or\n                    (and\n                       (eq (queue {| queue := nil; held := held st |})\n                          nil) (eq (app nil nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {| queue := nil; held := held st |})\n                                (cons next t))\n                             (eq (app nil nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app nil nil) nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c0))\n                 (and (eq nil (cons c (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq nil (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c0 : Client_index =>\n         and (eq src (Client c0))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c0))\n                 (and (eq nil (cons c (cons c0 nil)))\n                    (or\n                       (and (eq (cons c nil) nil)\n                          (eq nil (cons (pair (Client c0) Locked) nil)))\n                       (and (not (eq (cons c nil) nil)) (eq nil nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq nil nil)\n                 (or (and (eq nil nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq nil (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil)\n           (and (eq {| queue := nil; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : and (eq (app nil nil) nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c1))\n                 (and\n                    (eq\n                       (queue\n                          {| queue := cons c0 l6; held := held st |})\n                       (app (cons c (cons c0 l6)) (cons c1 nil)))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil)\n                             (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq\n                             (app (cons (pair (Client c0) Locked) nil)\n                                nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and\n                 (eq (queue {| queue := cons c0 l6; held := held st |})\n                    (List.tl (cons c (cons c0 l6))))\n                 (or\n                    (and\n                       (eq\n                          (queue\n                             {| queue := cons c0 l6; held := held st |})\n                          nil)\n                       (eq\n                          (app (cons (pair (Client c0) Locked) nil) nil)\n                          nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and\n                             (eq\n                                (queue\n                                   {|\n                                     queue := cons c0 l6;\n                                     held := held st\n                                   |}) (cons next t))\n                             (eq\n                                (app\n                                   (cons (pair (Client c0) Locked) nil)\n                                   nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (app (cons (pair (Client c0) Locked) nil) nil) nil)\n           (and (eq {| queue := cons c0 l6; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c1))\n                 (and\n                    (eq (cons c0 l6)\n                       (cons c (cons c0 (app l6 (cons c1 nil)))))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq (cons (pair (Client c0) Locked) nil)\n                             (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq (cons (pair (Client c0) Locked) nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq (cons c0 l6) (cons c0 l6))\n                 (or\n                    (and (eq (cons c0 l6) nil)\n                       (eq (cons (pair (Client c0) Locked) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (cons c0 l6) (cons next t))\n                             (eq (cons (pair (Client c0) Locked) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (cons (pair (Client c0) Locked) nil) nil)\n           (and (eq {| queue := cons c0 l6; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition eauto .",
                "tactic_sig_no_out_arg": "intuition eauto .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c1 : Client_index =>\n         and (eq src (Client c1))\n           (and (eq Unlock Lock)\n              (and (eq MsgUnlock (MsgLock c1))\n                 (and\n                    (eq (cons c0 l6)\n                       (cons c (cons c0 (app l6 (cons c1 nil)))))\n                    (or\n                       (and (eq (cons c (cons c0 l6)) nil)\n                          (eq (cons (pair (Client c0) Locked) nil)\n                             (cons (pair (Client c1) Locked) nil)))\n                       (and (not (eq (cons c (cons c0 l6)) nil))\n                          (eq (cons (pair (Client c0) Locked) nil) nil))))))))\n     (or\n        (and (eq Unlock Unlock)\n           (and (eq MsgUnlock MsgUnlock)\n              (and (eq (cons c0 l6) (cons c0 l6))\n                 (or\n                    (and (eq (cons c0 l6) nil)\n                       (eq (cons (pair (Client c0) Locked) nil) nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (cons c0 l6) (cons next t))\n                             (eq (cons (pair (Client c0) Locked) nil)\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq (cons (pair (Client c0) Locked) nil) nil)\n           (and (eq {| queue := cons c0 l6; held := held st |} st)\n              (eq MsgUnlock Nop)))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ],
                "tactic_res": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : and (eq nil nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq src (Client c))\n           (and (eq Locked Lock)\n              (and (eq Nop (MsgLock c))\n                 (and (eq (queue st') (app (queue st') (cons c nil)))\n                    (or\n                       (and (eq (queue st') nil)\n                          (eq nil (cons (pair (Client c) Locked) nil)))\n                       (and (not (eq (queue st') nil)) (eq nil nil))))))))\n     (or\n        (and (eq Locked Unlock)\n           (and (eq Nop MsgUnlock)\n              (and (eq (queue st') (List.tl (queue st')))\n                 (or (and (eq (queue st') nil) (eq nil nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue st') (cons next t))\n                             (eq nil\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq nil nil) (and (eq st' st') (eq Nop Nop)))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Lock_enables_MsgLock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall i : Client_index,\nmessage_enables_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ],
                "tactic_res": [
                    "_goal : forall i : Client_index,\nmessage_enables_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "unfold message_enables_label .",
                "tactic_sig_no_out_arg": "unfold message_enables_label .",
                "tactic_args": [
                    "_goal : forall i : Client_index,\nmessage_enables_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ],
                "tactic_res": [
                    "_goal : forall (i : Client_index) (net : network)\n  (_ : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n         (nwPackets net)), lb_step_ex lb_step_async (MsgLock i) net"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i : Client_index) (net : network)\n  (_ : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n         (nwPackets net)), lb_step_ex lb_step_async (MsgLock i) net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net",
                    "H : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (nwPackets net)",
                    "net : network",
                    "i : Client_index"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp in_split .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp in_split .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun l1 : list packet =>\n   ex\n     (fun l2 : list packet =>\n      eq (nwPackets net)\n        (app l1\n           (cons {| pSrc := Client i; pDst := Server; pBody := Lock |}\n              l2))))"
                ]
            },
            {
                "tactic_sig": "break_exists_name xs .",
                "tactic_sig_no_out_arg": "break_exists_name xs .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun l2 : list packet =>\n   eq (nwPackets net)\n     (app xs\n        (cons {| pSrc := Client i; pDst := Server; pBody := Lock |} l2)))",
                    "xs : list packet"
                ]
            },
            {
                "tactic_sig": "break_exists_name ys .",
                "tactic_sig_no_out_arg": "break_exists_name ys .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (nwPackets net)\n  (app xs\n     (cons {| pSrc := Client i; pDst := Server; pBody := Lock |} ys))",
                    "ys : list packet"
                ]
            },
            {
                "tactic_sig": "unfold enabled .",
                "tactic_sig_no_out_arg": "unfold enabled .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net"
                ]
            },
            {
                "tactic_sig": "destruct ( ServerNetHandler ( Client _i ) Lock ( nwState _i Server ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ServerNetHandler ( Client _i ) Lock ( nwState _i Server ) ) eqn : ? .",
                "tactic_args": [
                    "i : Client_index",
                    "net : network"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler (Client i) Lock (nwState net Server)) (pair p l)",
                    "l : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "p : prod (prod Label (list Output)) Data"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler (Client i) Lock (nwState net Server))\n  (pair (pair p d) l)",
                    "d : Data",
                    "p : prod Label (list Output)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "p : prod Label (list Output)"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler (Client i) Lock (nwState net Server))\n  (pair (pair (pair l0 l1) d) l)",
                    "l1 : list Output",
                    "l0 : Label"
                ]
            },
            {
                "tactic_sig": "cut ( _i = MsgLock _i ) .",
                "tactic_sig_no_out_arg": "cut ( _i = MsgLock _i ) .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net",
                    "l0 : Label",
                    "i : Client_index"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq l0 (MsgLock i), lb_step_ex lb_step_async (MsgLock i) net",
                    "_goal : eq l0 (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq l0 (MsgLock i), lb_step_ex lb_step_async (MsgLock i) net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net",
                    "H0 : eq l0 (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler (Client i) Lock (nwState net Server))\n  (pair (pair (pair (MsgLock i) l1) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat eexists .",
                "tactic_sig_no_out_arg": "repeat eexists .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async (MsgLock i) net"
                ],
                "tactic_res": [
                    "_goal : lb_step_async net (MsgLock i) ?a' ?tr"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : lb_step_async net (MsgLock i) ?a' ?tr"
                ],
                "tactic_res": [
                    "_goal : eq (nwPackets net) (app ?xs (cons ?p ?ys))",
                    "_goal : eq\n  (lb_net_handlers (pDst ?p) (pSrc ?p) (pBody ?p)\n     (nwState net (pDst ?p)))\n  (pair (pair (pair (MsgLock i) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (pDst ?p) ?l) (app ?xs ?ys);\n    nwState := update name_eq_dec (nwState net) (pDst ?p) ?d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (nwPackets net) (app ?xs (cons ?p ?ys))",
                    "_goal : eq\n  (lb_net_handlers (pDst ?p) (pSrc ?p) (pBody ?p)\n     (nwState net (pDst ?p)))\n  (pair (pair (pair (MsgLock i) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (pDst ?p) ?l) (app ?xs ?ys);\n    nwState := update name_eq_dec (nwState net) (pDst ?p) ?d\n  |}"
                ],
                "tactic_res": [
                    "_goal : eq\n  (lb_net_handlers\n     (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pSrc {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pBody {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (nwState net\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})))\n  (pair (pair (pair (MsgLock i) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n           ?l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |}) \n        ?d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq\n  (lb_net_handlers\n     (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pSrc {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pBody {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (nwState net\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})))\n  (pair (pair (pair (MsgLock i) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n           ?l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |}) \n        ?d\n  |}"
                ],
                "tactic_res": [
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n           l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |}) d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n           l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |}) d\n  |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    let\n    'pair (pair (pair _ os1) s') ws1 :=\n     let\n     'pair (pair (pair _ os1) _) ws1 :=\n      (if null (queue (nwState net Server))\n       then\n        fun s : Data =>\n        pair (pair (pair tt (app nil nil)) s)\n          (app (cons (pair (Client i) Locked) nil) nil)\n       else fun s : Data => pair (pair (pair tt nil) s) nil)\n        (nwState net Server) in\n      pair\n        (pair (pair tt (app os1 nil))\n           {|\n             queue := app (queue (nwState net Server)) (cons i nil);\n             held := held (nwState net Server)\n           |}) (app ws1 nil) in\n     pair (pair (pair (MsgLock i) (app os1 nil)) s') (app ws1 nil) in\n    pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair l0 l1) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq (pair (pair (pair l3 (app nil l4)) d0) (app nil l2))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp0 : eq (pair (pair (pair (MsgLock i) (app l6 nil)) d1) (app l5 nil))\n  (pair (pair (pair l3 l4) d0) l2)",
                    "Heqp3 : eq\n  (pair\n     (pair (pair tt (app l8 nil))\n        {|\n          queue := app (queue (nwState net Server)) (cons i nil);\n          held := held (nwState net Server)\n        |}) (app l7 nil)) (pair (pair (pair u l6) d1) l5)",
                    "Heqp6 : eq\n  (pair (pair (pair tt (app nil nil)) (nwState net Server))\n     (app (cons (pair (Client i) Locked) nil) nil))\n  (pair (pair (pair u0 l8) d2) l7)",
                    "Heqb : eq (null (queue (nwState net Server))) true",
                    "Heqp7 : eq p3 (pair (pair u0 l8) d2)",
                    "Heqp8 : eq p4 (pair u0 l8)",
                    "l8 : list Output",
                    "u0 : unit",
                    "d2 : Data",
                    "p4 : prod unit (list Output)",
                    "l7 : list (prod Name Msg)",
                    "p3 : prod (prod unit (list Output)) Data",
                    "Heqp4 : eq p1 (pair (pair u l6) d1)",
                    "Heqp5 : eq p2 (pair u l6)",
                    "l6 : list Output",
                    "u : unit",
                    "d1 : Data",
                    "p2 : prod unit (list Output)",
                    "l5 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp1 : eq p (pair (pair l3 l4) d0)",
                    "Heqp2 : eq p0 (pair l3 l4)",
                    "l4 : list Output",
                    "l3 : Label",
                    "d0 : Data",
                    "p0 : prod Label (list Output)",
                    "l2 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqp6 : eq (pair (pair (pair tt nil) (nwState net Server)) nil)\n  (pair (pair (pair u0 l8) d2) l7)",
                    "Heqb : eq (null (queue (nwState net Server))) false"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [
                    "_goal : eq l0 (MsgLock i)"
                ],
                "tactic_res": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_split_not_In",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (A : Type) (p p' : A) (xs ys zs : list A)\n  (_ : In p (app xs (cons p' ys)))\n  (_ : not (In p (app zs (app xs ys)))), eq p p'"
                ],
                "tactic_res": [
                    "_goal : forall (A : Type) (p p' : A) (xs ys zs : list A)\n  (_ : In p (app xs (cons p' ys)))\n  (_ : not (In p (app zs (app xs ys)))), eq p p'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (A : Type) (p p' : A) (xs ys zs : list A)\n  (_ : In p (app xs (cons p' ys)))\n  (_ : not (In p (app zs (app xs ys)))), eq p p'"
                ],
                "tactic_res": [
                    "_goal : eq p p'",
                    "H0 : not (In p (app zs (app xs ys)))",
                    "H : In p (app xs (cons p' ys))",
                    "xs : list A",
                    "ys : list A",
                    "zs : list A",
                    "p : A",
                    "p' : A",
                    "A : Type"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp in_app_iff .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp in_app_iff .",
                "tactic_args": [],
                "tactic_res": [
                    "H : or (In p xs) (In p (cons p' ys))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : or (In p xs) (or (eq p' p) (In p ys))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : In p xs",
                    "H0 : forall _ : In p (app zs (app xs ys)), False",
                    "H : In p ys"
                ]
            },
            {
                "tactic_sig": "find_false .",
                "tactic_sig_no_out_arg": "find_false .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : In p (app zs (app xs ys))"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In p (app zs (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : or (In p zs) (In p (app xs ys))"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "_goal : or (In p zs) (In p (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : In p (app xs ys)"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In p (app xs ys)"
                ],
                "tactic_res": [
                    "_goal : or (In p xs) (In p ys)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or (In p xs) (In p ys)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "find_false .",
                "tactic_sig_no_out_arg": "find_false .",
                "tactic_args": [
                    "_goal : eq p p'"
                ],
                "tactic_res": [
                    "_goal : In p (app zs (app xs ys))"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In p (app zs (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : or (In p zs) (In p (app xs ys))"
                ]
            },
            {
                "tactic_sig": "right .",
                "tactic_sig_no_out_arg": "right .",
                "tactic_args": [
                    "_goal : or (In p zs) (In p (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : In p (app xs ys)"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In p (app xs ys)"
                ],
                "tactic_res": [
                    "_goal : or (In p xs) (In p ys)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or (In p xs) (In p ys)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Lock_delivered_MsgLock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall i : Client_index,\nmessage_delivered_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ],
                "tactic_res": [
                    "_goal : forall i : Client_index,\nmessage_delivered_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "unfold message_delivered_label .",
                "tactic_sig_no_out_arg": "unfold message_delivered_label .",
                "tactic_args": [
                    "_goal : forall i : Client_index,\nmessage_delivered_label\n  {| pSrc := Client i; pDst := Server; pBody := Lock |} \n  (MsgLock i)"
                ],
                "tactic_res": [
                    "_goal : forall (i : Client_index) (l' : label) (net net' : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : lb_step_async net l' net' tr)\n  (_ : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n         (nwPackets net))\n  (_ : not\n         (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n            (nwPackets net'))), eq (MsgLock i) l'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (i : Client_index) (l' : label) (net net' : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : lb_step_async net l' net' tr)\n  (_ : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n         (nwPackets net))\n  (_ : not\n         (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n            (nwPackets net'))), eq (MsgLock i) l'"
                ],
                "tactic_res": [
                    "_goal : eq (MsgLock i) l'",
                    "H1 : not\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (nwPackets net'))",
                    "H0 : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (nwPackets net)",
                    "H : lb_step_async net l' net' tr",
                    "tr : list (prod name (sum input (list output)))",
                    "net : network",
                    "net' : network",
                    "l' : label",
                    "i : Client_index"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "H : lb_step_async net l' net' tr"
                ],
                "tactic_res": [
                    "_goal : eq (MsgLock i) label_silent",
                    "H8 : eq (cons (pair (pDst p) (inr out)) nil) tr",
                    "H7 : eq net'0 net'",
                    "H6 : eq lb l'",
                    "H5 : eq net0 net",
                    "H4 : eq net'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |}",
                    "H3 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (nwState net (pDst p)))\n  (pair (pair (pair l' out) d) l)",
                    "H2 : eq (nwPackets net) (app xs (cons p ys))",
                    "lb : label",
                    "l : list (prod lb_name lb_msg)",
                    "d : data",
                    "out : list output",
                    "xs : list packet",
                    "ys : list packet",
                    "p : packet",
                    "net0 : network",
                    "net'0 : network",
                    "H7 : eq (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)) tr",
                    "H6 : eq net'0 net'",
                    "H5 : eq lb l'",
                    "H4 : eq net0 net",
                    "H3 : eq net'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |}",
                    "H2 : eq (lb_input_handlers h inp (nwState net h))\n  (pair (pair (pair l' out) d) l)",
                    "inp : input",
                    "h : lb_name",
                    "H5 : eq nil tr",
                    "H4 : eq net net'",
                    "H3 : eq label_silent l'",
                    "H2 : eq net0 net"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : not\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (nwPackets\n        {|\n          nwPackets := app (send_packets (pDst p) l) (app xs ys);\n          nwState := update name_eq_dec (nwState net) (pDst p) d\n        |}))",
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |} (cons (pair (pDst p) (inr out)) nil)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |} (cons (pair (pDst p) (inr out)) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (runGenHandler (nwState net (pDst p))\n     (NetHandler (pDst p) (pSrc p) (pBody p)))\n  (pair (pair (pair l' out) d) l)",
                    "H1 : not\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))",
                    "out : list Output",
                    "l : list (prod Name Msg)",
                    "d : Data",
                    "l' : Label"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : not\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (nwPackets\n        {|\n          nwPackets := app (send_packets h l) (nwPackets net);\n          nwState := update name_eq_dec (nwState net) h d\n        |}))",
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |} (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |} (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (runGenHandler (nwState net h) (InputHandler h inp))\n  (pair (pair (pair l' out) d) l)",
                    "H1 : not\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets net)))",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (nwPackets net')",
                    "H : lb_step_async net' label_silent net' nil"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net' label_silent net' nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) label_silent"
                ],
                "tactic_res": [
                    "_goal : eq (MsgLock i) Silent"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app xs (cons p ys))"
                ]
            },
            {
                "tactic_sig": "find_eapply_lem_hyp In_split_not_In .",
                "tactic_sig_no_out_arg": "find_eapply_lem_hyp In_split_not_In .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app xs (cons ?p' ys))",
                    "H1 : eq {| pSrc := Client i; pDst := Server; pBody := Lock |} p"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) l'"
                ],
                "tactic_res": [
                    "_goal : eq (MsgLock i) l'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app xs (cons ?p' ys))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app xs\n     (cons {| pSrc := Client i; pDst := Server; pBody := Lock |} ys))",
                    "H2 : eq (nwPackets net)\n  (app xs\n     (cons {| pSrc := Client i; pDst := Server; pBody := Lock |} ys))",
                    "H3 : eq\n  (runGenHandler\n     (nwState net\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |}))\n     (NetHandler\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n        (pSrc {| pSrc := Client i; pDst := Server; pBody := Lock |})\n        (pBody {| pSrc := Client i; pDst := Server; pBody := Lock |})))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (NetHandler\n     (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pSrc {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (pBody {| pSrc := Client i; pDst := Server; pBody := Lock |})\n     (nwState net\n        (pDst {| pSrc := Client i; pDst := Server; pBody := Lock |})))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq (ServerNetHandler (Client i) Lock (nwState net Server))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    let\n    'pair (pair (pair _ os1) s') ws1 :=\n     let\n     'pair (pair (pair _ os1) _) ws1 :=\n      (if null (queue (nwState net Server))\n       then\n        fun s : Data =>\n        pair (pair (pair tt (app nil nil)) s)\n          (app (cons (pair (Client i) Locked) nil) nil)\n       else fun s : Data => pair (pair (pair tt nil) s) nil)\n        (nwState net Server) in\n      pair\n        (pair (pair tt (app os1 nil))\n           {|\n             queue := app (queue (nwState net Server)) (cons i nil);\n             held := held (nwState net Server)\n           |}) (app ws1 nil) in\n     pair (pair (pair (MsgLock i) (app os1 nil)) s') (app ws1 nil) in\n    pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq (pair (pair (pair l1 (app nil l2)) d0) (app nil l0))\n  (pair (pair (pair l' out) d) l)",
                    "Heqp : eq (pair (pair (pair (MsgLock i) (app l4 nil)) d1) (app l3 nil))\n  (pair (pair (pair l1 l2) d0) l0)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app l6 nil))\n        {|\n          queue := app (queue (nwState net Server)) (cons i nil);\n          held := held (nwState net Server)\n        |}) (app l5 nil)) (pair (pair (pair u l4) d1) l3)",
                    "Heqp5 : eq\n  (pair (pair (pair tt (app nil nil)) (nwState net Server))\n     (app (cons (pair (Client i) Locked) nil) nil))\n  (pair (pair (pair u0 l6) d2) l5)",
                    "Heqb : eq (null (queue (nwState net Server))) true",
                    "Heqp6 : eq p3 (pair (pair u0 l6) d2)",
                    "Heqp7 : eq p4 (pair u0 l6)",
                    "l6 : list Output",
                    "u0 : unit",
                    "d2 : Data",
                    "p4 : prod unit (list Output)",
                    "l5 : list (prod Name Msg)",
                    "p3 : prod (prod unit (list Output)) Data",
                    "Heqp3 : eq p1 (pair (pair u l4) d1)",
                    "Heqp4 : eq p2 (pair u l4)",
                    "l4 : list Output",
                    "u : unit",
                    "d1 : Data",
                    "p2 : prod unit (list Output)",
                    "l3 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp0 : eq p (pair (pair l1 l2) d0)",
                    "Heqp1 : eq p0 (pair l1 l2)",
                    "l2 : list Output",
                    "l1 : Label",
                    "d0 : Data",
                    "p0 : prod Label (list Output)",
                    "l0 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heqp5 : eq (pair (pair (pair tt nil) (nwState net Server)) nil)\n  (pair (pair (pair u0 l6) d2) l5)",
                    "Heqb : eq (null (queue (nwState net Server))) false"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) (MsgLock i)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold not in * .",
                "tactic_sig_no_out_arg": "unfold not in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : forall\n  _ : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n        (app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n           (nwPackets net)), False"
                ]
            },
            {
                "tactic_sig": "find_false .",
                "tactic_sig_no_out_arg": "find_false .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) l'"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n     (nwPackets net))"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n     (nwPackets net))"
                ],
                "tactic_res": [
                    "_goal : or\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l))\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (nwPackets net))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l))\n  (In {| pSrc := Client i; pDst := Server; pBody := Lock |}\n     (nwPackets net))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (MsgLock i) Silent"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "label_eq_dec",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall x y : label, sumbool (eq x y) (not (eq x y))"
                ],
                "tactic_res": [
                    "_goal : forall x y : label, sumbool (eq x y) (not (eq x y))"
                ]
            },
            {
                "tactic_sig": "decide equality .",
                "tactic_sig_no_out_arg": "decide equality .",
                "tactic_args": [
                    "_goal : forall x y : label, sumbool (eq x y) (not (eq x y))"
                ],
                "tactic_res": [
                    "_goal : sumbool (eq c c0) (not (eq c c0))",
                    "_goal : sumbool (eq c c0) (not (eq c c0))",
                    "_goal : sumbool (eq c c0) (not (eq c c0))",
                    "_goal : sumbool (eq c c0) (not (eq c c0))",
                    "c : Client_index",
                    "c0 : Client_index",
                    "x : label",
                    "y : label"
                ]
            },
            {
                "tactic_sig": "apply fin_eq_dec .",
                "tactic_sig_no_out_arg": "apply fin_eq_dec .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply fin_eq_dec .",
                "tactic_sig_no_out_arg": "apply fin_eq_dec .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply fin_eq_dec .",
                "tactic_sig_no_out_arg": "apply fin_eq_dec .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply fin_eq_dec .",
                "tactic_sig_no_out_arg": "apply fin_eq_dec .",
                "tactic_args": [
                    "_goal : sumbool (eq c c0) (not (eq c c0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "messages_trigger_labels",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (l : label) (p : packet) (_ : message_enables_label p l)\n  (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : forall (l : label) (p : packet) (_ : message_enables_label p l)\n  (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros l p Henabled Hdelivered .",
                "tactic_args": [
                    "_goal : forall (l : label) (p : packet) (_ : message_enables_label p l)\n  (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s",
                    "Hdelivered : message_delivered_label p l",
                    "Henabled : message_enables_label p l",
                    "p : packet",
                    "l : label"
                ]
            },
            {
                "tactic_sig": "cofix c .",
                "tactic_sig_no_out_arg": "cofix c .",
                "tactic_args": [],
                "tactic_res": [
                    "c : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "destruct s as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct s .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : In p (nwPackets (evt_a (hd (Cons e s))))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons e s)",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "e : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : In p (nwPackets (evt_a (hd (Cons e s))))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons e s)",
                    "e : event network label (prod name (sum input (list output)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s))\n  (_ : In p\n         (nwPackets\n            (LabeledNet.evt_a\n               (hd\n                  (Cons\n                     {|\n                       evt_a := evt_a;\n                       evt_l := evt_l;\n                       evt_trace := evt_trace\n                     |} s))))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "evt_trace : list (prod name (sum input (list output)))",
                    "evt_l : label",
                    "evt_a : network"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s))\n  (_ : In p\n         (nwPackets\n            (LabeledNet.evt_a\n               (hd\n                  (Cons\n                     {|\n                       evt_a := evt_a;\n                       evt_l := evt_l;\n                       evt_trace := evt_trace\n                     |} s))))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s)) (_ : In p (nwPackets evt_a)),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hexec Hin .",
                "tactic_args": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s)) (_ : In p (nwPackets evt_a)),\nweak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ],
                "tactic_res": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "Hin : In p (nwPackets evt_a)",
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ],
                "tactic_res": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "H0 : eq (Cons e' s0) s",
                    "H : eq e {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}",
                    "H3 : lb_step_execution lb_step_async (Cons e' s0)",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app\n     (LabeledNet.evt_trace\n        {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n     tr)",
                    "H1 : lb_step_async\n  (LabeledNet.evt_a\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n  (LabeledNet.evt_l\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n  (LabeledNet.evt_a e') tr",
                    "s0 : infseq (event network Label (prod Name (sum Input (list Output))))",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "e : event network Label (prod Name (sum Input (list Output)))",
                    "e' : event network Label (prod Name (sum Input (list Output)))"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (LabeledNet.evt_trace e') (app evt_trace tr)",
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e') tr",
                    "evt_trace : list (prod Name (sum Input (list Output)))",
                    "evt_l : Label",
                    "c : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (LabeledNet.evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s",
                    "l : Label"
                ]
            },
            {
                "tactic_sig": "destruct ( label_eq_dec _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( label_eq_dec _i _i ) .",
                "tactic_args": [
                    "l : Label",
                    "evt_l : Label"
                ],
                "tactic_res": [
                    "e : eq l evt_l",
                    "n : not (eq l evt_l)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "evt_l : Label"
                ],
                "tactic_res": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "H1 : lb_step_async evt_a l (LabeledNet.evt_a e') tr"
                ]
            },
            {
                "tactic_sig": "apply W0 .",
                "tactic_sig_no_out_arg": "apply W0 .",
                "tactic_args": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : now (occurred l)\n  (Cons {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : now (occurred l)\n  (Cons {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : occurred l {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : occurred l {| evt_a := evt_a; evt_l := l; evt_trace := evt_trace |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply W_tl .",
                "tactic_sig_no_out_arg": "apply W_tl .",
                "tactic_args": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : now (enabled lb_step_async l)\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (tl\n     (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n        (Cons e' s0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : now (enabled lb_step_async l)\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : enabled lb_step_async l\n  {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}"
                ]
            },
            {
                "tactic_sig": "unfold message_enables_label in * .",
                "tactic_sig_no_out_arg": "unfold message_enables_label in * .",
                "tactic_args": [],
                "tactic_res": [
                    "Henabled : forall (net : network) (_ : In p (nwPackets net)),\nlb_step_ex lb_step_async l net"
                ]
            },
            {
                "tactic_sig": "unfold enabled .",
                "tactic_sig_no_out_arg": "unfold enabled .",
                "tactic_args": [
                    "_goal : enabled lb_step_async l\n  {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async l\n  (LabeledNet.evt_a\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async l\n  (LabeledNet.evt_a\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async l evt_a"
                ]
            },
            {
                "tactic_sig": "now auto .",
                "tactic_sig_no_out_arg": "now auto .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async l evt_a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (tl\n     (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n        (Cons e' s0)))"
                ],
                "tactic_res": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons e' s0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : weak_until (now (enabled lb_step_async l)) (now (occurred l))\n  (Cons e' s0)",
                    "c : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (LabeledNet.evt_a (hd s)))),\nweak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : lb_step_execution lb_step_async (Cons e' s0)",
                    "_goal : In p (nwPackets (LabeledNet.evt_a (hd (Cons e' s0))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : lb_step_execution lb_step_async (Cons e' s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a (hd (Cons e' s0))))"
                ],
                "tactic_res": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a (hd (Cons e' s0))))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a (hd (Cons e' s0))))"
                ],
                "tactic_res": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a e'))"
                ]
            },
            {
                "tactic_sig": "match goal with | | - In ?p ?ps => destruct ( In_dec packet_eq_dec _i ps ) end .",
                "tactic_sig_no_out_arg": "match goal with | | - In ?p ?ps => destruct ( In_dec packet_eq_dec _i ps ) end .",
                "tactic_args": [
                    "p : packet"
                ],
                "tactic_res": [
                    "i : In p (nwPackets (LabeledNet.evt_a e'))",
                    "n0 : not (In p (nwPackets (LabeledNet.evt_a e')))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a e'))"
                ]
            },
            {
                "tactic_sig": "unfold message_delivered_label in * .",
                "tactic_sig_no_out_arg": "unfold message_delivered_label in * .",
                "tactic_args": [],
                "tactic_res": [
                    "Hdelivered : forall (l' : label) (net net' : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : lb_step_async net l' net' tr) (_ : In p (nwPackets net))\n  (_ : not (In p (nwPackets net'))), eq l l'"
                ]
            },
            {
                "tactic_sig": "now find_apply_hyp_hyp .",
                "tactic_sig_no_out_arg": "now find_apply_hyp_hyp .",
                "tactic_args": [
                    "_goal : In p (nwPackets (LabeledNet.evt_a e'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "message_labels_eventually_occur",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (l : label) (p : packet) (_ : not (eq l label_silent))\n  (_ : message_enables_label p l) (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\neventually (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : forall (l : label) (p : packet) (_ : not (eq l label_silent))\n  (_ : message_enables_label p l) (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\neventually (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (l : label) (p : packet) (_ : not (eq l label_silent))\n  (_ : message_enables_label p l) (_ : message_delivered_label p l)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : lb_step_execution lb_step_async s)\n  (_ : In p (nwPackets (evt_a (hd s)))),\neventually (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred l)) s",
                    "H4 : In p (nwPackets (evt_a (hd s)))",
                    "H3 : lb_step_execution lb_step_async s",
                    "H2 : weak_fairness lb_step_async label_silent s",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "H1 : message_delivered_label p l",
                    "H0 : message_enables_label p l",
                    "H : not (eq l label_silent)",
                    "p : packet",
                    "l : label"
                ]
            },
            {
                "tactic_sig": "find_eapply_lem_hyp messages_trigger_labels .",
                "tactic_sig_no_out_arg": "find_eapply_lem_hyp messages_trigger_labels .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : message_enables_label p ?l",
                    "_goal : message_delivered_label p ?l",
                    "_goal : lb_step_execution lb_step_async s",
                    "H4 : weak_until (now (enabled lb_step_async l)) (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eventually (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : message_enables_label p ?l",
                    "_goal : message_delivered_label p ?l"
                ],
                "tactic_res": [
                    "_goal : message_delivered_label p l"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : message_delivered_label p l"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : lb_step_execution lb_step_async s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "find_apply_lem_hyp weak_until_until_or_always .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp weak_until_until_or_always .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : or (until (now (enabled lb_step_async l)) (now (occurred l)) s)\n  (always (now (enabled lb_step_async l)) s)"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : until (now (enabled lb_step_async l)) (now (occurred l)) s",
                    "H : forall _ : eq l label_silent, False",
                    "H5 : always (now (enabled lb_step_async l)) s"
                ]
            },
            {
                "tactic_sig": "now eauto using until_eventually .",
                "tactic_sig_no_out_arg": "now eauto using until_eventually .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "find_apply_lem_hyp always_continuously .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp always_continuously .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : continuously (now (enabled lb_step_async l)) s"
                ]
            },
            {
                "tactic_sig": "eapply_prop_hyp weak_fairness continuously .",
                "tactic_sig_no_out_arg": "eapply_prop_hyp weak_fairness continuously .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : not (eq l label_silent)",
                    "H5 : inf_occurred l s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eventually (now (occurred l)) s"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred l)) s"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : not (eq l label_silent)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eventually (now (occurred l)) s",
                    "s : infseq (event network label (prod name (sum input (list output))))"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred l)) (Cons e s)",
                    "H5 : inf_occurred l (Cons e s)",
                    "H3 : lb_step_execution lb_step_async (Cons e s)",
                    "H2 : weak_fairness lb_step_async label_silent (Cons e s)",
                    "e : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "now find_apply_lem_hyp always_now .",
                "tactic_sig_no_out_arg": "now find_apply_lem_hyp always_now .",
                "tactic_args": [
                    "_goal : eventually (now (occurred l)) (Cons e s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Nth_app",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l l' : list A) (a : A) (n : nat) (_ : Nth l n a),\nNth (app l l') n a"
                ],
                "tactic_res": [
                    "_goal : forall (A : Type) (l l' : list A) (a : A) (n : nat) (_ : Nth l n a),\nNth (app l l') n a"
                ]
            },
            {
                "tactic_sig": "induction l .",
                "tactic_sig_no_out_arg": "induction l .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l l' : list A) (a : A) (n : nat) (_ : Nth l n a),\nNth (app l l') n a"
                ],
                "tactic_res": [
                    "_goal : forall (l' : list A) (a : A) (n : nat) (_ : Nth nil n a),\nNth (app nil l') n a",
                    "_goal : forall (l' : list A) (a0 : A) (n : nat) (_ : Nth (cons a l) n a0),\nNth (app (cons a l) l') n a0",
                    "A : Type",
                    "IHl : forall (l' : list A) (a : A) (n : nat) (_ : Nth l n a),\nNth (app l l') n a",
                    "l : list A",
                    "a : A"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (l' : list A) (a : A) (n : nat) (_ : Nth nil n a),\nNth (app nil l') n a"
                ],
                "tactic_res": [
                    "_goal : Nth (app nil l') n a",
                    "H : Nth nil n a",
                    "n : nat",
                    "l' : list A"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Nth (app nil l') n a"
                ],
                "tactic_res": [
                    "_goal : Nth l' n a"
                ]
            },
            {
                "tactic_sig": "try solve_by_inversion .",
                "tactic_sig_no_out_arg": "try solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth l' n a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (l' : list A) (a0 : A) (n : nat) (_ : Nth (cons a l) n a0),\nNth (app (cons a l) l') n a0"
                ],
                "tactic_res": [
                    "_goal : Nth (app (cons a l) l') n a0",
                    "H : Nth (cons a l) n a0",
                    "n : nat",
                    "a0 : A",
                    "l' : list A"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Nth (app (cons a l) l') n a0"
                ],
                "tactic_res": [
                    "_goal : Nth (cons a (app l l')) n a0"
                ]
            },
            {
                "tactic_sig": "try solve_by_inversion .",
                "tactic_sig_no_out_arg": "try solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth (cons a (app l l')) n a0"
                ],
                "tactic_res": [
                    "_goal : Nth (cons a (app l l')) n a0"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : Nth (cons a (app l l')) n a0",
                    "H : Nth (cons a l) n a0"
                ],
                "tactic_res": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0",
                    "_goal : Nth (cons a (app l l')) (S n0) a0",
                    "H3 : eq a a0",
                    "H0 : eq 0 n",
                    "H2 : eq l0 l",
                    "H1 : eq x a",
                    "l0 : list A",
                    "x : A",
                    "H3 : eq x a0",
                    "H1 : eq (S n0) n",
                    "H0 : eq y a",
                    "H4 : Nth l n0 a0",
                    "y : A",
                    "n0 : nat"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H : Nth (cons a0 l) 0 a0"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : Nth (cons a0 l) 0 a0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0"
                ],
                "tactic_res": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H : Nth (cons a l) (S n0) a0"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : Nth (cons a l) (S n0) a0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0"
                ],
                "tactic_res": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : Nth (cons a0 (app l l')) 0 a0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : Nth (cons a (app l l')) (S n0) a0"
                ],
                "tactic_res": [
                    "_goal : Nth (app l l') n0 a0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Nth (app l l') n0 a0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Nth_tl",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l : list A) (a : A) (n : nat) (_ : Nth l (S n) a),\nNth (List.tl l) n a"
                ],
                "tactic_res": [
                    "_goal : forall (A : Type) (l : list A) (a : A) (n : nat) (_ : Nth l (S n) a),\nNth (List.tl l) n a"
                ]
            },
            {
                "tactic_sig": "induction l .",
                "tactic_sig_no_out_arg": "induction l .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l : list A) (a : A) (n : nat) (_ : Nth l (S n) a),\nNth (List.tl l) n a"
                ],
                "tactic_res": [
                    "_goal : forall (a : A) (n : nat) (_ : Nth nil (S n) a), Nth (List.tl nil) n a",
                    "_goal : forall (a0 : A) (n : nat) (_ : Nth (cons a l) (S n) a0),\nNth (List.tl (cons a l)) n a0",
                    "A : Type",
                    "IHl : forall (a : A) (n : nat) (_ : Nth l (S n) a), Nth (List.tl l) n a",
                    "l : list A",
                    "a : A"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (a : A) (n : nat) (_ : Nth nil (S n) a), Nth (List.tl nil) n a"
                ],
                "tactic_res": [
                    "_goal : Nth (List.tl nil) n a",
                    "H : Nth nil (S n) a",
                    "n : nat"
                ]
            },
            {
                "tactic_sig": "solve_by_inversion .",
                "tactic_sig_no_out_arg": "solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth (List.tl nil) n a"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (a0 : A) (n : nat) (_ : Nth (cons a l) (S n) a0),\nNth (List.tl (cons a l)) n a0"
                ],
                "tactic_res": [
                    "_goal : Nth (List.tl (cons a l)) n a0",
                    "H : Nth (cons a l) (S n) a0",
                    "n : nat",
                    "a0 : A"
                ]
            },
            {
                "tactic_sig": "solve_by_inversion .",
                "tactic_sig_no_out_arg": "solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth (List.tl (cons a l)) n a0"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "clients_only_move_up_in_queue",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (n : nat) (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : forall (n : nat) (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros n c .",
                "tactic_args": [
                    "_goal : forall (n : nat) (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s",
                    "c : Client_index",
                    "n : nat"
                ]
            },
            {
                "tactic_sig": "cofix CIH .",
                "tactic_sig_no_out_arg": "cofix CIH .",
                "tactic_args": [],
                "tactic_res": [
                    "CIH : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s"
                ]
            },
            {
                "tactic_sig": "destruct s as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct s .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : Nth (queue (nwState (evt_a (hd (Cons e s))) Server)) (S n) c),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s)))))) (Cons e s)",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "e : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : Nth (queue (nwState (evt_a (hd (Cons e s))) Server)) (S n) c),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (evt_a (hd s)))))) (Cons e s)",
                    "e : event network label (prod name (sum input (list output)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s))\n  (_ : Nth\n         (queue\n            (nwState\n               (LabeledNet.evt_a\n                  (hd\n                     (Cons\n                        {|\n                          evt_a := evt_a;\n                          evt_l := evt_l;\n                          evt_trace := evt_trace\n                        |} s))) Server)) (S n) c),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "evt_trace : list (prod name (sum input (list output)))",
                    "evt_l : label",
                    "evt_a : network"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros Hexec HNth .",
                "tactic_args": [
                    "_goal : forall\n  (_ : lb_step_execution lb_step_async\n         (Cons\n            {|\n              evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace\n            |} s))\n  (_ : Nth\n         (queue\n            (nwState\n               (LabeledNet.evt_a\n                  (hd\n                     (Cons\n                        {|\n                          evt_a := evt_a;\n                          evt_l := evt_l;\n                          evt_trace := evt_trace\n                        |} s))) Server)) (S n) c),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "HNth : Nth\n  (queue\n     (nwState\n        (LabeledNet.evt_a\n           (hd\n              (Cons\n                 {|\n                   evt_a := evt_a;\n                   evt_l := evt_l;\n                   evt_trace := evt_trace\n                 |} s))) Server)) (S n) c",
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)",
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |} s)"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "H0 : eq (Cons e' s0) s",
                    "H : eq e {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}",
                    "H3 : lb_step_execution lb_step_async (Cons e' s0)",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app\n     (LabeledNet.evt_trace\n        {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n     tr)",
                    "H1 : lb_step_async\n  (LabeledNet.evt_a\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n  (LabeledNet.evt_l\n     {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |})\n  (LabeledNet.evt_a e') tr",
                    "s0 : infseq (event network label (prod name (sum input (list output))))",
                    "tr : list (prod name (sum input (list output)))",
                    "e : event network label (prod name (sum input (list output)))",
                    "e' : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "HNth : Nth\n  (queue\n     (nwState\n        (LabeledNet.evt_a\n           (hd\n              (Cons\n                 {|\n                   evt_a := evt_a;\n                   evt_l := evt_l;\n                   evt_trace := evt_trace\n                 |} (Cons e' s0)))) Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "Hexec : lb_step_execution lb_step_async\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "H2 : eq (LabeledNet.evt_trace e') (app evt_trace tr)",
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e') tr",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "HNth : Nth (queue (nwState evt_a Server)) (S n) c",
                    "s0 : infseq (event network Label (prod Name (sum Input (list Output))))",
                    "e' : event network Label (prod Name (sum Input (list Output)))",
                    "evt_trace : list (prod Name (sum Input (list Output)))",
                    "evt_l : Label",
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e') tr"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons\n     {|\n       evt_a := LabeledNet.evt_a e';\n       evt_l := label_silent;\n       evt_trace := evt_trace\n     |} (Cons e' s0))",
                    "H8 : eq (cons (pair (pDst p) (inr out)) nil) tr",
                    "H7 : eq net' (LabeledNet.evt_a e')",
                    "H6 : eq lb evt_l",
                    "H5 : eq net evt_a",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState evt_a) (pDst p) d\n  |}",
                    "H0 : eq\n  (lb_net_handlers (pDst p) (pSrc p) (pBody p) (nwState evt_a (pDst p)))\n  (pair (pair (pair evt_l out) d) l)",
                    "H : eq (nwPackets evt_a) (app xs (cons p ys))",
                    "lb : label",
                    "l : list (prod lb_name lb_msg)",
                    "d : data",
                    "out : list output",
                    "xs : list packet",
                    "ys : list packet",
                    "p : packet",
                    "net : network",
                    "net' : network",
                    "H7 : eq (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)) tr",
                    "H6 : eq net' (LabeledNet.evt_a e')",
                    "H5 : eq lb evt_l",
                    "H4 : eq net evt_a",
                    "H0 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets := app (send_packets h l) (nwPackets evt_a);\n    nwState := update name_eq_dec (nwState evt_a) h d\n  |}",
                    "H : eq (lb_input_handlers h inp (nwState evt_a h))\n  (pair (pair (pair evt_l out) d) l)",
                    "inp : input",
                    "h : lb_name",
                    "H5 : eq nil tr",
                    "H4 : eq evt_a (LabeledNet.evt_a e')",
                    "H0 : eq label_silent evt_l",
                    "H : eq net evt_a"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair (pDst p) (inr out)) nil))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) (pDst p) d\n  |}",
                    "H0 : eq\n  (runGenHandler (nwState evt_a (pDst p))\n     (NetHandler (pDst p) (pSrc p) (pBody p)))\n  (pair (pair (pair evt_l out) d) l)",
                    "l : list (prod Name Msg)",
                    "d : Data",
                    "out : list Output"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace\n     (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H1 : lb_step_async evt_a evt_l (LabeledNet.evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets evt_a);\n    nwState := update Name_eq_dec (nwState evt_a) h d\n  |}",
                    "H : eq (runGenHandler (nwState evt_a h) (InputHandler h inp))\n  (pair (pair (pair evt_l out) d) l)",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : lb_step_async (LabeledNet.evt_a e') label_silent (LabeledNet.evt_a e')\n  nil",
                    "H2 : eq (LabeledNet.evt_trace e') (app evt_trace nil)",
                    "HNth : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H1 : lb_step_async (LabeledNet.evt_a e') label_silent (LabeledNet.evt_a e')\n  nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons\n     {|\n       evt_a := LabeledNet.evt_a e';\n       evt_l := label_silent;\n       evt_trace := evt_trace\n     |} (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons\n     {|\n       evt_a := LabeledNet.evt_a e';\n       evt_l := Silent;\n       evt_trace := evt_trace\n     |} (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "unfold runGenHandler , NetHandler in * .",
                "tactic_sig_no_out_arg": "unfold runGenHandler , NetHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq\n  (match pDst p with\n   | Client c => ClientNetHandler c (pBody p)\n   | Server => ServerNetHandler (pSrc p) (pBody p)\n   end (nwState evt_a (pDst p))) (pair (pair (pair evt_l out) d) l)"
                ]
            },
            {
                "tactic_sig": "break_match .",
                "tactic_sig_no_out_arg": "break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client c0; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) (Client c0) d\n  |}",
                    "H0 : eq (ClientNetHandler c0 (pBody p) (nwState evt_a (Client c0)))\n  (pair (pair (pair evt_l out) d) l)",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair (Client c0) (inr out)) nil))",
                    "Heqn0 : eq (pDst p) (Client c0)",
                    "c0 : Client_index",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "H0 : eq (ServerNetHandler (pSrc p) (pBody p) (nwState evt_a Server))\n  (pair (pair (pair evt_l out) d) l)",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr out)) nil))",
                    "Heqn0 : eq (pDst p) Server"
                ]
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "find_rewrite .",
                "tactic_sig_no_out_arg": "find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {|\n                    pSrc := Client c0; pDst := fst m; pBody := snd m\n                  |}) l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) (Client c0) d\n        |} Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {|\n                    pSrc := Client c0; pDst := fst m; pBody := snd m\n                  |}) l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) (Client c0) d\n        |} Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) (Client c0) d Server))\n  (S n) c"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) (Client c0) d Server))\n  (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "find_apply_lem_hyp ServerNetHandler_lbcases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp ServerNetHandler_lbcases .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq (pSrc p) (Client c))\n           (and (eq (pBody p) Lock)\n              (and (eq evt_l (MsgLock c))\n                 (and\n                    (eq (queue d)\n                       (app (queue (nwState evt_a Server)) (cons c nil)))\n                    (or\n                       (and (eq (queue (nwState evt_a Server)) nil)\n                          (eq l (cons (pair (Client c) Locked) nil)))\n                       (and\n                          (not (eq (queue (nwState evt_a Server)) nil))\n                          (eq l nil))))))))\n     (or\n        (and (eq (pBody p) Unlock)\n           (and (eq evt_l MsgUnlock)\n              (and\n                 (eq (queue d) (List.tl (queue (nwState evt_a Server))))\n                 (or (and (eq (queue d) nil) (eq l nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue d) (cons next t))\n                             (eq l\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq l nil)\n           (and (eq d (nwState evt_a Server)) (eq evt_l Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and (eq (pBody p) Lock)\n        (and (eq evt_l (MsgLock c))\n           (and\n              (eq (queue d)\n                 (app (queue (nwState evt_a Server)) (cons c nil)))\n              (or\n                 (and (eq (queue (nwState evt_a Server)) nil)\n                    (eq l (cons (pair (Client c) Locked) nil)))\n                 (and\n                    (forall _ : eq (queue (nwState evt_a Server)) nil,\n                     False) (eq l nil)))))))",
                    "H1 : eq out nil",
                    "H9 : eq l nil",
                    "H8 : eq (queue d) nil",
                    "H6 : eq (queue d) (List.tl (queue (nwState evt_a Server)))",
                    "H5 : eq evt_l MsgUnlock",
                    "H0 : eq (pBody p) Unlock",
                    "H7 : ex\n  (fun next : Client_index =>\n   ex\n     (fun t : list Client_index =>\n      and (eq (queue d) (cons next t))\n        (eq l (cons (pair (Client next) Locked) nil))))",
                    "H7 : eq evt_l Nop",
                    "H5 : eq d (nwState evt_a Server)",
                    "H0 : eq l nil"
                ]
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) Server d\n        |} Server)) (S n) c",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) Server d\n        |} Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) Server d Server)) \n  (S n) c"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) Server d Server)) \n  (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (queue d) (S n) c"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : and (eq (pSrc p) (Client x))\n  (and (eq (pBody p) Lock)\n     (and (eq evt_l (MsgLock x))\n        (and\n           (eq (queue d)\n              (app (queue (nwState evt_a Server)) (cons x nil)))\n           (or\n              (and (eq (queue (nwState evt_a Server)) nil)\n                 (eq l (cons (pair (Client x) Locked) nil)))\n              (and\n                 (forall _ : eq (queue (nwState evt_a Server)) nil,\n                  False) (eq l nil))))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H10 : eq l (cons (pair (Client x) Locked) nil)",
                    "H9 : eq (queue (nwState evt_a Server)) nil",
                    "H7 : eq (queue d) (app (queue (nwState evt_a Server)) (cons x nil))",
                    "H6 : eq evt_l (MsgLock x)",
                    "H0 : eq (pBody p) Lock",
                    "H5 : eq (pSrc p) (Client x)",
                    "H10 : eq l nil",
                    "H9 : forall _ : eq (queue (nwState evt_a Server)) nil, False"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Nth (app nil (cons x nil)) (S n) c",
                    "H7 : eq (queue d) (app nil (cons x nil))",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |})\n           (cons (pair (Client x) Locked) nil)) (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "HNth : Nth nil (S n) c"
                ]
            },
            {
                "tactic_sig": "try solve_by_inversion .",
                "tactic_sig_no_out_arg": "try solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth (app nil (cons x nil)) (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue d) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (app (queue (nwState evt_a Server)) (cons x nil)) (S n) c",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}"
                ]
            },
            {
                "tactic_sig": "try solve_by_inversion .",
                "tactic_sig_no_out_arg": "try solve_by_inversion .",
                "tactic_args": [
                    "_goal : Nth (app (queue (nwState evt_a Server)) (cons x nil)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (app (queue (nwState evt_a Server)) (cons x nil)) (S n) c"
                ]
            },
            {
                "tactic_sig": "now eauto using Nth_app .",
                "tactic_sig_no_out_arg": "now eauto using Nth_app .",
                "tactic_args": [
                    "_goal : Nth (app (queue (nwState evt_a Server)) (cons x nil)) (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "HNth : Nth (queue (nwState evt_a Server)) (S n) c"
                ],
                "tactic_res": [
                    "H9 : eq x c",
                    "H5 : eq n0 n",
                    "H1 : eq (cons y l) (queue (nwState evt_a Server))",
                    "H7 : Nth l n c",
                    "y : Client_index",
                    "n0 : nat",
                    "x : Client_index",
                    "l : list Client_index"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "HNth : Nth (queue (nwState evt_a Server)) (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}"
                ]
            },
            {
                "tactic_sig": "repeat find_reverse_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_reverse_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (cons y l) (queue (nwState evt_a (pDst p)))",
                    "H6 : eq (queue d) (List.tl (cons y l))",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState := update Name_eq_dec (nwState evt_a) (pDst p) d\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair (pDst p) (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H6 : eq (queue d) l"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (cons y nil) (queue (nwState evt_a Server))",
                    "H7 : Nth nil n c",
                    "H8 : eq l nil",
                    "H6 : eq (queue d) nil",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "now solve_by_inversion .",
                "tactic_sig_no_out_arg": "now solve_by_inversion .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply W0 .",
                "tactic_sig_no_out_arg": "apply W0 .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   =>\n   and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n     (forall _ : eq n 0,\n      In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n        (nwPackets (LabeledNet.evt_a (hd s)))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   =>\n   and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n     (forall _ : eq n 0,\n      In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n        (nwPackets (LabeledNet.evt_a (hd s)))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : and (Nth (queue (nwState (LabeledNet.evt_a e') Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets (LabeledNet.evt_a e')))"
                ]
            },
            {
                "tactic_sig": "fold LockServ_MultiParams in * .",
                "tactic_sig_no_out_arg": "fold LockServ_MultiParams in * .",
                "tactic_args": [
                    "_goal : and (Nth (queue (nwState (LabeledNet.evt_a e') Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets (LabeledNet.evt_a e')))"
                ],
                "tactic_res": [
                    "_goal : and (Nth (queue (nwState (LabeledNet.evt_a e') Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets (LabeledNet.evt_a e')))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : and (Nth (queue (nwState (LabeledNet.evt_a e') Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets (LabeledNet.evt_a e')))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Nth\n     (queue\n        (nwState\n           {|\n             nwPackets :=\n               app\n                 (map\n                    (fun m : prod Name Msg =>\n                     {|\n                       pSrc := Server; pDst := fst m; pBody := snd m\n                     |}) l) (app xs ys);\n             nwState := update Name_eq_dec (nwState evt_a) Server d\n           |} Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) Server d\n        |}))",
                    "H7 : ex\n  (fun next : Client_index =>\n   ex\n     (fun t : list Client_index =>\n      and (eq (List.tl (queue (nwState evt_a Server))) (cons next t))\n        (eq l (cons (pair (Client next) Locked) nil))))",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and\n  (Nth\n     (queue\n        (nwState\n           {|\n             nwPackets :=\n               app\n                 (map\n                    (fun m : prod Name Msg =>\n                     {|\n                       pSrc := Server; pDst := fst m; pBody := snd m\n                     |}) l) (app xs ys);\n             nwState := update Name_eq_dec (nwState evt_a) Server d\n           |} Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (nwPackets\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState evt_a) Server d\n        |}))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Nth (queue (update Name_eq_dec (nwState evt_a) Server d Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : and\n  (Nth (queue (update Name_eq_dec (nwState evt_a) Server d Server)) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ],
                "tactic_res": [
                    "_goal : and (Nth (queue d) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : and (Nth (queue d) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ],
                "tactic_res": [
                    "_goal : and (Nth (List.tl (queue (nwState evt_a Server))) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ]
            },
            {
                "tactic_sig": "intuition eauto using Nth_tl .",
                "tactic_sig_no_out_arg": "intuition eauto using Nth_tl .",
                "tactic_args": [
                    "_goal : and (Nth (List.tl (queue (nwState evt_a Server))) n c)\n  (forall _ : eq n 0,\n   In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n     (app xs ys))",
                    "H8 : eq n 0"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H7 : and (eq (List.tl (queue (nwState evt_a Server))) (cons x x0))\n  (eq l (cons (pair (Client x) Locked) nil))",
                    "x0 : list Client_index",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H10 : eq l (cons (pair (Client x) Locked) nil)",
                    "H9 : eq (List.tl (queue (nwState evt_a Server))) (cons x x0)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n     (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |})\n        (cons (pair (Client x) Locked) nil)) (app xs ys))",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |})\n           (cons (pair (Client x) Locked) nil)) (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "HNth : Nth (queue (nwState evt_a Server)) 1 c"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp Nth_tl .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp Nth_tl .",
                "tactic_args": [],
                "tactic_res": [
                    "HNth : Nth (List.tl (queue (nwState evt_a Server))) 0 c"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H6 : eq (queue d) (cons x x0)",
                    "HNth : Nth (cons x x0) 0 c"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |})\n        (cons (pair (Client x) Locked) nil)) (app xs ys))",
                    "HNth : Nth (cons x x0) 0 c"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |})\n        (cons (pair (Client c) Locked) nil)) (app xs ys))",
                    "H1 : eq x c",
                    "H7 : eq l x0",
                    "H5 : eq x1 x",
                    "l : list Client_index",
                    "x1 : Client_index"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : eq (List.tl (queue (nwState evt_a Server))) (cons c x0)",
                    "H6 : eq (queue d) (cons c x0)",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |})\n           (cons (pair (Client c) Locked) nil)) (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}",
                    "HNth : Nth (cons c x0) 0 c"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "HNth : Nth (cons c x0) 0 c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := Server; pDst := fst m; pBody := snd m |})\n        (cons (pair (Client c) Locked) nil)) (app xs ys))"
                ],
                "tactic_res": [
                    "_goal : or\n  (eq {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     {| pSrc := Server; pDst := Client c; pBody := Locked |})\n  (In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app xs ys))",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      cons {| pSrc := Server; pDst := Client c; pBody := Locked |}\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState evt_a) Server d\n  |}"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (eq {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     {| pSrc := Server; pDst := Client c; pBody := Locked |})\n  (In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n     (app xs ys))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 nil) (app xs ys);\n          nwState :=\n            update Name_eq_dec (nwState evt_a) Server\n              (nwState evt_a Server)\n        |} Server)) (S n) c",
                    "H4 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState :=\n      update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 nil) (app xs ys);\n          nwState :=\n            update Name_eq_dec (nwState evt_a) Server\n              (nwState evt_a Server)\n        |} Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n        Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n        Server)) (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold runGenHandler in * .",
                "tactic_sig_no_out_arg": "unfold runGenHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (InputHandler h inp (nwState evt_a h))\n  (pair (pair (pair evt_l out) d) l)"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp InputHandler_cases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp InputHandler_cases .",
                "tactic_args": [],
                "tactic_res": [
                    "H : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq inp Lock)\n              (and (eq out nil)\n                 (and (eq d (nwState evt_a h))\n                    (eq l (cons (pair Server Lock) nil)))))\n           (and (eq inp Unlock)\n              (and (eq out nil)\n                 (and (eq (held d) false)\n                    (or\n                       (and (eq (held (nwState evt_a h)) true)\n                          (eq l (cons (pair Server Unlock) nil)))\n                       (and (eq d (nwState evt_a h)) (eq l nil)))))))))\n  (and (eq out nil) (and (eq d (nwState evt_a h)) (eq l nil)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : ex\n  (fun c : Client_index =>\n   and (eq h (Client c))\n     (or\n        (and (eq inp Lock)\n           (and (eq out nil)\n              (and (eq d (nwState evt_a h))\n                 (eq l (cons (pair Server Lock) nil)))))\n        (and (eq inp Unlock)\n           (and (eq out nil)\n              (and (eq (held d) false)\n                 (or\n                    (and (eq (held (nwState evt_a h)) true)\n                       (eq l (cons (pair Server Unlock) nil)))\n                    (and (eq d (nwState evt_a h)) (eq l nil))))))))",
                    "H5 : eq l nil",
                    "H1 : eq d (nwState evt_a h)",
                    "H : eq out nil"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq h (Client x))\n  (or\n     (and (eq inp Lock)\n        (and (eq out nil)\n           (and (eq d (nwState evt_a h))\n              (eq l (cons (pair Server Lock) nil)))))\n     (and (eq inp Unlock)\n        (and (eq out nil)\n           (and (eq (held d) false)\n              (or\n                 (and (eq (held (nwState evt_a h)) true)\n                    (eq l (cons (pair Server Unlock) nil)))\n                 (and (eq d (nwState evt_a h)) (eq l nil)))))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "break_and .",
                "tactic_sig_no_out_arg": "break_and .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : or\n  (and (eq inp Lock)\n     (and (eq out nil)\n        (and (eq d (nwState evt_a h))\n           (eq l (cons (pair Server Lock) nil)))))\n  (and (eq inp Unlock)\n     (and (eq out nil)\n        (and (eq (held d) false)\n           (or\n              (and (eq (held (nwState evt_a h)) true)\n                 (eq l (cons (pair Server Unlock) nil)))\n              (and (eq d (nwState evt_a h)) (eq l nil))))))",
                    "H : eq h (Client x)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : or\n  (and (eq inp Lock)\n     (and (eq out nil)\n        (and (eq d (nwState evt_a (Client x)))\n           (eq l (cons (pair Server Lock) nil)))))\n  (and (eq inp Unlock)\n     (and (eq out nil)\n        (and (eq (held d) false)\n           (or\n              (and (eq (held (nwState evt_a (Client x))) true)\n                 (eq l (cons (pair Server Unlock) nil)))\n              (and (eq d (nwState evt_a (Client x))) (eq l nil))))))",
                    "H0 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client x; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets evt_a);\n    nwState := update Name_eq_dec (nwState evt_a) (Client x) d\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace\n     (cons (pair (Client x) (inl inp))\n        (cons (pair (Client x) (inr out)) nil)))"
                ]
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 l) (nwPackets evt_a);\n          nwState := update Name_eq_dec (nwState evt_a) (Client x) d\n        |} Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 l) (nwPackets evt_a);\n          nwState := update Name_eq_dec (nwState evt_a) (Client x) d\n        |} Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) (Client x) d Server))\n  (S n) c"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : Nth (queue (update Name_eq_dec (nwState evt_a) (Client x) d Server))\n  (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons {| evt_a := evt_a; evt_l := evt_l; evt_trace := evt_trace |}\n     (Cons e' s0))",
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : Nth (queue (nwState (LabeledNet.evt_a e') Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n              (nwPackets evt_a);\n          nwState :=\n            update Name_eq_dec (nwState evt_a) h (nwState evt_a h)\n        |} Server)) (S n) c",
                    "H0 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n        (nwPackets evt_a);\n    nwState := update Name_eq_dec (nwState evt_a) h (nwState evt_a h)\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace\n     (cons (pair h (inl inp)) (cons (pair h (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n              (nwPackets evt_a);\n          nwState :=\n            update Name_eq_dec (nwState evt_a) h (nwState evt_a h)\n        |} Server)) (S n) c"
                ],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) h (nwState evt_a h) Server))\n  (S n) c"
                ]
            },
            {
                "tactic_sig": "update_destruct .",
                "tactic_sig_no_out_arg": "update_destruct .",
                "tactic_args": [],
                "tactic_res": [
                    "e : eq h Server",
                    "n0 : not (eq h Server)"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n        Server)) (S n) c",
                    "H0 : eq (LabeledNet.evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (nwPackets evt_a);\n    nwState :=\n      update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n  |}",
                    "H2 : eq (LabeledNet.evt_trace e')\n  (app evt_trace\n     (cons (pair Server (inl inp)) (cons (pair Server (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) Server (nwState evt_a Server)\n        Server)) (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : Nth\n  (queue\n     (update Name_eq_dec (nwState evt_a) h (nwState evt_a h) Server))\n  (S n) c"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s))))))\n  (Cons\n     {|\n       evt_a := LabeledNet.evt_a e';\n       evt_l := Silent;\n       evt_trace := evt_trace\n     |} (Cons e' s0))",
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : Nth (queue (nwState (LabeledNet.evt_a (hd s)) Server)) (S n) c),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) (S n) c)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      and (Nth (queue (nwState (LabeledNet.evt_a (hd s0)) Server)) n c)\n        (forall _ : eq n 0,\n         In {| pSrc := Server; pDst := Client c; pBody := Locked |}\n           (nwPackets (LabeledNet.evt_a (hd s0)))))) s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Unlock_enables_MsgUnlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall n : name,\nmessage_enables_label {| pSrc := n; pDst := Server; pBody := Unlock |}\n  MsgUnlock"
                ],
                "tactic_res": [
                    "_goal : forall n : name,\nmessage_enables_label {| pSrc := n; pDst := Server; pBody := Unlock |}\n  MsgUnlock"
                ]
            },
            {
                "tactic_sig": "unfold message_enables_label .",
                "tactic_sig_no_out_arg": "unfold message_enables_label .",
                "tactic_args": [
                    "_goal : forall n : name,\nmessage_enables_label {| pSrc := n; pDst := Server; pBody := Unlock |}\n  MsgUnlock"
                ],
                "tactic_res": [
                    "_goal : forall (n : name) (net : network)\n  (_ : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n         (nwPackets net)), lb_step_ex lb_step_async MsgUnlock net"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : name) (net : network)\n  (_ : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n         (nwPackets net)), lb_step_ex lb_step_async MsgUnlock net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net",
                    "H : In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net)",
                    "net : network",
                    "n : name"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp in_split .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp in_split .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun l1 : list packet =>\n   ex\n     (fun l2 : list packet =>\n      eq (nwPackets net)\n        (app l1\n           (cons {| pSrc := n; pDst := Server; pBody := Unlock |} l2))))"
                ]
            },
            {
                "tactic_sig": "break_exists_name xs .",
                "tactic_sig_no_out_arg": "break_exists_name xs .",
                "tactic_args": [],
                "tactic_res": [
                    "H : ex\n  (fun l2 : list packet =>\n   eq (nwPackets net)\n     (app xs (cons {| pSrc := n; pDst := Server; pBody := Unlock |} l2)))",
                    "xs : list packet"
                ]
            },
            {
                "tactic_sig": "break_exists_name ys .",
                "tactic_sig_no_out_arg": "break_exists_name ys .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (nwPackets net)\n  (app xs (cons {| pSrc := n; pDst := Server; pBody := Unlock |} ys))",
                    "ys : list packet"
                ]
            },
            {
                "tactic_sig": "unfold enabled .",
                "tactic_sig_no_out_arg": "unfold enabled .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net"
                ]
            },
            {
                "tactic_sig": "destruct ( ServerNetHandler _i Unlock ( nwState _i Server ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ServerNetHandler _i Unlock ( nwState _i Server ) ) eqn : ? .",
                "tactic_args": [
                    "n : name",
                    "net : network"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler n Unlock (nwState net Server)) (pair p l)",
                    "l : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "p : prod (prod Label (list Output)) Data"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler n Unlock (nwState net Server)) (pair (pair p d) l)",
                    "d : Data",
                    "p : prod Label (list Output)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "p : prod Label (list Output)"
                ],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler n Unlock (nwState net Server))\n  (pair (pair (pair l0 l1) d) l)",
                    "l1 : list Output",
                    "l0 : Label"
                ]
            },
            {
                "tactic_sig": "cut ( _i = MsgUnlock ) .",
                "tactic_sig_no_out_arg": "cut ( _i = MsgUnlock ) .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net",
                    "l0 : Label"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq l0 MsgUnlock, lb_step_ex lb_step_async MsgUnlock net",
                    "_goal : eq l0 MsgUnlock"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : eq l0 MsgUnlock, lb_step_ex lb_step_async MsgUnlock net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net",
                    "H0 : eq l0 MsgUnlock"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq (ServerNetHandler n Unlock (nwState net Server))\n  (pair (pair (pair MsgUnlock l1) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat eexists .",
                "tactic_sig_no_out_arg": "repeat eexists .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async MsgUnlock net"
                ],
                "tactic_res": [
                    "_goal : lb_step_async net MsgUnlock ?a' ?tr"
                ]
            },
            {
                "tactic_sig": "econstructor .",
                "tactic_sig_no_out_arg": "econstructor .",
                "tactic_args": [
                    "_goal : lb_step_async net MsgUnlock ?a' ?tr"
                ],
                "tactic_res": [
                    "_goal : eq (nwPackets net) (app ?xs (cons ?p ?ys))",
                    "_goal : eq\n  (lb_net_handlers (pDst ?p) (pSrc ?p) (pBody ?p)\n     (nwState net (pDst ?p))) (pair (pair (pair MsgUnlock ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (pDst ?p) ?l) (app ?xs ?ys);\n    nwState := update name_eq_dec (nwState net) (pDst ?p) ?d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (nwPackets net) (app ?xs (cons ?p ?ys))",
                    "_goal : eq\n  (lb_net_handlers (pDst ?p) (pSrc ?p) (pBody ?p)\n     (nwState net (pDst ?p))) (pair (pair (pair MsgUnlock ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (pDst ?p) ?l) (app ?xs ?ys);\n    nwState := update name_eq_dec (nwState net) (pDst ?p) ?d\n  |}"
                ],
                "tactic_res": [
                    "_goal : eq\n  (lb_net_handlers\n     (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pSrc {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pBody {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (nwState net\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})))\n  (pair (pair (pair MsgUnlock ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) \n           ?l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) \n        ?d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq\n  (lb_net_handlers\n     (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pSrc {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pBody {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (nwState net\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})))\n  (pair (pair (pair MsgUnlock ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) \n           ?l) (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) \n        ?d\n  |}"
                ],
                "tactic_res": [
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) l)\n        (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq ?a'\n  {|\n    nwPackets :=\n      app\n        (send_packets\n           (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) l)\n        (app xs ys);\n    nwState :=\n      update name_eq_dec (nwState net)\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}) d\n  |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    let\n    'pair (pair (pair _ os1) s') ws1 :=\n     match queue (nwState net Server) with\n     | cons _ (cons x xs) =>\n         fun _ : Data =>\n         pair\n           (pair (pair tt (app nil nil))\n              {|\n                queue := cons x xs; held := held (nwState net Server)\n              |}) (app nil (cons (pair (Client x) Locked) nil))\n     | _ =>\n         fun _ : Data =>\n         pair\n           (pair (pair tt nil)\n              {| queue := nil; held := held (nwState net Server) |})\n           nil\n     end (nwState net Server) in\n     pair (pair (pair MsgUnlock (app os1 nil)) s') (app ws1 nil) in\n    pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair l0 l1) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "Heqp : eq (pair (pair (pair l3 (app nil l4)) d0) (app nil l2))\n  (pair (pair (pair l0 l1) d) l)",
                    "Heqp0 : eq (pair (pair (pair MsgUnlock (app l6 nil)) d1) (app l5 nil))\n  (pair (pair (pair l3 l4) d0) l2)",
                    "Heqp3 : eq\n  (pair\n     (pair (pair tt nil)\n        {| queue := nil; held := held (nwState net Server) |}) nil)\n  (pair (pair (pair u l6) d1) l5)",
                    "Heql7 : eq (queue (nwState net Server)) nil",
                    "Heqp4 : eq p1 (pair (pair u l6) d1)",
                    "Heqp5 : eq p2 (pair u l6)",
                    "l6 : list Output",
                    "u : unit",
                    "d1 : Data",
                    "p2 : prod unit (list Output)",
                    "l5 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp1 : eq p (pair (pair l3 l4) d0)",
                    "Heqp2 : eq p0 (pair l3 l4)",
                    "l4 : list Output",
                    "l3 : Label",
                    "d0 : Data",
                    "p0 : prod Label (list Output)",
                    "l2 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heql7 : eq (queue (nwState net Server)) (cons c nil)",
                    "Heql8 : eq l7 nil",
                    "l7 : list Client_index",
                    "c : Client_index",
                    "Heqp3 : eq\n  (pair\n     (pair (pair tt (app nil nil))\n        {| queue := cons c0 l8; held := held (nwState net Server) |})\n     (app nil (cons (pair (Client c0) Locked) nil)))\n  (pair (pair (pair u l6) d1) l5)",
                    "Heql7 : eq (queue (nwState net Server)) (cons c (cons c0 l8))",
                    "Heql8 : eq l7 (cons c0 l8)",
                    "l8 : list Client_index",
                    "c0 : Client_index"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [
                    "_goal : eq l0 MsgUnlock"
                ],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Unlock_delivered_MsgUnlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall n : name,\nmessage_delivered_label\n  {| pSrc := n; pDst := Server; pBody := Unlock |} MsgUnlock"
                ],
                "tactic_res": [
                    "_goal : forall n : name,\nmessage_delivered_label\n  {| pSrc := n; pDst := Server; pBody := Unlock |} MsgUnlock"
                ]
            },
            {
                "tactic_sig": "unfold message_delivered_label .",
                "tactic_sig_no_out_arg": "unfold message_delivered_label .",
                "tactic_args": [
                    "_goal : forall n : name,\nmessage_delivered_label\n  {| pSrc := n; pDst := Server; pBody := Unlock |} MsgUnlock"
                ],
                "tactic_res": [
                    "_goal : forall (n : name) (l' : label) (net net' : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : lb_step_async net l' net' tr)\n  (_ : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n         (nwPackets net))\n  (_ : not\n         (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n            (nwPackets net'))), eq MsgUnlock l'"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (n : name) (l' : label) (net net' : network)\n  (tr : list (prod name (sum input (list output))))\n  (_ : lb_step_async net l' net' tr)\n  (_ : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n         (nwPackets net))\n  (_ : not\n         (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n            (nwPackets net'))), eq MsgUnlock l'"
                ],
                "tactic_res": [
                    "_goal : eq MsgUnlock l'",
                    "H1 : not\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net'))",
                    "H0 : In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net)",
                    "H : lb_step_async net l' net' tr",
                    "tr : list (prod name (sum input (list output)))",
                    "net : network",
                    "net' : network",
                    "l' : label",
                    "n : name"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "H : lb_step_async net l' net' tr"
                ],
                "tactic_res": [
                    "_goal : eq MsgUnlock label_silent",
                    "H8 : eq (cons (pair (pDst p) (inr out)) nil) tr",
                    "H7 : eq net'0 net'",
                    "H6 : eq lb l'",
                    "H5 : eq net0 net",
                    "H4 : eq net'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |}",
                    "H3 : eq (lb_net_handlers (pDst p) (pSrc p) (pBody p) (nwState net (pDst p)))\n  (pair (pair (pair l' out) d) l)",
                    "H2 : eq (nwPackets net) (app xs (cons p ys))",
                    "lb : label",
                    "l : list (prod lb_name lb_msg)",
                    "d : data",
                    "out : list output",
                    "xs : list packet",
                    "ys : list packet",
                    "p : packet",
                    "net0 : network",
                    "net'0 : network",
                    "H7 : eq (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)) tr",
                    "H6 : eq net'0 net'",
                    "H5 : eq lb l'",
                    "H4 : eq net0 net",
                    "H3 : eq net'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |}",
                    "H2 : eq (lb_input_handlers h inp (nwState net h))\n  (pair (pair (pair l' out) d) l)",
                    "inp : input",
                    "h : lb_name",
                    "H5 : eq nil tr",
                    "H4 : eq net net'",
                    "H3 : eq label_silent l'",
                    "H2 : eq net0 net"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : not\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (nwPackets\n        {|\n          nwPackets := app (send_packets (pDst p) l) (app xs ys);\n          nwState := update name_eq_dec (nwState net) (pDst p) d\n        |}))",
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |} (cons (pair (pDst p) (inr out)) nil)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState net) (pDst p) d\n  |} (cons (pair (pDst p) (inr out)) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (runGenHandler (nwState net (pDst p))\n     (NetHandler (pDst p) (pSrc p) (pBody p)))\n  (pair (pair (pair l' out) d) l)",
                    "H1 : not\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys)))",
                    "out : list Output",
                    "l : list (prod Name Msg)",
                    "d : Data",
                    "l' : Label",
                    "n : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : not\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (nwPackets\n        {|\n          nwPackets := app (send_packets h l) (nwPackets net);\n          nwState := update name_eq_dec (nwState net) h d\n        |}))",
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |} (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net l'\n  {|\n    nwPackets := app (send_packets h l) (nwPackets net);\n    nwState := update name_eq_dec (nwState net) h d\n  |} (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (runGenHandler (nwState net h) (InputHandler h inp))\n  (pair (pair (pair l' out) d) l)",
                    "H1 : not\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets net)))",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net')",
                    "H : lb_step_async net' label_silent net' nil"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_async net' label_silent net' nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : eq MsgUnlock label_silent"
                ],
                "tactic_res": [
                    "_goal : eq MsgUnlock Silent"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app xs (cons p ys))"
                ]
            },
            {
                "tactic_sig": "find_eapply_lem_hyp In_split_not_In .",
                "tactic_sig_no_out_arg": "find_eapply_lem_hyp In_split_not_In .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app xs (cons ?p' ys))",
                    "H1 : eq {| pSrc := n; pDst := Server; pBody := Unlock |} p"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock l'"
                ],
                "tactic_res": [
                    "_goal : eq MsgUnlock l'"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app xs (cons ?p' ys))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app xs (cons {| pSrc := n; pDst := Server; pBody := Unlock |} ys))",
                    "H2 : eq (nwPackets net)\n  (app xs (cons {| pSrc := n; pDst := Server; pBody := Unlock |} ys))",
                    "H3 : eq\n  (runGenHandler\n     (nwState net\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |}))\n     (NetHandler\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})\n        (pSrc {| pSrc := n; pDst := Server; pBody := Unlock |})\n        (pBody {| pSrc := n; pDst := Server; pBody := Unlock |})))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (NetHandler (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pSrc {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (pBody {| pSrc := n; pDst := Server; pBody := Unlock |})\n     (nwState net\n        (pDst {| pSrc := n; pDst := Server; pBody := Unlock |})))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq (ServerNetHandler n Unlock (nwState net Server))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "handler_unfold .",
                "tactic_sig_no_out_arg": "handler_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq\n  (let\n   'pair (pair (pair b os2) s'') ws2 :=\n    let\n    'pair (pair (pair _ os1) s') ws1 :=\n     match queue (nwState net Server) with\n     | cons _ (cons x xs) =>\n         fun _ : Data =>\n         pair\n           (pair (pair tt (app nil nil))\n              {|\n                queue := cons x xs; held := held (nwState net Server)\n              |}) (app nil (cons (pair (Client x) Locked) nil))\n     | _ =>\n         fun _ : Data =>\n         pair\n           (pair (pair tt nil)\n              {| queue := nil; held := held (nwState net Server) |})\n           nil\n     end (nwState net Server) in\n     pair (pair (pair MsgUnlock (app os1 nil)) s') (app ws1 nil) in\n    pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n  (pair (pair (pair l' out) d) l)"
                ]
            },
            {
                "tactic_sig": "repeat break_match .",
                "tactic_sig_no_out_arg": "repeat break_match .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : eq (pair (pair (pair l1 (app nil l2)) d0) (app nil l0))\n  (pair (pair (pair l' out) d) l)",
                    "Heqp : eq (pair (pair (pair MsgUnlock (app l4 nil)) d1) (app l3 nil))\n  (pair (pair (pair l1 l2) d0) l0)",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt nil)\n        {| queue := nil; held := held (nwState net Server) |}) nil)\n  (pair (pair (pair u l4) d1) l3)",
                    "Heql5 : eq (queue (nwState net Server)) nil",
                    "Heqp3 : eq p1 (pair (pair u l4) d1)",
                    "Heqp4 : eq p2 (pair u l4)",
                    "l4 : list Output",
                    "u : unit",
                    "d1 : Data",
                    "p2 : prod unit (list Output)",
                    "l3 : list (prod Name Msg)",
                    "p1 : prod (prod unit (list Output)) Data",
                    "Heqp0 : eq p (pair (pair l1 l2) d0)",
                    "Heqp1 : eq p0 (pair l1 l2)",
                    "l2 : list Output",
                    "l1 : Label",
                    "d0 : Data",
                    "p0 : prod Label (list Output)",
                    "l0 : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data",
                    "Heql5 : eq (queue (nwState net Server)) (cons c nil)",
                    "Heql6 : eq l5 nil",
                    "l5 : list Client_index",
                    "c : Client_index",
                    "Heqp2 : eq\n  (pair\n     (pair (pair tt (app nil nil))\n        {| queue := cons c0 l6; held := held (nwState net Server) |})\n     (app nil (cons (pair (Client c0) Locked) nil)))\n  (pair (pair (pair u l4) d1) l3)",
                    "Heql5 : eq (queue (nwState net Server)) (cons c (cons c0 l6))",
                    "Heql6 : eq l5 (cons c0 l6)",
                    "l6 : list Client_index",
                    "c0 : Client_index"
                ]
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_inversion .",
                "tactic_sig_no_out_arg": "repeat find_inversion .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq MsgUnlock MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold not in * .",
                "tactic_sig_no_out_arg": "unfold not in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : forall\n  _ : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n        (app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n           (nwPackets net)), False"
                ]
            },
            {
                "tactic_sig": "find_false .",
                "tactic_sig_no_out_arg": "find_false .",
                "tactic_args": [
                    "_goal : eq MsgUnlock l'"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n     (nwPackets net))"
                ]
            },
            {
                "tactic_sig": "apply in_app_iff .",
                "tactic_sig_no_out_arg": "apply in_app_iff .",
                "tactic_args": [
                    "_goal : In {| pSrc := n; pDst := Server; pBody := Unlock |}\n  (app\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n     (nwPackets net))"
                ],
                "tactic_res": [
                    "_goal : or\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l))\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |}\n     (map\n        (fun m : prod Name Msg =>\n         {| pSrc := h; pDst := fst m; pBody := snd m |}) l))\n  (In {| pSrc := n; pDst := Server; pBody := Unlock |} (nwPackets net))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq MsgUnlock Silent"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Unlock_in_network_eventually_MsgUnlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : name)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : In {| pSrc := c; pDst := Server; pBody := Unlock |}\n         (nwPackets (evt_a (hd s)))),\neventually (now (occurred MsgUnlock)) s"
                ],
                "tactic_res": [
                    "_goal : forall (c : name)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : In {| pSrc := c; pDst := Server; pBody := Unlock |}\n         (nwPackets (evt_a (hd s)))),\neventually (now (occurred MsgUnlock)) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : name)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s)\n  (_ : In {| pSrc := c; pDst := Server; pBody := Unlock |}\n         (nwPackets (evt_a (hd s)))),\neventually (now (occurred MsgUnlock)) s"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred MsgUnlock)) s",
                    "H1 : In {| pSrc := c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a (hd s)))",
                    "H0 : weak_fairness lb_step_async label_silent s",
                    "H : lb_step_execution lb_step_async s",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "c : name"
                ]
            },
            {
                "tactic_sig": "eapply message_labels_eventually_occur .",
                "tactic_sig_no_out_arg": "eapply message_labels_eventually_occur .",
                "tactic_args": [
                    "_goal : eventually (now (occurred MsgUnlock)) s"
                ],
                "tactic_res": [
                    "_goal : not (eq MsgUnlock label_silent)",
                    "_goal : message_enables_label ?p MsgUnlock",
                    "_goal : message_delivered_label ?p MsgUnlock",
                    "_goal : weak_fairness lb_step_async label_silent s",
                    "_goal : lb_step_execution lb_step_async s",
                    "_goal : In ?p (nwPackets (evt_a (hd s)))"
                ]
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : not (eq MsgUnlock label_silent)"
                ],
                "tactic_res": [
                    "_goal : not (eq MsgUnlock label_silent)"
                ]
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : message_enables_label ?p MsgUnlock",
                    "_goal : message_delivered_label ?p MsgUnlock",
                    "_goal : In ?p (nwPackets (evt_a (hd s)))"
                ],
                "tactic_res": [
                    "_goal : message_delivered_label\n  {| pSrc := ?n; pDst := Server; pBody := Unlock |} MsgUnlock",
                    "_goal : In {| pSrc := ?n; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a (hd s)))"
                ]
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : message_delivered_label\n  {| pSrc := ?n; pDst := Server; pBody := Unlock |} MsgUnlock"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : weak_fairness lb_step_async label_silent s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : lb_step_execution lb_step_async s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_sig_no_out_arg": "eauto using Unlock_enables_MsgUnlock , Unlock_delivered_MsgUnlock .",
                "tactic_args": [
                    "_goal : In {| pSrc := ?n; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a (hd s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold label_silent .",
                "tactic_sig_no_out_arg": "unfold label_silent .",
                "tactic_args": [
                    "_goal : not (eq MsgUnlock label_silent)"
                ],
                "tactic_res": [
                    "_goal : not\n  (eq MsgUnlock\n     (let\n        (lb_name, lb_msg, _, _, lb_nodes, _, _, label, label_silent, _,\n         _, _) as LabeledMultiParams return label :=\n        LockServ_LabeledParams in\n      label_silent))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : not\n  (eq MsgUnlock\n     (let\n        (lb_name, lb_msg, _, _, lb_nodes, _, _, label, label_silent, _,\n         _, _) as LabeledMultiParams return label :=\n        LockServ_LabeledParams in\n      label_silent))"
                ],
                "tactic_res": [
                    "_goal : not (eq MsgUnlock Silent)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : not (eq MsgUnlock Silent)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "Nth_something_at_head",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l : list A) (n : nat) (x : A) (_ : Nth l n x),\nex (fun y : A => ex (fun l' : list A => eq l (cons y l')))"
                ],
                "tactic_res": [
                    "_goal : forall (A : Type) (l : list A) (n : nat) (x : A) (_ : Nth l n x),\nex (fun y : A => ex (fun l' : list A => eq l (cons y l')))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (A : Type) (l : list A) (n : nat) (x : A) (_ : Nth l n x),\nex (fun y : A => ex (fun l' : list A => eq l (cons y l')))"
                ],
                "tactic_res": [
                    "_goal : ex (fun y : A => ex (fun l' : list A => eq l (cons y l')))",
                    "H : Nth l n x",
                    "x : A",
                    "n : nat",
                    "l : list A",
                    "A : Type"
                ]
            },
            {
                "tactic_sig": "solve_by_inversion' eauto .",
                "tactic_sig_no_out_arg": "solve_by_inversion' eauto .",
                "tactic_args": [
                    "_goal : ex (fun y : A => ex (fun l' : list A => eq l (cons y l')))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputUnlock_held",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (_ : now (occurred (InputUnlock c)) s),\nnext\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s0)))) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (_ : now (occurred (InputUnlock c)) s),\nnext\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s0)))) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (_ : now (occurred (InputUnlock c)) s),\nnext\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s0)))) s"
                ],
                "tactic_res": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) s",
                    "H1 : now (occurred (InputUnlock c)) s",
                    "H0 : eq (held (nwState (evt_a (hd s)) (Client c))) true",
                    "H : lb_step_execution lb_step_async s",
                    "c : Client_index",
                    "s : infseq (event network label (prod name (sum input (list output))))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) s",
                    "H : lb_step_execution lb_step_async s"
                ],
                "tactic_res": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) (Cons e (Cons e' s0))",
                    "H5 : eq (Cons e (Cons e' s0)) s",
                    "H4 : lb_step_execution lb_step_async (Cons e' s0)",
                    "H3 : eq (evt_trace e') (app (evt_trace e) tr)",
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e') tr",
                    "s0 : infseq (event network label (prod name (sum input (list output))))",
                    "tr : list (prod name (sum input (list output)))",
                    "e : event network label (prod name (sum input (list output)))",
                    "e' : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H : lb_step_execution lb_step_async (Cons e (Cons e' s0))",
                    "H0 : eq (held (nwState (evt_a (hd (Cons e (Cons e' s0)))) (Client c))) true",
                    "H1 : now (occurred (InputUnlock c)) (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_execution lb_step_async (Cons e (Cons e' s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   =>\n   In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "H0 : eq (held (nwState (evt_a e) (Client c))) true",
                    "H1 : occurred (InputUnlock c) e",
                    "s0 : infseq (event network Label (prod Name (sum Input (list Output))))",
                    "e : event network Label (prod Name (sum Input (list Output)))",
                    "e' : event network Label (prod Name (sum Input (list Output)))"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e') tr"
                ],
                "tactic_res": [
                    "H10 : eq (cons (pair (pDst p) (inr out)) nil) tr",
                    "H9 : eq net' (evt_a e')",
                    "H8 : eq lb (evt_l e)",
                    "H7 : eq net (evt_a e)",
                    "H6 : eq (evt_a e')\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState (evt_a e)) (pDst p) d\n  |}",
                    "H5 : eq\n  (lb_net_handlers (pDst p) (pSrc p) (pBody p)\n     (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H : eq (nwPackets (evt_a e)) (app xs (cons p ys))",
                    "lb : label",
                    "l : list (prod lb_name lb_msg)",
                    "d : data",
                    "out : list output",
                    "xs : list packet",
                    "ys : list packet",
                    "p : packet",
                    "net : network",
                    "net' : network",
                    "H9 : eq (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)) tr",
                    "H8 : eq net' (evt_a e')",
                    "H7 : eq lb (evt_l e)",
                    "H6 : eq net (evt_a e)",
                    "H5 : eq (evt_a e')\n  {|\n    nwPackets := app (send_packets h l) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) h d\n  |}",
                    "H : eq (lb_input_handlers h inp (nwState (evt_a e) h))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "inp : input",
                    "h : lb_name",
                    "H5 : eq nil tr",
                    "H7 : eq (evt_a e) (evt_a e')",
                    "H6 : eq Silent (evt_l e)",
                    "H : eq net (evt_a e)"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)",
                    "H3 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (pDst p) (inr out)) nil))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H6 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) (pDst p) d\n  |}",
                    "H5 : eq\n  (runGenHandler (nwState (evt_a e) (pDst p))\n     (NetHandler (pDst p) (pSrc p) (pBody p)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "l : list (prod Name Msg)",
                    "d : Data",
                    "out : list Output"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))",
                    "H3 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets (evt_a e));\n    nwState := update Name_eq_dec (nwState (evt_a e)) h d\n  |}",
                    "H : eq (runGenHandler (nwState (evt_a e) h) (InputHandler h inp))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e') nil",
                    "H3 : eq (evt_trace e') (app (evt_trace e) nil)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H2 : lb_step_async (evt_a e) (evt_l e) (evt_a e') nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eq\n  (NetHandler (pDst p) (pSrc p) (pBody p) (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "unfold NetHandler in * .",
                "tactic_sig_no_out_arg": "unfold NetHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : eq\n  (match pDst p with\n   | Client c => ClientNetHandler c (pBody p)\n   | Server => ServerNetHandler (pSrc p) (pBody p)\n   end (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "break_match_hyp .",
                "tactic_sig_no_out_arg": "break_match_hyp .",
                "tactic_args": [],
                "tactic_res": [
                    "H6 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client c0; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client c0) d\n  |}",
                    "H5 : eq (ClientNetHandler c0 (pBody p) (nwState (evt_a e) (Client c0)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H3 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (Client c0) (inr out)) nil))",
                    "Heqn : eq (pDst p) (Client c0)",
                    "c0 : Client_index",
                    "H6 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H5 : eq (ServerNetHandler (pSrc p) (pBody p) (nwState (evt_a e) Server))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H3 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr out)) nil))",
                    "Heqn : eq (pDst p) Server"
                ]
            },
            {
                "tactic_sig": "unfold occurred in * .",
                "tactic_sig_no_out_arg": "unfold occurred in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (InputUnlock c) (evt_l e)"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp ClientNetHandler_lbcases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp ClientNetHandler_lbcases .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : and (eq l nil)\n  (or\n     (and (eq d (nwState (evt_a e) (Client c0)))\n        (and (eq out nil) (eq (evt_l e) Nop)))\n     (and (eq (pBody p) Locked)\n        (and (eq out (cons Locked nil))\n           (and (eq (held d) true) (eq (evt_l e) (MsgLocked c0))))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : eq (evt_l e) Nop",
                    "H5 : eq out nil",
                    "H7 : eq d (nwState (evt_a e) (Client c0))",
                    "H2 : eq l nil",
                    "H10 : eq (evt_l e) (MsgLocked c0)",
                    "H8 : eq (held d) true",
                    "H5 : eq out (cons Locked nil)",
                    "H7 : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold occurred in * .",
                "tactic_sig_no_out_arg": "unfold occurred in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (InputUnlock c) (evt_l e)"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp ServerNetHandler_lbcases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp ServerNetHandler_lbcases .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq (pSrc p) (Client c))\n           (and (eq (pBody p) Lock)\n              (and (eq (evt_l e) (MsgLock c))\n                 (and\n                    (eq (queue d)\n                       (app (queue (nwState (evt_a e) Server))\n                          (cons c nil)))\n                    (or\n                       (and (eq (queue (nwState (evt_a e) Server)) nil)\n                          (eq l (cons (pair (Client c) Locked) nil)))\n                       (and\n                          (not\n                             (eq (queue (nwState (evt_a e) Server)) nil))\n                          (eq l nil))))))))\n     (or\n        (and (eq (pBody p) Unlock)\n           (and (eq (evt_l e) MsgUnlock)\n              (and\n                 (eq (queue d)\n                    (List.tl (queue (nwState (evt_a e) Server))))\n                 (or (and (eq (queue d) nil) (eq l nil))\n                    (ex\n                       (fun next : Client_index =>\n                        ex\n                          (fun t : list Client_index =>\n                           and (eq (queue d) (cons next t))\n                             (eq l\n                                (cons (pair (Client next) Locked) nil)))))))))\n        (and (eq l nil)\n           (and (eq d (nwState (evt_a e) Server)) (eq (evt_l e) Nop)))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and (eq (pBody p) Lock)\n        (and (eq (evt_l e) (MsgLock c))\n           (and\n              (eq (queue d)\n                 (app (queue (nwState (evt_a e) Server)) (cons c nil)))\n              (or\n                 (and (eq (queue (nwState (evt_a e) Server)) nil)\n                    (eq l (cons (pair (Client c) Locked) nil)))\n                 (and\n                    (forall\n                       _ : eq (queue (nwState (evt_a e) Server)) nil,\n                     False) (eq l nil)))))))",
                    "H2 : eq out nil",
                    "H11 : eq l nil",
                    "H10 : eq (queue d) nil",
                    "H8 : eq (queue d) (List.tl (queue (nwState (evt_a e) Server)))",
                    "H7 : eq (evt_l e) MsgUnlock",
                    "H5 : eq (pBody p) Unlock",
                    "H9 : ex\n  (fun next : Client_index =>\n   ex\n     (fun t : list Client_index =>\n      and (eq (queue d) (cons next t))\n        (eq l (cons (pair (Client next) Locked) nil))))",
                    "H9 : eq (evt_l e) Nop",
                    "H7 : eq d (nwState (evt_a e) Server)",
                    "H5 : eq l nil"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H5 : and (eq (pSrc p) (Client x))\n  (and (eq (pBody p) Lock)\n     (and (eq (evt_l e) (MsgLock x))\n        (and\n           (eq (queue d)\n              (app (queue (nwState (evt_a e) Server)) (cons x nil)))\n           (or\n              (and (eq (queue (nwState (evt_a e) Server)) nil)\n                 (eq l (cons (pair (Client x) Locked) nil)))\n              (and\n                 (forall _ : eq (queue (nwState (evt_a e) Server)) nil,\n                  False) (eq l nil))))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H12 : eq l (cons (pair (Client x) Locked) nil)",
                    "H11 : eq (queue (nwState (evt_a e) Server)) nil",
                    "H9 : eq (queue d) (app (queue (nwState (evt_a e) Server)) (cons x nil))",
                    "H8 : eq (evt_l e) (MsgLock x)",
                    "H5 : eq (pBody p) Lock",
                    "H7 : eq (pSrc p) (Client x)",
                    "H12 : eq l nil",
                    "H11 : forall _ : eq (queue (nwState (evt_a e) Server)) nil, False"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : and (eq (queue d) (cons x x0))\n  (eq l (cons (pair (Client x) Locked) nil))",
                    "x0 : list Client_index",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H11 : eq l (cons (pair (Client x) Locked) nil)",
                    "H10 : eq (queue d) (cons x x0)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (InputHandler h inp (nwState (evt_a e) h))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp InputHandler_lbcases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp InputHandler_lbcases .",
                "tactic_args": [],
                "tactic_res": [
                    "H : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq inp Lock)\n              (and (eq out nil)\n                 (and (eq d (nwState (evt_a e) h))\n                    (and (eq l (cons (pair Server Lock) nil))\n                       (eq (evt_l e) (InputLock c))))))\n           (and (eq (evt_l e) (InputUnlock c))\n              (and (eq inp Unlock)\n                 (and (eq out nil)\n                    (and (eq (held d) false)\n                       (or\n                          (and (eq (held (nwState (evt_a e) h)) true)\n                             (eq l (cons (pair Server Unlock) nil)))\n                          (and (eq d (nwState (evt_a e) h)) (eq l nil))))))))))\n  (and (eq out nil)\n     (and (eq d (nwState (evt_a e) h))\n        (and (eq l nil) (eq (evt_l e) Nop))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : ex\n  (fun c : Client_index =>\n   and (eq h (Client c))\n     (or\n        (and (eq inp Lock)\n           (and (eq out nil)\n              (and (eq d (nwState (evt_a e) h))\n                 (and (eq l (cons (pair Server Lock) nil))\n                    (eq (evt_l e) (InputLock c))))))\n        (and (eq (evt_l e) (InputUnlock c))\n           (and (eq inp Unlock)\n              (and (eq out nil)\n                 (and (eq (held d) false)\n                    (or\n                       (and (eq (held (nwState (evt_a e) h)) true)\n                          (eq l (cons (pair Server Unlock) nil)))\n                       (and (eq d (nwState (evt_a e) h)) (eq l nil)))))))))",
                    "H8 : eq (evt_l e) Nop",
                    "H6 : eq l nil",
                    "H2 : eq d (nwState (evt_a e) h)",
                    "H : eq out nil"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq h (Client x))\n  (or\n     (and (eq inp Lock)\n        (and (eq out nil)\n           (and (eq d (nwState (evt_a e) h))\n              (and (eq l (cons (pair Server Lock) nil))\n                 (eq (evt_l e) (InputLock x))))))\n     (and (eq (evt_l e) (InputUnlock x))\n        (and (eq inp Unlock)\n           (and (eq out nil)\n              (and (eq (held d) false)\n                 (or\n                    (and (eq (held (nwState (evt_a e) h)) true)\n                       (eq l (cons (pair Server Unlock) nil)))\n                    (and (eq d (nwState (evt_a e) h)) (eq l nil))))))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H10 : eq (evt_l e) (InputLock x)",
                    "H8 : eq l (cons (pair Server Lock) nil)",
                    "H7 : eq d (nwState (evt_a e) h)",
                    "H : eq out nil",
                    "H6 : eq inp Lock",
                    "H2 : eq h (Client x)",
                    "H11 : eq l (cons (pair Server Unlock) nil)",
                    "H10 : eq (held (nwState (evt_a e) h)) true",
                    "H8 : eq (held d) false",
                    "H7 : eq out nil",
                    "H : eq inp Unlock",
                    "H6 : eq (evt_l e) (InputUnlock x)",
                    "H11 : eq l nil",
                    "H10 : eq d (nwState (evt_a e) h)"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "try congruence .",
                "tactic_sig_no_out_arg": "try congruence .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "fold LockServ_MultiParams in * .",
                "tactic_sig_no_out_arg": "fold LockServ_MultiParams in * .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets\n     {|\n       nwPackets :=\n         app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n              (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n       nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n     |})",
                    "H10 : eq (held (nwState (evt_a e) (Client x))) true",
                    "H5 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n           (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n  |}",
                    "H3 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client x) (inl Unlock))\n        (cons (pair (Client x) (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets\n     {|\n       nwPackets :=\n         app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n              (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n       nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n     |})"
                ],
                "tactic_res": [
                    "_goal : or\n  (eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     {| pSrc := Client c; pDst := Server; pBody := Unlock |})\n  (In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a e)))"
                ]
            },
            {
                "tactic_sig": "left .",
                "tactic_sig_no_out_arg": "left .",
                "tactic_args": [
                    "_goal : or\n  (eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     {| pSrc := Client c; pDst := Server; pBody := Unlock |})\n  (In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a e)))"
                ],
                "tactic_res": [
                    "_goal : eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  {| pSrc := Client c; pDst := Server; pBody := Unlock |}"
                ]
            },
            {
                "tactic_sig": "unfold occurred in * .",
                "tactic_sig_no_out_arg": "unfold occurred in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (InputUnlock c) (evt_l e)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  {| pSrc := Client c; pDst := Server; pBody := Unlock |}"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "unfold occurred in * .",
                "tactic_sig_no_out_arg": "unfold occurred in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (InputUnlock c) (evt_l e)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputHandler_Client_Unlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (sigma : Data),\nex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (InputHandler (Client c) Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index) (sigma : Data),\nex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (InputHandler (Client c) Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : Client_index) (sigma : Data),\nex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (InputHandler (Client c) Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (InputHandler (Client c) Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))",
                    "sigma : Data",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "unfold InputHandler .",
                "tactic_sig_no_out_arg": "unfold InputHandler .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (InputHandler (Client c) Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (ClientIOHandler c Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ]
            },
            {
                "tactic_sig": "unfold ClientIOHandler .",
                "tactic_sig_no_out_arg": "unfold ClientIOHandler .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (ClientIOHandler c Unlock sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (bind get\n              (fun data : Data =>\n               bind\n                 (when (held data)\n                    (bind (put {| queue := nil; held := false |})\n                       (fun _ : unit => send (pair Server Unlock))))\n                 (fun _ : unit => ret (InputUnlock c))) sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (bind get\n              (fun data : Data =>\n               bind\n                 (when (held data)\n                    (bind (put {| queue := nil; held := false |})\n                       (fun _ : unit => send (pair Server Unlock))))\n                 (fun _ : unit => ret (InputUnlock c))) sigma)\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (let\n            'pair (pair (pair b os2) s'') ws2 :=\n             let\n             'pair (pair (pair _ os1) s') ws1 :=\n              (if held sigma\n               then\n                fun _ : Data =>\n                pair\n                  (pair (pair tt (app (app nil nil) nil))\n                     {| queue := nil; held := false |})\n                  (app (app nil (cons (pair Server Unlock) nil)) nil)\n               else fun s : Data => pair (pair (pair tt nil) s) nil)\n                sigma in\n              pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                (app ws1 nil) in\n             pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ]
            },
            {
                "tactic_sig": "repeat break_let .",
                "tactic_sig_no_out_arg": "repeat break_let .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (let\n            'pair (pair (pair b os2) s'') ws2 :=\n             let\n             'pair (pair (pair _ os1) s') ws1 :=\n              (if held sigma\n               then\n                fun _ : Data =>\n                pair\n                  (pair (pair tt (app (app nil nil) nil))\n                     {| queue := nil; held := false |})\n                  (app (app nil (cons (pair Server Unlock) nil)) nil)\n               else fun s : Data => pair (pair (pair tt nil) s) nil)\n                sigma in\n              pair (pair (pair (InputUnlock c) (app os1 nil)) s')\n                (app ws1 nil) in\n             pair (pair (pair b (app nil os2)) s'') (app nil ws2))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (pair (pair (pair l2 (app nil l3)) d0) (app nil l))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))",
                    "Heqp : eq (pair (pair (pair (InputUnlock c) (app l1 nil)) d) (app l0 nil))\n  (pair (pair (pair l2 l3) d0) l)",
                    "Heqp3 : eq p (pair (pair l2 l3) d0)",
                    "Heqp4 : eq p2 (pair l2 l3)",
                    "l3 : list Output",
                    "l2 : Label",
                    "d0 : Data",
                    "p2 : prod Label (list Output)",
                    "Heqp0 : eq\n  ((if held sigma\n    then\n     fun _ : Data =>\n     pair\n       (pair (pair tt (app (app nil nil) nil))\n          {| queue := nil; held := false |})\n       (app (app nil (cons (pair Server Unlock) nil)) nil)\n    else fun s : Data => pair (pair (pair tt nil) s) nil) sigma)\n  (pair (pair (pair u l1) d) l0)",
                    "Heqp1 : eq p0 (pair (pair u l1) d)",
                    "Heqp2 : eq p1 (pair u l1)",
                    "l1 : list Output",
                    "u : unit",
                    "d : Data",
                    "p1 : prod unit (list Output)",
                    "l0 : list (prod Name Msg)",
                    "p0 : prod (prod unit (list Output)) Data",
                    "l : list (prod Name Msg)",
                    "p : prod (prod Label (list Output)) Data"
                ]
            },
            {
                "tactic_sig": "find_inversion .",
                "tactic_sig_no_out_arg": "find_inversion .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq (pair (pair (pair l2 (app nil l3)) d0) (app nil l))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (pair\n              (pair (pair (InputUnlock c) (app nil (app l1 nil))) d0)\n              (app nil (app l0 nil)))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))",
                    "Heqp0 : eq\n  ((if held sigma\n    then\n     fun _ : Data =>\n     pair\n       (pair (pair tt (app (app nil nil) nil))\n          {| queue := nil; held := false |})\n       (app (app nil (cons (pair Server Unlock) nil)) nil)\n    else fun s : Data => pair (pair (pair tt nil) s) nil) sigma)\n  (pair (pair (pair u l1) d0) l0)"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (pair\n              (pair (pair (InputUnlock c) (app nil (app l1 nil))) d0)\n              (app nil (app l0 nil)))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputUnlock_enabled",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\nnow (enabled lb_step_async (InputUnlock c)) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\nnow (enabled lb_step_async (InputUnlock c)) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\nnow (enabled lb_step_async (InputUnlock c)) s"
                ],
                "tactic_res": [
                    "_goal : now (enabled lb_step_async (InputUnlock c)) s",
                    "H : lb_step_execution lb_step_async s",
                    "c : Client_index",
                    "s : infseq (event network label (prod name (sum input (list output))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : now (enabled lb_step_async (InputUnlock c)) s",
                    "s : infseq (event network label (prod name (sum input (list output))))"
                ],
                "tactic_res": [
                    "_goal : now (enabled lb_step_async (InputUnlock c)) (Cons e s)",
                    "H : lb_step_execution lb_step_async (Cons e s)",
                    "e : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : now (enabled lb_step_async (InputUnlock c)) (Cons e s)"
                ],
                "tactic_res": [
                    "_goal : enabled lb_step_async (InputUnlock c) e"
                ]
            },
            {
                "tactic_sig": "unfold enabled , enabled .",
                "tactic_sig_no_out_arg": "unfold enabled , enabled .",
                "tactic_args": [
                    "_goal : enabled lb_step_async (InputUnlock c) e"
                ],
                "tactic_res": [
                    "_goal : lb_step_ex lb_step_async (InputUnlock c) (evt_a e)"
                ]
            },
            {
                "tactic_sig": "pose proof ( InputHandler_Client_Unlock _i ( nwState ( evt_a _i ) ( Client _i ) ) ) .",
                "tactic_sig_no_out_arg": "pose proof ( InputHandler_Client_Unlock _i ( nwState ( evt_a _i ) ( Client _i ) ) ) .",
                "tactic_args": [
                    "c : Client_index",
                    "e : event network label (prod name (sum input (list output)))",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "H0 : ex\n  (fun sigma' : Data =>\n   ex\n     (fun os : list Output =>\n      ex\n        (fun ms : list (prod Name Msg) =>\n         eq\n           (InputHandler (Client c) Unlock\n              (nwState (evt_a e) (Client c)))\n           (pair (pair (pair (InputUnlock c) os) sigma') ms))))"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (InputHandler (Client c) Unlock (nwState (evt_a e) (Client c)))\n  (pair (pair (pair (InputUnlock c) x0) x) x1)",
                    "x1 : list (prod Name Msg)",
                    "x0 : list Output",
                    "x : Data"
                ]
            },
            {
                "tactic_sig": "repeat eexists .",
                "tactic_sig_no_out_arg": "repeat eexists .",
                "tactic_args": [
                    "_goal : lb_step_ex lb_step_async (InputUnlock c) (evt_a e)"
                ],
                "tactic_res": [
                    "_goal : lb_step_async (evt_a e) (InputUnlock c) ?a' ?tr"
                ]
            },
            {
                "tactic_sig": "unfold InputHandler in * .",
                "tactic_sig_no_out_arg": "unfold InputHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq (ClientIOHandler c Unlock (nwState (evt_a e) (Client c)))\n  (pair (pair (pair (InputUnlock c) x0) x) x1)"
                ]
            },
            {
                "tactic_sig": "unfold ClientIOHandler in * .",
                "tactic_sig_no_out_arg": "unfold ClientIOHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : eq\n  (bind get\n     (fun data : Data =>\n      bind\n        (when (held data)\n           (bind (put {| queue := nil; held := false |})\n              (fun _ : unit => send (pair Server Unlock))))\n        (fun _ : unit => ret (InputUnlock c)))\n     (nwState (evt_a e) (Client c)))\n  (pair (pair (pair (InputUnlock c) x0) x) x1)"
                ]
            },
            {
                "tactic_sig": "eapply LabeledStepAsync_input with ( h := ( Client _i ) ) ( inp := Unlock ) .",
                "tactic_sig_no_out_arg": "eapply LabeledStepAsync_input with ( h := ( Client _i ) ) ( inp := Unlock ) .",
                "tactic_args": [
                    "_goal : lb_step_async (evt_a e) (InputUnlock c) ?a' ?tr",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "_goal : eq (lb_input_handlers (Client c) Unlock (nwState (evt_a e) (Client c)))\n  (pair (pair (pair (InputUnlock c) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (Client c) ?l) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) (Client c) ?d\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (lb_input_handlers (Client c) Unlock (nwState (evt_a e) (Client c)))\n  (pair (pair (pair (InputUnlock c) ?out) ?d) ?l)",
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (Client c) ?l) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) (Client c) ?d\n  |}"
                ],
                "tactic_res": [
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (Client c) x1) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) (Client c) x\n  |}"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq ?a'\n  {|\n    nwPackets := app (send_packets (Client c) x1) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) (Client c) x\n  |}"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "InputUnlock_continuously_enabled",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\ncont_enabled lb_step_async (InputUnlock c) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\ncont_enabled lb_step_async (InputUnlock c) s"
                ]
            },
            {
                "tactic_sig": "unfold cont_enabled .",
                "tactic_sig_no_out_arg": "unfold cont_enabled .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\ncont_enabled lb_step_async (InputUnlock c) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\ncontinuously (now (enabled lb_step_async (InputUnlock c))) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (c : Client_index) (_ : lb_step_execution lb_step_async s),\ncontinuously (now (enabled lb_step_async (InputUnlock c))) s"
                ],
                "tactic_res": [
                    "_goal : continuously (now (enabled lb_step_async (InputUnlock c))) s",
                    "H : lb_step_execution lb_step_async s",
                    "c : Client_index",
                    "s : infseq (event network label (prod name (sum input (list output))))"
                ]
            },
            {
                "tactic_sig": "apply always_continuously .",
                "tactic_sig_no_out_arg": "apply always_continuously .",
                "tactic_args": [
                    "_goal : continuously (now (enabled lb_step_async (InputUnlock c))) s"
                ],
                "tactic_res": [
                    "_goal : always (now (enabled lb_step_async (InputUnlock c))) s"
                ]
            },
            {
                "tactic_sig": "eapply always_monotonic;[ |eapply always_inv ; eauto ; eauto using lb_step_execution_invar ];eauto using InputUnlock_enabled .",
                "tactic_sig_no_out_arg": "eapply always_monotonic;[ |eapply always_inv ; eauto ; eauto using lb_step_execution_invar ];eauto using InputUnlock_enabled .",
                "tactic_args": [
                    "_goal : always (now (enabled lb_step_async (InputUnlock c))) s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "held_until_Unlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros c .",
                "tactic_args": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "cofix CIH .",
                "tactic_sig_no_out_arg": "cofix CIH .",
                "tactic_args": [],
                "tactic_res": [
                    "CIH : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ]
            },
            {
                "tactic_sig": "destruct s as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct s .",
                "tactic_args": [
                    "_goal : forall\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network label\n                  (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : eq (held (nwState (evt_a (hd (Cons e s))) (Client c))) true),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "e : event network label (prod name (sum input (list output)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : eq (held (nwState (evt_a (hd (Cons e s))) (Client c))) true),\nweak_until\n  (fun\n     s : infseq\n           (event network label (prod name (sum input (list output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network label\n                 (prod name (sum input (list output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)"
                ],
                "tactic_res": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : eq (held (nwState (evt_a e) (Client c))) true),\nweak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : lb_step_execution lb_step_async (Cons e s))\n  (_ : eq (held (nwState (evt_a e) (Client c))) true),\nweak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)",
                    "H0 : eq (held (nwState (evt_a e) (Client c))) true",
                    "H : lb_step_execution lb_step_async (Cons e s)"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e s)",
                    "H : lb_step_execution lb_step_async (Cons e s)"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))",
                    "H2 : eq (Cons e' s0) s",
                    "H1 : eq e0 e",
                    "H5 : lb_step_execution lb_step_async (Cons e' s0)",
                    "H4 : eq (evt_trace e') (app (evt_trace e) tr)",
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e') tr",
                    "s0 : infseq (event network Label (prod Name (sum Input (list Output))))",
                    "tr : list (prod Name (sum Input (list Output)))",
                    "e0 : event network Label (prod Name (sum Input (list Output)))",
                    "e' : event network Label (prod Name (sum Input (list Output)))"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H : lb_step_execution lb_step_async (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H : lb_step_execution lb_step_async (Cons e (Cons e' s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "e : event network Label (prod Name (sum Input (list Output)))",
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ]
            },
            {
                "tactic_sig": "inversion _i .",
                "tactic_sig_no_out_arg": "inversion _i .",
                "tactic_args": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e') tr"
                ],
                "tactic_res": [
                    "H9 : eq (cons (pair (pDst p) (inr out)) nil) tr",
                    "H8 : eq net' (evt_a e')",
                    "H7 : eq lb (evt_l e)",
                    "H6 : eq net (evt_a e)",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets := app (send_packets (pDst p) l) (app xs ys);\n    nwState := update name_eq_dec (nwState (evt_a e)) (pDst p) d\n  |}",
                    "H1 : eq\n  (lb_net_handlers (pDst p) (pSrc p) (pBody p)\n     (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H : eq (nwPackets (evt_a e)) (app xs (cons p ys))",
                    "lb : label",
                    "l : list (prod lb_name lb_msg)",
                    "d : data",
                    "out : list output",
                    "xs : list packet",
                    "ys : list packet",
                    "p : packet",
                    "net : network",
                    "net' : network",
                    "H8 : eq (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)) tr",
                    "H7 : eq net' (evt_a e')",
                    "H6 : eq lb (evt_l e)",
                    "H2 : eq net (evt_a e)",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets := app (send_packets h l) (nwPackets (evt_a e));\n    nwState := update name_eq_dec (nwState (evt_a e)) h d\n  |}",
                    "H : eq (lb_input_handlers h inp (nwState (evt_a e) h))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "inp : input",
                    "h : lb_name",
                    "H1 : eq nil tr",
                    "H6 : eq (evt_a e) (evt_a e')",
                    "H2 : eq Silent (evt_l e)",
                    "H : eq net (evt_a e)"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (pDst p) (inr out)) nil))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair (pDst p) (inr out)) nil)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := pDst p; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) (pDst p) d\n  |}",
                    "H1 : eq\n  (runGenHandler (nwState (evt_a e) (pDst p))\n     (NetHandler (pDst p) (pSrc p) (pBody p)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "l : list (prod Name Msg)",
                    "d : Data",
                    "out : list Output"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair h (inl inp)) (cons (pair h (inr out)) nil)))"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e')\n  (cons (pair h (inl inp)) (cons (pair h (inr out)) nil))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) l)\n        (nwPackets (evt_a e));\n    nwState := update Name_eq_dec (nwState (evt_a e)) h d\n  |}",
                    "H : eq (runGenHandler (nwState (evt_a e) h) (InputHandler h inp))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "inp : Input",
                    "h : Name"
                ]
            },
            {
                "tactic_sig": "subst_max .",
                "tactic_sig_no_out_arg": "subst_max .",
                "tactic_args": [],
                "tactic_res": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e') nil",
                    "H4 : eq (evt_trace e') (app (evt_trace e) nil)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "H3 : lb_step_async (evt_a e) (evt_l e) (evt_a e') nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in * .",
                "tactic_sig_no_out_arg": "simpl in * .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ]
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq\n  (NetHandler (pDst p) (pSrc p) (pBody p) (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "unfold NetHandler in * .",
                "tactic_sig_no_out_arg": "unfold NetHandler in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq\n  (match pDst p with\n   | Client c => ClientNetHandler c (pBody p)\n   | Server => ServerNetHandler (pSrc p) (pBody p)\n   end (nwState (evt_a e) (pDst p)))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "break_match_hyp .",
                "tactic_sig_no_out_arg": "break_match_hyp .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client c0; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client c0) d\n  |}",
                    "H1 : eq (ClientNetHandler c0 (pBody p) (nwState (evt_a e) (Client c0)))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (Client c0) (inr out)) nil))",
                    "Heqn : eq (pDst p) (Client c0)",
                    "c0 : Client_index",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) l)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H1 : eq (ServerNetHandler (pSrc p) (pBody p) (nwState (evt_a e) Server))\n  (pair (pair (pair (evt_l e) out) d) l)",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr out)) nil))",
                    "Heqn : eq (pDst p) Server"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp ClientNetHandler_cases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp ClientNetHandler_cases .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (eq l nil)\n  (or\n     (and (eq d (nwState (evt_a e) (Client c0)))\n        (and (eq out nil) (not (eq (pBody p) Locked))))\n     (and (eq (pBody p) Locked)\n        (and (eq out (cons Locked nil)) (eq (held d) true))))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {|\n                    pSrc := Client c0; pDst := fst m; pBody := snd m\n                  |}) l) (app xs ys);\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) (Client c0) d\n        |} (Client c))) true"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {|\n                    pSrc := Client c0; pDst := fst m; pBody := snd m\n                  |}) l) (app xs ys);\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) (Client c0) d\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client c0) d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H8 : forall _ : eq (pBody p) Locked, False",
                    "H1 : eq out nil",
                    "H6 : eq d (nwState (evt_a e) (Client c0))",
                    "H3 : eq l nil",
                    "H8 : eq (held d) true",
                    "H1 : eq out (cons Locked nil)",
                    "H6 : eq (pBody p) Locked"
                ]
            },
            {
                "tactic_sig": "update_destruct_max_simplify .",
                "tactic_sig_no_out_arg": "update_destruct_max_simplify .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c0))) true",
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "e0 : eq (Client c0) (Client c)",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client c0)\n        (nwState (evt_a e) (Client c0))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (Client c0) (inr nil)) nil))",
                    "n : not (eq (Client c0) (Client c))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c0))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client c)\n        (nwState (evt_a e) (Client c))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair (Client c) (inr nil)) nil))",
                    "Heqn : eq (pDst p) (Client c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "update_destruct_max_simplify .",
                "tactic_sig_no_out_arg": "update_destruct_max_simplify .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client c0) d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held d) true",
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "e0 : eq (Client c0) (Client c)",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client c0) d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client c0) (inr (cons Locked nil))) nil))",
                    "n : not (eq (Client c0) (Client c))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held d) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets := app xs ys;\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client c) d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client c) (inr (cons Locked nil))) nil))",
                    "Heqn : eq (pDst p) (Client c)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "find_apply_lem_hyp ServerNetHandler_cases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp ServerNetHandler_cases .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (eq out nil)\n  (or\n     (ex\n        (fun c : Client_index =>\n         and (eq (pSrc p) (Client c))\n           (and (eq (pBody p) Lock)\n              (and\n                 (eq (queue d)\n                    (app (queue (nwState (evt_a e) Server))\n                       (cons c nil)))\n                 (or\n                    (and (eq (queue (nwState (evt_a e) Server)) nil)\n                       (eq l (cons (pair (Client c) Locked) nil)))\n                    (and\n                       (not (eq (queue (nwState (evt_a e) Server)) nil))\n                       (eq l nil)))))))\n     (or\n        (and (eq (pBody p) Unlock)\n           (and\n              (eq (queue d)\n                 (List.tl (queue (nwState (evt_a e) Server))))\n              (or (and (eq (queue d) nil) (eq l nil))\n                 (ex\n                    (fun next : Client_index =>\n                     ex\n                       (fun t : list Client_index =>\n                        and (eq (queue d) (cons next t))\n                          (eq l (cons (pair (Client next) Locked) nil))))))))\n        (and (eq l nil)\n           (and (eq d (nwState (evt_a e) Server))\n              (not (eq (pBody p) Unlock))))))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n        |} (Client c))) true"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Server; pDst := fst m; pBody := snd m |})\n                 l) (app xs ys);\n          nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : ex\n  (fun c : Client_index =>\n   and (eq (pSrc p) (Client c))\n     (and (eq (pBody p) Lock)\n        (and\n           (eq (queue d)\n              (app (queue (nwState (evt_a e) Server)) (cons c nil)))\n           (or\n              (and (eq (queue (nwState (evt_a e) Server)) nil)\n                 (eq l (cons (pair (Client c) Locked) nil)))\n              (and\n                 (forall _ : eq (queue (nwState (evt_a e) Server)) nil,\n                  False) (eq l nil))))))",
                    "H3 : eq out nil",
                    "H9 : eq l nil",
                    "H8 : eq (queue d) nil",
                    "H6 : eq (queue d) (List.tl (queue (nwState (evt_a e) Server)))",
                    "H1 : eq (pBody p) Unlock",
                    "H7 : ex\n  (fun next : Client_index =>\n   ex\n     (fun t : list Client_index =>\n      and (eq (queue d) (cons next t))\n        (eq l (cons (pair (Client next) Locked) nil))))",
                    "H8 : forall _ : eq (pBody p) Unlock, False",
                    "H6 : eq d (nwState (evt_a e) Server)",
                    "H1 : eq l nil"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (eq (pSrc p) (Client x))\n  (and (eq (pBody p) Lock)\n     (and\n        (eq (queue d)\n           (app (queue (nwState (evt_a e) Server)) (cons x nil)))\n        (or\n           (and (eq (queue (nwState (evt_a e) Server)) nil)\n              (eq l (cons (pair (Client x) Locked) nil)))\n           (and\n              (forall _ : eq (queue (nwState (evt_a e) Server)) nil,\n               False) (eq l nil)))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H10 : eq l (cons (pair (Client x) Locked) nil)",
                    "H9 : eq (queue (nwState (evt_a e) Server)) nil",
                    "H7 : eq (queue d) (app (queue (nwState (evt_a e) Server)) (cons x nil))",
                    "H1 : eq (pBody p) Lock",
                    "H6 : eq (pSrc p) (Client x)",
                    "H10 : eq l nil",
                    "H9 : forall _ : eq (queue (nwState (evt_a e) Server)) nil, False"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H7 : eq (queue d) (app nil (cons x nil))",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |})\n           (cons (pair (Client x) Locked) nil)) (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H8 : eq (List.tl (queue (nwState (evt_a e) Server))) nil",
                    "H6 : eq (queue d) nil",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H7 : and (eq (queue d) (cons x x0))\n  (eq l (cons (pair (Client x) Locked) nil))",
                    "x0 : list Client_index",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : eq l (cons (pair (Client x) Locked) nil)",
                    "H8 : eq (queue d) (cons x x0)"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H8 : eq (List.tl (queue (nwState (evt_a e) Server))) (cons x x0)",
                    "H6 : eq (queue d) (cons x x0)",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |})\n           (cons (pair (Client x) Locked) nil)) (app xs ys);\n    nwState := update Name_eq_dec (nwState (evt_a e)) Server d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "rewrite_update .",
                "tactic_sig_no_out_arg": "rewrite_update .",
                "tactic_args": [
                    "_goal : eq (held (update Name_eq_dec (nwState (evt_a e)) Server d (Client c)))\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H2 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Server; pDst := fst m; pBody := snd m |}) nil)\n        (app xs ys);\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) Server\n        (nwState (evt_a e) Server)\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e) (cons (pair Server (inr nil)) nil))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "monad_unfold .",
                "tactic_sig_no_out_arg": "monad_unfold .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (InputHandler h inp (nwState (evt_a e) h))\n  (pair (pair (pair (evt_l e) out) d) l)"
                ]
            },
            {
                "tactic_sig": "find_apply_lem_hyp InputHandler_lbcases .",
                "tactic_sig_no_out_arg": "find_apply_lem_hyp InputHandler_lbcases .",
                "tactic_args": [],
                "tactic_res": [
                    "H : or\n  (ex\n     (fun c : Client_index =>\n      and (eq h (Client c))\n        (or\n           (and (eq inp Lock)\n              (and (eq out nil)\n                 (and (eq d (nwState (evt_a e) h))\n                    (and (eq l (cons (pair Server Lock) nil))\n                       (eq (evt_l e) (InputLock c))))))\n           (and (eq (evt_l e) (InputUnlock c))\n              (and (eq inp Unlock)\n                 (and (eq out nil)\n                    (and (eq (held d) false)\n                       (or\n                          (and (eq (held (nwState (evt_a e) h)) true)\n                             (eq l (cons (pair Server Unlock) nil)))\n                          (and (eq d (nwState (evt_a e) h)) (eq l nil))))))))))\n  (and (eq out nil)\n     (and (eq d (nwState (evt_a e) h))\n        (and (eq l nil) (eq (evt_l e) Nop))))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : ex\n  (fun c : Client_index =>\n   and (eq h (Client c))\n     (or\n        (and (eq inp Lock)\n           (and (eq out nil)\n              (and (eq d (nwState (evt_a e) h))\n                 (and (eq l (cons (pair Server Lock) nil))\n                    (eq (evt_l e) (InputLock c))))))\n        (and (eq (evt_l e) (InputUnlock c))\n           (and (eq inp Unlock)\n              (and (eq out nil)\n                 (and (eq (held d) false)\n                    (or\n                       (and (eq (held (nwState (evt_a e) h)) true)\n                          (eq l (cons (pair Server Unlock) nil)))\n                       (and (eq d (nwState (evt_a e) h)) (eq l nil)))))))))",
                    "H7 : eq (evt_l e) Nop",
                    "H3 : eq l nil",
                    "H2 : eq d (nwState (evt_a e) h)",
                    "H : eq out nil"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (eq h (Client x))\n  (or\n     (and (eq inp Lock)\n        (and (eq out nil)\n           (and (eq d (nwState (evt_a e) h))\n              (and (eq l (cons (pair Server Lock) nil))\n                 (eq (evt_l e) (InputLock x))))))\n     (and (eq (evt_l e) (InputUnlock x))\n        (and (eq inp Unlock)\n           (and (eq out nil)\n              (and (eq (held d) false)\n                 (or\n                    (and (eq (held (nwState (evt_a e) h)) true)\n                       (eq l (cons (pair Server Unlock) nil)))\n                    (and (eq d (nwState (evt_a e) h)) (eq l nil))))))))",
                    "x : Client_index"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : eq (evt_l e) (InputLock x)",
                    "H7 : eq l (cons (pair Server Lock) nil)",
                    "H6 : eq d (nwState (evt_a e) h)",
                    "H3 : eq inp Lock",
                    "H2 : eq h (Client x)",
                    "H10 : eq l (cons (pair Server Unlock) nil)",
                    "H9 : eq (held (nwState (evt_a e) h)) true",
                    "H7 : eq (held d) false",
                    "H6 : eq out nil",
                    "H : eq inp Unlock",
                    "H3 : eq (evt_l e) (InputUnlock x)",
                    "H10 : eq l nil",
                    "H9 : eq d (nwState (evt_a e) h)"
                ]
            },
            {
                "tactic_sig": "break_exists .",
                "tactic_sig_no_out_arg": "break_exists .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 (cons (pair Server Lock) nil)) (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) \n              (Client x) (nwState (evt_a e) (Client x))\n        |} (Client c))) true",
                    "H6 : eq d (nwState (evt_a e) (Client x))",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n           (cons (pair Server Lock) nil)) (nwPackets (evt_a e));\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client x) (inl Lock))\n        (cons (pair (Client x) (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 (cons (pair Server Lock) nil)) (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) \n              (Client x) (nwState (evt_a e) (Client x))\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x)) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "update_destruct_max_simplify .",
                "tactic_sig_no_out_arg": "update_destruct_max_simplify .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x)) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client x))) true",
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "e0 : eq (Client x) (Client c)",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      cons {| pSrc := Client x; pDst := Server; pBody := Lock |}\n        (nwPackets (evt_a e));\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x))\n  |}",
                    "n : not (eq (Client x) (Client c))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client x))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      cons {| pSrc := Client c; pDst := Server; pBody := Lock |}\n        (nwPackets (evt_a e));\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client c)\n        (nwState (evt_a e) (Client c))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client c) (inl Lock))\n        (cons (pair (Client c) (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H9 : eq (held (nwState (evt_a e) (Client x))) true",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n           (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client x) (inl Unlock))\n        (cons (pair (Client x) (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "destruct ( fin_eq_dec _ _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( fin_eq_dec _ _i _i ) .",
                "tactic_args": [
                    "c : Client_index",
                    "x : Client_index"
                ],
                "tactic_res": [
                    "e0 : eq c x",
                    "n : not (eq c x)"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client x))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))",
                    "H0 : eq (held (nwState (evt_a e) (Client x))) true"
                ]
            },
            {
                "tactic_sig": "apply W0 .",
                "tactic_sig_no_out_arg": "apply W0 .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client x))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   =>\n   In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) (Cons e (Cons e' s0))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : next\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   =>\n   In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a (hd s)))) (Cons e (Cons e' s0))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "fold LockServ_MultiParams in * .",
                "tactic_sig_no_out_arg": "fold LockServ_MultiParams in * .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets (evt_a e'))"
                ],
                "tactic_res": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets\n     {|\n       nwPackets :=\n         app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n              (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n       nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n     |})",
                    "H9 : eq true true"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n  (nwPackets\n     {|\n       nwPackets :=\n         app\n           (map\n              (fun m : prod Name Msg =>\n               {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n              (cons (pair Server Unlock) nil)) (nwPackets (evt_a e));\n       nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n     |})"
                ],
                "tactic_res": [
                    "_goal : or\n  (eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     {| pSrc := Client x; pDst := Server; pBody := Unlock |})\n  (In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a e)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or\n  (eq {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     {| pSrc := Client x; pDst := Server; pBody := Unlock |})\n  (In {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n     (nwPackets (evt_a e)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      cons {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a e));\n    nwState := update Name_eq_dec (nwState (evt_a e)) (Client x) d\n  |}"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            cons\n              {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n              (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) (Client x) d\n        |} (Client c))) true"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            cons\n              {| pSrc := Client x; pDst := Server; pBody := Unlock |}\n              (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) (Client x) d\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x) d (Client c)))\n  true"
                ]
            },
            {
                "tactic_sig": "now rewrite_update .",
                "tactic_sig_no_out_arg": "now rewrite_update .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x) d (Client c)))\n  true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 nil) (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) \n              (Client x) (nwState (evt_a e) (Client x))\n        |} (Client c))) true",
                    "H9 : eq d (nwState (evt_a e) (Client x))",
                    "H7 : eq (held (nwState (evt_a e) (Client x))) false",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := Client x; pDst := fst m; pBody := snd m |}) nil)\n        (nwPackets (evt_a e));\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client x) (inl Unlock))\n        (cons (pair (Client x) (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := Client x; pDst := fst m; pBody := snd m |})\n                 nil) (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) \n              (Client x) (nwState (evt_a e) (Client x))\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x)) (Client c))) true"
                ]
            },
            {
                "tactic_sig": "update_destruct_max_simplify .",
                "tactic_sig_no_out_arg": "update_destruct_max_simplify .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x)) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "e0 : eq (Client x) (Client c)",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets := nwPackets (evt_a e);\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client x)\n        (nwState (evt_a e) (Client x))\n  |}",
                    "n : not (eq (Client x) (Client c))"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq false false",
                    "H7 : eq true false",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets := nwPackets (evt_a e);\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client c)\n        (nwState (evt_a e) (Client c))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client c) (inl Unlock))\n        (cons (pair (Client c) (inr nil)) nil)))",
                    "H0 : eq (held (nwState (evt_a e) (Client c))) false"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq false false"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n              (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) h\n              (nwState (evt_a e) h)\n        |} (Client c))) true",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets :=\n      app\n        (map\n           (fun m : prod Name Msg =>\n            {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n        (nwPackets (evt_a e));\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) h (nwState (evt_a e) h)\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair h (inl inp)) (cons (pair h (inr nil)) nil)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (nwState\n        {|\n          nwPackets :=\n            app\n              (map\n                 (fun m : prod Name Msg =>\n                  {| pSrc := h; pDst := fst m; pBody := snd m |}) nil)\n              (nwPackets (evt_a e));\n          nwState :=\n            update Name_eq_dec (nwState (evt_a e)) h\n              (nwState (evt_a e) h)\n        |} (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) h (nwState (evt_a e) h)\n        (Client c))) true"
                ]
            },
            {
                "tactic_sig": "update_destruct_max_simplify .",
                "tactic_sig_no_out_arg": "update_destruct_max_simplify .",
                "tactic_args": [
                    "_goal : eq\n  (held\n     (update Name_eq_dec (nwState (evt_a e)) h (nwState (evt_a e) h)\n        (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets := nwPackets (evt_a e);\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) (Client c)\n        (nwState (evt_a e) (Client c))\n  |}",
                    "H4 : eq (evt_trace e')\n  (app (evt_trace e)\n     (cons (pair (Client c) (inl inp))\n        (cons (pair (Client c) (inr nil)) nil)))",
                    "n : not (eq h (Client c))",
                    "H1 : eq (evt_a e')\n  {|\n    nwPackets := nwPackets (evt_a e);\n    nwState :=\n      update Name_eq_dec (nwState (evt_a e)) h (nwState (evt_a e) h)\n  |}"
                ]
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "repeat find_rewrite .",
                "tactic_sig_no_out_arg": "repeat find_rewrite .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e) (Client c))) true"
                ],
                "tactic_res": [
                    "_goal : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "coinductive_case _i .",
                "tactic_sig_no_out_arg": "coinductive_case _i .",
                "tactic_args": [
                    "_goal : weak_until\n  (fun\n     s : infseq\n           (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s)) (Client c))) true)\n  (next\n     (fun\n        s : infseq\n              (event network Label\n                 (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s))))) (Cons e (Cons e' s0))",
                    "CIH : forall\n  (s : infseq\n         (event network Label (prod Name (sum Input (list Output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : eq (held (nwState (evt_a (hd s)) (Client c))) true),\nweak_until\n  (fun\n     s0 : infseq\n            (event network Label (prod Name (sum Input (list Output))))\n   => eq (held (nwState (evt_a (hd s0)) (Client c))) true)\n  (next\n     (fun\n        s0 : infseq\n               (event network Label\n                  (prod Name (sum Input (list Output)))) =>\n      In {| pSrc := Client c; pDst := Server; pBody := Unlock |}\n        (nwPackets (evt_a (hd s0))))) s"
                ],
                "tactic_res": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq (held (nwState (evt_a e') (Client c))) true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "held_eventually_InputUnlock",
        "proof": [
            {
                "tactic_sig": "Proof using .",
                "tactic_sig_no_out_arg": "Proof using .",
                "tactic_args": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s),\neventually (now (occurred (InputUnlock c))) s"
                ],
                "tactic_res": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s),\neventually (now (occurred (InputUnlock c))) s"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : Client_index)\n  (s : infseq\n         (event network label (prod name (sum input (list output)))))\n  (_ : lb_step_execution lb_step_async s)\n  (_ : weak_fairness lb_step_async label_silent s),\neventually (now (occurred (InputUnlock c))) s"
                ],
                "tactic_res": [
                    "_goal : eventually (now (occurred (InputUnlock c))) s",
                    "H0 : weak_fairness lb_step_async label_silent s",
                    "H : lb_step_execution lb_step_async s",
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "c : Client_index"
                ]
            },
            {
                "tactic_sig": "pose proof ( @InputUnlock_continuously_enabled _i _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( @InputUnlock_continuously_enabled _i _i ) .",
                "tactic_args": [
                    "s : infseq (event network label (prod name (sum input (list output))))",
                    "c : Client_index"
                ],
                "tactic_res": [
                    "H1 : forall _ : lb_step_execution lb_step_async s,\ncont_enabled lb_step_async (InputUnlock c) s"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : cont_enabled lb_step_async (InputUnlock c) s"
                ]
            },
            {
                "tactic_sig": "eapply_prop_hyp weak_fairness cont_enabled;[ |now unfold label_silent ] .",
                "tactic_sig_no_out_arg": "eapply_prop_hyp weak_fairness cont_enabled;[ |now unfold label_silent ] .",
                "tactic_args": [],
                "tactic_res": [
                    "H2 : inf_occurred (InputUnlock c) s"
                ]
            },
            {
                "tactic_sig": "solve_by_inversion .",
                "tactic_sig_no_out_arg": "solve_by_inversion .",
                "tactic_args": [
                    "_goal : eventually (now (occurred (InputUnlock c))) s"
                ],
                "tactic_res": []
            }
        ]
    }
]