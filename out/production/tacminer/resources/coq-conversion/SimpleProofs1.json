[
    {
        "lemma_name": "var_name_goodness_is_not_42",
        "proof": [
            {
                "tactic_sig": "unfold var_name_goodness .",
                "tactic_sig_no_out_arg": "unfold var_name_goodness .",
                "tactic_args": [
                    "_goal : forall v : var, not (eq (var_name_goodness v) 42)"
                ],
                "tactic_res": [
                    "_goal : forall v : var,\nnot\n  (eq\n     (if var_eq v \"i\"%string\n      then 0\n      else if var_eq v \"james\"%string then 50 else 10) 42)"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro v .",
                "tactic_args": [
                    "_goal : forall v : var,\nnot\n  (eq\n     (if var_eq v \"i\"%string\n      then 0\n      else if var_eq v \"james\"%string then 50 else 10) 42)"
                ],
                "tactic_res": [
                    "_goal : not\n  (eq\n     (if var_eq v \"i\"%string\n      then 0\n      else if var_eq v \"james\"%string then 50 else 10) 42)",
                    "v : var"
                ]
            },
            {
                "tactic_sig": "destruct ( var_eq _i \"i\" % string ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( var_eq _i \"i\" % string ) .",
                "tactic_args": [
                    "_goal : not\n  (eq\n     (if var_eq v \"i\"%string\n      then 0\n      else if var_eq v \"james\"%string then 50 else 10) 42)",
                    "v : var"
                ],
                "tactic_res": [
                    "_goal : not (eq 0 42)",
                    "_goal : not (eq (if var_eq v \"james\"%string then 50 else 10) 42)",
                    "e : eq v \"i\"%string",
                    "n : not (eq v \"i\"%string)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : not (eq 0 42)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( var_eq _i \"james\" % string ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( var_eq _i \"james\" % string ) .",
                "tactic_args": [
                    "_goal : not (eq (if var_eq v \"james\"%string then 50 else 10) 42)",
                    "v : var"
                ],
                "tactic_res": [
                    "_goal : not (eq 50 42)",
                    "_goal : not (eq 10 42)",
                    "e : eq v \"james\"%string",
                    "n0 : not (eq v \"james\"%string)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : not (eq 50 42)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : not (eq 10 42)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "read_var",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (const_map 5 \"x\"%string) 5"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "set_map_unchanged",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (map : var_map) (var1 var2 : var) (value : nat)\n  (_ : not (eq var1 var2)), eq (set_map map var1 value var2) (map var2)"
                ],
                "tactic_res": [
                    "_goal : eq (set_map map var1 value var2) (map var2)",
                    "map : var_map",
                    "var2 : var",
                    "var1 : var",
                    "value : nat",
                    "H : not (eq var1 var2)"
                ]
            },
            {
                "tactic_sig": "unfold set_map .",
                "tactic_sig_no_out_arg": "unfold set_map .",
                "tactic_args": [
                    "_goal : eq (set_map map var1 value var2) (map var2)"
                ],
                "tactic_res": [
                    "_goal : eq (if var_eq var1 var2 then value else map var2) (map var2)"
                ]
            },
            {
                "tactic_sig": "destruct ( var_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( var_eq _i _i ) .",
                "tactic_args": [
                    "_goal : eq (if var_eq var1 var2 then value else map var2) (map var2)",
                    "var1 : var",
                    "var2 : var"
                ],
                "tactic_res": [
                    "_goal : eq value (map var2)",
                    "_goal : eq (map var2) (map var2)",
                    "e : eq var1 var2",
                    "n : not (eq var1 var2)"
                ]
            },
            {
                "tactic_sig": "contradiction .",
                "tactic_sig_no_out_arg": "contradiction .",
                "tactic_args": [
                    "_goal : eq value (map var2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (map var2) (map var2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flip_involutive",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall e : expr, eq (flip (flip e)) e"
                ],
                "tactic_res": [
                    "_goal : eq (flip (flip e)) e",
                    "e : expr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "_goal : eq (flip (flip e)) e",
                    "e : expr"
                ],
                "tactic_res": [
                    "_goal : eq (flip (flip (Const n))) (Const n)",
                    "_goal : eq (flip (flip (Var v))) (Var v)",
                    "_goal : eq (flip (flip (Plus e1 e2))) (Plus e1 e2)",
                    "_goal : eq (flip (flip (Times e1 e2))) (Times e1 e2)",
                    "n : nat",
                    "v : var",
                    "IHe2 : eq (flip (flip e2)) e2",
                    "IHe1 : eq (flip (flip e1)) e1",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : eq (flip (flip (Const n))) (Const n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : eq (flip (flip (Var v))) (Var v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (flip (flip (Plus e1 e2))) (Plus e1 e2)"
                ],
                "tactic_res": [
                    "_goal : eq (Plus (flip (flip e1)) (flip (flip e2))) (Plus e1 e2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Plus (flip (flip e1)) (flip (flip e2))) (Plus e1 e2)",
                    "IHe1 : eq (flip (flip e1)) e1"
                ],
                "tactic_res": [
                    "_goal : eq (Plus e1 (flip (flip e2))) (Plus e1 e2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Plus e1 (flip (flip e2))) (Plus e1 e2)",
                    "IHe2 : eq (flip (flip e2)) e2"
                ],
                "tactic_res": [
                    "_goal : eq (Plus e1 e2) (Plus e1 e2)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (Plus e1 e2) (Plus e1 e2)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (flip (flip (Times e1 e2))) (Times e1 e2)"
                ],
                "tactic_res": [
                    "_goal : eq (Times (flip (flip e1)) (flip (flip e2))) (Times e1 e2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Times (flip (flip e1)) (flip (flip e2))) (Times e1 e2)",
                    "IHe1 : eq (flip (flip e1)) e1"
                ],
                "tactic_res": [
                    "_goal : eq (Times e1 (flip (flip e2))) (Times e1 e2)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (Times e1 (flip (flip e2))) (Times e1 e2)",
                    "IHe2 : eq (flip (flip e2)) e2"
                ],
                "tactic_res": [
                    "_goal : eq (Times e1 e2) (Times e1 e2)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (Times e1 e2) (Times e1 e2)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "flip_preserves_count_vars",
        "proof": [
            {
                "tactic_sig": "induction e .",
                "tactic_sig_no_out_arg": "induction e .",
                "tactic_args": [
                    "_goal : forall e : expr, eq (count_vars e) (count_vars (flip e))"
                ],
                "tactic_res": [
                    "_goal : eq (count_vars (Const n)) (count_vars (flip (Const n)))",
                    "_goal : eq (count_vars (Var v)) (count_vars (flip (Var v)))",
                    "_goal : eq (count_vars (Plus e1 e2)) (count_vars (flip (Plus e1 e2)))",
                    "_goal : eq (count_vars (Times e1 e2)) (count_vars (flip (Times e1 e2)))",
                    "n : nat",
                    "v : var",
                    "IHe2 : eq (count_vars e2) (count_vars (flip e2))",
                    "IHe1 : eq (count_vars e1) (count_vars (flip e1))",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : eq (count_vars (Const n)) (count_vars (flip (Const n)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : eq (count_vars (Var v)) (count_vars (flip (Var v)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (count_vars (Plus e1 e2)) (count_vars (flip (Plus e1 e2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars (flip e1)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars (flip e1)))",
                    "IHe1 : eq (count_vars e1) (count_vars (flip e1))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars e1))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars e1))",
                    "IHe2 : eq (count_vars e2) (count_vars (flip e2))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars e2) (count_vars e1))"
                ]
            },
            {
                "tactic_sig": "apply Nat.add_comm .",
                "tactic_sig_no_out_arg": "apply Nat.add_comm .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars e2) (count_vars e1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (count_vars (Times e1 e2)) (count_vars (flip (Times e1 e2)))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars (flip e1)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars (flip e1)))",
                    "IHe1 : eq (count_vars e1) (count_vars (flip e1))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars e1))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars (flip e2)) (count_vars e1))",
                    "IHe2 : eq (count_vars e2) (count_vars (flip e2))"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars e2) (count_vars e1))"
                ]
            },
            {
                "tactic_sig": "apply Nat.add_comm .",
                "tactic_sig_no_out_arg": "apply Nat.add_comm .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (count_vars e1) (count_vars e2))\n  (Init.Nat.add (count_vars e2) (count_vars e1))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "count_vars_bounded_by_size",
        "proof": [
            {
                "tactic_sig": "induction e .",
                "tactic_sig_no_out_arg": "induction e .",
                "tactic_args": [
                    "_goal : forall e : expr, le (count_vars e) (size e)"
                ],
                "tactic_res": [
                    "_goal : le (count_vars (Const n)) (size (Const n))",
                    "_goal : le (count_vars (Var v)) (size (Var v))",
                    "_goal : le (count_vars (Plus e1 e2)) (size (Plus e1 e2))",
                    "_goal : le (count_vars (Times e1 e2)) (size (Times e1 e2))",
                    "n : nat",
                    "v : var",
                    "IHe2 : le (count_vars e2) (size e2)",
                    "IHe1 : le (count_vars e1) (size e1)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (count_vars (Const n)) (size (Const n))"
                ],
                "tactic_res": [
                    "_goal : le 0 1"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : le 0 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (count_vars (Var v)) (size (Var v))"
                ],
                "tactic_res": [
                    "_goal : le 1 1"
                ]
            },
            {
                "tactic_sig": "firstorder .",
                "tactic_sig_no_out_arg": "firstorder .",
                "tactic_args": [
                    "_goal : le 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (count_vars (Plus e1 e2)) (size (Plus e1 e2))"
                ],
                "tactic_res": [
                    "_goal : le (Init.Nat.add (count_vars e1) (count_vars e2))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (Init.Nat.add (count_vars e1) (count_vars e2))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (count_vars (Times e1 e2)) (size (Times e1 e2))"
                ],
                "tactic_res": [
                    "_goal : le (Init.Nat.add (count_vars e1) (count_vars e2))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (Init.Nat.add (count_vars e1) (count_vars e2))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "zero_vars_independent",
        "proof": [
            {
                "tactic_sig": "induction e .",
                "tactic_sig_no_out_arg": "induction e .",
                "tactic_args": [
                    "_goal : forall (e : expr) (_ : eq (count_vars e) 0) (m1 m2 : var_map),\neq (eval_expr e m1) (eval_expr e m2)"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (count_vars (Const n)) 0) (m1 m2 : var_map),\neq (eval_expr (Const n) m1) (eval_expr (Const n) m2)",
                    "_goal : forall (_ : eq (count_vars (Var v)) 0) (m1 m2 : var_map),\neq (eval_expr (Var v) m1) (eval_expr (Var v) m2)",
                    "_goal : forall (_ : eq (count_vars (Plus e1 e2)) 0) (m1 m2 : var_map),\neq (eval_expr (Plus e1 e2) m1) (eval_expr (Plus e1 e2) m2)",
                    "_goal : forall (_ : eq (count_vars (Times e1 e2)) 0) (m1 m2 : var_map),\neq (eval_expr (Times e1 e2) m1) (eval_expr (Times e1 e2) m2)",
                    "n : nat",
                    "v : var",
                    "IHe2 : forall (_ : eq (count_vars e2) 0) (m1 m2 : var_map),\neq (eval_expr e2 m1) (eval_expr e2 m2)",
                    "IHe1 : forall (_ : eq (count_vars e1) 0) (m1 m2 : var_map),\neq (eval_expr e1 m1) (eval_expr e1 m2)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq (count_vars (Const n)) 0) (m1 m2 : var_map),\neq (eval_expr (Const n) m1) (eval_expr (Const n) m2)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_expr (Const n) m1) (eval_expr (Const n) m2)",
                    "H : eq (count_vars (Const n)) 0",
                    "m2 : var_map",
                    "m1 : var_map"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Const n) m1) (eval_expr (Const n) m2)"
                ],
                "tactic_res": [
                    "_goal : eq n n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (count_vars (Var v)) 0) (m1 m2 : var_map),\neq (eval_expr (Var v) m1) (eval_expr (Var v) m2)"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq 1 0) (m1 m2 : var_map), eq (m1 v) (m2 v)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : forall (_ : eq 1 0) (m1 m2 : var_map), eq (m1 v) (m2 v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq (count_vars (Plus e1 e2)) 0) (m1 m2 : var_map),\neq (eval_expr (Plus e1 e2) m1) (eval_expr (Plus e1 e2) m2)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_expr (Plus e1 e2) m1) (eval_expr (Plus e1 e2) m2)",
                    "H : eq (count_vars (Plus e1 e2)) 0",
                    "m2 : var_map",
                    "m1 : var_map"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Plus e1 e2) m1) (eval_expr (Plus e1 e2) m2)"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (eval_expr e1 m1) (eval_expr e2 m1))\n  (Init.Nat.add (eval_expr e1 m2) (eval_expr e2 m2))"
                ]
            },
            {
                "tactic_sig": "assert ( count_vars _i + count_vars _i = 0 -> ( count_vars _i = 0 /\\ count_vars _i = 0 ) ) .",
                "tactic_sig_no_out_arg": "assert ( count_vars _i + count_vars _i = 0 -> ( count_vars _i = 0 /\\ count_vars _i = 0 ) ) .",
                "tactic_args": [
                    "e1 : expr",
                    "e2 : expr",
                    "e1 : expr",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "H0 : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "_global_plus_is_O : forall (n m : nat) (_ : eq (Init.Nat.add n m) 0),\n       and (eq n 0) (eq m 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "H0 : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "H : eq (count_vars (Plus e1 e2)) 0"
                ],
                "tactic_res": [
                    "H0 : and (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H0 : and (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ],
                "tactic_res": [
                    "H1 : eq (count_vars e2) 0",
                    "H0 : eq (count_vars e1) 0"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "IHe1 : forall (_ : eq (count_vars e1) 0) (m1 m2 : var_map),\neq (eval_expr e1 m1) (eval_expr e1 m2)",
                    "H0 : eq (count_vars e1) 0"
                ],
                "tactic_res": [
                    "IHe1 : forall m1 m2 : var_map, eq (eval_expr e1 m1) (eval_expr e1 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "IHe2 : forall (_ : eq (count_vars e2) 0) (m1 m2 : var_map),\neq (eval_expr e2 m1) (eval_expr e2 m2)",
                    "H1 : eq (count_vars e2) 0"
                ],
                "tactic_res": [
                    "IHe2 : forall m1 m2 : var_map, eq (eval_expr e2 m1) (eval_expr e2 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i ) .",
                "tactic_args": [
                    "IHe1 : forall m1 m2 : var_map, eq (eval_expr e1 m1) (eval_expr e1 m2)",
                    "m1 : var_map",
                    "m2 : var_map"
                ],
                "tactic_res": [
                    "IHe1 : eq (eval_expr e1 m1) (eval_expr e1 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i ) .",
                "tactic_args": [
                    "IHe2 : forall m1 m2 : var_map, eq (eval_expr e2 m1) (eval_expr e2 m2)",
                    "m1 : var_map",
                    "m2 : var_map"
                ],
                "tactic_res": [
                    "IHe2 : eq (eval_expr e2 m1) (eval_expr e2 m2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (eval_expr e1 m1) (eval_expr e2 m1))\n  (Init.Nat.add (eval_expr e1 m2) (eval_expr e2 m2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq (count_vars (Times e1 e2)) 0) (m1 m2 : var_map),\neq (eval_expr (Times e1 e2) m1) (eval_expr (Times e1 e2) m2)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_expr (Times e1 e2) m1) (eval_expr (Times e1 e2) m2)",
                    "H : eq (count_vars (Times e1 e2)) 0",
                    "m2 : var_map",
                    "m1 : var_map"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Times e1 e2) m1) (eval_expr (Times e1 e2) m2)"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.mul (eval_expr e1 m1) (eval_expr e2 m1))\n  (Init.Nat.mul (eval_expr e1 m2) (eval_expr e2 m2))"
                ]
            },
            {
                "tactic_sig": "assert ( count_vars _i + count_vars _i = 0 -> ( count_vars _i = 0 /\\ count_vars _i = 0 ) ) .",
                "tactic_sig_no_out_arg": "assert ( count_vars _i + count_vars _i = 0 -> ( count_vars _i = 0 /\\ count_vars _i = 0 ) ) .",
                "tactic_args": [
                    "e1 : expr",
                    "e2 : expr",
                    "e1 : expr",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "H0 : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "_global_plus_is_O : forall (n m : nat) (_ : eq (Init.Nat.add n m) 0),\n       and (eq n 0) (eq m 0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "H0 : forall _ : eq (Init.Nat.add (count_vars e1) (count_vars e2)) 0,\nand (eq (count_vars e1) 0) (eq (count_vars e2) 0)",
                    "H : eq (count_vars (Times e1 e2)) 0"
                ],
                "tactic_res": [
                    "H0 : and (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H0 : and (eq (count_vars e1) 0) (eq (count_vars e2) 0)"
                ],
                "tactic_res": [
                    "H1 : eq (count_vars e2) 0",
                    "H0 : eq (count_vars e1) 0"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "IHe1 : forall (_ : eq (count_vars e1) 0) (m1 m2 : var_map),\neq (eval_expr e1 m1) (eval_expr e1 m2)",
                    "H0 : eq (count_vars e1) 0"
                ],
                "tactic_res": [
                    "IHe1 : forall m1 m2 : var_map, eq (eval_expr e1 m1) (eval_expr e1 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ) .",
                "tactic_args": [
                    "IHe2 : forall (_ : eq (count_vars e2) 0) (m1 m2 : var_map),\neq (eval_expr e2 m1) (eval_expr e2 m2)",
                    "H1 : eq (count_vars e2) 0"
                ],
                "tactic_res": [
                    "IHe2 : forall m1 m2 : var_map, eq (eval_expr e2 m1) (eval_expr e2 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i ) .",
                "tactic_args": [
                    "IHe1 : forall m1 m2 : var_map, eq (eval_expr e1 m1) (eval_expr e1 m2)",
                    "m1 : var_map",
                    "m2 : var_map"
                ],
                "tactic_res": [
                    "IHe1 : eq (eval_expr e1 m1) (eval_expr e1 m2)"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i ) .",
                "tactic_args": [
                    "IHe2 : forall m1 m2 : var_map, eq (eval_expr e2 m1) (eval_expr e2 m2)",
                    "m1 : var_map",
                    "m2 : var_map"
                ],
                "tactic_res": [
                    "IHe2 : eq (eval_expr e2 m1) (eval_expr e2 m2)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.mul (eval_expr e1 m1) (eval_expr e2 m1))\n  (Init.Nat.mul (eval_expr e1 m2) (eval_expr e2 m2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "rename_preserves_semantics",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (e : expr) (m : forall _ : var, nat) (from to : var)\n  (_ : eq (m from) (m to)),\neq (eval_expr e m) (eval_expr (rename e from to) m)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_expr e m) (eval_expr (rename e from to) m)",
                    "e : expr",
                    "m : forall _ : var, nat",
                    "to : var",
                    "from : var",
                    "H : eq (m from) (m to)"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "_goal : eq (eval_expr e m) (eval_expr (rename e from to) m)",
                    "e : expr"
                ],
                "tactic_res": [
                    "_goal : eq (eval_expr (Const n) m) (eval_expr (rename (Const n) from to) m)",
                    "_goal : eq (eval_expr (Var v) m) (eval_expr (rename (Var v) from to) m)",
                    "_goal : eq (eval_expr (Plus e1 e2) m)\n  (eval_expr (rename (Plus e1 e2) from to) m)",
                    "_goal : eq (eval_expr (Times e1 e2) m)\n  (eval_expr (rename (Times e1 e2) from to) m)",
                    "n : nat",
                    "v : var",
                    "IHe2 : eq (eval_expr e2 m) (eval_expr (rename e2 from to) m)",
                    "IHe1 : eq (eval_expr e1 m) (eval_expr (rename e1 from to) m)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "[ > try simpl ; auto ] .",
                "tactic_sig_no_out_arg": "[ > try simpl ; auto ] .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Const n) m) (eval_expr (rename (Const n) from to) m)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Var v) m) (eval_expr (rename (Var v) from to) m)"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (eval_expr (if var_eq from v then Var to else Var v) m)"
                ]
            },
            {
                "tactic_sig": "destruct ( var_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( var_eq _i _i ) .",
                "tactic_args": [
                    "_goal : eq (m v) (eval_expr (if var_eq from v then Var to else Var v) m)",
                    "from : var",
                    "v : var"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (eval_expr (Var to) m)",
                    "_goal : eq (m v) (eval_expr (Var v) m)",
                    "e : eq from v",
                    "n : not (eq from v)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (m v) (eval_expr (Var to) m)"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (m to)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq (m v) (m to)",
                    "H : eq (m from) (m to)"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (m from)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq (m v) (m from)",
                    "e : eq from v"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (m v)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (m v) (m v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (m v) (eval_expr (Var v) m)"
                ],
                "tactic_res": [
                    "_goal : eq (m v) (m v)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (m v) (m v)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Plus e1 e2) m)\n  (eval_expr (rename (Plus e1 e2) from to) m)"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (eval_expr e1 m) (eval_expr e2 m))\n  (Init.Nat.add (eval_expr (rename e1 from to) m)\n     (eval_expr (rename e2 from to) m))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (eval_expr e1 m) (eval_expr e2 m))\n  (Init.Nat.add (eval_expr (rename e1 from to) m)\n     (eval_expr (rename e2 from to) m))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : eq (eval_expr (Times e1 e2) m)\n  (eval_expr (rename (Times e1 e2) from to) m)"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.mul (eval_expr e1 m) (eval_expr e2 m))\n  (Init.Nat.mul (eval_expr (rename e1 from to) m)\n     (eval_expr (rename e2 from to) m))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.mul (eval_expr e1 m) (eval_expr e2 m))\n  (Init.Nat.mul (eval_expr (rename e1 from to) m)\n     (eval_expr (rename e2 from to) m))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "constant_fold_is_effective",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall e : expr, le (size (constant_fold e)) (size e)"
                ],
                "tactic_res": [
                    "_goal : le (size (constant_fold e)) (size e)",
                    "e : expr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "_goal : le (size (constant_fold e)) (size e)",
                    "e : expr"
                ],
                "tactic_res": [
                    "_goal : le (size (constant_fold (Const n))) (size (Const n))",
                    "_goal : le (size (constant_fold (Var v))) (size (Var v))",
                    "_goal : le (size (constant_fold (Plus e1 e2))) (size (Plus e1 e2))",
                    "_goal : le (size (constant_fold (Times e1 e2))) (size (Times e1 e2))",
                    "n : nat",
                    "v : var",
                    "IHe2 : le (size (constant_fold e2)) (size e2)",
                    "IHe1 : le (size (constant_fold e1)) (size e1)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : le (size (constant_fold (Const n))) (size (Const n))"
                ],
                "tactic_res": [
                    "_goal : le 1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : le 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : le (size (constant_fold (Var v))) (size (Var v))"
                ],
                "tactic_res": [
                    "_goal : le 1 1"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : le 1 1"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : le (size (constant_fold (Plus e1 e2))) (size (Plus e1 e2))"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match constant_fold e1 with\n     | Const (0 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n1 n2)\n         | _ => constant_fold e2\n         end\n     | Const (S _ as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n1 n2)\n         | _ => Plus (constant_fold e1) (constant_fold e2)\n         end\n     | _ =>\n         match constant_fold e2 with\n         | Const 0 => constant_fold e1\n         | _ => Plus (constant_fold e1) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl .",
                "tactic_sig_no_out_arg": "try simpl .",
                "tactic_args": [
                    "_goal : le (size (constant_fold (Times e1 e2))) (size (Times e1 e2))"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match constant_fold e1 with\n     | Const (0 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => Const 0\n         end\n     | Const (1 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => constant_fold e2\n         end\n     | Const (S (S _) as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => Times (constant_fold e1) (constant_fold e2)\n         end\n     | _ =>\n         match constant_fold e2 with\n         | Const 0 => Const 0\n         | Const 1 => constant_fold e1\n         | _ => Times (constant_fold e1) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e1 with\n     | Const (0 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n1 n2)\n         | _ => constant_fold e2\n         end\n     | Const (S _ as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n1 n2)\n         | _ => Plus (constant_fold e1) (constant_fold e2)\n         end\n     | _ =>\n         match constant_fold e2 with\n         | Const 0 => constant_fold e1\n         | _ => Plus (constant_fold e1) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e1 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n n2)\n         | _ => constant_fold e2\n         end\n     | S _ =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n n2)\n         | _ => Plus (Const n) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Var v\n     | _ => Plus (Var v) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Plus e3 e4\n     | _ => Plus (Plus e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Times e3 e4\n     | _ => Plus (Times e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const n)) (size e1)",
                    "n : nat",
                    "IHe1 : le (size (Var v)) (size e1)",
                    "v : var",
                    "IHe1 : le (size (Plus e3 e4)) (size e1)",
                    "e3 : expr",
                    "e4 : expr",
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ]
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n n2)\n         | _ => constant_fold e2\n         end\n     | S _ =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.add n n2)\n         | _ => Plus (Const n) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.add n n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size match n with\n         | 0 => Var v\n         | S _ => Plus (Const n) (Var v)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Plus (Const n) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Plus (Const n) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n0)) (size e2)",
                    "n0 : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "IHe2 : le (size (Plus e3 e4)) (size e2)",
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.add n n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const (Init.Nat.add 0 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Const (Init.Nat.add (S n) n0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const (Init.Nat.add 0 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const n0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const (Init.Nat.add (S n) n0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const n0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le (size match n with\n         | 0 => Var v\n         | S _ => Plus (Const n) (Var v)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Const (S n)) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Const (S n)) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Plus (Const n) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Const (S n)) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Const (S n)) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Plus (Const n) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Const (S n)) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Const (S n)) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Var v\n     | _ => Plus (Var v) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le (size match n with\n         | 0 => Var v\n         | S _ => Plus (Var v) (Const n)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Var v) (Var v0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Var v) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Var v) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v0)) (size e2)",
                    "v0 : var",
                    "IHe2 : le (size (Plus e3 e4)) (size e2)",
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le (size match n with\n         | 0 => Var v\n         | S _ => Plus (Var v) (Const n)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Var v) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Var v) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Var v) (Var v0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Var v) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Var v) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Plus e3 e4\n     | _ => Plus (Plus e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Plus (Plus e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Plus e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Plus e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Plus e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "v : var",
                    "IHe2 : le (size (Plus e5 e6)) (size e2)",
                    "e5 : expr",
                    "e6 : expr",
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Plus (Plus e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Plus e3 e4) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Plus e3 e4) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Plus e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Plus e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Plus e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Times e3 e4\n     | _ => Plus (Times e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Plus (Times e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Times e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Times e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Times e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "v : var",
                    "IHe2 : le (size (Plus e5 e6)) (size e2)",
                    "e5 : expr",
                    "e6 : expr",
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Plus (Times e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Plus (Times e3 e4) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Times e3 e4) (Const (S n))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Times e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Times e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus (Times e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try simpl in _i .",
                "tactic_sig_no_out_arg": "try simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e1 with\n     | Const (0 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => Const 0\n         end\n     | Const (1 as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => constant_fold e2\n         end\n     | Const (S (S _) as n1) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n1 n2)\n         | _ => Times (constant_fold e1) (constant_fold e2)\n         end\n     | _ =>\n         match constant_fold e2 with\n         | Const 0 => Const 0\n         | Const 1 => constant_fold e1\n         | _ => Times (constant_fold e1) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e1 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => Const 0\n         end\n     | 1 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => constant_fold e2\n         end\n     | S (S _) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => Times (Const n) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Var v\n     | _ => Times (Var v) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Plus e3 e4\n     | _ => Times (Plus e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Times e3 e4\n     | _ => Times (Times e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const n)) (size e1)",
                    "n : nat",
                    "IHe1 : le (size (Var v)) (size e1)",
                    "v : var",
                    "IHe1 : le (size (Plus e3 e4)) (size e1)",
                    "e3 : expr",
                    "e4 : expr",
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ]
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => Const 0\n         end\n     | 1 =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => constant_fold e2\n         end\n     | S (S _) =>\n         match constant_fold e2 with\n         | Const n2 => Const (Init.Nat.mul n n2)\n         | _ => Times (Const n) (constant_fold e2)\n         end\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.mul n n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Var v\n     | S (S _) => Times (Const n) (Var v)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Plus e3 e4\n     | S (S _) => Times (Const n) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Times e3 e4\n     | S (S _) => Times (Const n) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n0)) (size e2)",
                    "n0 : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "IHe2 : le (size (Plus e3 e4)) (size e2)",
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.mul n n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const (Init.Nat.mul 0 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.mul (S n) n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const n0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const (Init.Nat.mul 0 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le (size match n with\n         | 0 | _ => Const (Init.Nat.mul (S n) n0)\n         end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const (Init.Nat.mul 1 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Const (Init.Nat.mul (S (S n)) n0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 1)) (size e1)",
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 1)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const n0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const (Init.Nat.mul 1 n0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const n0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const (Init.Nat.mul (S (S n)) n0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Var v\n     | S (S _) => Times (Const n) (Var v)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Var v\n     | S _ => Times (Const (S n)) (Var v)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Var v\n     | S _ => Times (Const (S n)) (Var v)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Const (S (S n))) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 1)) (size e1)",
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 1)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Const (S (S n))) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Plus e3 e4\n     | S (S _) => Times (Const n) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Times (Const (S n)) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Times (Const (S n)) (Plus e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Const (S (S n))) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 1)) (size e1)",
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 1)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Const (S (S n))) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Times e3 e4\n     | S (S _) => Times (Const n) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Times (Const (S n)) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 0)) (size e1)",
                    "IHe1 : le (size (Const (S n))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 0)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Times (Const (S n)) (Times e3 e4)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Const (S (S n))) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe1 : le (size (Const 1)) (size e1)",
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const 1)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Const (S (S n)))) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Const (S (S n))) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Var v\n     | _ => Times (Var v) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Var v\n     | S (S _) => Times (Var v) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Var v) (Var v0)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Var v) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Var v) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v0)) (size e2)",
                    "v0 : var",
                    "IHe2 : le (size (Plus e3 e4)) (size e2)",
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Var v\n     | S (S _) => Times (Var v) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Var v\n     | S _ => Times (Var v) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Var v\n     | S _ => Times (Var v) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Var v) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 1)) (size e2)",
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Var v)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 1)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Var v) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Var v) (Var v0)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 3 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Var v) (Plus e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Var v) (Times e3 e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Var v)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le 1 (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e3 e4)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e3) (size e4))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (S (Init.Nat.add (size e3) (size e4)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Plus e3 e4\n     | _ => Times (Plus e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Plus e3 e4\n     | S (S _) => Times (Plus e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Plus e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Plus e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Plus e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "v : var",
                    "IHe2 : le (size (Plus e5 e6)) (size e2)",
                    "e5 : expr",
                    "e6 : expr",
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Plus e3 e4\n     | S (S _) => Times (Plus e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Times (Plus e3 e4) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Plus e3 e4\n     | S _ => Times (Plus e3 e4) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Plus e3 e4) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 1)) (size e2)",
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Plus e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 1)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Plus e3 e4) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Plus e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Plus e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Plus e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Plus e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "try lia .",
                "tactic_sig_no_out_arg": "try lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( constant_fold _i ) as [_o _o | _o _o | _o _o _o | _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( constant_fold _i ) .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match constant_fold e2 with\n     | Const 0 => Const 0\n     | Const 1 => Times e3 e4\n     | _ => Times (Times e3 e4) (constant_fold e2)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "e2 : expr"
                ],
                "tactic_res": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Times e3 e4\n     | S (S _) => Times (Times e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Times e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Times e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Times e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const n)) (size e2)",
                    "n : nat",
                    "IHe2 : le (size (Var v)) (size e2)",
                    "v : var",
                    "IHe2 : le (size (Plus e5 e6)) (size e2)",
                    "e5 : expr",
                    "e6 : expr",
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ]
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Const 0\n     | 1 => Times e3 e4\n     | S (S _) => Times (Times e3 e4) (Const n)\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Times (Times e3 e4) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 0)) (size e2)",
                    "IHe2 : le (size (Const (S n))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 0)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Const 0)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le 1 (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try destruct _i .",
                "tactic_sig_no_out_arg": "try destruct _i .",
                "tactic_args": [
                    "_goal : le\n  (size\n     match n with\n     | 0 => Times e3 e4\n     | S _ => Times (Times e3 e4) (Const (S n))\n     end) (S (Init.Nat.add (size e1) (size e2)))",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))",
                    "_goal : le (size (Times (Times e3 e4) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))",
                    "IHe2 : le (size (Const 1)) (size e2)",
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const 1)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times e3 e4)) (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (Init.Nat.add (size e3) (size e4)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Const (S (S n)))) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Times e3 e4) (Const (S (S n)))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Var v)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le 1 (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Times e3 e4) (Var v)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le (S (S (Init.Nat.add (Init.Nat.add (size e3) (size e4)) 1)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Plus e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Times e3 e4) (Plus e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe1 : le (size (Times e3 e4)) (size e1)"
                ],
                "tactic_res": [
                    "IHe1 : le (S (Init.Nat.add (size e3) (size e4))) (size e1)"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "IHe2 : le (size (Times e5 e6)) (size e2)"
                ],
                "tactic_res": [
                    "IHe2 : le (S (Init.Nat.add (size e5) (size e6))) (size e2)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : le (size (Times (Times e3 e4) (Times e5 e6)))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : le\n  (S\n     (S\n        (Init.Nat.add (Init.Nat.add (size e3) (size e4))\n           (S (Init.Nat.add (size e5) (size e6))))))\n  (S (Init.Nat.add (size e1) (size e2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_instr_add",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state := eval_instr (ADD 1 2 0) example_state in\nand (eq (final_state 1) 5)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 12))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_instr_ldi",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state := eval_instr (LDI 17 0) example_state in\nand (eq (final_state 1) 5)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 17))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_instr_mov",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state := eval_instr (MOV 1 0) example_state in\nand (eq (final_state 1) 5)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 5))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_prog'_ldi_add",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state :=\n  eval_prog' (cons (LDI 17 1) (cons (ADD 1 2 0) nil)) example_state in\nand (eq (final_state 1) 17)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 24))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_prog'_add_ldi",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state :=\n  eval_prog' (cons (ADD 1 2 0) (cons (LDI 13 1) nil)) example_state in\nand (eq (final_state 1) 13)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 12))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_prog'_add_mov",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let final_state :=\n  eval_prog' (cons (ADD 1 2 0) (cons (MOV 0 1) nil)) example_state in\nand (eq (final_state 1) 12)\n  (and (eq (final_state 2) 7) (eq (final_state 0) 12))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_const",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Const 10))) 10"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_plus",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Plus (Const 7) (Const 9)))) 16"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_nested_plus",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog\n     (compile\n        (Plus (Plus (Const 7) (Const 8)) (Plus (Const 9) (Const 11)))))\n  35"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile'_plus_0_is_unmodified",
        "proof": [
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : let example_state := set_register initial_state 0 12 in\nlet final_state :=\n  eval_prog' (compile' (Plus (Const 7) (Const 8)) 1) example_state in\nand (eq (final_state 0) 12) (eq (final_state 1) 15)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "eval_prog_append",
        "proof": [
            {
                "tactic_sig": "induction p1 .",
                "tactic_sig_no_out_arg": "induction p1 .",
                "tactic_args": [
                    "_goal : forall (p1 p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app p1 p2) st r) (eval_prog' p2 (eval_prog' p1 st) r)"
                ],
                "tactic_res": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app nil p2) st r) (eval_prog' p2 (eval_prog' nil st) r)",
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app (cons a p1) p2) st r)\n  (eval_prog' p2 (eval_prog' (cons a p1) st) r)",
                    "IHp1 : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app p1 p2) st r) (eval_prog' p2 (eval_prog' p1 st) r)",
                    "p1 : list instr",
                    "a : instr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app nil p2) st r) (eval_prog' p2 (eval_prog' nil st) r)"
                ],
                "tactic_res": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' p2 st r) (eval_prog' p2 st r)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' p2 st r) (eval_prog' p2 st r)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app (cons a p1) p2) st r)\n  (eval_prog' p2 (eval_prog' (cons a p1) st) r)"
                ],
                "tactic_res": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)",
                    "p2 : prog",
                    "st : state",
                    "r : nat"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i ( eval_instr _i _i ) _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i ( eval_instr _i _i ) _i ) .",
                "tactic_args": [
                    "IHp1 : forall (p2 : prog) (st : state) (r : nat),\neq (eval_prog' (app p1 p2) st r) (eval_prog' p2 (eval_prog' p1 st) r)",
                    "p2 : prog",
                    "a : instr",
                    "st : state",
                    "r : nat"
                ],
                "tactic_res": [
                    "IHp1 : eq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)",
                    "IHp1 : eq (eval_prog' (app p1 p2) (eval_instr a st) r)\n  (eval_prog' p2 (eval_prog' p1 (eval_instr a st)) r)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_correct",
        "proof": [
            {
                "tactic_sig": "induction e .",
                "tactic_sig_no_out_arg": "induction e .",
                "tactic_args": [
                    "_goal : forall e : expr, eq (eval_prog (compile e)) (eval_expr e)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile (Const n))) (eval_expr (Const n))",
                    "_goal : eq (eval_prog (compile (Plus e1 e2))) (eval_expr (Plus e1 e2))",
                    "n : nat",
                    "IHe2 : eq (eval_prog (compile e2)) (eval_expr e2)",
                    "IHe1 : eq (eval_prog (compile e1)) (eval_expr e1)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Const n))) (eval_expr (Const n))"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile (Const n))) n"
                ]
            },
            {
                "tactic_sig": "unfold compile .",
                "tactic_sig_no_out_arg": "unfold compile .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Const n))) n"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile' (Const n) 0)) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile' (Const n) 0)) n"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (cons (LDI n 0) nil)) n"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog .",
                "tactic_sig_no_out_arg": "unfold eval_prog .",
                "tactic_args": [
                    "_goal : eq (eval_prog (cons (LDI n 0) nil)) n"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog' (cons (LDI n 0) nil) initial_state 0) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_prog' (cons (LDI n 0) nil) initial_state 0) n"
                ],
                "tactic_res": [
                    "_goal : eq (set_register initial_state 0 n 0) n"
                ]
            },
            {
                "tactic_sig": "unfold set_register .",
                "tactic_sig_no_out_arg": "unfold set_register .",
                "tactic_args": [
                    "_goal : eq (set_register initial_state 0 n 0) n"
                ],
                "tactic_res": [
                    "_goal : eq (if reg_eq 0 0 then n else initial_state 0) n"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (if reg_eq 0 0 then n else initial_state 0) n"
                ],
                "tactic_res": [
                    "_goal : eq n n"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Plus e1 e2))) (eval_expr (Plus e1 e2))"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile (Plus e1 e2)))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "unfold compile .",
                "tactic_sig_no_out_arg": "unfold compile .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile (Plus e1 e2)))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile' (Plus e1 e2) 0))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile' (Plus e1 e2) 0))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog\n     (app (compile' e1 0) (app (compile' e2 1) (cons (ADD 0 1 0) nil))))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog .",
                "tactic_sig_no_out_arg": "unfold eval_prog .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog\n     (app (compile' e1 0) (app (compile' e2 1) (cons (ADD 0 1 0) nil))))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e1 0) (app (compile' e2 1) (cons (ADD 0 1 0) nil)))\n     initial_state 0) (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog in _i .",
                "tactic_sig_no_out_arg": "unfold eval_prog in _i .",
                "tactic_args": [
                    "IHe1 : eq (eval_prog (compile e1)) (eval_expr e1)"
                ],
                "tactic_res": [
                    "IHe1 : eq (eval_prog' (compile e1) initial_state 0) (eval_expr e1)"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog in _i .",
                "tactic_sig_no_out_arg": "unfold eval_prog in _i .",
                "tactic_args": [
                    "IHe2 : eq (eval_prog (compile e2)) (eval_expr e2)"
                ],
                "tactic_res": [
                    "IHe2 : eq (eval_prog' (compile e2) initial_state 0) (eval_expr e2)"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e1 0) (app (compile' e2 1) (cons (ADD 0 1 0) nil)))\n     initial_state 0) (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (app (compile' e2 1) (cons (ADD 0 1 0) nil))\n     (eval_prog' (compile' e1 0) initial_state) 0)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (app (compile' e2 1) (cons (ADD 0 1 0) nil))\n     (eval_prog' (compile' e1 0) initial_state) 0)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (cons (ADD 0 1 0) nil)\n     (eval_prog' (compile' e2 1)\n        (eval_prog' (compile' e1 0) initial_state)) 0)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            }
        ]
    },
    {
        "lemma_name": "add_registers_untouched",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil) st r)\n  (st r)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil) st r)\n  (st r)",
                    "dest_reg : nat",
                    "st : state",
                    "r : nat",
                    "H : lt r dest_reg"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog' .",
                "tactic_sig_no_out_arg": "unfold eval_prog' .",
                "tactic_args": [
                    "_goal : eq (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil) st r)\n  (st r)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_instr (ADD dest_reg (S dest_reg) dest_reg) st r) (st r)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (eval_instr (ADD dest_reg (S dest_reg) dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (set_register st dest_reg\n     (Init.Nat.add (st dest_reg) (st (S dest_reg))) r) \n  (st r)"
                ]
            },
            {
                "tactic_sig": "unfold set_register .",
                "tactic_sig_no_out_arg": "unfold set_register .",
                "tactic_args": [
                    "_goal : eq\n  (set_register st dest_reg\n     (Init.Nat.add (st dest_reg) (st (S dest_reg))) r) \n  (st r)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if reg_eq dest_reg r\n   then Init.Nat.add (st dest_reg) (st (S dest_reg))\n   else st r) (st r)"
                ]
            },
            {
                "tactic_sig": "destruct ( reg_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( reg_eq _i _i ) .",
                "tactic_args": [
                    "_goal : eq\n  (if reg_eq dest_reg r\n   then Init.Nat.add (st dest_reg) (st (S dest_reg))\n   else st r) (st r)",
                    "dest_reg : nat",
                    "r : nat"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (st dest_reg) (st (S dest_reg))) (st r)",
                    "_goal : eq (st r) (st r)",
                    "e : eq dest_reg r",
                    "n : not (eq dest_reg r)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (st dest_reg) (st (S dest_reg))) (st r)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (st r) (st r)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile'_registers_untouched",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros e .",
                "tactic_args": [
                    "_goal : forall (e : expr) (dest_reg : nat) (st : state) (r : nat)\n  (_ : lt r dest_reg),\neq (eval_prog' (compile' e dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e dest_reg) st r) (st r)",
                    "e : expr"
                ]
            },
            {
                "tactic_sig": "induction _i .",
                "tactic_sig_no_out_arg": "induction _i .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e dest_reg) st r) (st r)",
                    "e : expr"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' (Const n) dest_reg) st r) (st r)",
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' (Plus e1 e2) dest_reg) st r) (st r)",
                    "n : nat",
                    "IHe2 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e2 dest_reg) st r) (st r)",
                    "IHe1 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e1 dest_reg) st r) (st r)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' (Const n) dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (set_register st dest_reg n r) (st r)"
                ]
            },
            {
                "tactic_sig": "unfold set_register .",
                "tactic_sig_no_out_arg": "unfold set_register .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (set_register st dest_reg n r) (st r)"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (if reg_eq dest_reg r then n else st r) (st r)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros dest_reg st r .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (if reg_eq dest_reg r then n else st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : forall _ : lt r dest_reg,\neq (if reg_eq dest_reg r then n else st r) (st r)",
                    "dest_reg : nat",
                    "st : state",
                    "r : nat"
                ]
            },
            {
                "tactic_sig": "destruct ( reg_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( reg_eq _i _i ) .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg,\neq (if reg_eq dest_reg r then n else st r) (st r)",
                    "dest_reg : nat",
                    "r : nat"
                ],
                "tactic_res": [
                    "_goal : forall _ : lt r dest_reg, eq n (st r)",
                    "_goal : forall _ : lt r dest_reg, eq (st r) (st r)",
                    "e : eq dest_reg r",
                    "n0 : not (eq dest_reg r)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg, eq n (st r)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg, eq (st r) (st r)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' (Plus e1 e2) dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros dest_reg .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)"
                ],
                "tactic_res": [
                    "_goal : forall (st : state) (r : nat) (_ : lt r dest_reg),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)",
                    "dest_reg : nat"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros st r .",
                "tactic_args": [
                    "_goal : forall (st : state) (r : nat) (_ : lt r dest_reg),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)"
                ],
                "tactic_res": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)",
                    "st : state",
                    "r : nat"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st r)\n  (st r)"
                ],
                "tactic_res": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog'\n     (app (compile' e2 (S dest_reg))\n        (cons (ADD dest_reg (S dest_reg) dest_reg) nil))\n     (eval_prog' (compile' e1 dest_reg) st) r) (st r)"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append with ( p1 := compile' _i ( S _i ) ) ( p2 := [ ADD ( _i ) ( S _i ) _i ] ) ( _i := ( eval_prog' ( compile' _i _i ) _i ) ) ( _i := _i ) .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append with ( p1 := compile' _i ( S _i ) ) ( p2 := [ ADD ( _i ) ( S _i ) _i ] ) ( _i := ( eval_prog' ( compile' _i _i ) _i ) ) ( _i := _i ) .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog'\n     (app (compile' e2 (S dest_reg))\n        (cons (ADD dest_reg (S dest_reg) dest_reg) nil))\n     (eval_prog' (compile' e1 dest_reg) st) r) (st r)",
                    "e2 : expr",
                    "dest_reg : nat",
                    "dest_reg : nat",
                    "dest_reg : nat",
                    "dest_reg : nat",
                    "st : state",
                    "e1 : expr",
                    "dest_reg : nat",
                    "st : state",
                    "r : nat",
                    "r : nat"
                ],
                "tactic_res": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r) \n  (st r)"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : lt r dest_reg,\neq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r) \n  (st r)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r) \n  (st r)",
                    "H : lt r dest_reg"
                ]
            },
            {
                "tactic_sig": "specialize ( _i _i _i _i _i ) .",
                "tactic_sig_no_out_arg": "specialize ( _i _i _i _i _i ) .",
                "tactic_args": [
                    "IHe1 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e1 dest_reg) st r) (st r)",
                    "dest_reg : nat",
                    "st : state",
                    "r : nat",
                    "H : lt r dest_reg"
                ],
                "tactic_res": [
                    "IHe1 : eq (eval_prog' (compile' e1 dest_reg) st r) (st r)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r) \n  (st r)",
                    "IHe1 : eq (eval_prog' (compile' e1 dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r)\n  (eval_prog' (compile' e1 dest_reg) st r)"
                ]
            },
            {
                "tactic_sig": "symmetry in _i .",
                "tactic_sig_no_out_arg": "symmetry in _i .",
                "tactic_args": [
                    "IHe2 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (eval_prog' (compile' e2 dest_reg) st r) (st r)"
                ],
                "tactic_res": [
                    "IHe2 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (st r) (eval_prog' (compile' e2 dest_reg) st r)"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( _i := ( S _i ) ) ( _i := eval_prog' ( compile' _i _i ) _i ) ( _i := _i ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( _i := ( S _i ) ) ( _i := eval_prog' ( compile' _i _i ) _i ) ( _i := _i ) .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r)\n  (eval_prog' (compile' e1 dest_reg) st r)",
                    "IHe2 : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\neq (st r) (eval_prog' (compile' e2 dest_reg) st r)",
                    "dest_reg : nat",
                    "dest_reg : nat",
                    "st : state",
                    "e1 : expr",
                    "dest_reg : nat",
                    "st : state",
                    "r : nat",
                    "r : nat"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r)\n  (eval_prog' (compile' e2 (S dest_reg))\n     (eval_prog' (compile' e1 dest_reg) st) r)",
                    "_goal : lt r (S dest_reg)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) r)\n  (eval_prog' (compile' e2 (S dest_reg))\n     (eval_prog' (compile' e1 dest_reg) st) r)",
                    "_global_add_registers_untouched : forall (dest_reg : nat) (st : state) (r : nat) (_ : lt r dest_reg),\n       eq (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil) st r)\n         (st r)"
                ],
                "tactic_res": [
                    "_goal : lt r dest_reg"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : lt r dest_reg"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : lt r (S dest_reg)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_correct'",
        "proof": [
            {
                "tactic_sig": "induction e .",
                "tactic_sig_no_out_arg": "induction e .",
                "tactic_args": [
                    "_goal : forall (e : expr) (dest_reg : nat) (st : state),\neq (eval_prog' (compile' e dest_reg) st dest_reg) (eval_expr e)"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' (Const n) dest_reg) st dest_reg)\n  (eval_expr (Const n))",
                    "_goal : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' (Plus e1 e2) dest_reg) st dest_reg)\n  (eval_expr (Plus e1 e2))",
                    "n : nat",
                    "IHe2 : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' e2 dest_reg) st dest_reg) (eval_expr e2)",
                    "IHe1 : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' e1 dest_reg) st dest_reg) (eval_expr e1)",
                    "e1 : expr",
                    "e2 : expr"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' (Const n) dest_reg) st dest_reg)\n  (eval_expr (Const n))"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (set_register st dest_reg n dest_reg) n"
                ]
            },
            {
                "tactic_sig": "unfold set_register .",
                "tactic_sig_no_out_arg": "unfold set_register .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (set_register st dest_reg n dest_reg) n"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (if reg_eq dest_reg dest_reg then n else st dest_reg) n"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (if reg_eq dest_reg dest_reg then n else st dest_reg) n"
                ],
                "tactic_res": [
                    "_goal : eq (if reg_eq dest_reg dest_reg then n else st dest_reg) n",
                    "dest_reg : nat",
                    "st : state"
                ]
            },
            {
                "tactic_sig": "destruct ( reg_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( reg_eq _i _i ) .",
                "tactic_args": [
                    "_goal : eq (if reg_eq dest_reg dest_reg then n else st dest_reg) n",
                    "dest_reg : nat",
                    "dest_reg : nat"
                ],
                "tactic_res": [
                    "_goal : eq n n",
                    "_goal : eq (st dest_reg) n",
                    "e : eq dest_reg dest_reg",
                    "n0 : not (eq dest_reg dest_reg)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq n n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (st dest_reg) n"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' (Plus e1 e2) dest_reg) st dest_reg)\n  (eval_expr (Plus e1 e2))"
                ],
                "tactic_res": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st\n     dest_reg) (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (dest_reg : nat) (st : state),\neq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st\n     dest_reg) (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st\n     dest_reg) (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "dest_reg : nat",
                    "st : state"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e1 dest_reg)\n        (app (compile' e2 (S dest_reg))\n           (cons (ADD dest_reg (S dest_reg) dest_reg) nil))) st\n     dest_reg) (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e2 (S dest_reg))\n        (cons (ADD dest_reg (S dest_reg) dest_reg) nil))\n     (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "rewrite eval_prog_append .",
                "tactic_sig_no_out_arg": "rewrite eval_prog_append .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog'\n     (app (compile' e2 (S dest_reg))\n        (cons (ADD dest_reg (S dest_reg) dest_reg) nil))\n     (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (cons (ADD dest_reg (S dest_reg) dest_reg) nil)\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "rewrite compile'_registers_untouched .",
                "tactic_sig_no_out_arg": "rewrite compile'_registers_untouched .",
                "tactic_args": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_prog' (compile' e1 dest_reg) st dest_reg)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "_goal : lt dest_reg (S dest_reg)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_prog' (compile' e1 dest_reg) st dest_reg)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "IHe1 : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' e1 dest_reg) st dest_reg) (eval_expr e1)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_expr e1)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "rewrite _i with ( _i := ( S _i ) ) .",
                "tactic_sig_no_out_arg": "rewrite _i with ( _i := ( S _i ) ) .",
                "tactic_args": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_expr e1)\n        (eval_prog' (compile' e2 (S dest_reg))\n           (eval_prog' (compile' e1 dest_reg) st) \n           (S dest_reg))) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "IHe2 : forall (dest_reg : nat) (st : state),\neq (eval_prog' (compile' e2 dest_reg) st dest_reg) (eval_expr e2)",
                    "dest_reg : nat",
                    "dest_reg : nat"
                ],
                "tactic_res": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_expr e1) (eval_expr e2)) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "unfold set_register .",
                "tactic_sig_no_out_arg": "unfold set_register .",
                "tactic_args": [
                    "_goal : eq\n  (set_register\n     (eval_prog' (compile' e2 (S dest_reg))\n        (eval_prog' (compile' e1 dest_reg) st)) dest_reg\n     (Init.Nat.add (eval_expr e1) (eval_expr e2)) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (if reg_eq dest_reg dest_reg\n   then Init.Nat.add (eval_expr e1) (eval_expr e2)\n   else\n    eval_prog' (compile' e2 (S dest_reg))\n      (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ]
            },
            {
                "tactic_sig": "destruct ( reg_eq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( reg_eq _i _i ) .",
                "tactic_args": [
                    "_goal : eq\n  (if reg_eq dest_reg dest_reg\n   then Init.Nat.add (eval_expr e1) (eval_expr e2)\n   else\n    eval_prog' (compile' e2 (S dest_reg))\n      (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "dest_reg : nat",
                    "dest_reg : nat"
                ],
                "tactic_res": [
                    "_goal : eq (Init.Nat.add (eval_expr e1) (eval_expr e2))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "_goal : eq\n  (eval_prog' (compile' e2 (S dest_reg))\n     (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))",
                    "e : eq dest_reg dest_reg",
                    "n : not (eq dest_reg dest_reg)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Init.Nat.add (eval_expr e1) (eval_expr e2))\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq\n  (eval_prog' (compile' e2 (S dest_reg))\n     (eval_prog' (compile' e1 dest_reg) st) dest_reg)\n  (Init.Nat.add (eval_expr e1) (eval_expr e2))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : lt dest_reg (S dest_reg)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "compile_correct",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall e : expr, eq (eval_prog (compile e)) (eval_expr e)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog (compile e)) (eval_expr e)",
                    "e : expr"
                ]
            },
            {
                "tactic_sig": "unfold eval_prog .",
                "tactic_sig_no_out_arg": "unfold eval_prog .",
                "tactic_args": [
                    "_goal : eq (eval_prog (compile e)) (eval_expr e)"
                ],
                "tactic_res": [
                    "_goal : eq (eval_prog' (compile e) initial_state 0) (eval_expr e)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eq (eval_prog' (compile e) initial_state 0) (eval_expr e)",
                    "_global_compile_correct' : forall (e : expr) (dest_reg : nat) (st : state),\n       eq (eval_prog' (compile' e dest_reg) st dest_reg) (eval_expr e)"
                ],
                "tactic_res": []
            }
        ]
    }
]