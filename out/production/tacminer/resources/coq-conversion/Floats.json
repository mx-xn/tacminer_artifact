[
    {
        "lemma_name": "integer_representable_n",
        "proof": [
            {
                "tactic_sig": "now apply integer_representable_n .",
                "tactic_sig_no_out_arg": "now apply integer_representable_n .",
                "tactic_args": [
                    "_goal : forall (n : Z)\n  (_ : and (Z.le (Z.opp (Z.pow 2 53)) n) (Z.le n (Z.pow 2 53))),\ninteger_representable 53 1024 n"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_swap",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : comparison) (x : option Datatypes.comparison),\neq (cmp_of_comparison (swap_comparison c) x)\n  (cmp_of_comparison c\n     match x with\n     | Some x0 => Some (CompOpp x0)\n     | None => None\n     end)"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) x)\n  (cmp_of_comparison c\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison",
                    "c : comparison"
                ]
            },
            {
                "tactic_sig": "destruct _i as [| | | | | ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) x)\n  (cmp_of_comparison c\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "c : comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) x)\n  (cmp_of_comparison Ceq\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) x)\n  (cmp_of_comparison Cne\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) x)\n  (cmp_of_comparison Clt\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) x)\n  (cmp_of_comparison Cle\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) x)\n  (cmp_of_comparison Cgt\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) x)\n  (cmp_of_comparison Cge\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) x)\n  (cmp_of_comparison Ceq\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Eq))\n  (cmp_of_comparison Ceq (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Lt))\n  (cmp_of_comparison Ceq (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Gt))\n  (cmp_of_comparison Ceq (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) None)\n  (cmp_of_comparison Ceq None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Eq))\n  (cmp_of_comparison Ceq (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Lt))\n  (cmp_of_comparison Ceq (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) (Some Gt))\n  (cmp_of_comparison Ceq (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Ceq) None)\n  (cmp_of_comparison Ceq None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) x)\n  (cmp_of_comparison Cne\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Eq))\n  (cmp_of_comparison Cne (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Lt))\n  (cmp_of_comparison Cne (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Gt))\n  (cmp_of_comparison Cne (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) None)\n  (cmp_of_comparison Cne None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Eq))\n  (cmp_of_comparison Cne (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Lt))\n  (cmp_of_comparison Cne (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) (Some Gt))\n  (cmp_of_comparison Cne (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cne) None)\n  (cmp_of_comparison Cne None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) x)\n  (cmp_of_comparison Clt\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Eq))\n  (cmp_of_comparison Clt (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Lt))\n  (cmp_of_comparison Clt (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Gt))\n  (cmp_of_comparison Clt (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) None)\n  (cmp_of_comparison Clt None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Eq))\n  (cmp_of_comparison Clt (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Lt))\n  (cmp_of_comparison Clt (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) (Some Gt))\n  (cmp_of_comparison Clt (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Clt) None)\n  (cmp_of_comparison Clt None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) x)\n  (cmp_of_comparison Cle\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Eq))\n  (cmp_of_comparison Cle (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Lt))\n  (cmp_of_comparison Cle (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Gt))\n  (cmp_of_comparison Cle (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) None)\n  (cmp_of_comparison Cle None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Eq))\n  (cmp_of_comparison Cle (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Lt))\n  (cmp_of_comparison Cle (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) (Some Gt))\n  (cmp_of_comparison Cle (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cle) None)\n  (cmp_of_comparison Cle None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) x)\n  (cmp_of_comparison Cgt\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Eq))\n  (cmp_of_comparison Cgt (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Lt))\n  (cmp_of_comparison Cgt (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Gt))\n  (cmp_of_comparison Cgt (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) None)\n  (cmp_of_comparison Cgt None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Eq))\n  (cmp_of_comparison Cgt (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Lt))\n  (cmp_of_comparison Cgt (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) (Some Gt))\n  (cmp_of_comparison Cgt (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cgt) None)\n  (cmp_of_comparison Cgt None)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) x)\n  (cmp_of_comparison Cge\n     match x with\n     | Some x => Some (CompOpp x)\n     | None => None\n     end)",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Eq))\n  (cmp_of_comparison Cge (Some (CompOpp Eq)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Lt))\n  (cmp_of_comparison Cge (Some (CompOpp Lt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Gt))\n  (cmp_of_comparison Cge (Some (CompOpp Gt)))",
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) None)\n  (cmp_of_comparison Cge None)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Eq))\n  (cmp_of_comparison Cge (Some (CompOpp Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Lt))\n  (cmp_of_comparison Cge (Some (CompOpp Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) (Some Gt))\n  (cmp_of_comparison Cge (Some (CompOpp Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison Cge) None)\n  (cmp_of_comparison Cge None)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_ne_eq",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : option Datatypes.comparison,\neq (cmp_of_comparison Cne x) (negb (cmp_of_comparison Ceq x))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison Cne x) (negb (cmp_of_comparison Ceq x))",
                    "x : option Datatypes.comparison"
                ]
            },
            {
                "tactic_sig": "destruct _i as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct _i as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cne x) (negb (cmp_of_comparison Ceq x))",
                    "x : option Datatypes.comparison"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison Cne (Some Eq))\n  (negb (cmp_of_comparison Ceq (Some Eq)))",
                    "_goal : eq (cmp_of_comparison Cne (Some Lt))\n  (negb (cmp_of_comparison Ceq (Some Lt)))",
                    "_goal : eq (cmp_of_comparison Cne (Some Gt))\n  (negb (cmp_of_comparison Ceq (Some Gt)))",
                    "_goal : eq (cmp_of_comparison Cne None) (negb (cmp_of_comparison Ceq None))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cne (Some Eq))\n  (negb (cmp_of_comparison Ceq (Some Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cne (Some Lt))\n  (negb (cmp_of_comparison Ceq (Some Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cne (Some Gt))\n  (negb (cmp_of_comparison Ceq (Some Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cne None) (negb (cmp_of_comparison Ceq None))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_lt_eq_false",
        "proof": [
            {
                "tactic_sig": "destruct x as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct x as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : forall (x : option Datatypes.comparison)\n  (_ : eq (cmp_of_comparison Clt x) true)\n  (_ : eq (cmp_of_comparison Ceq x) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Eq)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Lt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Gt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt None) true)\n  (_ : eq (cmp_of_comparison Ceq None) true), False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Eq)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq true true",
                    "H : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Lt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq false true",
                    "H : eq true true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Gt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt None) true)\n  (_ : eq (cmp_of_comparison Ceq None) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_le_lt_eq",
        "proof": [
            {
                "tactic_sig": "destruct x as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct x as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : forall x : option Datatypes.comparison,\neq (cmp_of_comparison Cle x)\n  (orb (cmp_of_comparison Clt x) (cmp_of_comparison Ceq x))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison Cle (Some Eq))\n  (orb (cmp_of_comparison Clt (Some Eq))\n     (cmp_of_comparison Ceq (Some Eq)))",
                    "_goal : eq (cmp_of_comparison Cle (Some Lt))\n  (orb (cmp_of_comparison Clt (Some Lt))\n     (cmp_of_comparison Ceq (Some Lt)))",
                    "_goal : eq (cmp_of_comparison Cle (Some Gt))\n  (orb (cmp_of_comparison Clt (Some Gt))\n     (cmp_of_comparison Ceq (Some Gt)))",
                    "_goal : eq (cmp_of_comparison Cle None)\n  (orb (cmp_of_comparison Clt None) (cmp_of_comparison Ceq None))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cle (Some Eq))\n  (orb (cmp_of_comparison Clt (Some Eq))\n     (cmp_of_comparison Ceq (Some Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cle (Some Lt))\n  (orb (cmp_of_comparison Clt (Some Lt))\n     (cmp_of_comparison Ceq (Some Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cle (Some Gt))\n  (orb (cmp_of_comparison Clt (Some Gt))\n     (cmp_of_comparison Ceq (Some Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cle None)\n  (orb (cmp_of_comparison Clt None) (cmp_of_comparison Ceq None))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_gt_eq_false",
        "proof": [
            {
                "tactic_sig": "destruct x as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct x as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : forall (x : option Datatypes.comparison)\n  (_ : eq (cmp_of_comparison Cgt x) true)\n  (_ : eq (cmp_of_comparison Ceq x) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Eq)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Lt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Gt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt None) true)\n  (_ : eq (cmp_of_comparison Ceq None) true), False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Eq)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq true true",
                    "H : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Lt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Ceq (Some Gt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq false true",
                    "H : eq true true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Cgt None) true)\n  (_ : eq (cmp_of_comparison Ceq None) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_ge_gt_eq",
        "proof": [
            {
                "tactic_sig": "destruct x as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct x as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : forall x : option Datatypes.comparison,\neq (cmp_of_comparison Cge x)\n  (orb (cmp_of_comparison Cgt x) (cmp_of_comparison Ceq x))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison Cge (Some Eq))\n  (orb (cmp_of_comparison Cgt (Some Eq))\n     (cmp_of_comparison Ceq (Some Eq)))",
                    "_goal : eq (cmp_of_comparison Cge (Some Lt))\n  (orb (cmp_of_comparison Cgt (Some Lt))\n     (cmp_of_comparison Ceq (Some Lt)))",
                    "_goal : eq (cmp_of_comparison Cge (Some Gt))\n  (orb (cmp_of_comparison Cgt (Some Gt))\n     (cmp_of_comparison Ceq (Some Gt)))",
                    "_goal : eq (cmp_of_comparison Cge None)\n  (orb (cmp_of_comparison Cgt None) (cmp_of_comparison Ceq None))"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cge (Some Eq))\n  (orb (cmp_of_comparison Cgt (Some Eq))\n     (cmp_of_comparison Ceq (Some Eq)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cge (Some Lt))\n  (orb (cmp_of_comparison Cgt (Some Lt))\n     (cmp_of_comparison Ceq (Some Lt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cge (Some Gt))\n  (orb (cmp_of_comparison Cgt (Some Gt))\n     (cmp_of_comparison Ceq (Some Gt)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison Cge None)\n  (orb (cmp_of_comparison Cgt None) (cmp_of_comparison Ceq None))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_of_comparison_lt_gt_false",
        "proof": [
            {
                "tactic_sig": "destruct x as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct x as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : forall (x : option Datatypes.comparison)\n  (_ : eq (cmp_of_comparison Clt x) true)\n  (_ : eq (cmp_of_comparison Cgt x) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Eq)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Lt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Gt)) true), False",
                    "_goal : forall (_ : eq (cmp_of_comparison Clt None) true)\n  (_ : eq (cmp_of_comparison Cgt None) true), False"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Eq)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Eq)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Lt)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Lt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq true true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq false true",
                    "H : eq true true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt (Some Gt)) true)\n  (_ : eq (cmp_of_comparison Cgt (Some Gt)) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq true true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H0 : eq true true",
                    "H : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp_of_comparison Clt None) true)\n  (_ : eq (cmp_of_comparison Cgt None) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (_ : eq false true) (_ : eq false true), False"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H : eq false true",
                    "H0 : eq false true"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "normalized_nan",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (prec : Z) (n : nat) (p : positive)\n  (_ : eq (Z.of_nat n) (Z.sub prec 1)) (_ : Z.lt 1 prec),\neq (nan_pl prec (Z.to_pos (P_mod_two_p p n))) true"
                ],
                "tactic_res": [
                    "_goal : eq (nan_pl prec (Z.to_pos (P_mod_two_p p n))) true",
                    "H0 : Z.lt 1 prec",
                    "H : eq (Z.of_nat n) (Z.sub prec 1)",
                    "p : positive",
                    "n : nat",
                    "prec : Z"
                ]
            },
            {
                "tactic_sig": "unfold nan_pl .",
                "tactic_sig_no_out_arg": "unfold nan_pl .",
                "tactic_args": [
                    "_goal : eq (nan_pl prec (Z.to_pos (P_mod_two_p p n))) true"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Z.ltb (Zpos (SpecFloat.digits2_pos (Z.to_pos (P_mod_two_p p n))))\n     prec) true"
                ]
            },
            {
                "tactic_sig": "apply Z.ltb_lt .",
                "tactic_sig_no_out_arg": "apply Z.ltb_lt .",
                "tactic_args": [
                    "_goal : eq\n  (Z.ltb (Zpos (SpecFloat.digits2_pos (Z.to_pos (P_mod_two_p p n))))\n     prec) true"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zpos (SpecFloat.digits2_pos (Z.to_pos (P_mod_two_p p n)))) prec"
                ]
            },
            {
                "tactic_sig": "rewrite Digits.Zpos_digits2_pos .",
                "tactic_sig_no_out_arg": "rewrite Digits.Zpos_digits2_pos .",
                "tactic_args": [
                    "_goal : Z.lt (Zpos (SpecFloat.digits2_pos (Z.to_pos (P_mod_two_p p n)))) prec"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos (P_mod_two_p p n)))) prec"
                ]
            },
            {
                "tactic_sig": "set ( p' := P_mod_two_p _i _i ) .",
                "tactic_sig_no_out_arg": "set ( p' := P_mod_two_p _i _i ) .",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos (P_mod_two_p p n)))) prec",
                    "p : positive",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec",
                    "p' : Z"
                ]
            },
            {
                "tactic_sig": "assert ( A : 0 <= _i < 2 ^ Z.of_nat _i ) .",
                "tactic_sig_no_out_arg": "assert ( A : 0 <= _i < 2 ^ Z.of_nat _i ) .",
                "tactic_args": [
                    "p' : Z",
                    "n : nat"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (Z.pow 2 (Z.of_nat n)))",
                    "A : and (Z.le 0 p') (Z.lt p' (Z.pow 2 (Z.of_nat n)))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (Z.pow 2 (Z.of_nat n)))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (Z.pow 2 (Z.of_nat n)))"
                ]
            },
            {
                "tactic_sig": "rewrite <- two_power_nat_equiv .",
                "tactic_sig_no_out_arg": "rewrite <- two_power_nat_equiv .",
                "tactic_args": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (Z.pow 2 (Z.of_nat n)))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (two_power_nat n))"
                ]
            },
            {
                "tactic_sig": "apply P_mod_two_p_range .",
                "tactic_sig_no_out_arg": "apply P_mod_two_p_range .",
                "tactic_args": [
                    "_goal : and (Z.le 0 p') (Z.lt p' (two_power_nat n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec"
                ]
            },
            {
                "tactic_sig": "assert ( B : Digits.Zdigits radix2 _i <= _i - 1 ) .",
                "tactic_sig_no_out_arg": "assert ( B : Digits.Zdigits radix2 _i <= _i - 1 ) .",
                "tactic_args": [
                    "p' : Z",
                    "prec : Z"
                ],
                "tactic_res": [
                    "_goal : Z.le (Zdigits radix2 p') (Z.sub prec 1)",
                    "B : Z.le (Zdigits radix2 p') (Z.sub prec 1)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : Z.le (Zdigits radix2 p') (Z.sub prec 1)"
                ],
                "tactic_res": [
                    "_goal : Z.le (Zdigits radix2 p') (Z.sub prec 1)"
                ]
            },
            {
                "tactic_sig": "apply Digits.Zdigits_le_Zpower .",
                "tactic_sig_no_out_arg": "apply Digits.Zdigits_le_Zpower .",
                "tactic_args": [
                    "_goal : Z.le (Zdigits radix2 p') (Z.sub prec 1)"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Z.abs p') (Z.pow radix2 (Z.sub prec 1))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : Z.lt (Z.abs p') (Z.pow radix2 (Z.sub prec 1))",
                    "H : eq (Z.of_nat n) (Z.sub prec 1)"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Z.abs p') (Z.pow radix2 (Z.of_nat n))"
                ]
            },
            {
                "tactic_sig": "rewrite Z.abs_eq .",
                "tactic_sig_no_out_arg": "rewrite Z.abs_eq .",
                "tactic_args": [
                    "_goal : Z.lt (Z.abs p') (Z.pow radix2 (Z.of_nat n))"
                ],
                "tactic_res": [
                    "_goal : Z.lt p' (Z.pow radix2 (Z.of_nat n))",
                    "_goal : Z.le 0 p'"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : Z.lt p' (Z.pow radix2 (Z.of_nat n))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : Z.le 0 p'"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec"
                ]
            },
            {
                "tactic_sig": "destruct ( zeq _i 0 ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zeq _i 0 ) .",
                "tactic_args": [
                    "p' : Z"
                ],
                "tactic_res": [
                    "e : eq p' 0",
                    "n0 : not (eq p' 0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "e : eq p' 0"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos 0))) prec"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos 0))) prec"
                ],
                "tactic_res": [
                    "_goal : Z.lt 1 prec"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt 1 prec"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Z2Pos.id by lia .",
                "tactic_sig_no_out_arg": "rewrite Z2Pos.id by lia .",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 (Zpos (Z.to_pos p'))) prec"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zdigits radix2 p') prec"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt (Zdigits radix2 p') prec"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "quiet_nan_64_proof",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall p : positive, eq (nan_pl 53 (quiet_nan_64_payload p)) true"
                ],
                "tactic_res": [
                    "_goal : eq (nan_pl 53 (quiet_nan_64_payload p)) true",
                    "p : positive"
                ]
            },
            {
                "tactic_sig": "apply normalized_nan .",
                "tactic_sig_no_out_arg": "apply normalized_nan .",
                "tactic_args": [
                    "_goal : eq (nan_pl 53 (quiet_nan_64_payload p)) true"
                ],
                "tactic_res": [
                    "_goal : eq (Z.of_nat 52%nat) (Z.sub 53 1)",
                    "_goal : Z.lt 1 53"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Z.of_nat 52%nat) (Z.sub 53 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt 1 53"
                ],
                "tactic_res": [
                    "_goal : Z.lt 1 53"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt 1 53"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "quiet_nan_32_proof",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall p : positive, eq (nan_pl 24 (quiet_nan_32_payload p)) true"
                ],
                "tactic_res": [
                    "_goal : eq (nan_pl 24 (quiet_nan_32_payload p)) true",
                    "p : positive"
                ]
            },
            {
                "tactic_sig": "apply normalized_nan .",
                "tactic_sig_no_out_arg": "apply normalized_nan .",
                "tactic_args": [
                    "_goal : eq (nan_pl 24 (quiet_nan_32_payload p)) true"
                ],
                "tactic_res": [
                    "_goal : eq (Z.of_nat 23%nat) (Z.sub 24 1)",
                    "_goal : Z.lt 1 24"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Z.of_nat 23%nat) (Z.sub 24 1)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt 1 24"
                ],
                "tactic_res": [
                    "_goal : Z.lt 1 24"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt 1 24"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "expand_nan_proof",
        "proof": [
            {
                "tactic_sig": "unfold nan_pl , expand_nan_payload .",
                "tactic_sig_no_out_arg": "unfold nan_pl , expand_nan_payload .",
                "tactic_args": [
                    "_goal : forall _ : eq (nan_pl 24 p) true,\neq (nan_pl 53 (expand_nan_payload p)) true"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq (Z.ltb (Zpos (SpecFloat.digits2_pos p)) 24) true,\neq (Z.ltb (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53)\n  true"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros K .",
                "tactic_args": [
                    "_goal : forall _ : eq (Z.ltb (Zpos (SpecFloat.digits2_pos p)) 24) true,\neq (Z.ltb (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53)\n  true"
                ],
                "tactic_res": [
                    "_goal : eq (Z.ltb (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53)\n  true",
                    "K : eq (Z.ltb (Zpos (SpecFloat.digits2_pos p)) 24) true"
                ]
            },
            {
                "tactic_sig": "rewrite Z.ltb_lt in * .",
                "tactic_sig_no_out_arg": "rewrite Z.ltb_lt in * .",
                "tactic_args": [
                    "_goal : eq (Z.ltb (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53)\n  true"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53",
                    "K : Z.lt (Zpos (SpecFloat.digits2_pos p)) 24"
                ]
            },
            {
                "tactic_sig": "unfold Pos.shiftl_nat , nat_rect , Digits.digits2_pos .",
                "tactic_sig_no_out_arg": "unfold Pos.shiftl_nat , nat_rect , Digits.digits2_pos .",
                "tactic_args": [
                    "_goal : Z.lt (Zpos (SpecFloat.digits2_pos (Pos.shiftl_nat p 29%nat))) 53"
                ],
                "tactic_res": [
                    "_goal : Z.lt\n  (Zpos\n     (Pos.succ\n        (Pos.succ\n           (Pos.succ\n              (Pos.succ\n                 (Pos.succ\n                    (Pos.succ\n                       (Pos.succ\n                          (Pos.succ\n                             (Pos.succ\n                                (Pos.succ\n                                   (Pos.succ\n                                      (Pos.succ\n                                         (Pos.succ\n                                            (Pos.succ\n                                               (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 ((fix digits2_pos\n                                                 (n : positive) :\n                                                 positive :=\n                                                 match n with\n                                                 | xI p | xO p =>\n                                                 Pos.succ\n                                                 (digits2_pos p)\n                                                 | 1%positive =>\n                                                 1%positive\n                                                 end) p)))))))))))))))))))))))))))))))\n  53"
                ]
            },
            {
                "tactic_sig": "fold ( Digits.digits2_pos _i ) .",
                "tactic_sig_no_out_arg": "fold ( Digits.digits2_pos _i ) .",
                "tactic_args": [
                    "_goal : Z.lt\n  (Zpos\n     (Pos.succ\n        (Pos.succ\n           (Pos.succ\n              (Pos.succ\n                 (Pos.succ\n                    (Pos.succ\n                       (Pos.succ\n                          (Pos.succ\n                             (Pos.succ\n                                (Pos.succ\n                                   (Pos.succ\n                                      (Pos.succ\n                                         (Pos.succ\n                                            (Pos.succ\n                                               (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 ((fix digits2_pos\n                                                 (n : positive) :\n                                                 positive :=\n                                                 match n with\n                                                 | xI p | xO p =>\n                                                 Pos.succ\n                                                 (digits2_pos p)\n                                                 | 1%positive =>\n                                                 1%positive\n                                                 end) p)))))))))))))))))))))))))))))))\n  53",
                    "p : positive"
                ],
                "tactic_res": [
                    "_goal : Z.lt\n  (Zpos\n     (Pos.succ\n        (Pos.succ\n           (Pos.succ\n              (Pos.succ\n                 (Pos.succ\n                    (Pos.succ\n                       (Pos.succ\n                          (Pos.succ\n                             (Pos.succ\n                                (Pos.succ\n                                   (Pos.succ\n                                      (Pos.succ\n                                         (Pos.succ\n                                            (Pos.succ\n                                               (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (SpecFloat.digits2_pos\n                                                 p)))))))))))))))))))))))))))))))\n  53"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : Z.lt\n  (Zpos\n     (Pos.succ\n        (Pos.succ\n           (Pos.succ\n              (Pos.succ\n                 (Pos.succ\n                    (Pos.succ\n                       (Pos.succ\n                          (Pos.succ\n                             (Pos.succ\n                                (Pos.succ\n                                   (Pos.succ\n                                      (Pos.succ\n                                         (Pos.succ\n                                            (Pos.succ\n                                               (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (Pos.succ\n                                                 (SpecFloat.digits2_pos\n                                                 p)))))))))))))))))))))))))))))))\n  53"
                ],
                "tactic_res": [
                    "_goal : Z.lt\n  (Z.add\n     (Z.add\n        (Z.add\n           (Z.add\n              (Z.add\n                 (Z.add\n                    (Z.add\n                       (Z.add\n                          (Z.add\n                             (Z.add\n                                (Z.add\n                                   (Z.add\n                                      (Z.add\n                                         (Z.add\n                                            (Z.add\n                                               (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Zpos\n                                                 (SpecFloat.digits2_pos\n                                                 p)) 1) 1) 1) 1) 1) 1)\n                                                 1) 1) 1) 1) 1) 1) 1) 1)\n                                               1) 1) 1) 1) 1) 1) 1) 1)\n                       1) 1) 1) 1) 1) 1) 1) 53",
                    "cstr : Z.lt 0 (Zpos (SpecFloat.digits2_pos p))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt\n  (Z.add\n     (Z.add\n        (Z.add\n           (Z.add\n              (Z.add\n                 (Z.add\n                    (Z.add\n                       (Z.add\n                          (Z.add\n                             (Z.add\n                                (Z.add\n                                   (Z.add\n                                      (Z.add\n                                         (Z.add\n                                            (Z.add\n                                               (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Z.add\n                                                 (Zpos\n                                                 (SpecFloat.digits2_pos\n                                                 p)) 1) 1) 1) 1) 1) 1)\n                                                 1) 1) 1) 1) 1) 1) 1) 1)\n                                               1) 1) 1) 1) 1) 1) 1) 1)\n                       1) 1) 1) 1) 1) 1) 1) 53"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_commut",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : binary_float 53 1024)\n  (_ : or (eq (is_nan 53 1024 x) false) (eq (is_nan 53 1024 y) false)),\neq (add x y) (add y x)"
                ],
                "tactic_res": [
                    "_goal : eq (add x y) (add y x)",
                    "H : or (eq (is_nan 53 1024 x) false) (eq (is_nan 53 1024 y) false)",
                    "x : binary_float 53 1024",
                    "y : binary_float 53 1024"
                ]
            },
            {
                "tactic_sig": "apply Bplus_commut .",
                "tactic_sig_no_out_arg": "apply Bplus_commut .",
                "tactic_args": [
                    "_goal : eq (add x y) (add y x)"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan x y) (binop_nan y x)"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [_o _o _o | _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o | _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq (binop_nan x y) (binop_nan y x)",
                    "x : binary_float 53 1024",
                    "y : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_infinity 53 1024 s))",
                    "_goal : eq\n  (binop_nan (B754_infinity 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq\n  (binop_nan (B754_nan 53 1024 s pl e) (B754_finite 53 1024 s0 m e0 e1))\n  (binop_nan (B754_finite 53 1024 s0 m e0 e1) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_finite 53 1024 s m e e0) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_nan 53 1024 s0 pl e1))\n  (binop_nan (B754_nan 53 1024 s0 pl e1) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0)\n     (B754_finite 53 1024 s0 m0 e1 e2))\n  (binop_nan (B754_finite 53 1024 s0 m0 e1 e2)\n     (B754_finite 53 1024 s m e e0))",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "s : bool",
                    "s0 : bool",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e)) false)",
                    "e : eq (nan_pl 53 pl) true",
                    "pl : positive",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e e0)) false)",
                    "e0 : eq (SpecFloat.bounded 53 1024 m e) true",
                    "e : Z",
                    "m : positive",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e e0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl0 e0)) false)",
                    "e0 : eq (nan_pl 53 pl0) true",
                    "pl0 : positive",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e0 e1)) false)",
                    "e1 : eq (SpecFloat.bounded 53 1024 m e0) true",
                    "e0 : Z",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e1)) false)",
                    "e1 : eq (nan_pl 53 pl) true",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m0 e1 e2)) false)",
                    "e2 : eq (SpecFloat.bounded 53 1024 m0 e1) true",
                    "e1 : Z",
                    "m0 : positive"
                ]
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_infinity 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))"
                ]
            },
            {
                "tactic_sig": "now destruct _i .",
                "tactic_sig_no_out_arg": "now destruct _i .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl0 e0)) false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_nan 53 1024 s pl e) (B754_finite 53 1024 s0 m e0 e1))\n  (binop_nan (B754_finite 53 1024 s0 m e0 e1) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_finite 53 1024 s m e e0) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_nan 53 1024 s0 pl e1))\n  (binop_nan (B754_nan 53 1024 s0 pl e1) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0)\n     (B754_finite 53 1024 s0 m0 e1 e2))\n  (binop_nan (B754_finite 53 1024 s0 m0 e1 e2)\n     (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mul_commut",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y : binary_float 53 1024)\n  (_ : or (eq (is_nan 53 1024 x) false) (eq (is_nan 53 1024 y) false)),\neq (mul x y) (mul y x)"
                ],
                "tactic_res": [
                    "_goal : eq (mul x y) (mul y x)",
                    "H : or (eq (is_nan 53 1024 x) false) (eq (is_nan 53 1024 y) false)",
                    "x : binary_float 53 1024",
                    "y : binary_float 53 1024"
                ]
            },
            {
                "tactic_sig": "apply Bmult_commut .",
                "tactic_sig_no_out_arg": "apply Bmult_commut .",
                "tactic_args": [
                    "_goal : eq (mul x y) (mul y x)"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan x y) (binop_nan y x)"
                ]
            },
            {
                "tactic_sig": "destruct _i , _i as [_o _o _o | _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o | _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq (binop_nan x y) (binop_nan y x)",
                    "x : binary_float 53 1024",
                    "y : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_zero 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_infinity 53 1024 s))",
                    "_goal : eq\n  (binop_nan (B754_infinity 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_infinity 53 1024 s))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))",
                    "_goal : eq\n  (binop_nan (B754_nan 53 1024 s pl e) (B754_finite 53 1024 s0 m e0 e1))\n  (binop_nan (B754_finite 53 1024 s0 m e0 e1) (B754_nan 53 1024 s pl e))",
                    "_goal : eq (binop_nan (B754_finite 53 1024 s m e e0) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_nan 53 1024 s0 pl e1))\n  (binop_nan (B754_nan 53 1024 s0 pl e1) (B754_finite 53 1024 s m e e0))",
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0)\n     (B754_finite 53 1024 s0 m0 e1 e2))\n  (binop_nan (B754_finite 53 1024 s0 m0 e1 e2)\n     (B754_finite 53 1024 s m e e0))",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "s : bool",
                    "s0 : bool",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e)) false)",
                    "e : eq (nan_pl 53 pl) true",
                    "pl : positive",
                    "H : or (eq (is_nan 53 1024 (B754_zero 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e e0)) false)",
                    "e0 : eq (SpecFloat.bounded 53 1024 m e) true",
                    "e : Z",
                    "m : positive",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_infinity 53 1024 s)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e e0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl0 e0)) false)",
                    "e0 : eq (nan_pl 53 pl0) true",
                    "pl0 : positive",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m e0 e1)) false)",
                    "e1 : eq (SpecFloat.bounded 53 1024 m e0) true",
                    "e0 : Z",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_zero 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_infinity 53 1024 s0)) false)",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl e1)) false)",
                    "e1 : eq (nan_pl 53 pl) true",
                    "H : or (eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) false)\n  (eq (is_nan 53 1024 (B754_finite 53 1024 s0 m0 e1 e2)) false)",
                    "e2 : eq (SpecFloat.bounded 53 1024 m0 e1) true",
                    "e1 : Z",
                    "m0 : positive"
                ]
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_zero 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_zero 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_infinity 53 1024 s) (B754_nan 53 1024 s0 pl e))\n  (binop_nan (B754_nan 53 1024 s0 pl e) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_infinity 53 1024 s) (B754_finite 53 1024 s0 m e e0))\n  (binop_nan (B754_finite 53 1024 s0 m e e0) (B754_infinity 53 1024 s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))"
                ]
            },
            {
                "tactic_sig": "now destruct _i .",
                "tactic_sig_no_out_arg": "now destruct _i .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_nan 53 1024 s pl e) (B754_nan 53 1024 s0 pl0 e0))\n  (binop_nan (B754_nan 53 1024 s0 pl0 e0) (B754_nan 53 1024 s pl e))",
                    "H : or (eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) false)\n  (eq (is_nan 53 1024 (B754_nan 53 1024 s0 pl0 e0)) false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_nan 53 1024 s pl e) (B754_finite 53 1024 s0 m e0 e1))\n  (binop_nan (B754_finite 53 1024 s0 m e0 e1) (B754_nan 53 1024 s pl e))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq (binop_nan (B754_finite 53 1024 s m e e0) (B754_zero 53 1024 s0))\n  (binop_nan (B754_zero 53 1024 s0) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_infinity 53 1024 s0))\n  (binop_nan (B754_infinity 53 1024 s0) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0) (B754_nan 53 1024 s0 pl e1))\n  (binop_nan (B754_nan 53 1024 s0 pl e1) (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try reflexivity .",
                "tactic_sig_no_out_arg": "try reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (binop_nan (B754_finite 53 1024 s m e e0)\n     (B754_finite 53 1024 s0 m0 e1 e2))\n  (binop_nan (B754_finite 53 1024 s0 m0 e1 e2)\n     (B754_finite 53 1024 s m e e0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mul2_add",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall f : float, eq (add f f) (mul f (of_int (Int.repr 2)))"
                ],
                "tactic_res": [
                    "_goal : eq (add f f) (mul f (of_int (Int.repr 2)))",
                    "f : float"
                ]
            },
            {
                "tactic_sig": "apply Bmult2_Bplus .",
                "tactic_sig_no_out_arg": "apply Bmult2_Bplus .",
                "tactic_args": [
                    "_goal : eq (add f f) (mul f (of_int (Int.repr 2)))"
                ],
                "tactic_res": [
                    "_goal : forall (x y : binary_float 53 1024) (_ : eq (is_nan 53 1024 x) true)\n  (_ : eq (is_finite 53 1024 y) true),\neq (binop_nan x x) (binop_nan x y)"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x y Hx Hy .",
                "tactic_args": [
                    "_goal : forall (x y : binary_float 53 1024) (_ : eq (is_nan 53 1024 x) true)\n  (_ : eq (is_finite 53 1024 y) true),\neq (binop_nan x x) (binop_nan x y)"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan x x) (binop_nan x y)",
                    "Hy : eq (is_finite 53 1024 y) true",
                    "Hx : eq (is_nan 53 1024 x) true",
                    "x : binary_float 53 1024",
                    "y : binary_float 53 1024"
                ]
            },
            {
                "tactic_sig": "unfold binop_nan .",
                "tactic_sig_no_out_arg": "unfold binop_nan .",
                "tactic_args": [
                    "_goal : eq (binop_nan x x) (binop_nan x y)"
                ],
                "tactic_res": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x (cons_pl x nil))))\n  (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x (cons_pl y nil))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x (cons_pl x nil))))\n  (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x (cons_pl y nil))))",
                    "x : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s)\n           (cons_pl (B754_zero 53 1024 s) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl y nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s)\n           (cons_pl (B754_infinity 53 1024 s) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl y nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s pl e) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0)\n           (cons_pl (B754_finite 53 1024 s m e e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl y nil))))",
                    "Hx : eq (is_nan 53 1024 (B754_zero 53 1024 s)) true",
                    "s : bool",
                    "Hx : eq (is_nan 53 1024 (B754_infinity 53 1024 s)) true",
                    "Hx : eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) true",
                    "e : eq (nan_pl 53 pl) true",
                    "pl : positive",
                    "Hx : eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) true",
                    "e0 : eq (SpecFloat.bounded 53 1024 m e) true",
                    "e : Z",
                    "m : positive"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s)\n           (cons_pl (B754_zero 53 1024 s) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl y nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s)\n           (cons_pl (B754_infinity 53 1024 s) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl y nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s pl e) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y nil))))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s pl e) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y nil))))"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0)\n           (cons_pl (B754_finite 53 1024 s m e e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl y nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s pl e) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y nil))))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons (pair s pl) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons_pl y nil))))"
                ]
            },
            {
                "tactic_sig": "rewrite Archi.choose_nan_64_idem .",
                "tactic_sig_no_out_arg": "rewrite Archi.choose_nan_64_idem .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons (pair s pl) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons_pl y nil))))"
                ],
                "tactic_res": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons_pl y nil))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64 (cons (pair s pl) (cons_pl y nil))))",
                    "y : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_zero 53 1024 s0) nil))))",
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_infinity 53 1024 s0) nil))))",
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))",
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))",
                    "Hy : eq (is_finite 53 1024 (B754_zero 53 1024 s0)) true",
                    "s0 : bool",
                    "Hy : eq (is_finite 53 1024 (B754_infinity 53 1024 s0)) true",
                    "Hy : eq (is_finite 53 1024 (B754_nan 53 1024 s0 pl0 e0)) true",
                    "e0 : eq (nan_pl 53 pl0) true",
                    "pl0 : positive",
                    "Hy : eq (is_finite 53 1024 (B754_finite 53 1024 s0 m e0 e1)) true",
                    "e1 : eq (SpecFloat.bounded 53 1024 m e0) true",
                    "e0 : Z",
                    "m : positive"
                ]
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_zero 53 1024 s0) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_infinity 53 1024 s0) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl) (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons (pair s pl) nil)))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons (pair s pl)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "div_mul_inverse",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x y z : float) (_ : eq (exact_inverse y) (Some z)),\neq (div x y) (mul x z)"
                ],
                "tactic_res": [
                    "_goal : eq (div x y) (mul x z)",
                    "H : eq (exact_inverse y) (Some z)",
                    "x : float",
                    "y : float",
                    "z : float"
                ]
            },
            {
                "tactic_sig": "apply Bdiv_mult_inverse .",
                "tactic_sig_no_out_arg": "apply Bdiv_mult_inverse .",
                "tactic_args": [
                    "_goal : eq (div x y) (mul x z)"
                ],
                "tactic_res": [
                    "_goal : forall (x y z : binary_float 53 1024) (_ : eq (is_nan 53 1024 x) true)\n  (_ : eq (is_finite 53 1024 y) true)\n  (_ : eq (is_finite 53 1024 z) true),\neq (binop_nan x y) (binop_nan x z)",
                    "_goal : eq (Bexact_inverse 53 1024 eq_refl eq_refl y) (Some z)"
                ]
            },
            {
                "tactic_sig": "easy .",
                "tactic_sig_no_out_arg": "easy .",
                "tactic_args": [
                    "_goal : eq (Bexact_inverse 53 1024 eq_refl eq_refl y) (Some z)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros x0 y0 z0 Hx Hy Hz .",
                "tactic_args": [
                    "_goal : forall (x y z : binary_float 53 1024) (_ : eq (is_nan 53 1024 x) true)\n  (_ : eq (is_finite 53 1024 y) true)\n  (_ : eq (is_finite 53 1024 z) true),\neq (binop_nan x y) (binop_nan x z)"
                ],
                "tactic_res": [
                    "_goal : eq (binop_nan x0 y0) (binop_nan x0 z0)",
                    "Hz : eq (is_finite 53 1024 z0) true",
                    "Hy : eq (is_finite 53 1024 y0) true",
                    "Hx : eq (is_nan 53 1024 x0) true",
                    "x0 : binary_float 53 1024",
                    "y0 : binary_float 53 1024",
                    "z0 : binary_float 53 1024"
                ]
            },
            {
                "tactic_sig": "unfold binop_nan .",
                "tactic_sig_no_out_arg": "unfold binop_nan .",
                "tactic_args": [
                    "_goal : eq (binop_nan x0 y0) (binop_nan x0 z0)"
                ],
                "tactic_res": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x0 (cons_pl y0 nil))))\n  (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x0 (cons_pl z0 nil))))"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o | _o _o | _o _o _o _o | _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "_goal : eq (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x0 (cons_pl y0 nil))))\n  (quiet_nan_64 (Archi.choose_nan_64 (cons_pl x0 (cons_pl z0 nil))))",
                    "x0 : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl z0 nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl z0 nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl z0 nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl z0 nil))))",
                    "Hx : eq (is_nan 53 1024 (B754_zero 53 1024 s)) true",
                    "s : bool",
                    "Hx : eq (is_nan 53 1024 (B754_infinity 53 1024 s)) true",
                    "Hx : eq (is_nan 53 1024 (B754_nan 53 1024 s pl e)) true",
                    "e : eq (nan_pl 53 pl) true",
                    "pl : positive",
                    "Hx : eq (is_nan 53 1024 (B754_finite 53 1024 s m e e0)) true",
                    "e0 : eq (SpecFloat.bounded 53 1024 m e) true",
                    "e : Z",
                    "m : positive"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_zero 53 1024 s) (cons_pl z0 nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_infinity 53 1024 s) (cons_pl z0 nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl z0 nil))))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl z0 nil))))"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_finite 53 1024 s m e e0) (cons_pl z0 nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct _i , _i as [_o _o _o _o | _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o | _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o | _o _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o _o | _o _o _o _o _o _o _o _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i , _i .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl y0 nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e) (cons_pl z0 nil))))",
                    "y0 : binary_float 53 1024",
                    "z0 : binary_float 53 1024"
                ],
                "tactic_res": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e0) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e0 e1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e0) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e0 e1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl1 e1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e1 e2) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e2) nil))))",
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m0 e2 e3) nil))))",
                    "Hz : eq (is_finite 53 1024 (B754_zero 53 1024 s1)) true",
                    "Hy : eq (is_finite 53 1024 (B754_zero 53 1024 s0)) true",
                    "s0 : bool",
                    "s1 : bool",
                    "Hz : eq (is_finite 53 1024 (B754_infinity 53 1024 s1)) true",
                    "Hz : eq (is_finite 53 1024 (B754_nan 53 1024 s1 pl0 e0)) true",
                    "e0 : eq (nan_pl 53 pl0) true",
                    "pl0 : positive",
                    "Hz : eq (is_finite 53 1024 (B754_finite 53 1024 s1 m e0 e1)) true",
                    "e1 : eq (SpecFloat.bounded 53 1024 m e0) true",
                    "e0 : Z",
                    "m : positive",
                    "Hy : eq (is_finite 53 1024 (B754_infinity 53 1024 s0)) true",
                    "Hy : eq (is_finite 53 1024 (B754_nan 53 1024 s0 pl0 e0)) true",
                    "Hz : eq (is_finite 53 1024 (B754_nan 53 1024 s1 pl1 e1)) true",
                    "e1 : eq (nan_pl 53 pl1) true",
                    "pl1 : positive",
                    "Hz : eq (is_finite 53 1024 (B754_finite 53 1024 s1 m e1 e2)) true",
                    "e2 : eq (SpecFloat.bounded 53 1024 m e1) true",
                    "e1 : Z",
                    "Hy : eq (is_finite 53 1024 (B754_finite 53 1024 s0 m e0 e1)) true",
                    "Hz : eq (is_finite 53 1024 (B754_nan 53 1024 s1 pl0 e2)) true",
                    "e2 : eq (nan_pl 53 pl0) true",
                    "Hz : eq (is_finite 53 1024 (B754_finite 53 1024 s1 m0 e2 e3)) true",
                    "e3 : eq (SpecFloat.bounded 53 1024 m0 e2) true",
                    "e2 : Z",
                    "m0 : positive"
                ]
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e0) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e0 e1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e0) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e0 e1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl1 e1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s0 pl0 e0) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m e1 e2) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_zero 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_infinity 53 1024 s1) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_nan 53 1024 s1 pl0 e2) nil))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "reflexivity || discriminate .",
                "tactic_sig_no_out_arg": "reflexivity || discriminate .",
                "tactic_args": [
                    "_goal : eq\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s0 m e0 e1) nil))))\n  (quiet_nan_64\n     (Archi.choose_nan_64\n        (cons_pl (B754_nan 53 1024 s pl e)\n           (cons_pl (B754_finite 53 1024 s1 m0 e2 e3) nil))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_swap",
        "proof": [
            {
                "tactic_sig": "unfold cmp , compare .",
                "tactic_sig_no_out_arg": "unfold cmp , compare .",
                "tactic_args": [
                    "_goal : forall (c : comparison) (x y : float),\neq (cmp (swap_comparison c) x y) (cmp c y x)"
                ],
                "tactic_res": [
                    "_goal : forall (c : comparison) (x y : float),\neq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c (Bcompare 53 1024 y x))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (c : comparison) (x y : float),\neq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c (Bcompare 53 1024 y x))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c (Bcompare 53 1024 y x))",
                    "x : float",
                    "y : float",
                    "c : comparison"
                ]
            },
            {
                "tactic_sig": "rewrite ( Bcompare_swap _ _ _i _i ) .",
                "tactic_sig_no_out_arg": "rewrite ( Bcompare_swap _ _ _i _i ) .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c (Bcompare 53 1024 y x))",
                    "x : float",
                    "y : float"
                ],
                "tactic_res": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c\n     match Bcompare 53 1024 x y with\n     | Some c => Some (CompOpp c)\n     | None => None\n     end)"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_swap .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_swap .",
                "tactic_args": [
                    "_goal : eq (cmp_of_comparison (swap_comparison c) (Bcompare 53 1024 x y))\n  (cmp_of_comparison c\n     match Bcompare 53 1024 x y with\n     | Some c => Some (CompOpp c)\n     | None => None\n     end)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_ne_eq",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall f1 f2 : float, eq (cmp Cne f1 f2) (negb (cmp Ceq f1 f2))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp Cne f1 f2) (negb (cmp Ceq f1 f2))",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_ne_eq .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_ne_eq .",
                "tactic_args": [
                    "_goal : eq (cmp Cne f1 f2) (negb (cmp Ceq f1 f2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_lt_eq_false",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros f1 f2 .",
                "tactic_args": [
                    "_goal : forall (f1 f2 : float) (_ : eq (cmp Clt f1 f2) true)\n  (_ : eq (cmp Ceq f1 f2) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp Clt f1 f2) true) (_ : eq (cmp Ceq f1 f2) true),\nFalse",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_lt_eq_false .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_lt_eq_false .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp Clt f1 f2) true) (_ : eq (cmp Ceq f1 f2) true),\nFalse"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_le_lt_eq",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros f1 f2 .",
                "tactic_args": [
                    "_goal : forall f1 f2 : float,\neq (cmp Cle f1 f2) (orb (cmp Clt f1 f2) (cmp Ceq f1 f2))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp Cle f1 f2) (orb (cmp Clt f1 f2) (cmp Ceq f1 f2))",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_le_lt_eq .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_le_lt_eq .",
                "tactic_args": [
                    "_goal : eq (cmp Cle f1 f2) (orb (cmp Clt f1 f2) (cmp Ceq f1 f2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_gt_eq_false",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros f1 f2 .",
                "tactic_args": [
                    "_goal : forall (x y : float) (_ : eq (cmp Cgt x y) true)\n  (_ : eq (cmp Ceq x y) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp Cgt f1 f2) true) (_ : eq (cmp Ceq f1 f2) true),\nFalse",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_gt_eq_false .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_gt_eq_false .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp Cgt f1 f2) true) (_ : eq (cmp Ceq f1 f2) true),\nFalse"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_ge_gt_eq",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros f1 f2 .",
                "tactic_args": [
                    "_goal : forall f1 f2 : float,\neq (cmp Cge f1 f2) (orb (cmp Cgt f1 f2) (cmp Ceq f1 f2))"
                ],
                "tactic_res": [
                    "_goal : eq (cmp Cge f1 f2) (orb (cmp Cgt f1 f2) (cmp Ceq f1 f2))",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_ge_gt_eq .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_ge_gt_eq .",
                "tactic_args": [
                    "_goal : eq (cmp Cge f1 f2) (orb (cmp Cgt f1 f2) (cmp Ceq f1 f2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "cmp_lt_gt_false",
        "proof": [
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros f1 f2 .",
                "tactic_args": [
                    "_goal : forall (f1 f2 : float) (_ : eq (cmp Clt f1 f2) true)\n  (_ : eq (cmp Cgt f1 f2) true), False"
                ],
                "tactic_res": [
                    "_goal : forall (_ : eq (cmp Clt f1 f2) true) (_ : eq (cmp Cgt f1 f2) true),\nFalse",
                    "f1 : float",
                    "f2 : float"
                ]
            },
            {
                "tactic_sig": "apply cmp_of_comparison_lt_gt_false .",
                "tactic_sig_no_out_arg": "apply cmp_of_comparison_lt_gt_false .",
                "tactic_args": [
                    "_goal : forall (_ : eq (cmp Clt f1 f2) true) (_ : eq (cmp Cgt f1 f2) true),\nFalse"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "of_to_bits",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall f : float, eq (of_bits (to_bits f)) f"
                ],
                "tactic_res": [
                    "_goal : eq (of_bits (to_bits f)) f",
                    "f : float"
                ]
            },
            {
                "tactic_sig": "unfold of_bits , to_bits , bits_of_b64 , b64_of_bits .",
                "tactic_sig_no_out_arg": "unfold of_bits , to_bits , bits_of_b64 , b64_of_bits .",
                "tactic_args": [
                    "_goal : eq (of_bits (to_bits f)) f"
                ],
                "tactic_res": [
                    "_goal : eq\n  (binary_float_of_bits 52 11 eq_refl eq_refl eq_refl\n     (Int64.unsigned (Int64.repr (bits_of_binary_float 52 11 f)))) f"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.unsigned_repr , binary_float_of_bits_of_binary_float;[ reflexivity| ] .",
                "tactic_sig_no_out_arg": "rewrite Int64.unsigned_repr , binary_float_of_bits_of_binary_float;[ reflexivity| ] .",
                "tactic_args": [
                    "_goal : eq\n  (binary_float_of_bits 52 11 eq_refl eq_refl eq_refl\n     (Int64.unsigned (Int64.repr (bits_of_binary_float 52 11 f)))) f"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "generalize ( bits_of_binary_float_range 52 11 __ __ _i ) .",
                "tactic_sig_no_out_arg": "generalize ( bits_of_binary_float_range 52 11 __ __ _i ) .",
                "tactic_args": [
                    "_goal : and (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)",
                    "f : float"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 (bits_of_binary_float 52 11 f))\n        (Z.lt (bits_of_binary_float 52 11 f)\n           (Z.pow 2 (Z.add (Z.add 52 11) 1))),\nand (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "change ( 2 ^ ( 52 + 11 + 1 ) ) with ( Int64.max_unsigned + 1 ) .",
                "tactic_sig_no_out_arg": "change ( 2 ^ ( 52 + 11 + 1 ) ) with ( Int64.max_unsigned + 1 ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 (bits_of_binary_float 52 11 f))\n        (Z.lt (bits_of_binary_float 52 11 f)\n           (Z.pow 2 (Z.add (Z.add 52 11) 1))),\nand (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 (bits_of_binary_float 52 11 f))\n        (Z.lt (bits_of_binary_float 52 11 f)\n           (Z.add Int64.max_unsigned 1)),\nand (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 (bits_of_binary_float 52 11 f))\n        (Z.lt (bits_of_binary_float 52 11 f)\n           (Z.add Int64.max_unsigned 1)),\nand (Z.le 0 (bits_of_binary_float 52 11 f))\n  (Z.le (bits_of_binary_float 52 11 f) Int64.max_unsigned)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "to_of_bits",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall b : Int64.int, eq (to_bits (of_bits b)) b"
                ],
                "tactic_res": [
                    "_goal : eq (to_bits (of_bits b)) b",
                    "b : Int64.int"
                ]
            },
            {
                "tactic_sig": "unfold of_bits , to_bits , bits_of_b64 , b64_of_bits .",
                "tactic_sig_no_out_arg": "unfold of_bits , to_bits , bits_of_b64 , b64_of_bits .",
                "tactic_args": [
                    "_goal : eq (to_bits (of_bits b)) b"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Int64.repr\n     (bits_of_binary_float 52 11\n        (binary_float_of_bits 52 11 eq_refl eq_refl eq_refl\n           (Int64.unsigned b)))) b"
                ]
            },
            {
                "tactic_sig": "rewrite bits_of_binary_float_of_bits .",
                "tactic_sig_no_out_arg": "rewrite bits_of_binary_float_of_bits .",
                "tactic_args": [
                    "_goal : eq\n  (Int64.repr\n     (bits_of_binary_float 52 11\n        (binary_float_of_bits 52 11 eq_refl eq_refl eq_refl\n           (Int64.unsigned b)))) b"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.repr (Int64.unsigned b)) b",
                    "_goal : and (Z.le 0 (Int64.unsigned b))\n  (Z.lt (Int64.unsigned b) (Z.pow 2 (Z.add (Z.add 52 11) 1)))"
                ]
            },
            {
                "tactic_sig": "apply Int64.repr_unsigned .",
                "tactic_sig_no_out_arg": "apply Int64.repr_unsigned .",
                "tactic_args": [
                    "_goal : eq (Int64.repr (Int64.unsigned b)) b"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply Int64.unsigned_range .",
                "tactic_sig_no_out_arg": "apply Int64.unsigned_range .",
                "tactic_args": [
                    "_goal : and (Z.le 0 (Int64.unsigned b))\n  (Z.lt (Int64.unsigned b) (Z.pow 2 (Z.add (Z.add 52 11) 1)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "of_intu_of_int_1",
        "proof": [
            {
                "tactic_sig": "unfold of_intu , of_int , Int.signed , Int.ltu .",
                "tactic_sig_no_out_arg": "unfold of_intu , of_int , Int.signed , Int.ltu .",
                "tactic_args": [
                    "_goal : forall (x : Int.int) (_ : eq (Int.ltu x ox8000_0000) true),\neq (of_intu x) (of_int x)"
                ],
                "tactic_res": [
                    "_goal : forall (x : Int.int)\n  (_ : eq\n         (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n          then true\n          else false) true),\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))"
                ]
            },
            {
                "tactic_sig": "intro _o .",
                "tactic_sig_no_out_arg": "intro .",
                "tactic_args": [
                    "_goal : forall (x : Int.int)\n  (_ : eq\n         (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n          then true\n          else false) true),\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n         then true\n         else false) true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "change ( Int.unsigned ox8000_0000 ) with Int.half_modulus .",
                "tactic_sig_no_out_arg": "change ( Int.unsigned ox8000_0000 ) with Int.half_modulus .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n         then true\n         else false) true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : eq\n        (if zlt (Int.unsigned x) Int.half_modulus then true else false)\n        true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt ( Int.unsigned _i ) Int.half_modulus ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt ( Int.unsigned _i ) Int.half_modulus ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : eq\n        (if zlt (Int.unsigned x) Int.half_modulus then true else false)\n        true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (if zlt (Int.unsigned x) Int.half_modulus\n      then Int.unsigned x\n      else Z.sub (Int.unsigned x) Int.modulus))",
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall _ : eq true true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))",
                    "_goal : forall _ : eq false true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl (Z.sub (Int.unsigned x) Int.modulus))",
                    "l : Z.lt (Int.unsigned x) Int.half_modulus",
                    "g : Z.ge (Int.unsigned x) Int.half_modulus"
                ]
            },
            {
                "tactic_sig": "now intuition .",
                "tactic_sig_no_out_arg": "now intuition .",
                "tactic_args": [
                    "_goal : forall _ : eq true true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "now intuition .",
                "tactic_sig_no_out_arg": "now intuition .",
                "tactic_args": [
                    "_goal : forall _ : eq false true,\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl (Z.sub (Int.unsigned x) Int.modulus))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "of_intu_of_int_2",
        "proof": [
            {
                "tactic_sig": "unfold add , of_intu , of_int .",
                "tactic_sig_no_out_arg": "unfold add , of_intu , of_int .",
                "tactic_args": [
                    "_goal : forall (x : Int.int) (_ : eq (Int.ltu x ox8000_0000) false),\neq (of_intu x)\n  (add (of_int (Int.sub x ox8000_0000)) (of_intu ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : forall (x : Int.int) (_ : eq (Int.ltu x ox8000_0000) false),\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed (Int.sub x ox8000_0000)))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Int.int) (_ : eq (Int.ltu x ox8000_0000) false),\neq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed (Int.sub x ox8000_0000)))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed (Int.sub x ox8000_0000)))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))",
                    "H : eq (Int.ltu x ox8000_0000) false",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "set ( y := Int.sub _i ox8000_0000 ) .",
                "tactic_sig_no_out_arg": "set ( y := Int.sub _i ox8000_0000 ) .",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed (Int.sub x ox8000_0000)))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))",
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))",
                    "y : Int.int"
                ]
            },
            {
                "tactic_sig": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "H0 : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "pose proof ( Int.signed_range _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( Int.signed_range _i ) .",
                "tactic_args": [
                    "y : Int.int"
                ],
                "tactic_res": [
                    "H1 : and (Z.le Int.min_signed (Int.signed y))\n  (Z.le (Int.signed y) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "assert ( Ry : integer_representable 53 1024 ( Int.signed _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( Ry : integer_representable 53 1024 ( Int.signed _i ) ) .",
                "tactic_args": [
                    "y : Int.int"
                ],
                "tactic_res": [
                    "_goal : integer_representable 53 1024 (Int.signed y)",
                    "Ry : integer_representable 53 1024 (Int.signed y)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : integer_representable 53 1024 (Int.signed y)"
                ],
                "tactic_res": [
                    "_goal : integer_representable 53 1024 (Int.signed y)"
                ]
            },
            {
                "tactic_sig": "apply integer_representable_n .",
                "tactic_sig_no_out_arg": "apply integer_representable_n .",
                "tactic_args": [
                    "_goal : integer_representable 53 1024 (Int.signed y)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (Z.le (-2147483648) (Int.signed y))\n  (Z.le (Int.signed y) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : and (Z.le (-2147483648) (Int.signed y))\n  (Z.le (Int.signed y) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow_pos 2 53%positive)) (Int.signed y))\n  (Z.le (Int.signed y) (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp 9007199254740992) (Int.signed y))\n  (Z.le (Int.signed y) 9007199254740992)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "assert ( R8 : integer_representable 53 1024 ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_sig_no_out_arg": "assert ( R8 : integer_representable 53 1024 ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : integer_representable 53 1024 (Int.unsigned ox8000_0000)",
                    "R8 : integer_representable 53 1024 (Int.unsigned ox8000_0000)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : integer_representable 53 1024 (Int.unsigned ox8000_0000)"
                ],
                "tactic_res": [
                    "_goal : integer_representable 53 1024 (Int.unsigned ox8000_0000)"
                ]
            },
            {
                "tactic_sig": "apply integer_representable_2p with ( p := 31 ) .",
                "tactic_sig_no_out_arg": "apply integer_representable_2p with ( p := 31 ) .",
                "tactic_args": [
                    "_goal : integer_representable 53 1024 (Int.unsigned ox8000_0000)"
                ],
                "tactic_res": [
                    "_goal : Prec_gt_0 53",
                    "_goal : Prec_lt_emax 53 1024",
                    "_goal : and (Z.le 0 31) (Z.le 31 (Z.sub 1024 1))"
                ]
            },
            {
                "tactic_sig": "easy .",
                "tactic_sig_no_out_arg": "easy .",
                "tactic_args": [
                    "_goal : Prec_gt_0 53"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "easy .",
                "tactic_sig_no_out_arg": "easy .",
                "tactic_args": [
                    "_goal : Prec_lt_emax 53 1024"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "easy .",
                "tactic_sig_no_out_arg": "easy .",
                "tactic_args": [
                    "_goal : and (Z.le 0 31) (Z.le 31 (Z.sub 1024 1))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "rewrite BofZ_plus by auto .",
                "tactic_sig_no_out_arg": "rewrite BofZ_plus by auto .",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (Bplus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl (Int.signed y))\n     (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.add (Int.signed y) (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.add (Int.signed y) (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x) (Z.add (Int.signed y) (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "unfold Int.ltu in _i .",
                "tactic_sig_no_out_arg": "unfold Int.ltu in _i .",
                "tactic_args": [
                    "H : eq (Int.ltu x ox8000_0000) false"
                ],
                "tactic_res": [
                    "H : eq\n  (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n   then true\n   else false) false"
                ]
            },
            {
                "tactic_sig": "destruct zlt in _i as [_o _o | _o _o ] .",
                "tactic_sig_no_out_arg": "destruct zlt in _i .",
                "tactic_args": [
                    "H : eq\n  (if zlt (Int.unsigned x) (Int.unsigned ox8000_0000)\n   then true\n   else false) false"
                ],
                "tactic_res": [
                    "H : eq true false",
                    "l : Z.lt (Int.unsigned x) (Int.unsigned ox8000_0000)",
                    "H : eq false false",
                    "g : Z.ge (Int.unsigned x) (Int.unsigned ox8000_0000)"
                ]
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "try discriminate .",
                "tactic_sig_no_out_arg": "try discriminate .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x) (Z.add (Int.signed y) (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x) (Z.add (Int.signed y) (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "unfold _i , Int.sub .",
                "tactic_sig_no_out_arg": "unfold _i , Int.sub .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x) (Z.add (Int.signed y) (Int.unsigned ox8000_0000))",
                    "y : Int.int"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x)\n  (Z.add\n     (Int.signed\n        (Int.repr (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))))\n     (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.signed_repr .",
                "tactic_sig_no_out_arg": "rewrite Int.signed_repr .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x)\n  (Z.add\n     (Int.signed\n        (Int.repr (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))))\n     (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x)\n  (Z.add (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))\n     (Int.unsigned ox8000_0000))",
                    "_goal : and\n  (Z.le Int.min_signed\n     (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000)))\n  (Z.le (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))\n     Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x)\n  (Z.add (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))\n     (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "compute_this ( Int.unsigned ox8000_0000 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Int.unsigned ox8000_0000 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le Int.min_signed\n     (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000)))\n  (Z.le (Z.sub (Int.unsigned x) (Int.unsigned ox8000_0000))\n     Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)",
                    "R8 : integer_representable 53 1024 2147483648",
                    "g : Z.ge (Int.unsigned x) 2147483648"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [],
                "tactic_res": [
                    "H0 : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [
                    "_goal : and (Z.le Int.min_signed (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)",
                    "H1 : and (Z.le (-2147483648) (Int.signed y))\n  (Z.le (Int.signed y) Int.max_signed)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) Int.max_signed)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)",
                    "H1 : and (Z.le (-2147483648) (Int.signed y))\n  (Z.le (Int.signed y) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and (Z.le (-2147483648) (Z.sub (Int.unsigned x) 2147483648))\n  (Z.le (Z.sub (Int.unsigned x) 2147483648) 2147483647)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "to_intu_to_int_1",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : float) (n : Int.int)\n  (_ : eq (cmp Clt x (of_intu ox8000_0000)) true)\n  (_ : eq (to_intu x) (Some n)), eq (to_int x) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (to_int x) (Some n)",
                    "H0 : eq (to_intu x) (Some n)",
                    "H : eq (cmp Clt x (of_intu ox8000_0000)) true",
                    "n : Int.int",
                    "x : float"
                ]
            },
            {
                "tactic_sig": "unfold to_intu in _i .",
                "tactic_sig_no_out_arg": "unfold to_intu in _i .",
                "tactic_args": [
                    "H0 : eq (to_intu x) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Int.repr (ZofB_range 53 1024 x 0 Int.max_unsigned))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "destruct ( ZofB_range 53 1024 _i 0 Int.max_unsigned ) as [ p| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ZofB_range 53 1024 _i 0 Int.max_unsigned ) as [ p| ] eqn : E .",
                "tactic_args": [
                    "x : float"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Int.repr (Some p)) (Some n)",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) (Some p)",
                    "p : Z",
                    "H0 : eq (option_map Int.repr None) (Some n)",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (option_map Int.repr (Some p)) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Int.repr p)) (Some n)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq (Some (Int.repr p)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (to_int x) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (option_map Int.repr None) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some n)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (to_int x) (Some n)",
                    "H0 : eq None (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ZofB_range_inversion .",
                "tactic_sig_no_out_arg": "exploit ZofB_range_inversion .",
                "tactic_args": [
                    "_goal : eq (to_int x) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : eq (ZofB_range ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3) (Some ?Goal4)",
                    "_goal : forall\n  _ : and (Z.le ?Goal2 ?Goal4)\n        (and (Z.le ?Goal4 ?Goal3)\n           (eq (ZofB ?Goal ?Goal0 ?Goal1) (Some ?Goal4))),\neq (to_int x) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (ZofB_range ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3) (Some ?Goal4)",
                    "_goal : forall\n  _ : and (Z.le ?Goal2 ?Goal4)\n        (and (Z.le ?Goal4 ?Goal3)\n           (eq (ZofB ?Goal ?Goal0 ?Goal1) (Some ?Goal4))),\neq (to_int x) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int x) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int x) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int x) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( A & B & C ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int x) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int x) (Some (Int.repr p))",
                    "C : eq (ZofB 53 1024 x) (Some p)",
                    "B : Z.le p Int.max_unsigned",
                    "A : Z.le 0 p"
                ]
            },
            {
                "tactic_sig": "unfold to_int , ZofB_range .",
                "tactic_sig_no_out_arg": "unfold to_int , ZofB_range .",
                "tactic_args": [
                    "_goal : eq (to_int x) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (option_map Int.repr\n     match ZofB 53 1024 x with\n     | Some z =>\n         if andb (Z.leb Int.min_signed z) (Z.leb z Int.max_signed)\n         then Some z\n         else None\n     | None => None\n     end) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq\n  (option_map Int.repr\n     match ZofB 53 1024 x with\n     | Some z =>\n         if andb (Z.leb Int.min_signed z) (Z.leb z Int.max_signed)\n         then Some z\n         else None\n     | None => None\n     end) (Some (Int.repr p))",
                    "C : eq (ZofB 53 1024 x) (Some p)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (option_map Int.repr\n     (if andb (Z.leb Int.min_signed p) (Z.leb p Int.max_signed)\n      then Some p\n      else None)) (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "rewrite Zle_bool_true by smart_omega .",
                "tactic_sig_no_out_arg": "rewrite Zle_bool_true by smart_omega .",
                "tactic_args": [
                    "_goal : eq\n  (option_map Int.repr\n     (if andb (Z.leb Int.min_signed p) (Z.leb p Int.max_signed)\n      then Some p\n      else None)) (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (option_map Int.repr\n     (if andb true (Z.leb p Int.max_signed) then Some p else None))\n  (Some (Int.repr p))"
                ]
            },
            {
                "tactic_sig": "rewrite Zle_bool_true .",
                "tactic_sig_no_out_arg": "rewrite Zle_bool_true .",
                "tactic_args": [
                    "_goal : eq\n  (option_map Int.repr\n     (if andb true (Z.leb p Int.max_signed) then Some p else None))\n  (Some (Int.repr p))"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Int.repr (if andb true true then Some p else None))\n  (Some (Int.repr p))",
                    "_goal : Z.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (option_map Int.repr (if andb true true then Some p else None))\n  (Some (Int.repr p))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "exploit ( BofZ_exact 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_sig_no_out_arg": "exploit ( BofZ_exact 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.unsigned ox8000_0000))\n  (Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53))",
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\nZ.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "vm_compute .",
                "tactic_sig_no_out_arg": "vm_compute .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.unsigned ox8000_0000))\n  (Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (forall _ : eq Lt Gt, False) (forall _ : eq Lt Gt, False)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "_goal : and (forall _ : eq Lt Gt, False) (forall _ : eq Lt Gt, False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( y := of_intu ox8000_0000 ) in * .",
                "tactic_sig_no_out_arg": "set ( y := of_intu ox8000_0000 ) in * .",
                "tactic_args": [],
                "tactic_res": [
                    "H : eq (cmp Clt x y) true",
                    "y : float"
                ]
            },
            {
                "tactic_sig": "change ( BofZ 53 1024 eq_refl eq_refl ( Int.unsigned ox8000_0000 ) ) with _i .",
                "tactic_sig_no_out_arg": "change ( BofZ 53 1024 eq_refl eq_refl ( Int.unsigned ox8000_0000 ) ) with _i .",
                "tactic_args": [
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\nZ.le p Int.max_signed",
                    "y : float"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000)))\n        (and (eq (is_finite 53 1024 y) true)\n           (eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0))),\nZ.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( EQy & FINy & SIGNy ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000)))\n        (and (eq (is_finite 53 1024 y) true)\n           (eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0))),\nZ.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p Int.max_signed",
                    "SIGNy : eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0)",
                    "FINy : eq (is_finite 53 1024 y) true",
                    "EQy : eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "assert ( FINx : is_finite _ _ _i = true ) .",
                "tactic_sig_no_out_arg": "assert ( FINx : is_finite _ _ _i = true ) .",
                "tactic_args": [
                    "x : float"
                ],
                "tactic_res": [
                    "_goal : eq (is_finite 53 1024 x) true",
                    "FINx : eq (is_finite 53 1024 x) true"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : eq (is_finite 53 1024 x) true"
                ],
                "tactic_res": [
                    "_goal : eq (is_finite 53 1024 x) true"
                ]
            },
            {
                "tactic_sig": "rewrite ZofB_correct in _i .",
                "tactic_sig_no_out_arg": "rewrite ZofB_correct in _i .",
                "tactic_args": [
                    "C : eq (ZofB 53 1024 x) (Some p)"
                ],
                "tactic_res": [
                    "C : eq\n  (if is_finite 53 1024 x then Some (Ztrunc (B2R 53 1024 x)) else None)\n  (Some p)"
                ]
            },
            {
                "tactic_sig": "destruct ( is_finite _ _ _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_finite _ _ _i ) eqn : _i .",
                "tactic_args": [
                    "_goal : eq (is_finite 53 1024 x) true",
                    "x : float",
                    "FINx : eq (is_finite 53 1024 x) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "_goal : eq false true",
                    "C : eq (Some (Ztrunc (B2R 53 1024 x))) (Some p)",
                    "C : eq None (Some p)",
                    "FINx : eq (is_finite 53 1024 x) false"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "destruct ( zeq _i 0 ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zeq _i 0 ) .",
                "tactic_args": [
                    "p : Z"
                ],
                "tactic_res": [
                    "e : eq p 0",
                    "n : not (eq p 0)"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "p : Z"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 Int.max_signed",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) (Some 0)",
                    "A : Z.le 0 0",
                    "B : Z.le 0 Int.max_unsigned",
                    "C : eq (ZofB 53 1024 x) (Some 0)"
                ]
            },
            {
                "tactic_sig": "smart_omega .",
                "tactic_sig_no_out_arg": "smart_omega .",
                "tactic_args": [
                    "_goal : Z.le 0 Int.max_signed"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( ZofB_range_pos 53 1024 __ __ _i _i _i ) as [ P Q ] .",
                "tactic_sig_no_out_arg": "destruct ( ZofB_range_pos 53 1024 __ __ _i _i _i ) as [ P Q ] .",
                "tactic_args": [
                    "x : float",
                    "p : Z",
                    "C : eq (ZofB 53 1024 x) (Some p)"
                ],
                "tactic_res": [
                    "_goal : Z.lt 0 p",
                    "Q : Rlt (B2R 53 1024 x) (IZR (Z.add p 1))",
                    "P : Rle (IZR p) (B2R 53 1024 x)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt 0 p"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( CMP : Bcompare _ _ _i _i = Some Lt ) .",
                "tactic_sig_no_out_arg": "assert ( CMP : Bcompare _ _ _i _i = Some Lt ) .",
                "tactic_args": [
                    "x : float",
                    "y : float"
                ],
                "tactic_res": [
                    "_goal : eq (Bcompare 53 1024 x y) (Some Lt)",
                    "CMP : eq (Bcompare 53 1024 x y) (Some Lt)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : eq (Bcompare 53 1024 x y) (Some Lt)"
                ],
                "tactic_res": [
                    "_goal : eq (Bcompare 53 1024 x y) (Some Lt)"
                ]
            },
            {
                "tactic_sig": "unfold cmp , cmp_of_comparison , compare in _i .",
                "tactic_sig_no_out_arg": "unfold cmp , cmp_of_comparison , compare in _i .",
                "tactic_args": [
                    "H : eq (cmp Clt x y) true"
                ],
                "tactic_res": [
                    "H : eq match Bcompare 53 1024 x y with\n   | Some Lt => true\n   | _ => false\n   end true"
                ]
            },
            {
                "tactic_sig": "destruct ( Bcompare _ _ _i _i ) as [ [ ] | ] .",
                "tactic_sig_no_out_arg": "destruct ( Bcompare _ _ _i _i ) as [ [ ] | ] .",
                "tactic_args": [
                    "_goal : eq (Bcompare 53 1024 x y) (Some Lt)",
                    "x : float",
                    "y : float"
                ],
                "tactic_res": [
                    "_goal : eq (Some Eq) (Some Lt)",
                    "_goal : eq (Some Lt) (Some Lt)",
                    "_goal : eq (Some Gt) (Some Lt)",
                    "_goal : eq None (Some Lt)",
                    "H : eq false true",
                    "H : eq true true"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some Eq) (Some Lt)"
                ],
                "tactic_res": [
                    "_goal : eq (Some Eq) (Some Lt)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : eq (Some Eq) (Some Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some Lt) (Some Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some Gt) (Some Lt)"
                ],
                "tactic_res": [
                    "_goal : eq (Some Gt) (Some Lt)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : eq (Some Gt) (Some Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq None (Some Lt)"
                ],
                "tactic_res": [
                    "_goal : eq None (Some Lt)"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : eq None (Some Lt)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "rewrite Bcompare_correct in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite Bcompare_correct in _i by auto .",
                "tactic_args": [
                    "CMP : eq (Bcompare 53 1024 x y) (Some Lt)"
                ],
                "tactic_res": [
                    "CMP : eq (Some (Rcompare (B2R 53 1024 x) (B2R 53 1024 y))) (Some Lt)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "CMP : eq (Some (Rcompare (B2R 53 1024 x) (B2R 53 1024 y))) (Some Lt)"
                ],
                "tactic_res": [
                    "H1 : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Lt"
                ]
            },
            {
                "tactic_sig": "apply Rcompare_Lt_inv in _i .",
                "tactic_sig_no_out_arg": "apply Rcompare_Lt_inv in _i .",
                "tactic_args": [
                    "H1 : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Lt"
                ],
                "tactic_res": [
                    "H1 : Rlt (B2R 53 1024 x) (B2R 53 1024 y)"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i .",
                "tactic_sig_no_out_arg": "rewrite _i in _i .",
                "tactic_args": [
                    "EQy : eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000))",
                    "H1 : Rlt (B2R 53 1024 x) (B2R 53 1024 y)"
                ],
                "tactic_res": [
                    "H1 : Rlt (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "assert ( _i < Int.unsigned ox8000_0000 ) .",
                "tactic_sig_no_out_arg": "assert ( _i < Int.unsigned ox8000_0000 ) .",
                "tactic_args": [
                    "p : Z"
                ],
                "tactic_res": [
                    "_goal : Z.lt p (Int.unsigned ox8000_0000)",
                    "H0 : Z.lt p (Int.unsigned ox8000_0000)"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : Z.lt p (Int.unsigned ox8000_0000)"
                ],
                "tactic_res": [
                    "_goal : Z.lt p (Int.unsigned ox8000_0000)"
                ]
            },
            {
                "tactic_sig": "apply lt_IZR .",
                "tactic_sig_no_out_arg": "apply lt_IZR .",
                "tactic_args": [
                    "_goal : Z.lt p (Int.unsigned ox8000_0000)"
                ],
                "tactic_res": [
                    "_goal : Rlt (IZR p) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "apply Rle_lt_trans with ( 1 := _i ) ( 2 := _i ) .",
                "tactic_sig_no_out_arg": "apply Rle_lt_trans with ( 1 := _i ) ( 2 := _i ) .",
                "tactic_args": [
                    "_goal : Rlt (IZR p) (IZR (Int.unsigned ox8000_0000))",
                    "P : Rle (IZR p) (B2R 53 1024 x)",
                    "H1 : Rlt (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p Int.max_signed"
                ]
            },
            {
                "tactic_sig": "change Int.max_signed with ( Int.unsigned ox8000_0000 - 1 ) .",
                "tactic_sig_no_out_arg": "change Int.max_signed with ( Int.unsigned ox8000_0000 - 1 ) .",
                "tactic_args": [
                    "_goal : Z.le p Int.max_signed"
                ],
                "tactic_res": [
                    "_goal : Z.le p (Z.sub (Int.unsigned ox8000_0000) 1)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.le p (Z.sub (Int.unsigned ox8000_0000) 1)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "to_intu_to_int_2",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : float) (n : Int.int)\n  (_ : eq (cmp Clt x (of_intu ox8000_0000)) false)\n  (_ : eq (to_intu x) (Some n)),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub n ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub n ox8000_0000))",
                    "H0 : eq (to_intu x) (Some n)",
                    "H : eq (cmp Clt x (of_intu ox8000_0000)) false",
                    "n : Int.int",
                    "x : float"
                ]
            },
            {
                "tactic_sig": "unfold to_intu in _i .",
                "tactic_sig_no_out_arg": "unfold to_intu in _i .",
                "tactic_args": [
                    "H0 : eq (to_intu x) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Int.repr (ZofB_range 53 1024 x 0 Int.max_unsigned))\n  (Some n)"
                ]
            },
            {
                "tactic_sig": "destruct ( ZofB_range _ _ _i 0 Int.max_unsigned ) as [ p| ] eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( ZofB_range _ _ _i 0 Int.max_unsigned ) as [ p| ] eqn : E .",
                "tactic_args": [
                    "x : float"
                ],
                "tactic_res": [
                    "H0 : eq (option_map Int.repr (Some p)) (Some n)",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) (Some p)",
                    "p : Z",
                    "H0 : eq (option_map Int.repr None) (Some n)",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) None"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (option_map Int.repr (Some p)) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq (Some (Int.repr p)) (Some n)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H0 : eq (Some (Int.repr p)) (Some n)"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "simpl in _i .",
                "tactic_sig_no_out_arg": "simpl in _i .",
                "tactic_args": [
                    "H0 : eq (option_map Int.repr None) (Some n)"
                ],
                "tactic_res": [
                    "H0 : eq None (Some n)"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub n ox8000_0000))",
                    "H0 : eq None (Some n)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit ZofB_range_inversion .",
                "tactic_sig_no_out_arg": "exploit ZofB_range_inversion .",
                "tactic_args": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (ZofB_range ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3) (Some ?Goal4)",
                    "_goal : forall\n  _ : and (Z.le ?Goal2 ?Goal4)\n        (and (Z.le ?Goal4 ?Goal3)\n           (eq (ZofB ?Goal ?Goal0 ?Goal1) (Some ?Goal4))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : eq (ZofB_range ?Goal ?Goal0 ?Goal1 ?Goal2 ?Goal3) (Some ?Goal4)",
                    "_goal : forall\n  _ : and (Z.le ?Goal2 ?Goal4)\n        (and (Z.le ?Goal4 ?Goal3)\n           (eq (ZofB ?Goal ?Goal0 ?Goal1) (Some ?Goal4))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "eauto .",
                "tactic_sig_no_out_arg": "eauto .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( A & B & C ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 p)\n        (and (Z.le p Int.max_unsigned) (eq (ZofB 53 1024 x) (Some p))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))",
                    "C : eq (ZofB 53 1024 x) (Some p)",
                    "B : Z.le p Int.max_unsigned",
                    "A : Z.le 0 p"
                ]
            },
            {
                "tactic_sig": "exploit ( BofZ_exact 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_sig_no_out_arg": "exploit ( BofZ_exact 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) .",
                "tactic_args": [
                    "_goal : eq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.unsigned ox8000_0000))\n  (Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53))",
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "vm_compute .",
                "tactic_sig_no_out_arg": "vm_compute .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Int.unsigned ox8000_0000))\n  (Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (forall _ : eq Lt Gt, False) (forall _ : eq Lt Gt, False)"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "_goal : and (forall _ : eq Lt Gt, False) (forall _ : eq Lt Gt, False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "set ( y := of_intu ox8000_0000 ) in * .",
                "tactic_sig_no_out_arg": "set ( y := of_intu ox8000_0000 ) in * .",
                "tactic_args": [
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x (of_intu ox8000_0000)))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))",
                    "H : eq (cmp Clt x y) false",
                    "y : float"
                ]
            },
            {
                "tactic_sig": "change ( BofZ 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) with _i .",
                "tactic_sig_no_out_arg": "change ( BofZ 53 1024 __ __ ( Int.unsigned ox8000_0000 ) ) with _i .",
                "tactic_args": [
                    "_goal : forall\n  _ : and\n        (eq\n           (B2R 53 1024\n              (BofZ 53 1024 eq_refl eq_refl (Int.unsigned ox8000_0000)))\n           (IZR (Int.unsigned ox8000_0000)))\n        (and\n           (eq\n              (is_finite 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000))) true)\n           (eq\n              (Bsign 53 1024\n                 (BofZ 53 1024 eq_refl eq_refl\n                    (Int.unsigned ox8000_0000)))\n              (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))",
                    "y : float"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000)))\n        (and (eq (is_finite 53 1024 y) true)\n           (eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ( EQy & FINy & SIGNy ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000)))\n        (and (eq (is_finite 53 1024 y) true)\n           (eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0))),\neq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))",
                    "SIGNy : eq (Bsign 53 1024 y) (Z.ltb (Int.unsigned ox8000_0000) 0)",
                    "FINy : eq (is_finite 53 1024 y) true",
                    "EQy : eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "assert ( FINx : is_finite _ _ _i = true ) .",
                "tactic_sig_no_out_arg": "assert ( FINx : is_finite _ _ _i = true ) .",
                "tactic_args": [
                    "x : float"
                ],
                "tactic_res": [
                    "_goal : eq (is_finite 53 1024 x) true",
                    "FINx : eq (is_finite 53 1024 x) true"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : eq (is_finite 53 1024 x) true"
                ],
                "tactic_res": [
                    "_goal : eq (is_finite 53 1024 x) true"
                ]
            },
            {
                "tactic_sig": "rewrite ZofB_correct in _i .",
                "tactic_sig_no_out_arg": "rewrite ZofB_correct in _i .",
                "tactic_args": [
                    "C : eq (ZofB 53 1024 x) (Some p)"
                ],
                "tactic_res": [
                    "C : eq\n  (if is_finite 53 1024 x then Some (Ztrunc (B2R 53 1024 x)) else None)\n  (Some p)"
                ]
            },
            {
                "tactic_sig": "destruct ( is_finite _ _ _i ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( is_finite _ _ _i ) eqn : _i .",
                "tactic_args": [
                    "_goal : eq (is_finite 53 1024 x) true",
                    "x : float",
                    "FINx : eq (is_finite 53 1024 x) true"
                ],
                "tactic_res": [
                    "_goal : eq true true",
                    "_goal : eq false true",
                    "C : eq (Some (Ztrunc (B2R 53 1024 x))) (Some p)",
                    "C : eq None (Some p)",
                    "FINx : eq (is_finite 53 1024 x) false"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "assert ( GE : ( B2R _ _ _i >= IZR ( Int.unsigned ox8000_0000 ) ) % R ) .",
                "tactic_sig_no_out_arg": "assert ( GE : ( B2R _ _ _i >= IZR ( Int.unsigned ox8000_0000 ) ) % R ) .",
                "tactic_args": [
                    "x : float"
                ],
                "tactic_res": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))",
                    "GE : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))",
                    "EQy : eq (B2R 53 1024 y) (IZR (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : Rge (B2R 53 1024 x) (B2R 53 1024 y)"
                ]
            },
            {
                "tactic_sig": "unfold cmp , cmp_of_comparison , compare in _i .",
                "tactic_sig_no_out_arg": "unfold cmp , cmp_of_comparison , compare in _i .",
                "tactic_args": [
                    "H : eq (cmp Clt x y) false"
                ],
                "tactic_res": [
                    "H : eq match Bcompare 53 1024 x y with\n   | Some Lt => true\n   | _ => false\n   end false"
                ]
            },
            {
                "tactic_sig": "rewrite Bcompare_correct in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite Bcompare_correct in _i by auto .",
                "tactic_args": [
                    "H : eq match Bcompare 53 1024 x y with\n   | Some Lt => true\n   | _ => false\n   end false"
                ],
                "tactic_res": [
                    "H : eq\n  match Rcompare (B2R 53 1024 x) (B2R 53 1024 y) with\n  | Lt => true\n  | _ => false\n  end false"
                ]
            },
            {
                "tactic_sig": "destruct ( Rcompare ( B2R 53 1024 _i ) ( B2R 53 1024 _i ) ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Rcompare ( B2R 53 1024 _i ) ( B2R 53 1024 _i ) ) eqn : CMP .",
                "tactic_args": [
                    "x : float",
                    "y : float"
                ],
                "tactic_res": [
                    "H : eq false false",
                    "CMP : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Eq",
                    "H : eq true false",
                    "CMP : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Lt",
                    "CMP : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Gt"
                ]
            },
            {
                "tactic_sig": "apply Req_ge .",
                "tactic_sig_no_out_arg": "apply Req_ge .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : eq (B2R 53 1024 x) (B2R 53 1024 y)"
                ]
            },
            {
                "tactic_sig": "apply Rcompare_Eq_inv .",
                "tactic_sig_no_out_arg": "apply Rcompare_Eq_inv .",
                "tactic_args": [
                    "_goal : eq (B2R 53 1024 x) (B2R 53 1024 y)"
                ],
                "tactic_res": [
                    "_goal : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Eq"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Eq"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply Rgt_ge .",
                "tactic_sig_no_out_arg": "apply Rgt_ge .",
                "tactic_args": [
                    "_goal : Rge (B2R 53 1024 x) (B2R 53 1024 y)"
                ],
                "tactic_res": [
                    "_goal : Rgt (B2R 53 1024 x) (B2R 53 1024 y)"
                ]
            },
            {
                "tactic_sig": "apply Rcompare_Gt_inv .",
                "tactic_sig_no_out_arg": "apply Rcompare_Gt_inv .",
                "tactic_args": [
                    "_goal : Rgt (B2R 53 1024 x) (B2R 53 1024 y)"
                ],
                "tactic_res": [
                    "_goal : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Gt"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Rcompare (B2R 53 1024 x) (B2R 53 1024 y)) Gt"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "assert ( EQ : ZofB_range _ _ ( sub _i _i ) Int.min_signed Int.max_signed = Some ( _i - Int.unsigned ox8000_0000 ) ) .",
                "tactic_sig_no_out_arg": "assert ( EQ : ZofB_range _ _ ( sub _i _i ) Int.min_signed Int.max_signed = Some ( _i - Int.unsigned ox8000_0000 ) ) .",
                "tactic_args": [
                    "x : float",
                    "y : float",
                    "p : Z"
                ],
                "tactic_res": [
                    "_goal : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))",
                    "EQ : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "{",
                "tactic_sig_no_out_arg": "{",
                "tactic_args": [
                    "_goal : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))"
                ]
            },
            {
                "tactic_sig": "apply ZofB_range_minus .",
                "tactic_sig_no_out_arg": "apply ZofB_range_minus .",
                "tactic_args": [
                    "_goal : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (ZofB_range 53 1024 x 0\n     (Z.sub (Z.mul 2 (Int.unsigned ox8000_0000)) 1)) \n  (Some p)",
                    "_goal : Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53)",
                    "_goal : Rle (IZR (Int.unsigned ox8000_0000)) (B2R 53 1024 x)"
                ]
            },
            {
                "tactic_sig": "exact _i .",
                "tactic_sig_no_out_arg": "exact _i .",
                "tactic_args": [
                    "_goal : eq\n  (ZofB_range 53 1024 x 0\n     (Z.sub (Z.mul 2 (Int.unsigned ox8000_0000)) 1)) \n  (Some p)",
                    "E : eq (ZofB_range 53 1024 x 0 Int.max_unsigned) (Some p)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "compute_this ( Int.unsigned ox8000_0000 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Int.unsigned ox8000_0000 ) .",
                "tactic_args": [
                    "_goal : Z.le (Int.unsigned ox8000_0000) (Z.pow 2 53)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow 2 53)",
                    "GE : Rge (B2R 53 1024 x) 2147483648",
                    "SIGNy : eq (Bsign 53 1024 y) (Z.ltb 2147483648 0)",
                    "EQy : eq (B2R 53 1024 y) 2147483648%R"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow 2 53)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow 2 53)"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow 2 53)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [],
                "tactic_res": [
                    "B : Z.le p 4294967295",
                    "E : eq (ZofB_range 53 1024 x 0 4294967295) (Some p)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 (Z.pow_pos 2 53%positive)"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ],
                "tactic_res": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.le 2147483648 9007199254740992"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply Rge_le .",
                "tactic_sig_no_out_arg": "apply Rge_le .",
                "tactic_args": [
                    "_goal : Rle (IZR (Int.unsigned ox8000_0000)) (B2R 53 1024 x)"
                ],
                "tactic_res": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Rge (B2R 53 1024 x) (IZR (Int.unsigned ox8000_0000))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "}",
                "tactic_sig_no_out_arg": "}",
                "tactic_args": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "unfold to_int .",
                "tactic_sig_no_out_arg": "unfold to_int .",
                "tactic_args": [
                    "_goal : eq (to_int (sub x y)) (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq\n  (option_map Int.repr\n     (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : eq\n  (option_map Int.repr\n     (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed))\n  (Some (Int.sub (Int.repr p) ox8000_0000))",
                    "EQ : eq (ZofB_range 53 1024 (sub x y) Int.min_signed Int.max_signed)\n  (Some (Z.sub p (Int.unsigned ox8000_0000)))"
                ],
                "tactic_res": [
                    "_goal : eq (option_map Int.repr (Some (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (option_map Int.repr (Some (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ]
            },
            {
                "tactic_sig": "unfold Int.sub .",
                "tactic_sig_no_out_arg": "unfold Int.sub .",
                "tactic_args": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.sub (Int.repr p) ox8000_0000))"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some\n     (Int.repr\n        (Z.sub (Int.unsigned (Int.repr p)) (Int.unsigned ox8000_0000))))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_repr by lia .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_repr by lia .",
                "tactic_args": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some\n     (Int.repr\n        (Z.sub (Int.unsigned (Int.repr p)) (Int.unsigned ox8000_0000))))"
                ],
                "tactic_res": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))\n  (Some (Int.repr (Z.sub p (Int.unsigned ox8000_0000))))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "split_bits_or",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : Int.int,\neq (split_bits 52 11 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n  (pair (pair false (Int.unsigned x)) 1075)"
                ],
                "tactic_res": [
                    "_goal : eq (split_bits 52 11 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n  (pair (pair false (Int.unsigned x)) 1075)",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "transitivity ( split_bits 52 11 ( join_bits 52 11 false ( Int.unsigned _i ) 1075 ) ) .",
                "tactic_sig_no_out_arg": "transitivity ( split_bits 52 11 ( join_bits 52 11 false ( Int.unsigned _i ) 1075 ) ) .",
                "tactic_args": [
                    "_goal : eq (split_bits 52 11 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n  (pair (pair false (Int.unsigned x)) 1075)",
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : eq (split_bits 52 11 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n  (split_bits 52 11 (join_bits 52 11 false (Int.unsigned x) 1075))",
                    "_goal : eq (split_bits 52 11 (join_bits 52 11 false (Int.unsigned x) 1075))\n  (pair (pair false (Int.unsigned x)) 1075)"
                ]
            },
            {
                "tactic_sig": "f_equal .",
                "tactic_sig_no_out_arg": "f_equal .",
                "tactic_args": [
                    "_goal : eq (split_bits 52 11 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n  (split_bits 52 11 (join_bits 52 11 false (Int.unsigned x) 1075))"
                ],
                "tactic_res": [
                    "_goal : eq (Int64.unsigned (Int64.ofwords ox4330_0000 x))\n  (join_bits 52 11 false (Int.unsigned x) 1075)"
                ]
            },
            {
                "tactic_sig": "rewrite Int64.ofwords_add' .",
                "tactic_sig_no_out_arg": "rewrite Int64.ofwords_add' .",
                "tactic_args": [
                    "_goal : eq (Int64.unsigned (Int64.ofwords ox4330_0000 x))\n  (join_bits 52 11 false (Int.unsigned x) 1075)"
                ],
                "tactic_res": [
                    "_goal : eq\n  (Z.add (Z.mul (Int.unsigned ox4330_0000) (two_p 32)) (Int.unsigned x))\n  (join_bits 52 11 false (Int.unsigned x) 1075)"
                ]
            },
            {
                "tactic_sig": "reflexivity .",
                "tactic_sig_no_out_arg": "reflexivity .",
                "tactic_args": [
                    "_goal : eq\n  (Z.add (Z.mul (Int.unsigned ox4330_0000) (two_p 32)) (Int.unsigned x))\n  (join_bits 52 11 false (Int.unsigned x) 1075)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply split_join_bits .",
                "tactic_sig_no_out_arg": "apply split_join_bits .",
                "tactic_args": [
                    "_goal : eq (split_bits 52 11 (join_bits 52 11 false (Int.unsigned x) 1075))\n  (pair (pair false (Int.unsigned x)) 1075)"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))",
                    "_goal : and (Z.le 0 1075) (Z.lt 1075 (Z.pow 2 11))"
                ]
            },
            {
                "tactic_sig": "generalize ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "generalize ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "_goal : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))",
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))"
                ]
            },
            {
                "tactic_sig": "compute_this ( 2 ^ 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( 2 ^ 52 ) .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) (Z.pow 2 52))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4503599627370496)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296),\nand (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4503599627370496)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "compute_this ( 2 ^ 11 ) .",
                "tactic_sig_no_out_arg": "compute_this ( 2 ^ 11 ) .",
                "tactic_args": [
                    "_goal : and (Z.le 0 1075) (Z.lt 1075 (Z.pow 2 11))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le 0 1075) (Z.lt 1075 2048)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and (Z.le 0 1075) (Z.lt 1075 2048)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "from_words_value",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : Int.int,\nand\n  (eq (B2R 53 1024 (from_words ox4330_0000 x))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and (eq (is_finite 53 1024 (from_words ox4330_0000 x)) true)\n     (eq (Bsign 53 1024 (from_words ox4330_0000 x)) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq (B2R 53 1024 (from_words ox4330_0000 x))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and (eq (is_finite 53 1024 (from_words ox4330_0000 x)) true)\n     (eq (Bsign 53 1024 (from_words ox4330_0000 x)) false))",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "unfold from_words , of_bits , b64_of_bits , binary_float_of_bits .",
                "tactic_sig_no_out_arg": "unfold from_words , of_bits , b64_of_bits , binary_float_of_bits .",
                "tactic_args": [
                    "_goal : and\n  (eq (B2R 53 1024 (from_words ox4330_0000 x))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and (eq (is_finite 53 1024 (from_words ox4330_0000 x)) true)\n     (eq (Bsign 53 1024 (from_words ox4330_0000 x)) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (B2R 53 1024\n        (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n           (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n              eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite 53 1024\n           (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n              (binary_float_of_bits_aux 52 11\n                 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n              (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n                 eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n        true)\n     (eq\n        (Bsign 53 1024\n           (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n              (binary_float_of_bits_aux 52 11\n                 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n              (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n                 eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n        false))"
                ]
            },
            {
                "tactic_sig": "rewrite B2R_FF2B , is_finite_FF2B , Bsign_FF2B .",
                "tactic_sig_no_out_arg": "rewrite B2R_FF2B , is_finite_FF2B , Bsign_FF2B .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (B2R 53 1024\n        (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n           (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n              eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite 53 1024\n           (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n              (binary_float_of_bits_aux 52 11\n                 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n              (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n                 eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n        true)\n     (eq\n        (Bsign 53 1024\n           (FF2B (Z.add 52 1) (Z.pow 2 (Z.sub 11 1))\n              (binary_float_of_bits_aux 52 11\n                 (Int64.unsigned (Int64.ofwords ox4330_0000 x)))\n              (binary_float_of_bits_aux_correct 52 11 eq_refl eq_refl\n                 eq_refl (Int64.unsigned (Int64.ofwords ox4330_0000 x)))))\n        false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (binary_float_of_bits_aux 52 11\n           (Int64.unsigned (Int64.ofwords ox4330_0000 x))))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))) true)\n     (eq\n        (sign_FF\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))) false))"
                ]
            },
            {
                "tactic_sig": "unfold binary_float_of_bits_aux .",
                "tactic_sig_no_out_arg": "unfold binary_float_of_bits_aux .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (binary_float_of_bits_aux 52 11\n           (Int64.unsigned (Int64.ofwords ox4330_0000 x))))\n     (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))) true)\n     (eq\n        (sign_FF\n           (binary_float_of_bits_aux 52 11\n              (Int64.unsigned (Int64.ofwords ox4330_0000 x)))) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (let\n         'pair (pair sx mx) ex :=\n          split_bits 52 11\n            (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n          if Zeq_bool ex 0\n          then\n           match mx with\n           | 0 => F754_zero sx\n           | Zpos px =>\n               F754_finite sx px\n                 (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n           | Zneg _ => F754_nan false 1\n           end\n          else\n           if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n           then\n            match mx with\n            | 0 => F754_infinity sx\n            | Zpos plx => F754_nan sx plx\n            | Zneg _ => F754_nan false 1\n            end\n           else\n            match Z.add mx (Z.pow 2 52) with\n            | Zpos px =>\n                F754_finite sx px\n                  (Z.sub\n                     (Z.add ex\n                        (SpecFloat.emin (Z.add 52 1)\n                           (Z.pow 2 (Z.sub 11 1)))) 1)\n            | _ => F754_nan false 1\n            end)) (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (let\n            'pair (pair sx mx) ex :=\n             split_bits 52 11\n               (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n             if Zeq_bool ex 0\n             then\n              match mx with\n              | 0 => F754_zero sx\n              | Zpos px =>\n                  F754_finite sx px\n                    (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n              then\n               match mx with\n               | 0 => F754_infinity sx\n               | Zpos plx => F754_nan sx plx\n               | Zneg _ => F754_nan false 1\n               end\n              else\n               match Z.add mx (Z.pow 2 52) with\n               | Zpos px =>\n                   F754_finite sx px\n                     (Z.sub\n                        (Z.add ex\n                           (SpecFloat.emin (Z.add 52 1)\n                              (Z.pow 2 (Z.sub 11 1)))) 1)\n               | _ => F754_nan false 1\n               end)) true)\n     (eq\n        (sign_FF\n           (let\n            'pair (pair sx mx) ex :=\n             split_bits 52 11\n               (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n             if Zeq_bool ex 0\n             then\n              match mx with\n              | 0 => F754_zero sx\n              | Zpos px =>\n                  F754_finite sx px\n                    (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n              then\n               match mx with\n               | 0 => F754_infinity sx\n               | Zpos plx => F754_nan sx plx\n               | Zneg _ => F754_nan false 1\n               end\n              else\n               match Z.add mx (Z.pow 2 52) with\n               | Zpos px =>\n                   F754_finite sx px\n                     (Z.sub\n                        (Z.add ex\n                           (SpecFloat.emin (Z.add 52 1)\n                              (Z.pow 2 (Z.sub 11 1)))) 1)\n               | _ => F754_nan false 1\n               end)) false))"
                ]
            },
            {
                "tactic_sig": "rewrite split_bits_or .",
                "tactic_sig_no_out_arg": "rewrite split_bits_or .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (let\n         'pair (pair sx mx) ex :=\n          split_bits 52 11\n            (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n          if Zeq_bool ex 0\n          then\n           match mx with\n           | 0 => F754_zero sx\n           | Zpos px =>\n               F754_finite sx px\n                 (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n           | Zneg _ => F754_nan false 1\n           end\n          else\n           if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n           then\n            match mx with\n            | 0 => F754_infinity sx\n            | Zpos plx => F754_nan sx plx\n            | Zneg _ => F754_nan false 1\n            end\n           else\n            match Z.add mx (Z.pow 2 52) with\n            | Zpos px =>\n                F754_finite sx px\n                  (Z.sub\n                     (Z.add ex\n                        (SpecFloat.emin (Z.add 52 1)\n                           (Z.pow 2 (Z.sub 11 1)))) 1)\n            | _ => F754_nan false 1\n            end)) (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (let\n            'pair (pair sx mx) ex :=\n             split_bits 52 11\n               (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n             if Zeq_bool ex 0\n             then\n              match mx with\n              | 0 => F754_zero sx\n              | Zpos px =>\n                  F754_finite sx px\n                    (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n              then\n               match mx with\n               | 0 => F754_infinity sx\n               | Zpos plx => F754_nan sx plx\n               | Zneg _ => F754_nan false 1\n               end\n              else\n               match Z.add mx (Z.pow 2 52) with\n               | Zpos px =>\n                   F754_finite sx px\n                     (Z.sub\n                        (Z.add ex\n                           (SpecFloat.emin (Z.add 52 1)\n                              (Z.pow 2 (Z.sub 11 1)))) 1)\n               | _ => F754_nan false 1\n               end)) true)\n     (eq\n        (sign_FF\n           (let\n            'pair (pair sx mx) ex :=\n             split_bits 52 11\n               (Int64.unsigned (Int64.ofwords ox4330_0000 x)) in\n             if Zeq_bool ex 0\n             then\n              match mx with\n              | 0 => F754_zero sx\n              | Zpos px =>\n                  F754_finite sx px\n                    (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              if Zeq_bool ex (Z.sub (Z.pow 2 11) 1)\n              then\n               match mx with\n               | 0 => F754_infinity sx\n               | Zpos plx => F754_nan sx plx\n               | Zneg _ => F754_nan false 1\n               end\n              else\n               match Z.add mx (Z.pow 2 52) with\n               | Zpos px =>\n                   F754_finite sx px\n                     (Z.sub\n                        (Z.add ex\n                           (SpecFloat.emin (Z.add 52 1)\n                              (Z.pow 2 (Z.sub 11 1)))) 1)\n               | _ => F754_nan false 1\n               end)) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (if Zeq_bool 1075 0\n         then\n          match Int.unsigned x with\n          | 0 => F754_zero false\n          | Zpos px =>\n              F754_finite false px\n                (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n          | Zneg _ => F754_nan false 1\n          end\n         else\n          if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n          then\n           match Int.unsigned x with\n           | 0 => F754_infinity false\n           | Zpos plx => F754_nan false plx\n           | Zneg _ => F754_nan false 1\n           end\n          else\n           match Z.add (Int.unsigned x) (Z.pow 2 52) with\n           | Zpos px =>\n               F754_finite false px\n                 (Z.sub\n                    (Z.add 1075\n                       (SpecFloat.emin (Z.add 52 1)\n                          (Z.pow 2 (Z.sub 11 1)))) 1)\n           | _ => F754_nan false 1\n           end)) (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (if Zeq_bool 1075 0\n            then\n             match Int.unsigned x with\n             | 0 => F754_zero false\n             | Zpos px =>\n                 F754_finite false px\n                   (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n             | Zneg _ => F754_nan false 1\n             end\n            else\n             if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n             then\n              match Int.unsigned x with\n              | 0 => F754_infinity false\n              | Zpos plx => F754_nan false plx\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              match Z.add (Int.unsigned x) (Z.pow 2 52) with\n              | Zpos px =>\n                  F754_finite false px\n                    (Z.sub\n                       (Z.add 1075\n                          (SpecFloat.emin (Z.add 52 1)\n                             (Z.pow 2 (Z.sub 11 1)))) 1)\n              | _ => F754_nan false 1\n              end)) true)\n     (eq\n        (sign_FF\n           (if Zeq_bool 1075 0\n            then\n             match Int.unsigned x with\n             | 0 => F754_zero false\n             | Zpos px =>\n                 F754_finite false px\n                   (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n             | Zneg _ => F754_nan false 1\n             end\n            else\n             if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n             then\n              match Int.unsigned x with\n              | 0 => F754_infinity false\n              | Zpos plx => F754_nan false plx\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              match Z.add (Int.unsigned x) (Z.pow 2 52) with\n              | Zpos px =>\n                  F754_finite false px\n                    (Z.sub\n                       (Z.add 1075\n                          (SpecFloat.emin (Z.add 52 1)\n                             (Z.pow 2 (Z.sub 11 1)))) 1)\n              | _ => F754_nan false 1\n              end)) false))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        (if Zeq_bool 1075 0\n         then\n          match Int.unsigned x with\n          | 0 => F754_zero false\n          | Zpos px =>\n              F754_finite false px\n                (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n          | Zneg _ => F754_nan false 1\n          end\n         else\n          if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n          then\n           match Int.unsigned x with\n           | 0 => F754_infinity false\n           | Zpos plx => F754_nan false plx\n           | Zneg _ => F754_nan false 1\n           end\n          else\n           match Z.add (Int.unsigned x) (Z.pow 2 52) with\n           | Zpos px =>\n               F754_finite false px\n                 (Z.sub\n                    (Z.add 1075\n                       (SpecFloat.emin (Z.add 52 1)\n                          (Z.pow 2 (Z.sub 11 1)))) 1)\n           | _ => F754_nan false 1\n           end)) (Rplus (bpow radix2 52) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           (if Zeq_bool 1075 0\n            then\n             match Int.unsigned x with\n             | 0 => F754_zero false\n             | Zpos px =>\n                 F754_finite false px\n                   (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n             | Zneg _ => F754_nan false 1\n             end\n            else\n             if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n             then\n              match Int.unsigned x with\n              | 0 => F754_infinity false\n              | Zpos plx => F754_nan false plx\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              match Z.add (Int.unsigned x) (Z.pow 2 52) with\n              | Zpos px =>\n                  F754_finite false px\n                    (Z.sub\n                       (Z.add 1075\n                          (SpecFloat.emin (Z.add 52 1)\n                             (Z.pow 2 (Z.sub 11 1)))) 1)\n              | _ => F754_nan false 1\n              end)) true)\n     (eq\n        (sign_FF\n           (if Zeq_bool 1075 0\n            then\n             match Int.unsigned x with\n             | 0 => F754_zero false\n             | Zpos px =>\n                 F754_finite false px\n                   (SpecFloat.emin (Z.add 52 1) (Z.pow 2 (Z.sub 11 1)))\n             | Zneg _ => F754_nan false 1\n             end\n            else\n             if Zeq_bool 1075 (Z.sub (Z.pow 2 11) 1)\n             then\n              match Int.unsigned x with\n              | 0 => F754_infinity false\n              | Zpos plx => F754_nan false plx\n              | Zneg _ => F754_nan false 1\n              end\n             else\n              match Z.add (Int.unsigned x) (Z.pow 2 52) with\n              | Zpos px =>\n                  F754_finite false px\n                    (Z.sub\n                       (Z.add 1075\n                          (SpecFloat.emin (Z.add 52 1)\n                             (Z.pow 2 (Z.sub 11 1)))) 1)\n              | _ => F754_nan false 1\n              end)) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n        | Zpos px => F754_finite false px 0\n        | _ => F754_nan false 1\n        end)\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n           | Zpos px => F754_finite false px 0\n           | _ => F754_nan false 1\n           end) true)\n     (eq\n        (sign_FF\n           match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n           | Zpos px => F754_finite false px 0\n           | _ => F754_nan false 1\n           end) false))"
                ]
            },
            {
                "tactic_sig": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "destruct ( Int.unsigned _i + Z.pow_pos 2 52 ) eqn : _o .",
                "tactic_sig_no_out_arg": "destruct ( Int.unsigned _i + Z.pow_pos 2 52 ) eqn : ? .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (FF2R radix2\n        match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n        | Zpos px => F754_finite false px 0\n        | _ => F754_nan false 1\n        end)\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and\n     (eq\n        (is_finite_FF\n           match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n           | Zpos px => F754_finite false px 0\n           | _ => F754_nan false 1\n           end) true)\n     (eq\n        (sign_FF\n           match Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive) with\n           | Zpos px => F754_finite false px 0\n           | _ => F754_nan false 1\n           end) false))",
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq (FF2R radix2 (F754_nan false 1))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq (is_finite_FF (F754_nan false 1)) true)\n     (eq (sign_FF (F754_nan false 1)) false))",
                    "_goal : and\n  (eq (FF2R radix2 (F754_finite false p 0))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq (is_finite_FF (F754_finite false p 0)) true)\n     (eq (sign_FF (F754_finite false p 0)) false))",
                    "_goal : and\n  (eq (FF2R radix2 (F754_nan false 1))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq (is_finite_FF (F754_nan false 1)) true)\n     (eq (sign_FF (F754_nan false 1)) false))",
                    "Heqz : eq (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive)) 0",
                    "Heqz : eq (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive)) (Zpos p)",
                    "p : positive",
                    "Heqz : eq (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive)) (Zneg p)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "now smart_omega .",
                "tactic_sig_no_out_arg": "now smart_omega .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and\n  (eq (FF2R radix2 (F754_finite false p 0))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq (is_finite_FF (F754_finite false p 0)) true)\n     (eq (sign_FF (F754_finite false p 0)) false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq (F2R {| Fnum := Zpos p; Fexp := 0 |})\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : and\n  (eq (F2R {| Fnum := Zpos p; Fexp := 0 |})\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))",
                    "Heqz : eq (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive)) (Zpos p)"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (F2R\n        {|\n          Fnum := Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n          Fexp := 0\n        |})\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ]
            },
            {
                "tactic_sig": "unfold F2R .",
                "tactic_sig_no_out_arg": "unfold F2R .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (F2R\n        {|\n          Fnum := Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n          Fexp := 0\n        |})\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (Rmult\n        (IZR\n           (Fnum\n              {|\n                Fnum :=\n                  Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n                Fexp := 0\n              |}))\n        (bpow radix2\n           (Fexp\n              {|\n                Fnum :=\n                  Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n                Fexp := 0\n              |})))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (Rmult\n        (IZR\n           (Fnum\n              {|\n                Fnum :=\n                  Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n                Fexp := 0\n              |}))\n        (bpow radix2\n           (Fexp\n              {|\n                Fnum :=\n                  Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive);\n                Fexp := 0\n              |})))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ],
                "tactic_res": [
                    "_goal : and\n  (eq\n     (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and\n  (eq\n     (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq true true) (eq false false))"
                ],
                "tactic_res": [
                    "_goal : eq (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))",
                    "_goal : and (eq true true) (eq false false)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : and (eq true true) (eq false false)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite Rmult_1_r , plus_IZR .",
                "tactic_sig_no_out_arg": "rewrite Rmult_1_r , plus_IZR .",
                "tactic_args": [
                    "_goal : eq (Rmult (IZR (Z.add (Int.unsigned x) (Z.pow_pos 2 52%positive))) 1)\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (Rplus (IZR (Int.unsigned x)) (IZR (Z.pow_pos 2 52%positive)))\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "apply Rplus_comm .",
                "tactic_sig_no_out_arg": "apply Rplus_comm .",
                "tactic_args": [
                    "_goal : eq (Rplus (IZR (Int.unsigned x)) (IZR (Z.pow_pos 2 52%positive)))\n  (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : and\n  (eq (FF2R radix2 (F754_nan false 1))\n     (Rplus (IZR (Z.pow_pos 2 52%positive)) (IZR (Int.unsigned x))))\n  (and (eq (is_finite_FF (F754_nan false 1)) true)\n     (eq (sign_FF (F754_nan false 1)) false))"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "now smart_omega .",
                "tactic_sig_no_out_arg": "now smart_omega .",
                "tactic_args": [
                    "_goal : False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "from_words_eq",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : Int.int,\neq (from_words ox4330_0000 x)\n  (BofZ 53 1024 eq_refl eq_refl (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (from_words ox4330_0000 x)\n  (BofZ 53 1024 eq_refl eq_refl (Z.add (Z.pow 2 52) (Int.unsigned x)))",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "destruct ( from_words_value _i ) as ( A & B & C ) as [_o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( from_words_value _i ) as ( A & B & C ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "C : eq (Bsign 53 1024 (from_words ox4330_0000 x)) false",
                    "B : eq (is_finite 53 1024 (from_words ox4330_0000 x)) true",
                    "A : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "destruct ( BofZ_exact 53 1024 __ __ ( 2 ^ 52 + Int.unsigned _i ) ) as ( D & E & F ) as [| _o _o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( BofZ_exact 53 1024 __ __ ( 2 ^ 52 + Int.unsigned _i ) ) as ( D & E & F ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))",
                    "F : eq\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))\n  (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0)",
                    "E : eq\n  (is_finite 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))) true",
                    "D : eq\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))\n  (IZR (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply B2R_Bsign_inj .",
                "tactic_sig_no_out_arg": "apply B2R_Bsign_inj .",
                "tactic_args": [
                    "_goal : eq (from_words ox4330_0000 x)\n  (BofZ 53 1024 eq_refl eq_refl (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (is_finite 53 1024 (from_words ox4330_0000 x)) true",
                    "_goal : eq\n  (is_finite 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))) true",
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))",
                    "_goal : eq (Bsign 53 1024 (from_words ox4330_0000 x))\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (is_finite 53 1024 (from_words ox4330_0000 x)) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq\n  (is_finite 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))) true"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))"
                ],
                "tactic_res": [
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))"
                ],
                "tactic_res": [
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))"
                ]
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "_goal : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))",
                    "A : eq (B2R 53 1024 (from_words ox4330_0000 x))\n  (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))",
                    "D : eq\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))\n  (IZR (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))\n  (IZR (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "rewrite plus_IZR .",
                "tactic_sig_no_out_arg": "rewrite plus_IZR .",
                "tactic_args": [
                    "_goal : eq (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))\n  (IZR (Z.add (Z.pow 2 52) (Int.unsigned x)))"
                ],
                "tactic_res": [
                    "_goal : eq (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))\n  (Rplus (IZR (Z.pow 2 52)) (IZR (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq (Rplus (bpow radix2 52) (IZR (Int.unsigned x)))\n  (Rplus (IZR (Z.pow 2 52)) (IZR (Int.unsigned x)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i , _i .",
                "tactic_sig_no_out_arg": "rewrite _i , _i .",
                "tactic_args": [
                    "_goal : eq (Bsign 53 1024 (from_words ox4330_0000 x))\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))",
                    "C : eq (Bsign 53 1024 (from_words ox4330_0000 x)) false",
                    "F : eq\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x))))\n  (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0)"
                ],
                "tactic_res": [
                    "_goal : eq false (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0)"
                ]
            },
            {
                "tactic_sig": "symmetry .",
                "tactic_sig_no_out_arg": "symmetry .",
                "tactic_args": [
                    "_goal : eq false (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0)"
                ],
                "tactic_res": [
                    "_goal : eq (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0) false"
                ]
            },
            {
                "tactic_sig": "apply Zlt_bool_false .",
                "tactic_sig_no_out_arg": "apply Zlt_bool_false .",
                "tactic_args": [
                    "_goal : eq (Z.ltb (Z.add (Z.pow 2 52) (Int.unsigned x)) 0) false"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow 2 52) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow 2 52) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow 2 52) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow 2 52) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))",
                    "F : eq\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))))\n  (Z.ltb (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)) 0)",
                    "E : eq\n  (is_finite 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))) true",
                    "D : eq\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))))\n  (IZR (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))",
                    "F : eq\n  (Bsign 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add 4503599627370496 (Int.unsigned x))))\n  (Z.ltb (Z.add 4503599627370496 (Int.unsigned x)) 0)",
                    "E : eq\n  (is_finite 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add 4503599627370496 (Int.unsigned x)))) true",
                    "D : eq\n  (B2R 53 1024\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add 4503599627370496 (Int.unsigned x))))\n  (IZR (Z.add 4503599627370496 (Int.unsigned x)))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.le 0 (Z.add 4503599627370496 (Int.unsigned x))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "of_intu_from_words",
        "proof": [
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : Int.int,\neq (of_intu x)\n  (sub (from_words ox4330_0000 x) (from_words ox4330_0000 Int.zero))"
                ],
                "tactic_res": [
                    "_goal : eq (of_intu x)\n  (sub (from_words ox4330_0000 x) (from_words ox4330_0000 Int.zero))",
                    "x : Int.int"
                ]
            },
            {
                "tactic_sig": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_sig_no_out_arg": "pose proof ( Int.unsigned_range _i ) .",
                "tactic_args": [
                    "x : Int.int"
                ],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) Int.modulus)"
                ]
            },
            {
                "tactic_sig": "rewrite ! from_words_eq .",
                "tactic_sig_no_out_arg": "rewrite ! from_words_eq .",
                "tactic_args": [
                    "_goal : eq (of_intu x)\n  (sub (from_words ox4330_0000 x) (from_words ox4330_0000 Int.zero))"
                ],
                "tactic_res": [
                    "_goal : eq (of_intu x)\n  (sub\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ]
            },
            {
                "tactic_sig": "unfold sub .",
                "tactic_sig_no_out_arg": "unfold sub .",
                "tactic_args": [
                    "_goal : eq (of_intu x)\n  (sub\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ],
                "tactic_res": [
                    "_goal : eq (of_intu x)\n  (Bminus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ]
            },
            {
                "tactic_sig": "rewrite BofZ_minus .",
                "tactic_sig_no_out_arg": "rewrite BofZ_minus .",
                "tactic_args": [
                    "_goal : eq (of_intu x)\n  (Bminus 53 1024 eq_refl eq_refl binop_nan mode_NE\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned x)))\n     (BofZ 53 1024 eq_refl eq_refl\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ],
                "tactic_res": [
                    "_goal : eq (of_intu x)\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))",
                    "_goal : integer_representable 53 1024 (Z.add (Z.pow 2 52) (Int.unsigned x))",
                    "_goal : integer_representable 53 1024\n  (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))"
                ]
            },
            {
                "tactic_sig": "unfold of_intu .",
                "tactic_sig_no_out_arg": "unfold of_intu .",
                "tactic_args": [
                    "_goal : eq (of_intu x)\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ],
                "tactic_res": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ]
            },
            {
                "tactic_sig": "apply ( f_equal ( BofZ 53 1024 __ __ ) ) .",
                "tactic_sig_no_out_arg": "apply ( f_equal ( BofZ 53 1024 __ __ ) ) .",
                "tactic_args": [
                    "_goal : eq (BofZ 53 1024 eq_refl eq_refl (Int.unsigned x))\n  (BofZ 53 1024 eq_refl eq_refl\n     (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n        (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x)\n  (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n     (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)))"
                ]
            },
            {
                "tactic_sig": "rewrite Int.unsigned_zero .",
                "tactic_sig_no_out_arg": "rewrite Int.unsigned_zero .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x)\n  (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x))\n     (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)))"
                ],
                "tactic_res": [
                    "_goal : eq (Int.unsigned x)\n  (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.add (Z.pow 2 52) 0))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : eq (Int.unsigned x)\n  (Z.sub (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.add (Z.pow 2 52) 0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply integer_representable_n .",
                "tactic_sig_no_out_arg": "apply integer_representable_n .",
                "tactic_args": [
                    "_goal : integer_representable 53 1024 (Z.add (Z.pow 2 52) (Int.unsigned x))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "simpl radix_val in * .",
                "tactic_sig_no_out_arg": "simpl radix_val in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "simpl Z.pow in * .",
                "tactic_sig_no_out_arg": "simpl Z.pow in * .",
                "tactic_args": [
                    "_goal : and (Z.le (Z.opp (Z.pow 2 53)) (Z.add (Z.pow 2 52) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned x)) (Z.pow 2 53))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.modulus .",
                "tactic_args": [],
                "tactic_res": [
                    "H : and (Z.le 0 (Int.unsigned x)) (Z.lt (Int.unsigned x) 4294967296)"
                ]
            },
            {
                "tactic_sig": "compute_this Int.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int.half_modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int.max_unsigned .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.min_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.min_signed .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int.max_signed .",
                "tactic_sig_no_out_arg": "compute_this Int.max_signed .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.half_modulus .",
                "tactic_sig_no_out_arg": "compute_this Int64.half_modulus .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this Int64.max_unsigned .",
                "tactic_sig_no_out_arg": "compute_this Int64.max_unsigned .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 1024 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 53 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow_pos 2 53%positive))\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     (Z.pow_pos 2 53%positive))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 52 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x)))\n  (Z.le (Z.add (Z.pow_pos 2 52%positive) (Int.unsigned x))\n     9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_sig_no_out_arg": "compute_this ( Z.pow_pos 2 32 ) .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "zify .",
                "tactic_sig_no_out_arg": "zify .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp 9007199254740992)\n     (Z.add 4503599627370496 (Int.unsigned x)))\n  (Z.le (Z.add 4503599627370496 (Int.unsigned x)) 9007199254740992)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply integer_representable_n .",
                "tactic_sig_no_out_arg": "apply integer_representable_n .",
                "tactic_args": [
                    "_goal : integer_representable 53 1024\n  (Z.add (Z.pow 2 52) (Int.unsigned Int.zero))"
                ],
                "tactic_res": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow 2 53))\n     (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)) (Z.pow 2 53))"
                ]
            },
            {
                "tactic_sig": "easy .",
                "tactic_sig_no_out_arg": "easy .",
                "tactic_args": [
                    "_goal : and\n  (Z.le (Z.opp (Z.pow 2 53))\n     (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)))\n  (Z.le (Z.add (Z.pow 2 52) (Int.unsigned Int.zero)) (Z.pow 2 53))"
                ],
                "tactic_res": []
            }
        ]
    }
]