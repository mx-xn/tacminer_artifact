[
    [
        {
            "tactic_sig": "unfold zwordsize , wordsize .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": [
                "_goal : Z.gt (Z.of_nat WS.wordsize) Z0"
            ]
        },
        {
            "tactic_sig": "generalize WS.wordsize_not_zero .",
            "tactic_args": [
                "_goal : Z.gt (Z.of_nat WS.wordsize) Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : not (eq WS.wordsize O), Z.gt (Z.of_nat WS.wordsize) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : not (eq WS.wordsize O), Z.gt (Z.of_nat WS.wordsize) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold modulus .",
            "tactic_args": [
                "_goal : eq modulus (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : eq (two_power_nat wordsize) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_power_nat_two_p .",
            "tactic_args": [
                "_goal : eq (two_power_nat wordsize) (two_p zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.gt modulus (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p zwordsize) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply Z.lt_gt .",
            "tactic_args": [
                "_goal : Z.gt (two_p zwordsize) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Zpos xH) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply ( two_p_monotone_strict 0 ) .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "generalize modulus_gt_one .",
            "tactic_args": [
                "_goal : Z.gt modulus Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt modulus (Zpos xH), Z.gt modulus Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt modulus (Zpos xH), Z.gt modulus Z0"
            ],
            "tactic_res": []
        }
    ],
    [],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : Z,\nand (Z.lt (Zneg xH) (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus)"
            ],
            "tactic_res": [
                "_goal : and (Z.lt (Zneg xH) (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus)",
                "x : Z"
            ]
        },
        {
            "tactic_sig": "generalize ( Z_mod_modulus_range _ ) .",
            "tactic_args": [
                "_goal : and (Z.lt (Zneg xH) (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus)",
                "x : Z"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : and (Z.le Z0 (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus),\nand (Z.lt (Zneg xH) (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus)"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : forall\n  _ : and (Z.le Z0 (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus),\nand (Z.lt (Zneg xH) (Z_mod_modulus x)) (Z.lt (Z_mod_modulus x) modulus)"
            ],
            "tactic_res": []
        }
    ],
    [],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : Z) (Px : and (Z.lt (Zneg xH) x) (Z.lt x modulus))\n  (Py : and (Z.lt (Zneg xH) y) (Z.lt y modulus)) (_ : eq x y),\neq {| intval := x; intrange := Px |} {| intval := y; intrange := Py |}"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := Px |} {| intval := y; intrange := Py |}",
                "H : eq x y",
                "Py : and (Z.lt (Zneg xH) y) (Z.lt y modulus)",
                "Px : and (Z.lt (Zneg xH) x) (Z.lt x modulus)",
                "x : Z",
                "y : Z"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := Px |} {| intval := y; intrange := Py |}",
                "y : Z"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := Px |} {| intval := x; intrange := Py |}",
                "Py : and (Z.lt (Zneg xH) x) (Z.lt x modulus)"
            ]
        },
        {
            "tactic_sig": "assert ( forall ( n m : Z ) ( P1 P2 : n < m ) , P1 = P2 ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall (n m : Z) (P1 P2 : Z.lt n m), eq P1 P2",
                "H : forall (n m : Z) (P1 P2 : Z.lt n m), eq P1 P2"
            ]
        },
        {
            "tactic_sig": "unfold Z.lt .",
            "tactic_args": [
                "_goal : forall (n m : Z) (P1 P2 : Z.lt n m), eq P1 P2"
            ],
            "tactic_res": [
                "_goal : forall (n m : Z) (P1 P2 : eq (Z.compare n m) Lt), eq P1 P2"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n m : Z) (P1 P2 : eq (Z.compare n m) Lt), eq P1 P2"
            ],
            "tactic_res": [
                "_goal : eq P1 P2",
                "P1 : eq (Z.compare n m) Lt",
                "P2 : eq (Z.compare n m) Lt",
                "n : Z",
                "m : Z"
            ]
        },
        {
            "tactic_sig": "apply eq_proofs_unicity .",
            "tactic_args": [
                "_goal : eq P1 P2"
            ],
            "tactic_res": [
                "_goal : forall x y : Datatypes.comparison, or (eq x y) (not (eq x y))"
            ]
        },
        {
            "tactic_sig": "intros c1 c2 .",
            "tactic_args": [
                "_goal : forall x y : Datatypes.comparison, or (eq x y) (not (eq x y))"
            ],
            "tactic_res": [
                "_goal : or (eq c1 c2) (not (eq c1 c2))",
                "c1 : Datatypes.comparison",
                "c2 : Datatypes.comparison"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : or (eq c1 c2) (not (eq c1 c2))",
                "c1 : Datatypes.comparison"
            ],
            "tactic_res": [
                "_goal : or (eq Eq c2) (not (eq Eq c2))",
                "_goal : or (eq Lt c2) (not (eq Lt c2))",
                "_goal : or (eq Gt c2) (not (eq Gt c2))"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : or (eq Eq c2) (not (eq Eq c2))",
                "c2 : Datatypes.comparison"
            ],
            "tactic_res": [
                "_goal : or (eq Eq Eq) (not (eq Eq Eq))",
                "_goal : or (eq Eq Lt) (not (eq Eq Lt))",
                "_goal : or (eq Eq Gt) (not (eq Eq Gt))"
            ]
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Eq Eq) (not (eq Eq Eq))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Eq Lt) (not (eq Eq Lt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Eq Gt) (not (eq Eq Gt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : or (eq Lt c2) (not (eq Lt c2))",
                "c2 : Datatypes.comparison"
            ],
            "tactic_res": [
                "_goal : or (eq Lt Eq) (not (eq Lt Eq))",
                "_goal : or (eq Lt Lt) (not (eq Lt Lt))",
                "_goal : or (eq Lt Gt) (not (eq Lt Gt))"
            ]
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Lt Eq) (not (eq Lt Eq))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Lt Lt) (not (eq Lt Lt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Lt Gt) (not (eq Lt Gt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : or (eq Gt c2) (not (eq Gt c2))",
                "c2 : Datatypes.comparison"
            ],
            "tactic_res": [
                "_goal : or (eq Gt Eq) (not (eq Gt Eq))",
                "_goal : or (eq Gt Lt) (not (eq Gt Lt))",
                "_goal : or (eq Gt Gt) (not (eq Gt Gt))"
            ]
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Gt Eq) (not (eq Gt Eq))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Gt Lt) (not (eq Gt Lt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "( left ; reflexivity ) || ( right ; congruence ) .",
            "tactic_args": [
                "_goal : or (eq Gt Gt) (not (eq Gt Gt))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct _ as [ Px1 Px2 ] .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := Px |} {| intval := x; intrange := Py |}",
                "Px : and (Z.lt (Zneg xH) x) (Z.lt x modulus)"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := conj Px1 Px2 |}\n  {| intval := x; intrange := Py |}",
                "Px2 : Z.lt x modulus",
                "Px1 : Z.lt (Zneg xH) x"
            ]
        },
        {
            "tactic_sig": "destruct _ as [ Py1 Py2 ] .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := conj Px1 Px2 |}\n  {| intval := x; intrange := Py |}",
                "Py : and (Z.lt (Zneg xH) x) (Z.lt x modulus)"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := conj Px1 Px2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}",
                "Py2 : Z.lt x modulus",
                "Py1 : Z.lt (Zneg xH) x"
            ]
        },
        {
            "tactic_sig": "rewrite ( _ _ _ _ _ ) .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := conj Px1 Px2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}",
                "H : forall (n m : Z) (P1 P2 : Z.lt n m), eq P1 P2",
                "Px1 : Z.lt (Zneg xH) x",
                "Py1 : Z.lt (Zneg xH) x"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := conj Py1 Px2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}"
            ]
        },
        {
            "tactic_sig": "rewrite ( _ _ _ _ _ ) .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := conj Py1 Px2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}",
                "H : forall (n m : Z) (P1 P2 : Z.lt n m), eq P1 P2",
                "Px2 : Z.lt x modulus",
                "Py2 : Z.lt x modulus"
            ],
            "tactic_res": [
                "_goal : eq {| intval := x; intrange := conj Py1 Py2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : eq {| intval := x; intrange := conj Py1 Py2 |}\n  {| intval := x; intrange := conj Py1 Py2 |}"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, sumbool (eq x y) (not (eq x y))"
            ],
            "tactic_res": [
                "_goal : sumbool (eq x y) (not (eq x y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : sumbool (eq x y) (not (eq x y))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : sumbool (eq {| intval := intval0; intrange := intrange0 |} y)\n  (not (eq {| intval := intval0; intrange := intrange0 |} y))",
                "intrange0 : and (Z.lt (Zneg xH) intval0) (Z.lt intval0 modulus)",
                "intval0 : Z"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : sumbool (eq {| intval := intval0; intrange := intrange0 |} y)\n  (not (eq {| intval := intval0; intrange := intrange0 |} y))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : sumbool\n  (eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})\n  (not\n     (eq {| intval := intval0; intrange := intrange0 |}\n        {| intval := intval1; intrange := intrange1 |}))",
                "intrange1 : and (Z.lt (Zneg xH) intval1) (Z.lt intval1 modulus)",
                "intval1 : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq _ _ ) .",
            "tactic_args": [
                "intval0 : Z",
                "intval1 : Z"
            ],
            "tactic_res": [
                "e : eq intval0 intval1",
                "n : not (eq intval0 intval1)"
            ]
        },
        {
            "tactic_sig": "left .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ]
        },
        {
            "tactic_sig": "apply mkint_eq .",
            "tactic_args": [
                "_goal : eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ],
            "tactic_res": [
                "_goal : eq intval0 intval1"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : eq intval0 intval1"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "right .",
            "tactic_args": [
                "_goal : sumbool\n  (eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})\n  (not\n     (eq {| intval := intval0; intrange := intrange0 |}\n        {| intval := intval1; intrange := intrange1 |}))"
            ],
            "tactic_res": [
                "_goal : not\n  (eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : not\n  (eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : eq {| intval := intval0; intrange := intrange0 |}\n        {| intval := intval1; intrange := intrange1 |}, False"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall\n  _ : eq {| intval := intval0; intrange := intrange0 |}\n        {| intval := intval1; intrange := intrange1 |}, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H : eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ]
        },
        {
            "tactic_sig": "injection _ .",
            "tactic_args": [
                "_goal : False",
                "H : eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ],
            "tactic_res": [
                "_goal : forall _ : eq intval0 intval1, False"
            ]
        },
        {
            "tactic_sig": "exact _ .",
            "tactic_args": [
                "_goal : forall _ : eq intval0 intval1, False",
                "n : not (eq intval0 intval1)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold half_modulus .",
            "tactic_args": [
                "_goal : Logic.eq half_modulus (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div modulus (Zpos (xO xH)))\n  (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div modulus (Zpos (xO xH)))\n  (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div (two_p zwordsize) (Zpos (xO xH)))\n  (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "set ( ws1 := zwordsize - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div (two_p zwordsize) (Zpos (xO xH)))\n  (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div (two_p zwordsize) (Zpos (xO xH))) (two_p ws1)",
                "ws1 : Z"
            ]
        },
        {
            "tactic_sig": "replace ( zwordsize ) with ( Z.succ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div (two_p zwordsize) (Zpos (xO xH))) (two_p ws1)",
                "ws1 : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div (two_p (Z.succ ws1)) (Zpos (xO xH))) (two_p ws1)",
                "_goal : Logic.eq (Z.succ ws1) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite two_p_S .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div (two_p (Z.succ ws1)) (Zpos (xO xH))) (two_p ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div (Z.mul (Zpos (xO xH)) (two_p ws1)) (Zpos (xO xH)))\n  (two_p ws1)",
                "_goal : Z.le Z0 ws1"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mul_comm .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div (Z.mul (Zpos (xO xH)) (two_p ws1)) (Zpos (xO xH)))\n  (two_p ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div (Z.mul (two_p ws1) (Zpos (xO xH))) (Zpos (xO xH)))\n  (two_p ws1)"
            ]
        },
        {
            "tactic_sig": "apply Z_div_mult .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div (Z.mul (two_p ws1) (Zpos (xO xH))) (Zpos (xO xH)))\n  (two_p ws1)"
            ],
            "tactic_res": [
                "_goal : Z.gt (Zpos (xO xH)) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.gt (Zpos (xO xH)) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Z.le Z0 ws1",
                "ws1 : Z"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.succ ws1) zwordsize",
                "ws1 : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.succ (Z.sub zwordsize (Zpos xH))) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.succ (Z.sub zwordsize (Zpos xH))) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "rewrite half_modulus_power .",
            "tactic_args": [
                "_goal : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq modulus\n  (Z.mul (Zpos (xO xH)) (two_p (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Logic.eq modulus\n  (Z.mul (Zpos (xO xH)) (two_p (Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p zwordsize)\n  (Z.mul (Zpos (xO xH)) (two_p (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_p_S .",
            "tactic_args": [
                "_goal : Logic.eq (two_p zwordsize)\n  (Z.mul (Zpos (xO xH)) (two_p (Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p zwordsize) (two_p (Z.succ (Z.sub zwordsize (Zpos xH))))",
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "apply f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (two_p zwordsize) (two_p (Z.succ (Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq zwordsize (Z.succ (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq zwordsize (Z.succ (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "rewrite half_modulus_power .",
            "tactic_args": [
                "_goal : Z.gt half_modulus Z0"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p (Z.sub zwordsize (Zpos xH))) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p (Z.sub zwordsize (Zpos xH))) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold min_signed .",
            "tactic_args": [
                "_goal : Z.lt min_signed Z0"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.opp half_modulus) Z0"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.lt (Z.opp half_modulus) Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt (Z.opp half_modulus) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt (Z.opp half_modulus) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : Z.ge max_signed Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.sub half_modulus (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub half_modulus (Zpos xH)) Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.ge (Z.sub half_modulus (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.ge (Z.sub half_modulus (Zpos xH)) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "assert ( zwordsize < modulus ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Z.lt zwordsize modulus",
                "H : Z.lt zwordsize modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt zwordsize modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt zwordsize (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_strict .",
            "tactic_args": [
                "_goal : Z.lt zwordsize (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.ge zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.ge zwordsize Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.ge zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.ge zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Z.le zwordsize max_unsigned"
            ],
            "tactic_res": [
                "_goal : Z.le zwordsize (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le zwordsize (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "assert ( 2 * zwordsize - 1 < modulus ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Z.lt (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH)) modulus",
                "H : Z.lt (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH)) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH)) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n  (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_strict_2 .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n  (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.ge zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.ge zwordsize Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.ge zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.ge zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH)) max_unsigned"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n  (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n  (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold max_signed , max_unsigned .",
            "tactic_args": [
                "_goal : Z.lt max_signed max_unsigned"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub half_modulus (Zpos xH)) (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub half_modulus (Zpos xH)) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub half_modulus (Zpos xH))\n  (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub half_modulus (Zpos xH))\n  (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0,\nZ.lt (Z.sub half_modulus (Zpos xH))\n  (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0,\nZ.lt (Z.sub half_modulus (Zpos xH))\n  (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : Z, Logic.eq (unsigned (repr x)) (Z.modulo x modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr x)) (Z.modulo x modulus)",
                "x : Z"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr x)) (Z.modulo x modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z_mod_modulus x) (Z.modulo x modulus)"
            ]
        },
        {
            "tactic_sig": "apply Z_mod_modulus_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z_mod_modulus x) (Z.modulo x modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : Z,\nLogic.eq (signed (repr x))\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr x))\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)",
                "x : Z"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr x))\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr x)) half_modulus\n   then unsigned (repr x)\n   else Z.sub (unsigned (repr x)) modulus)\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr x)) half_modulus\n   then unsigned (repr x)\n   else Z.sub (unsigned (repr x)) modulus)\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)\n  (if zlt (Z.modulo x modulus) half_modulus\n   then Z.modulo x modulus\n   else Z.sub (Z.modulo x modulus) modulus)"
            ],
            "tactic_res": []
        }
    ],
    [],
    [],
    [],
    [],
    [],
    [],
    [],
    [],
    [],
    [],
    [],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : Z) (_ : eqm x y), Logic.eq (repr x) (repr y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr x) (repr y)",
                "H : eqm x y",
                "x : Z",
                "y : Z"
            ]
        },
        {
            "tactic_sig": "unfold repr .",
            "tactic_args": [
                "_goal : Logic.eq (repr x) (repr y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  {| intval := Z_mod_modulus x; intrange := Z_mod_modulus_range' x |}\n  {| intval := Z_mod_modulus y; intrange := Z_mod_modulus_range' y |}"
            ]
        },
        {
            "tactic_sig": "apply mkint_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  {| intval := Z_mod_modulus x; intrange := Z_mod_modulus_range' x |}\n  {| intval := Z_mod_modulus y; intrange := Z_mod_modulus_range' y |}"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z_mod_modulus x) (Z_mod_modulus y)"
            ]
        },
        {
            "tactic_sig": "rewrite !Z_mod_modulus_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z_mod_modulus x) (Z_mod_modulus y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo x modulus) (Z.modulo y modulus)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo x modulus) (Z.modulo y modulus)"
            ],
            "tactic_res": [
                "_goal : Z.gt modulus Z0",
                "_goal : eqmod modulus x y"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Z.gt modulus Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exact _ .",
            "tactic_args": [
                "_goal : eqmod modulus x y",
                "H : eqm x y"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold eqm .",
            "tactic_args": [
                "_goal : forall z : Z, eqm z (unsigned (repr z))"
            ],
            "tactic_res": [
                "_goal : forall z : Z, eqmod modulus z (unsigned (repr z))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall z : Z, eqmod modulus z (unsigned (repr z))"
            ],
            "tactic_res": [
                "_goal : eqmod modulus z (unsigned (repr z))",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : eqmod modulus z (unsigned (repr z))"
            ],
            "tactic_res": [
                "_goal : eqmod modulus z (Z.modulo z modulus)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod .",
            "tactic_args": [
                "_goal : eqmod modulus z (Z.modulo z modulus)"
            ],
            "tactic_res": [
                "_goal : Z.gt modulus Z0"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Z.gt modulus Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a b : Z) (_ : eqm a b), eqm (unsigned (repr a)) b"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr a)) b",
                "H : eqm a b",
                "a : Z",
                "b : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with _ .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr a)) b",
                "a : Z"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr a)) a",
                "_goal : eqm a b"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr a)) a"
            ],
            "tactic_res": [
                "_goal : eqm a (unsigned (repr a))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm a (unsigned (repr a))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : eqm a b"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a b : Z) (_ : eqm a b), eqm a (unsigned (repr b))"
            ],
            "tactic_res": [
                "_goal : eqm a (unsigned (repr b))",
                "H : eqm a b",
                "a : Z",
                "b : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with _ .",
            "tactic_args": [
                "_goal : eqm a (unsigned (repr b))",
                "b : Z"
            ],
            "tactic_res": [
                "_goal : eqm a b",
                "_goal : eqm b (unsigned (repr b))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : eqm a b"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm b (unsigned (repr b))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, eqm (signed x) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : eqmod modulus (signed x) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod modulus\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "set ( y := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqmod modulus\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus) (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (if zlt y half_modulus then y else Z.sub y modulus) y",
                "y : Z"
            ]
        },
        {
            "tactic_sig": "case ( zlt _ half_modulus ) .",
            "tactic_args": [
                "_goal : eqmod modulus (if zlt y half_modulus then y else Z.sub y modulus) y",
                "y : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt y half_modulus, eqmod modulus y y",
                "_goal : forall _ : Z.ge y half_modulus, eqmod modulus (Z.sub y modulus) y"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.lt y half_modulus, eqmod modulus y y"
            ],
            "tactic_res": [
                "_goal : eqmod modulus y y",
                "l : Z.lt y half_modulus"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.ge y half_modulus, eqmod modulus (Z.sub y modulus) y"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (Z.sub y modulus) y",
                "g : Z.ge y half_modulus"
            ]
        },
        {
            "tactic_sig": "apply eqmod_refl .",
            "tactic_args": [
                "_goal : eqmod modulus y y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : eqmod modulus (Z.sub y modulus) y"
            ],
            "tactic_res": [
                "_goal : ex\n  (fun k : Z => Logic.eq (Z.sub y modulus) (Z.add (Z.mul k modulus) y))"
            ]
        },
        {
            "tactic_sig": "exists ( - 1 ) .",
            "tactic_args": [
                "_goal : ex\n  (fun k : Z => Logic.eq (Z.sub y modulus) (Z.add (Z.mul k modulus) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub y modulus) (Z.add (Z.mul (Zneg xH) modulus) y)"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub y modulus) (Z.add (Z.mul (Zneg xH) modulus) y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "destruct i .",
            "tactic_args": [
                "_goal : forall i : int,\nLogic.and (Z.le Z0 (unsigned i)) (Z.lt (unsigned i) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le Z0 (unsigned {| intval := intval0; intrange := intrange0 |}))\n  (Z.lt (unsigned {| intval := intval0; intrange := intrange0 |})\n     modulus)",
                "intrange0 : and (Z.lt (Zneg xH) intval0) (Z.lt intval0 modulus)",
                "intval0 : Z"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (unsigned {| intval := intval0; intrange := intrange0 |}))\n  (Z.lt (unsigned {| intval := intval0; intrange := intrange0 |})\n     modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 intval0) (Z.lt intval0 modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 intval0) (Z.lt intval0 modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall i : int,\nLogic.and (Z.le Z0 (unsigned i)) (Z.le (unsigned i) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned i)) (Z.le (unsigned i) max_unsigned)",
                "i : int"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned i)) (Z.le (unsigned i) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned i))\n  (Z.le (unsigned i) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned i))\n  (Z.le (unsigned i) (Z.sub modulus (Zpos xH)))",
                "i : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned i)) (Z.lt (unsigned i) modulus),\nLogic.and (Z.le Z0 (unsigned i))\n  (Z.le (unsigned i) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned i)) (Z.lt (unsigned i) modulus),\nLogic.and (Z.le Z0 (unsigned i))\n  (Z.le (unsigned i) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall i : int,\nLogic.and (Z.le min_signed (signed i)) (Z.le (signed i) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (signed i)) (Z.le (signed i) max_signed)",
                "i : int"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (signed i)) (Z.le (signed i) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le min_signed\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus))\n  (Z.le\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus) max_signed)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus))\n  (Z.le\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus) max_signed)",
                "i : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned i)) (Z.lt (unsigned i) modulus),\nLogic.and\n  (Z.le min_signed\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus))\n  (Z.le\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus) max_signed)"
            ]
        },
        {
            "tactic_sig": "set ( n := unsigned _ ) .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned i)) (Z.lt (unsigned i) modulus),\nLogic.and\n  (Z.le min_signed\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus))\n  (Z.le\n     (if zlt (unsigned i) half_modulus\n      then unsigned i\n      else Z.sub (unsigned i) modulus) max_signed)",
                "i : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 n) (Z.lt n modulus),\nLogic.and\n  (Z.le min_signed (if zlt n half_modulus then n else Z.sub n modulus))\n  (Z.le (if zlt n half_modulus then n else Z.sub n modulus) max_signed)",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 n) (Z.lt n modulus),\nLogic.and\n  (Z.le min_signed (if zlt n half_modulus then n else Z.sub n modulus))\n  (Z.le (if zlt n half_modulus then n else Z.sub n modulus) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le min_signed (if zlt n half_modulus then n else Z.sub n modulus))\n  (Z.le (if zlt n half_modulus then n else Z.sub n modulus) max_signed)",
                "H : Logic.and (Z.le Z0 n) (Z.lt n modulus)"
            ]
        },
        {
            "tactic_sig": "case ( zlt _ half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed (if zlt n half_modulus then n else Z.sub n modulus))\n  (Z.le (if zlt n half_modulus then n else Z.sub n modulus) max_signed)",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt n half_modulus,\nLogic.and (Z.le min_signed n) (Z.le n max_signed)",
                "_goal : forall _ : Z.ge n half_modulus,\nLogic.and (Z.le min_signed (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) max_signed)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.lt n half_modulus,\nLogic.and (Z.le min_signed n) (Z.le n max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed n) (Z.le n max_signed)",
                "l : Z.lt n half_modulus"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.ge n half_modulus,\nLogic.and (Z.le min_signed (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) max_signed)",
                "g : Z.ge n half_modulus"
            ]
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed n) (Z.le n max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed n) (Z.le n (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize min_signed_neg .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed n) (Z.le n (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed n) (Z.le n (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed n) (Z.le n (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold min_signed , max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus in * .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub n modulus))\n  (Z.le (Z.sub n modulus) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp half_modulus)\n     (Z.sub n (Z.mul (Zpos (xO xH)) half_modulus)))\n  (Z.le (Z.sub n (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.sub half_modulus (Zpos xH)))",
                "H : Logic.and (Z.le Z0 n) (Z.lt n (Z.mul (Zpos (xO xH)) half_modulus))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp half_modulus)\n     (Z.sub n (Z.mul (Zpos (xO xH)) half_modulus)))\n  (Z.le (Z.sub n (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "destruct i .",
            "tactic_args": [
                "_goal : forall i : int, Logic.eq (repr (unsigned i)) i"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (unsigned {| intval := intval0; intrange := intrange0 |}))\n  {| intval := intval0; intrange := intrange0 |}",
                "intrange0 : and (Z.lt (Zneg xH) intval0) (Z.lt intval0 modulus)",
                "intval0 : Z"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (unsigned {| intval := intval0; intrange := intrange0 |}))\n  {| intval := intval0; intrange := intrange0 |}"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr intval0) {| intval := intval0; intrange := intrange0 |}"
            ]
        },
        {
            "tactic_sig": "unfold repr .",
            "tactic_args": [
                "_goal : Logic.eq (repr intval0) {| intval := intval0; intrange := intrange0 |}"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  {|\n  intval := Z_mod_modulus intval0;\n  intrange := Z_mod_modulus_range' intval0 |}\n  {| intval := intval0; intrange := intrange0 |}"
            ]
        },
        {
            "tactic_sig": "apply mkint_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  {|\n  intval := Z_mod_modulus intval0;\n  intrange := Z_mod_modulus_range' intval0 |}\n  {| intval := intval0; intrange := intrange0 |}"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z_mod_modulus intval0) intval0"
            ]
        },
        {
            "tactic_sig": "rewrite Z_mod_modulus_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z_mod_modulus intval0) intval0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo intval0 modulus) intval0"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo intval0 modulus) intval0"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 intval0) (Z.lt intval0 modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 intval0) (Z.lt intval0 modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall i : int, Logic.eq (repr (signed i)) i"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed i)) i",
                "i : int"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed i)) i",
                "i : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed i)) (repr (unsigned i))",
                "_goal : Logic.eq (repr (unsigned i)) i"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed i)) (repr (unsigned i))"
            ],
            "tactic_res": [
                "_goal : eqm (signed i) (unsigned i)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed i) (unsigned i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned i)) i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : Z) (y : int) (_ : eqm x (unsigned y)), Logic.eq (repr x) y"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr x) y",
                "H : eqm x (unsigned y)",
                "y : int",
                "x : Z"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr x) y",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr x) (repr (unsigned y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr x) (repr (unsigned y))"
            ],
            "tactic_res": [
                "_goal : eqm x (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : eqm x (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (z : Z) (_ : Logic.and (Z.le Z0 z) (Z.le z max_unsigned)),\nLogic.eq (unsigned (repr z)) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr z)) z",
                "H : Logic.and (Z.le Z0 z) (Z.le z max_unsigned)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr z)) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo z modulus) z"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo z modulus) z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 z) (Z.lt z modulus)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 z) (Z.le z max_unsigned)"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 z) (Z.le z (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 z) (Z.lt z modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (z : Z) (_ : Logic.and (Z.le min_signed z) (Z.le z max_signed)),\nLogic.eq (signed (repr z)) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr z)) z",
                "H : Logic.and (Z.le min_signed z) (Z.le z max_signed)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr z)) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr z)) half_modulus\n   then unsigned (repr z)\n   else Z.sub (unsigned (repr z)) modulus) z"
            ]
        },
        {
            "tactic_sig": "destruct ( zle 0 _ ) .",
            "tactic_args": [
                "z : Z"
            ],
            "tactic_res": [
                "l : Z.le Z0 z",
                "g : Z.gt Z0 z"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned ( repr _ ) ) with _ .",
            "tactic_args": [
                "z : Z",
                "z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt z half_modulus then z else Z.sub z modulus) z",
                "_goal : Logic.eq z (unsigned (repr z))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt z half_modulus then z else Z.sub z modulus) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq z z",
                "_goal : Z.lt z half_modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq z z"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_signed in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le min_signed z) (Z.le z max_signed)"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le min_signed z) (Z.le z (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt z half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq z (unsigned (repr z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr z)) z"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr z)) z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 z) (Z.le z max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize max_signed_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 z) (Z.le z max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt max_signed max_unsigned,\nLogic.and (Z.le Z0 z) (Z.le z max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt max_signed max_unsigned,\nLogic.and (Z.le Z0 z) (Z.le z max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "pose ( z' := _ + modulus ) .",
            "tactic_args": [
                "z : Z"
            ],
            "tactic_res": [
                "z' : Z"
            ]
        },
        {
            "tactic_sig": "replace ( repr _ ) with ( repr _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr z)) half_modulus\n   then unsigned (repr z)\n   else Z.sub (unsigned (repr z)) modulus) z",
                "z : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr z')) half_modulus\n   then unsigned (repr z')\n   else Z.sub (unsigned (repr z')) modulus) z",
                "_goal : Logic.eq (repr z') (repr z)"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned ( repr _ ) ) with _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr z')) half_modulus\n   then unsigned (repr z')\n   else Z.sub (unsigned (repr z')) modulus) z",
                "z' : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt z' half_modulus then z' else Z.sub z' modulus) z",
                "_goal : Logic.eq z' (unsigned (repr z'))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt z' half_modulus then z' else Z.sub z' modulus) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub z' modulus) z",
                "_goal : Z.ge z' half_modulus"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub z' modulus) z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add z modulus) modulus) z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add z modulus) modulus) z"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Z.ge z' half_modulus",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add z modulus) half_modulus"
            ]
        },
        {
            "tactic_sig": "unfold min_signed in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le min_signed z) (Z.le z max_signed)"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le (Z.opp half_modulus) z) (Z.le z max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus .",
            "tactic_args": [
                "_goal : Z.ge (Z.add z modulus) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add z (Z.mul (Zpos (xO xH)) half_modulus)) half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add z (Z.mul (Zpos (xO xH)) half_modulus)) half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq z' (unsigned (repr z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr z')) z'"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr z')) z'"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 z') (Z.le z' max_unsigned)"
            ]
        },
        {
            "tactic_sig": "unfold _ , max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 z') (Z.le z' max_unsigned)",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add z modulus))\n  (Z.le (Z.add z modulus) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "unfold min_signed , max_signed in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le min_signed z) (Z.le z max_signed)"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le (Z.opp half_modulus) z)\n  (Z.le z (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add z modulus))\n  (Z.le (Z.add z modulus) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add z (Z.mul (Zpos (xO xH)) half_modulus)))\n  (Z.le (Z.add z (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add z (Z.mul (Zpos (xO xH)) half_modulus)))\n  (Z.le (Z.add z (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr z') (repr z)"
            ],
            "tactic_res": [
                "_goal : eqm z' z"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : eqm z' z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add z modulus) z"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : eqm (Z.add z modulus) z"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (Z.add z modulus) z"
            ]
        },
        {
            "tactic_sig": "exists 1 .",
            "tactic_args": [
                "_goal : eqmod modulus (Z.add z modulus) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add z modulus) (Z.add (Z.mul (Zpos xH) modulus) z)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add z modulus) (Z.add (Z.mul (Zpos xH) modulus) z)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Z.le (unsigned x) max_signed),\nLogic.eq (signed x) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed x) (unsigned x)",
                "H : Z.le (unsigned x) max_signed",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed x) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus) (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned x) (unsigned x)",
                "_goal : Logic.eq (Z.sub (unsigned x) modulus) (unsigned x)",
                "l : Z.lt (unsigned x) half_modulus",
                "g : Z.ge (unsigned x) half_modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_signed in _ .",
            "tactic_args": [
                "H : Z.le (unsigned x) max_signed"
            ],
            "tactic_res": [
                "H : Z.le (unsigned x) (Z.sub half_modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omegaContradiction .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (unsigned x) modulus) (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, iff (Z.ge (signed x) Z0) (Z.le (unsigned x) max_signed)"
            ],
            "tactic_res": [
                "_goal : iff (Z.ge (signed x) Z0) (Z.le (unsigned x) max_signed)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold signed , max_signed .",
            "tactic_args": [
                "_goal : iff (Z.ge (signed x) Z0) (Z.le (unsigned x) max_signed)"
            ],
            "tactic_res": [
                "_goal : iff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) half_modulus_modulus half_modulus_pos .",
            "tactic_args": [
                "_goal : iff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus))\n  (_ : Z.gt half_modulus Z0),\niff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus))\n  (_ : Z.gt half_modulus Z0),\niff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : iff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))",
                "H1 : Z.gt half_modulus Z0",
                "H0 : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus)",
                "H : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : iff\n  (Z.ge\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : iff (Z.ge (unsigned x) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))",
                "_goal : iff (Z.ge (Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))",
                "l : Z.lt (unsigned x) half_modulus",
                "g : Z.ge (unsigned x) half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : iff (Z.ge (unsigned x) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : iff (Z.ge (Z.sub (unsigned x) modulus) Z0)\n  (Z.le (unsigned x) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold zero .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned zero) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr Z0)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr Z0)) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo Z0 modulus) Z0"
            ]
        },
        {
            "tactic_sig": "apply Zmod_0_l .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo Z0 modulus) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold one .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned one) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Zpos xH))) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Zpos xH))) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Zpos xH) modulus) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Zpos xH) modulus) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Zpos xH)) (Z.lt (Zpos xH) modulus)"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Zpos xH)) (Z.lt (Zpos xH) modulus)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Zpos xH)",
                "_goal : Z.lt (Zpos xH) modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Zpos xH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold modulus .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (Zpos xH) (two_power_nat wordsize)"
            ]
        },
        {
            "tactic_sig": "replace wordsize with ( S ( Init.Nat.pred wordsize ) ) .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) (two_power_nat wordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Zpos xH) (two_power_nat (S (Init.Nat.pred wordsize)))",
                "_goal : Logic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ]
        },
        {
            "tactic_sig": "rewrite two_power_nat_S .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) (two_power_nat (S (Init.Nat.pred wordsize)))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Zpos xH)\n  (Z.mul (Zpos (xO xH)) (two_power_nat (Init.Nat.pred wordsize)))"
            ]
        },
        {
            "tactic_sig": "generalize ( two_power_nat_pos ( Init.Nat.pred wordsize ) ) .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH)\n  (Z.mul (Zpos (xO xH)) (two_power_nat (Init.Nat.pred wordsize)))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt (two_power_nat (Init.Nat.pred wordsize)) Z0,\nZ.lt (Zpos xH)\n  (Z.mul (Zpos (xO xH)) (two_power_nat (Init.Nat.pred wordsize)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt (two_power_nat (Init.Nat.pred wordsize)) Z0,\nZ.lt (Zpos xH)\n  (Z.mul (Zpos (xO xH)) (two_power_nat (Init.Nat.pred wordsize)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Logic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ]
        },
        {
            "tactic_sig": "unfold zwordsize .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt (Z.of_nat wordsize) Z0,\nLogic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt (Z.of_nat wordsize) Z0,\nLogic.eq (S (Init.Nat.pred wordsize)) wordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold mone .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned mone) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Zneg xH))) (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Zneg xH))) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Zneg xH) modulus) (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "replace ( - 1 ) with ( ( modulus - 1 ) + ( - 1 ) * modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Zneg xH) modulus) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.modulo (Z.add (Z.sub modulus (Zpos xH)) (Z.mul (Zneg xH) modulus))\n     modulus) (Z.sub modulus (Zpos xH))",
                "_goal : Logic.eq (Z.add (Z.sub modulus (Zpos xH)) (Z.mul (Zneg xH) modulus))\n  (Zneg xH)"
            ]
        },
        {
            "tactic_sig": "rewrite Z_mod_plus_full .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.modulo (Z.add (Z.sub modulus (Zpos xH)) (Z.mul (Zneg xH) modulus))\n     modulus) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub modulus (Zpos xH)) modulus)\n  (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub modulus (Zpos xH)) modulus)\n  (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub modulus (Zpos xH)))\n  (Z.lt (Z.sub modulus (Zpos xH)) modulus)"
            ]
        },
        {
            "tactic_sig": "generalize modulus_pos .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub modulus (Zpos xH)))\n  (Z.lt (Z.sub modulus (Zpos xH)) modulus)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt modulus Z0,\nLogic.and (Z.le Z0 (Z.sub modulus (Zpos xH)))\n  (Z.lt (Z.sub modulus (Zpos xH)) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt modulus Z0,\nLogic.and (Z.le Z0 (Z.sub modulus (Zpos xH)))\n  (Z.lt (Z.sub modulus (Zpos xH)) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub modulus (Zpos xH)) (Z.mul (Zneg xH) modulus))\n  (Zneg xH)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed zero) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned zero) half_modulus\n   then unsigned zero\n   else Z.sub (unsigned zero) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned zero) half_modulus\n   then unsigned zero\n   else Z.sub (unsigned zero) modulus) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt Z0 half_modulus then Z0 else Z.sub Z0 modulus) Z0"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt Z0 half_modulus then Z0 else Z.sub Z0 modulus) Z0"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 half_modulus"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.lt Z0 half_modulus"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt Z0 half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt Z0 half_modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize (Zpos xH), Logic.eq (signed one) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed one) (Zpos xH)",
                "H : Z.gt zwordsize (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed one) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned one) half_modulus\n   then unsigned one\n   else Z.sub (unsigned one) modulus) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned one) half_modulus\n   then unsigned one\n   else Z.sub (unsigned one) modulus) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Zpos xH) half_modulus\n   then Zpos xH\n   else Z.sub (Zpos xH) modulus) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Zpos xH) half_modulus\n   then Zpos xH\n   else Z.sub (Zpos xH) modulus) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Zpos xH) half_modulus"
            ]
        },
        {
            "tactic_sig": "change 1 with ( two_p 0 ) .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p Z0) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p Z0) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p Z0) (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p Z0) (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed mone) (Zneg xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned mone) half_modulus\n   then unsigned mone\n   else Z.sub (unsigned mone) modulus) (Zneg xH)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_mone .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned mone) half_modulus\n   then unsigned mone\n   else Z.sub (unsigned mone) modulus) (Zneg xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub modulus (Zpos xH)) half_modulus\n   then Z.sub modulus (Zpos xH)\n   else Z.sub (Z.sub modulus (Zpos xH)) modulus) (Zneg xH)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub modulus (Zpos xH)) half_modulus\n   then Z.sub modulus (Zpos xH)\n   else Z.sub (Z.sub modulus (Zpos xH)) modulus) (Zneg xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub modulus (Zpos xH)) modulus) (Zneg xH)",
                "_goal : Z.ge (Z.sub modulus (Zpos xH)) half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub modulus (Zpos xH)) modulus) (Zneg xH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub modulus (Zpos xH)) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)) half_modulus"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)) half_modulus"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0,\nZ.ge (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)) half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0,\nZ.ge (Z.sub (Z.mul (Zpos (xO xH)) half_modulus) (Zpos xH)) half_modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "assert ( unsigned one <> unsigned zero ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (unsigned one) (unsigned zero))",
                "H : Logic.not (Logic.eq (unsigned one) (unsigned zero))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned one) (unsigned zero))"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (Zpos xH) (unsigned zero))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (Zpos xH) (unsigned zero))"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (Zpos xH) Z0)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (Zpos xH) Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq one zero)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold iwordsize .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned iwordsize) zwordsize"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr zwordsize)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr zwordsize)) zwordsize"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo zwordsize modulus) zwordsize"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo zwordsize modulus) zwordsize"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt zwordsize Z0)\n  (_ : Z.le zwordsize (Z.sub modulus (Zpos xH))),\nLogic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt zwordsize Z0)\n  (_ : Z.le zwordsize (Z.sub modulus (Zpos xH))),\nLogic.and (Z.le Z0 zwordsize) (Z.lt zwordsize modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq y x)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold eq .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (if zeq (unsigned y) (unsigned x) then true else false)"
            ]
        },
        {
            "tactic_sig": "case ( zeq ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (if zeq (unsigned y) (unsigned x) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned x) (unsigned y),\nLogic.eq true (if zeq (unsigned y) (unsigned x) then true else false)",
                "_goal : forall _ : Logic.not (Logic.eq (unsigned x) (unsigned y)),\nLogic.eq false (if zeq (unsigned y) (unsigned x) then true else false)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned x) (unsigned y),\nLogic.eq true (if zeq (unsigned y) (unsigned x) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (if zeq (unsigned y) (unsigned x) then true else false)",
                "e : Logic.eq (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq (unsigned x) (unsigned y)),\nLogic.eq false (if zeq (unsigned y) (unsigned x) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (if zeq (unsigned y) (unsigned x) then true else false)",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq true (if zeq (unsigned y) (unsigned x) then true else false)",
                "e : Logic.eq (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (if zeq (unsigned y) (unsigned y) then true else false)"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_true .",
            "tactic_args": [
                "_goal : Logic.eq true (if zeq (unsigned y) (unsigned y) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zeq_false .",
            "tactic_args": [
                "_goal : Logic.eq false (if zeq (unsigned y) (unsigned x) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.not (Logic.eq (unsigned y) (unsigned x))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned y) (unsigned x))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nif eq x y then Logic.eq x y else Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "_goal : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold eq .",
            "tactic_args": [
                "_goal : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "_goal : if if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "case ( eq_dec _ _ ) .",
            "tactic_args": [
                "_goal : if if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq x y,\nif if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)",
                "_goal : forall _ : Logic.not (Logic.eq x y),\nif if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq x y,\nif if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "_goal : if if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)",
                "e : Logic.eq x y"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq x y),\nif if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "n : Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "_goal : if if zeq (unsigned x) (unsigned x) then true else false\nthen Logic.eq x x\nelse Logic.not (Logic.eq x x)"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_true .",
            "tactic_args": [
                "_goal : if if zeq (unsigned x) (unsigned x) then true else false\nthen Logic.eq x x\nelse Logic.not (Logic.eq x x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq x x"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq x x"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zeq_false .",
            "tactic_args": [
                "_goal : if if zeq (unsigned x) (unsigned y) then true else false\nthen Logic.eq x y\nelse Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq x y)",
                "_goal : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned x) (unsigned y))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.not\n  (Logic.eq (unsigned {| intval := intval0; intrange := intrange0 |})\n     (unsigned y))",
                "n : Logic.not (Logic.eq {| intval := intval0; intrange := intrange0 |} y)",
                "intrange0 : Logic.and (Z.lt (Zneg xH) intval0) (Z.lt intval0 modulus)",
                "intval0 : Z"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.not\n  (Logic.eq (unsigned {| intval := intval0; intrange := intrange0 |})\n     (unsigned y))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.not\n  (Logic.eq (unsigned {| intval := intval0; intrange := intrange0 |})\n     (unsigned {| intval := intval1; intrange := intrange1 |}))",
                "n : Logic.not\n  (Logic.eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})",
                "intrange1 : Logic.and (Z.lt (Zneg xH) intval1) (Z.lt intval1 modulus)",
                "intval1 : Z"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.not\n  (Logic.eq (unsigned {| intval := intval0; intrange := intrange0 |})\n     (unsigned {| intval := intval1; intrange := intrange1 |}))"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq intval0 intval1)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq intval0 intval1)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq intval0 intval1, False"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq intval0 intval1, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H : Logic.eq intval0 intval1"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : False",
                "n : Logic.not\n  (Logic.eq {| intval := intval0; intrange := intrange0 |}\n     {| intval := intval1; intrange := intrange1 |})"
            ],
            "tactic_res": [
                "_goal : Logic.eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ]
        },
        {
            "tactic_sig": "apply mkint_eq .",
            "tactic_args": [
                "_goal : Logic.eq {| intval := intval0; intrange := intrange0 |}\n  {| intval := intval1; intrange := intrange1 |}"
            ],
            "tactic_res": [
                "_goal : Logic.eq intval0 intval1"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq intval0 intval1"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (eq x x) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x x) true",
                "x : int"
            ]
        },
        {
            "tactic_sig": "generalize ( eq_spec _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (eq x x) true",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : if eq x x then Logic.eq x x else Logic.not (Logic.eq x x),\nLogic.eq (eq x x) true"
            ]
        },
        {
            "tactic_sig": "case ( eq _ _ ) .",
            "tactic_args": [
                "_goal : forall _ : if eq x x then Logic.eq x x else Logic.not (Logic.eq x x),\nLogic.eq (eq x x) true",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq x x, Logic.eq true true",
                "_goal : forall _ : Logic.not (Logic.eq x x), Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq x x, Logic.eq true true"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "H : Logic.eq x x"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq x x), Logic.eq false true"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "H : Logic.not (Logic.eq x x)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq false true"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.not (Logic.eq x y)),\nLogic.eq (eq x y) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) false",
                "H : Logic.not (Logic.eq x y)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "generalize ( eq_spec _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) false",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y),\nLogic.eq (eq x y) false"
            ]
        },
        {
            "tactic_sig": "case ( eq _ _ ) .",
            "tactic_args": [
                "_goal : forall _ : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y),\nLogic.eq (eq x y) false",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq x y, Logic.eq true false",
                "_goal : forall _ : Logic.not (Logic.eq x y), Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq x y, Logic.eq true false"
            ],
            "tactic_res": [
                "_goal : Logic.eq true false",
                "H0 : Logic.eq x y"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq true false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq x y), Logic.eq false false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "H0 : Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (eq x y) true), Logic.eq x y"
            ],
            "tactic_res": [
                "_goal : Logic.eq x y",
                "H : Logic.eq (eq x y) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "generalize ( eq_spec _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq x y",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y),\nLogic.eq x y"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : forall _ : if eq x y then Logic.eq x y else Logic.not (Logic.eq x y),\nLogic.eq x y",
                "H : Logic.eq (eq x y) true"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq x y, Logic.eq x y"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq x y, Logic.eq x y"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (eq x y) (if zeq (signed x) (signed y) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "predSpec eq eq_spec _ _ .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (if zeq (signed x) (signed y) then true else false)",
                "_goal : Logic.eq false (if zeq (signed x) (signed y) then true else false)",
                "H : Logic.eq x y",
                "H : Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq true (if zeq (signed x) (signed y) then true else false)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (if zeq (signed y) (signed y) then true else false)"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_true .",
            "tactic_args": [
                "_goal : Logic.eq true (if zeq (signed y) (signed y) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq false (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "_goal : Logic.eq false false",
                "e : Logic.eq (signed x) (signed y)",
                "n : Logic.not (Logic.eq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : Logic.eq false true",
                "H : Logic.not (Logic.eq x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq x y"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq x y",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed x)) y"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed x)) y",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed x)) (repr (signed y))"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed x)) (repr (signed y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (add x y) (repr (Z.add (unsigned x) (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x y) (repr (Z.add (unsigned x) (unsigned y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq (add x y) (repr (Z.add (unsigned x) (unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (add x y) (repr (Z.add (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x y) (repr (Z.add (signed x) (signed y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite add_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (add x y) (repr (Z.add (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned y)))\n  (repr (Z.add (signed x) (signed y)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned y)))\n  (repr (Z.add (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned x) (unsigned y)) (Z.add (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned x) (unsigned y)) (Z.add (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (signed x)",
                "_goal : eqm (unsigned y) (signed y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (signed x)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned y) (signed y)"
            ],
            "tactic_res": [
                "_goal : eqm (signed y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed y) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (add x y) (add y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x y) (add y x)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (add x y) (add y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned y)))\n  (repr (Z.add (unsigned y) (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned y)))\n  (repr (Z.add (unsigned y) (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (unsigned y) (unsigned x))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (unsigned y) (unsigned x))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (add x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (add x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned zero))) x"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) (unsigned zero))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) Z0)) x"
            ]
        },
        {
            "tactic_sig": "rewrite Z.add_0_r .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned x) Z0)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (add zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add zero x) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite add_commut .",
            "tactic_args": [
                "_goal : Logic.eq (add zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x zero) x"
            ]
        },
        {
            "tactic_sig": "apply add_zero .",
            "tactic_args": [
                "_goal : Logic.eq (add x zero) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (add (add x y) z) (add x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add x y) z) (add x (add y z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (add (add x y) z) (add x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.add (unsigned x)\n        (unsigned (repr (Z.add (unsigned y) (unsigned z))))))"
            ]
        },
        {
            "tactic_sig": "set ( x' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.add (unsigned x)\n        (unsigned (repr (Z.add (unsigned y) (unsigned z))))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.add (unsigned (repr (Z.add x' (unsigned y)))) (unsigned z)))\n  (repr (Z.add x' (unsigned (repr (Z.add (unsigned y) (unsigned z))))))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.add (unsigned (repr (Z.add x' (unsigned y)))) (unsigned z)))\n  (repr (Z.add x' (unsigned (repr (Z.add (unsigned y) (unsigned z))))))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned (repr (Z.add x' y'))) (unsigned z)))\n  (repr (Z.add x' (unsigned (repr (Z.add y' (unsigned z))))))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "set ( z' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned (repr (Z.add x' y'))) (unsigned z)))\n  (repr (Z.add x' (unsigned (repr (Z.add y' (unsigned z))))))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned (repr (Z.add x' y'))) z'))\n  (repr (Z.add x' (unsigned (repr (Z.add y' z')))))",
                "z' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned (repr (Z.add x' y'))) z'))\n  (repr (Z.add x' (unsigned (repr (Z.add y' z')))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned (repr (Z.add x' y'))) z')\n  (Z.add x' (unsigned (repr (Z.add y' z'))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( ( _ + _ ) + _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned (repr (Z.add x' y'))) z')\n  (Z.add x' (unsigned (repr (Z.add y' z'))))",
                "x' : Z",
                "y' : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned (repr (Z.add x' y'))) z') (Z.add (Z.add x' y') z')",
                "_goal : eqm (Z.add (Z.add x' y') z') (Z.add x' (unsigned (repr (Z.add y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned (repr (Z.add x' y'))) z') (Z.add (Z.add x' y') z')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite <- Z.add_assoc .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.add x' y') z') (Z.add x' (unsigned (repr (Z.add y' z'))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add x' (Z.add y' z')) (Z.add x' (unsigned (repr (Z.add y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add x' (Z.add y' z')) (Z.add x' (unsigned (repr (Z.add y' z'))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (add x (add y z)) (add y (add x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add y z)) (add y (add x z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite ( add_commut _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add y z)) (add y (add x z))",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add z y)) (add y (add x z))"
            ]
        },
        {
            "tactic_sig": "rewrite <- add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add z y)) (add y (add x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add x z) y) (add y (add x z))"
            ]
        },
        {
            "tactic_sig": "apply add_commut .",
            "tactic_args": [
                "_goal : Logic.eq (add (add x z) y) (add y (add x z))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (add x (neg x)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (neg x)) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold add , neg , zero .",
            "tactic_args": [
                "_goal : Logic.eq (add x (neg x)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x))))))\n  (repr Z0)"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x))))))\n  (repr Z0)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x))))) Z0"
            ]
        },
        {
            "tactic_sig": "replace 0 with ( unsigned _ + ( - ( unsigned _ ) ) ) .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x))))) Z0",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x)))))\n  (Z.add (unsigned x) (Z.opp (unsigned x)))",
                "_goal : Logic.eq (Z.add (unsigned x) (Z.opp (unsigned x))) Z0"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned x)))))\n  (Z.add (unsigned x) (Z.opp (unsigned x)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (unsigned x) (Z.opp (unsigned x))) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (unsigned (add x y))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned (add_carry x y zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (add x y))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned (add_carry x y zero)) modulus))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold add , add_carry .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (add x y))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned (add_carry x y zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if\n             zlt\n               (Z.add (Z.add (unsigned x) (unsigned y)) (unsigned zero))\n               modulus\n            then zero\n            else one)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if\n             zlt\n               (Z.add (Z.add (unsigned x) (unsigned y)) (unsigned zero))\n               modulus\n            then zero\n            else one)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0) modulus\n            then zero\n            else one)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.add_0_r .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0) modulus\n            then zero\n            else one)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)),\nLogic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)),\nLogic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))",
                "H0 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)",
                "H : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ + unsigned _ ) modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n            then zero\n            else one)) modulus))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned zero) modulus))",
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned one) modulus))",
                "l : Z.lt (Z.add (unsigned x) (unsigned y)) modulus",
                "g : Z.ge (Z.add (unsigned x) (unsigned y)) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned zero) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with 0 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (Z.mul Z0 modulus)\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))\n  (Z.lt (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (Z.mul Z0 modulus)\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))\n  (Z.lt (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y))\n     (Z.mul (unsigned one) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with 1 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add (unsigned x) (unsigned y)) modulus)\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (Z.mul (Zpos xH) modulus)\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))",
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))\n  (Z.lt\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (unsigned x) (unsigned y))\n  (Z.add (Z.mul (Zpos xH) modulus)\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))\n  (Z.lt\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.or\n  (Logic.eq (unsigned (add x y)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq (unsigned (add x y))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq (unsigned (add x y)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq (unsigned (add x y))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_add_carry .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq (unsigned (add x y)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq (unsigned (add x y))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned (add_carry x y zero)) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned (add_carry x y zero)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "unfold add_carry .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned (add_carry x y zero)) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned (add_carry x y zero)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt\n                  (Z.add (Z.add (unsigned x) (unsigned y))\n                     (unsigned zero)) modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt\n                  (Z.add (Z.add (unsigned x) (unsigned y))\n                     (unsigned zero)) modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt\n                  (Z.add (Z.add (unsigned x) (unsigned y))\n                     (unsigned zero)) modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt\n                  (Z.add (Z.add (unsigned x) (unsigned y))\n                     (unsigned zero)) modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0)\n                  modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0)\n                  modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.add_0_r .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0)\n                  modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if\n                zlt (Z.add (Z.add (unsigned x) (unsigned y)) Z0)\n                  modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ + unsigned _ ) modulus ) .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n               then zero\n               else one)) modulus)) (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul\n           (unsigned\n              (if zlt (Z.add (unsigned x) (unsigned y)) modulus\n               then zero\n               else one)) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned zero) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned zero) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))",
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned one) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned one) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))",
                "l : Z.lt (Z.add (unsigned x) (unsigned y)) modulus",
                "g : Z.ge (Z.add (unsigned x) (unsigned y)) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned zero) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned zero) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "left .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n  (Z.add (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n  (Z.add (unsigned x) (unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned one) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y))\n        (Z.mul (unsigned one) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ]
        },
        {
            "tactic_sig": "right .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     (Z.add (unsigned x) (unsigned y)))\n  (Logic.eq\n     (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     (Z.sub (Z.add (unsigned x) (unsigned y)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n  (Z.sub (Z.add (unsigned x) (unsigned y)) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub (Z.add (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n  (Z.sub (Z.add (unsigned x) (unsigned y)) modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall z : Z, Logic.eq (neg (repr z)) (repr (Z.opp z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (repr z)) (repr (Z.opp z))",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "unfold neg .",
            "tactic_args": [
                "_goal : Logic.eq (neg (repr z)) (repr (Z.opp z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr z)))) (repr (Z.opp z))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr z)))) (repr (Z.opp z))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr z))) (Z.opp z)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr z))) (Z.opp z)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold neg .",
            "tactic_args": [
                "_goal : Logic.eq (neg zero) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (unsigned zero))) zero"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (unsigned zero))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp Z0)) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp Z0)) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (neg (neg x)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (neg x)) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold neg .",
            "tactic_args": [
                "_goal : Logic.eq (neg (neg x)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.opp (unsigned x)))))) x"
            ]
        },
        {
            "tactic_sig": "apply eqm_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.opp (unsigned x)))))) x"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.opp (unsigned x))))) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "eapply eqm_trans .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.opp (unsigned x))))) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.opp (unsigned x))))) ?y",
                "_goal : eqm ?y (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_neg .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.opp (unsigned x))))) ?y",
                "_goal : eqm ?y (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (Z.opp (unsigned x)))) ?y",
                "_goal : eqm (Z.opp ?y) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Z.opp (unsigned x)))) ?y"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned x)) ?y"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned x)) ?y",
                "_goal : eqm (Z.opp ?y) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (Z.opp (unsigned x))) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm (Z.opp (Z.opp (unsigned x))) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.opp (Z.opp (unsigned x))) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.opp (Z.opp (unsigned x))) (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (neg (add x y)) (add (neg x) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (add x y)) (add (neg x) (neg y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold neg , add .",
            "tactic_args": [
                "_goal : Logic.eq (neg (add x y)) (add (neg x) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y))))))\n  (repr\n     (Z.add (unsigned (repr (Z.opp (unsigned x))))\n        (unsigned (repr (Z.opp (unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y))))))\n  (repr\n     (Z.add (unsigned (repr (Z.opp (unsigned x))))\n        (unsigned (repr (Z.opp (unsigned y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y)))))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( - ( unsigned _ + unsigned _ ) ) .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y)))))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y)))))\n  (Z.opp (Z.add (unsigned x) (unsigned y)))",
                "_goal : eqm (Z.opp (Z.add (unsigned x) (unsigned y)))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.add (unsigned x) (unsigned y)))))\n  (Z.opp (Z.add (unsigned x) (unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( - ( unsigned _ + unsigned _ ) ) with ( ( - unsigned _ ) + ( - unsigned _ ) ) .",
            "tactic_args": [
                "_goal : eqm (Z.opp (Z.add (unsigned x) (unsigned y)))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))",
                "x : int",
                "y : int",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (Z.opp (unsigned x)) (Z.opp (unsigned y)))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))",
                "_goal : Logic.eq (Z.add (Z.opp (unsigned x)) (Z.opp (unsigned y)))\n  (Z.opp (Z.add (unsigned x) (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.opp (unsigned x)) (Z.opp (unsigned y)))\n  (Z.add (unsigned (repr (Z.opp (unsigned x))))\n     (unsigned (repr (Z.opp (unsigned y)))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.opp (unsigned x)) (Z.opp (unsigned y)))\n  (Z.opp (Z.add (unsigned x) (unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (sub x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned zero))) x"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned zero))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) Z0)) x"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned _ - 0 ) with ( unsigned _ ) by omega .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) Z0)) x",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (sub zero x) (neg x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub zero x) (neg x)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold sub , neg .",
            "tactic_args": [
                "_goal : Logic.eq (sub zero x) (neg x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned zero) (unsigned x)))\n  (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned zero) (unsigned x)))\n  (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub Z0 (unsigned x))) (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub Z0 (unsigned x))) (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (sub x y) (add x (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x y) (add x (neg y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold sub , add , neg .",
            "tactic_args": [
                "_goal : Logic.eq (sub x y) (add x (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned y)))\n  (repr (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned y)))\n  (repr (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (unsigned x) (unsigned y))\n  (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.sub (unsigned x) (unsigned y))\n  (Z.add (unsigned x) (unsigned (repr (Z.opp (unsigned y)))))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned x)",
                "_goal : eqm (Z.opp (unsigned y)) (unsigned (repr (Z.opp (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned y)) (unsigned (repr (Z.opp (unsigned y))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (sub x x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x x) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub x x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned x))) zero"
            ]
        },
        {
            "tactic_sig": "unfold zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned x))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned x))) (repr Z0)"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned x))) (repr Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned x)) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned x)) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (sub (add x y) z) (add (sub x z) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (add x y) z) (add (sub x z) y)",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "repeat rewrite sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (sub (add x y) z) (add (sub x z) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add x y) (neg z)) (add (add x (neg z)) y)"
            ]
        },
        {
            "tactic_sig": "repeat rewrite add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (add (add x y) (neg z)) (add (add x (neg z)) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add y (neg z))) (add x (add (neg z) y))"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add y (neg z))) (add x (add (neg z) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add y (neg z)) (add (neg z) y)"
            ]
        },
        {
            "tactic_sig": "apply add_commut .",
            "tactic_args": [
                "_goal : Logic.eq (add y (neg z)) (add (neg z) y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (sub x (add y z)) (add (sub x z) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (add y z)) (add (sub x z) (neg y))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "repeat rewrite sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (add y z)) (add (sub x z) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (neg (add y z))) (add (add x (neg z)) (neg y))"
            ]
        },
        {
            "tactic_sig": "rewrite neg_add_distr .",
            "tactic_args": [
                "_goal : Logic.eq (add x (neg (add y z))) (add (add x (neg z)) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (neg y) (neg z))) (add (add x (neg z)) (neg y))"
            ]
        },
        {
            "tactic_sig": "rewrite add_permut .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (neg y) (neg z))) (add (add x (neg z)) (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (neg y) (add x (neg z))) (add (add x (neg z)) (neg y))"
            ]
        },
        {
            "tactic_sig": "apply add_commut .",
            "tactic_args": [
                "_goal : Logic.eq (add (neg y) (add x (neg z))) (add (add x (neg z)) (neg y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (sub (add x z) (add y z)) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (add x z) (add y z)) (sub x y)",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (sub (add x z) (add y z)) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add x z) (neg (add y z))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite neg_add_distr .",
            "tactic_args": [
                "_goal : Logic.eq (add (add x z) (neg (add y z))) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add x z) (add (neg y) (neg z))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (add (add x z) (add (neg y) (neg z))) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add z (add (neg y) (neg z)))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite ( add_commut ( neg _ ) ( neg _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add z (add (neg y) (neg z)))) (sub x y)",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add z (add (neg z) (neg y)))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( add_assoc _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add z (add (neg z) (neg y)))) (sub x y)",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (add z (neg z)) (neg y))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite add_neg_zero .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (add z (neg z)) (neg y))) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add zero (neg y))) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite ( add_commut zero ) .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add zero (neg y))) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (neg y) zero)) (sub x y)"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (neg y) zero)) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (neg y)) (sub x y)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (add x (neg y)) (sub x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x y) (add x (neg y))"
            ]
        },
        {
            "tactic_sig": "apply sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (sub x y) (add x (neg y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (sub x y) (repr (Z.sub (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x y) (repr (Z.sub (signed x) (signed y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub x y) (repr (Z.sub (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned y)))\n  (repr (Z.sub (signed x) (signed y)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned x) (unsigned y)))\n  (repr (Z.sub (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (unsigned x) (unsigned y)) (Z.sub (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_sub .",
            "tactic_args": [
                "_goal : eqm (Z.sub (unsigned x) (unsigned y)) (Z.sub (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (signed x)",
                "_goal : eqm (unsigned y) (signed y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (signed x)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned y) (signed y)"
            ],
            "tactic_res": [
                "_goal : eqm (signed y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed y) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (unsigned (sub x y))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned (sub_borrow x y zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (sub x y))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned (sub_borrow x y zero)) modulus))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold sub , sub_borrow .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (sub x y))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned (sub_borrow x y zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if\n             zlt\n               (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned zero))\n               Z0\n            then one\n            else zero)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if\n             zlt\n               (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned zero))\n               Z0\n            then one\n            else zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) Z0) Z0\n            then one\n            else zero)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.sub_0_r .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) Z0) Z0\n            then one\n            else zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned x) (unsigned y))))\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)),\nLogic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)),\nLogic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))",
                "H0 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)",
                "H : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ - unsigned _ ) 0 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul\n        (unsigned\n           (if zlt (Z.sub (unsigned x) (unsigned y)) Z0\n            then one\n            else zero)) modulus))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned one) modulus))",
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned zero) modulus))",
                "l : Z.lt (Z.sub (unsigned x) (unsigned y)) Z0",
                "g : Z.ge (Z.sub (unsigned x) (unsigned y)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned one) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned y))\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))",
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))\n  (Z.lt\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned y))\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus)))\n  (Z.lt\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul (Zpos xH) modulus))\n     modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y))\n     (Z.mul (unsigned zero) modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with 0 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (unsigned x) (unsigned y)) modulus)\n  (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned y))\n  (Z.add (Z.mul Z0 modulus)\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))",
                "_goal : Logic.and\n  (Z.le Z0 (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))\n  (Z.lt (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (unsigned x) (unsigned y))\n  (Z.add (Z.mul Z0 modulus)\n     (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus)))\n  (Z.lt (Z.add (Z.sub (unsigned x) (unsigned y)) (Z.mul Z0 modulus))\n     modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (mul x y) (mul y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x y) (mul y x)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul x y) (mul y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned y)))\n  (repr (Z.mul (unsigned y) (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned y)))\n  (repr (Z.mul (unsigned y) (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.mul (unsigned x) (unsigned y))\n  (Z.mul (unsigned y) (unsigned x))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.mul (unsigned x) (unsigned y))\n  (Z.mul (unsigned y) (unsigned x))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (mul x zero) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x zero) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul x zero) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned zero))) zero"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned zero))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) Z0)) zero"
            ]
        },
        {
            "tactic_sig": "unfold zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) Z0)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) Z0)) (repr Z0)"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) Z0)) (repr Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.mul (unsigned x) Z0) Z0"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.mul (unsigned x) Z0) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (mul x one) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x one) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul x one) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned one))) x"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Zpos xH))) x"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Zpos xH))) x",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Zpos xH))) (repr (unsigned x))",
                "_goal : Logic.eq (repr (unsigned x)) x"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Zpos xH))) (repr (unsigned x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.mul (unsigned x) (Zpos xH)) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.mul (unsigned x) (Zpos xH)) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (mul x mone) (neg x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x mone) (neg x)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold mul , neg .",
            "tactic_args": [
                "_goal : Logic.eq (mul x mone) (neg x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned mone)))\n  (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_mone .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned mone)))\n  (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Z.sub modulus (Zpos xH))))\n  (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (Z.sub modulus (Zpos xH))))\n  (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (Z.sub modulus (Zpos xH))) (Z.opp (unsigned x))"
            ]
        },
        {
            "tactic_sig": "replace ( - unsigned _ ) with ( 0 - unsigned _ ) by omega .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (Z.sub modulus (Zpos xH))) (Z.opp (unsigned x))",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (Z.sub modulus (Zpos xH)))\n  (Z.sub Z0 (unsigned x))"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned _ * ( modulus - 1 ) ) with ( unsigned _ * modulus - unsigned _ ) by ring .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (Z.sub modulus (Zpos xH)))\n  (Z.sub Z0 (unsigned x))",
                "x : int",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (Z.mul (unsigned x) modulus) (unsigned x))\n  (Z.sub Z0 (unsigned x))"
            ]
        },
        {
            "tactic_sig": "apply eqm_sub .",
            "tactic_args": [
                "_goal : eqm (Z.sub (Z.mul (unsigned x) modulus) (unsigned x))\n  (Z.sub Z0 (unsigned x))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) modulus) Z0",
                "_goal : eqm (unsigned x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "exists ( unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) modulus) Z0",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.mul (unsigned x) modulus)\n  (Z.add (Z.mul (unsigned x) modulus) Z0)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.mul (unsigned x) modulus)\n  (Z.add (Z.mul (unsigned x) modulus) Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (mul (mul x y) z) (mul x (mul y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (mul x y) z) (mul x (mul y z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul (mul x y) z) (mul x (mul y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.mul (unsigned (repr (Z.mul (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.mul (unsigned x)\n        (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))"
            ]
        },
        {
            "tactic_sig": "set ( x' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.mul (unsigned (repr (Z.mul (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.mul (unsigned x)\n        (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.mul (unsigned (repr (Z.mul x' (unsigned y)))) (unsigned z)))\n  (repr (Z.mul x' (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.mul (unsigned (repr (Z.mul x' (unsigned y)))) (unsigned z)))\n  (repr (Z.mul x' (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned (repr (Z.mul x' y'))) (unsigned z)))\n  (repr (Z.mul x' (unsigned (repr (Z.mul y' (unsigned z))))))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "set ( z' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned (repr (Z.mul x' y'))) (unsigned z)))\n  (repr (Z.mul x' (unsigned (repr (Z.mul y' (unsigned z))))))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned (repr (Z.mul x' y'))) z'))\n  (repr (Z.mul x' (unsigned (repr (Z.mul y' z')))))",
                "z' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned (repr (Z.mul x' y'))) z'))\n  (repr (Z.mul x' (unsigned (repr (Z.mul y' z')))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.mul x' y'))) z')\n  (Z.mul x' (unsigned (repr (Z.mul y' z'))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( ( _ * _ ) * _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.mul x' y'))) z')\n  (Z.mul x' (unsigned (repr (Z.mul y' z'))))",
                "x' : Z",
                "y' : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.mul x' y'))) z') (Z.mul (Z.mul x' y') z')",
                "_goal : eqm (Z.mul (Z.mul x' y') z') (Z.mul x' (unsigned (repr (Z.mul y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.mul x' y'))) z') (Z.mul (Z.mul x' y') z')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite <- Z.mul_assoc .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Z.mul x' y') z') (Z.mul x' (unsigned (repr (Z.mul y' z'))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul x' (Z.mul y' z')) (Z.mul x' (unsigned (repr (Z.mul y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.mul x' (Z.mul y' z')) (Z.mul x' (unsigned (repr (Z.mul y' z'))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int,\nLogic.eq (mul (add x y) z) (add (mul x z) (mul y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (add x y) z) (add (mul x z) (mul y z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "unfold mul , add .",
            "tactic_args": [
                "_goal : Logic.eq (mul (add x y) z) (add (mul x z) (mul y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.mul (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.add (unsigned (repr (Z.mul (unsigned x) (unsigned z))))\n        (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.mul (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n        (unsigned z)))\n  (repr\n     (Z.add (unsigned (repr (Z.mul (unsigned x) (unsigned z))))\n        (unsigned (repr (Z.mul (unsigned y) (unsigned z))))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.mul (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n     (unsigned z))\n  (Z.add (unsigned (repr (Z.mul (unsigned x) (unsigned z))))\n     (unsigned (repr (Z.mul (unsigned y) (unsigned z)))))"
            ]
        },
        {
            "tactic_sig": "set ( x' := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.mul (unsigned (repr (Z.add (unsigned x) (unsigned y))))\n     (unsigned z))\n  (Z.add (unsigned (repr (Z.mul (unsigned x) (unsigned z))))\n     (unsigned (repr (Z.mul (unsigned y) (unsigned z)))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' (unsigned y)))) (unsigned z))\n  (Z.add (unsigned (repr (Z.mul x' (unsigned z))))\n     (unsigned (repr (Z.mul (unsigned y) (unsigned z)))))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' (unsigned y)))) (unsigned z))\n  (Z.add (unsigned (repr (Z.mul x' (unsigned z))))\n     (unsigned (repr (Z.mul (unsigned y) (unsigned z)))))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) (unsigned z))\n  (Z.add (unsigned (repr (Z.mul x' (unsigned z))))\n     (unsigned (repr (Z.mul y' (unsigned z)))))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "set ( z' := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) (unsigned z))\n  (Z.add (unsigned (repr (Z.mul x' (unsigned z))))\n     (unsigned (repr (Z.mul y' (unsigned z)))))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) z')\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))",
                "z' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( ( _ + _ ) * _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) z')\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))",
                "x' : Z",
                "y' : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) z') (Z.mul (Z.add x' y') z')",
                "_goal : eqm (Z.mul (Z.add x' y') z')\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Z.add x' y'))) z') (Z.mul (Z.add x' y') z')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( ( _ + _ ) * _ ) with ( _ * _ + _ * _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Z.add x' y') z')\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))",
                "x' : Z",
                "y' : Z",
                "z' : Z",
                "x' : Z",
                "z' : Z",
                "y' : Z",
                "z' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (Z.mul x' z') (Z.mul y' z'))\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))",
                "_goal : Logic.eq (Z.add (Z.mul x' z') (Z.mul y' z')) (Z.mul (Z.add x' y') z')"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.mul x' z') (Z.mul y' z'))\n  (Z.add (unsigned (repr (Z.mul x' z')))\n     (unsigned (repr (Z.mul y' z'))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.mul x' z') (Z.mul y' z')) (Z.mul (Z.add x' y') z')"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int,\nLogic.eq (mul x (add y z)) (add (mul x y) (mul x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x (add y z)) (add (mul x y) (mul x z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul x (add y z)) (add (mul x y) (mul x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (add y z) x) (add (mul x y) (mul x z))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_add_distr_l .",
            "tactic_args": [
                "_goal : Logic.eq (mul (add y z) x) (add (mul x y) (mul x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (mul y x) (mul z x)) (add (mul x y) (mul x z))"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (add (mul y x) (mul z x)) (add (mul x y) (mul x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul y x) (mul x y)",
                "_goal : Logic.eq (mul z x) (mul x z)"
            ]
        },
        {
            "tactic_sig": "apply mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul y x) (mul x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul z x) (mul x z)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (neg (mul x y)) (mul (neg x) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (mul x y)) (mul (neg x) y)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold mul , neg .",
            "tactic_args": [
                "_goal : Logic.eq (neg (mul x y)) (mul (neg x) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.opp (unsigned (repr (Z.mul (unsigned x) (unsigned y))))))\n  (repr (Z.mul (unsigned (repr (Z.opp (unsigned x)))) (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "set ( x' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.opp (unsigned (repr (Z.mul (unsigned x) (unsigned y))))))\n  (repr (Z.mul (unsigned (repr (Z.opp (unsigned x)))) (unsigned y)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.mul x' (unsigned y))))))\n  (repr (Z.mul (unsigned (repr (Z.opp x'))) (unsigned y)))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.mul x' (unsigned y))))))\n  (repr (Z.mul (unsigned (repr (Z.opp x'))) (unsigned y)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.mul x' y')))))\n  (repr (Z.mul (unsigned (repr (Z.opp x'))) y'))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (unsigned (repr (Z.mul x' y')))))\n  (repr (Z.mul (unsigned (repr (Z.opp x'))) y'))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.mul x' y'))))\n  (Z.mul (unsigned (repr (Z.opp x'))) y')"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( - ( _ * _ ) ) .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.mul x' y'))))\n  (Z.mul (unsigned (repr (Z.opp x'))) y')",
                "x' : Z",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.mul x' y')))) (Z.opp (Z.mul x' y'))",
                "_goal : eqm (Z.opp (Z.mul x' y')) (Z.mul (unsigned (repr (Z.opp x'))) y')"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned (repr (Z.mul x' y')))) (Z.opp (Z.mul x' y'))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( - ( _ * _ ) ) with ( ( - _ ) * _ ) by ring .",
            "tactic_args": [
                "_goal : eqm (Z.opp (Z.mul x' y')) (Z.mul (unsigned (repr (Z.opp x'))) y')",
                "x' : Z",
                "y' : Z",
                "x' : Z",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (Z.opp x') y') (Z.mul (unsigned (repr (Z.opp x'))) y')"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Z.opp x') y') (Z.mul (unsigned (repr (Z.opp x'))) y')"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (neg (mul x y)) (mul x (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (mul x y)) (mul x (neg y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite ( mul_commut _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (neg (mul x y)) (mul x (neg y))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (mul y x)) (mul x (neg y))"
            ]
        },
        {
            "tactic_sig": "rewrite ( mul_commut _ ( neg _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (neg (mul y x)) (mul x (neg y))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg (mul y x)) (mul (neg y) x)"
            ]
        },
        {
            "tactic_sig": "apply neg_mul_distr_l .",
            "tactic_args": [
                "_goal : Logic.eq (neg (mul y x)) (mul (neg y) x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (mul x y) (repr (Z.mul (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x y) (repr (Z.mul (signed x) (signed y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul x y) (repr (Z.mul (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned y)))\n  (repr (Z.mul (signed x) (signed y)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (unsigned x) (unsigned y)))\n  (repr (Z.mul (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (unsigned y)) (Z.mul (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_mult .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (unsigned y)) (Z.mul (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (signed x)",
                "_goal : eqm (unsigned y) (signed y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (signed x)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned y) (signed y)"
            ],
            "tactic_res": [
                "_goal : eqm (signed y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed y) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.not (Logic.eq y zero)),\nLogic.eq x (add (mul (divu x y) y) (modu x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (add (mul (divu x y) y) (modu x y))",
                "H : Logic.not (Logic.eq y zero)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold add , mul , divu , modu .",
            "tactic_args": [
                "_goal : Logic.eq x (add (mul (divu x y) y) (modu x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul\n                 (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.modulo (unsigned x) (unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq x\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul\n                 (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.modulo (unsigned x) (unsigned y))))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (repr (unsigned x))",
                "_goal : Logic.eq (repr (unsigned x))\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul\n                 (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.modulo (unsigned x) (unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.eq x (repr (unsigned x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x))\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul\n                 (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.modulo (unsigned x) (unsigned y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x)\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n              (unsigned y))))\n     (unsigned (repr (Z.modulo (unsigned x) (unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "set ( x' := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (unsigned x)\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.div (unsigned x) (unsigned y))))\n              (unsigned y))))\n     (unsigned (repr (Z.modulo (unsigned x) (unsigned y)))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.div x' (unsigned y))))\n              (unsigned y))))\n     (unsigned (repr (Z.modulo x' (unsigned y)))))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.div x' (unsigned y))))\n              (unsigned y))))\n     (unsigned (repr (Z.modulo x' (unsigned y)))))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqm x'\n  (Z.add (unsigned (repr (Z.mul (unsigned (repr (Z.div x' y'))) y')))\n     (unsigned (repr (Z.modulo x' y'))))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( ( _ / _ ) * _ + _ mod _ ) .",
            "tactic_args": [
                "_goal : eqm x'\n  (Z.add (unsigned (repr (Z.mul (unsigned (repr (Z.div x' y'))) y')))\n     (unsigned (repr (Z.modulo x' y'))))",
                "x' : Z",
                "y' : Z",
                "y' : Z",
                "x' : Z",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : eqm x' (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))",
                "_goal : eqm (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))\n  (Z.add (unsigned (repr (Z.mul (unsigned (repr (Z.div x' y'))) y')))\n     (unsigned (repr (Z.modulo x' y'))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm x' (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mul_comm .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.add (Z.mul y' (Z.div x' y')) (Z.modulo x' y'))"
            ]
        },
        {
            "tactic_sig": "apply Z_div_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul y' (Z.div x' y')) (Z.modulo x' y'))"
            ],
            "tactic_res": [
                "_goal : Z.gt y' Z0"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.gt y' Z0",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.gt y' Z0"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.gt y' Z0"
            ],
            "tactic_res": [
                "_goal : Z.gt y' Z0",
                "H0 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned _ <> 0 ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (unsigned y) Z0)",
                "H1 : Logic.not (Logic.eq (unsigned y) Z0)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned y) Z0)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned y) Z0, False"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned y) Z0, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H1 : Logic.eq (unsigned y) Z0"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : False",
                "H : Logic.not (Logic.eq y zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq y zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq y zero",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned y)) zero"
            ]
        },
        {
            "tactic_sig": "unfold zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned y)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned y)) (repr Z0)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned y)) (repr Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Z.gt y' Z0",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : Z.gt (unsigned y) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.gt (unsigned y) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.mul (Z.div x' y') y') (Z.modulo x' y'))\n  (Z.add (unsigned (repr (Z.mul (unsigned (repr (Z.div x' y'))) y')))\n     (unsigned (repr (Z.modulo x' y'))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.not (Logic.eq y zero)),\nLogic.eq (modu x y) (sub x (mul (divu x y) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x y) (sub x (mul (divu x y) y))",
                "H : Logic.not (Logic.eq y zero)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( forall a b c , a = add b c -> c = sub a b ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)",
                "H0 : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (sub a b)",
                "H0 : Logic.eq a (add b c)",
                "a : int",
                "b : int",
                "c : int"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq c (sub a b)",
                "a : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (sub (add b c) b)"
            ]
        },
        {
            "tactic_sig": "rewrite sub_add_l .",
            "tactic_args": [
                "_goal : Logic.eq c (sub (add b c) b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add (sub b b) c)"
            ]
        },
        {
            "tactic_sig": "rewrite sub_idem .",
            "tactic_args": [
                "_goal : Logic.eq c (add (sub b b) c)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add zero c)"
            ]
        },
        {
            "tactic_sig": "rewrite add_commut .",
            "tactic_args": [
                "_goal : Logic.eq c (add zero c)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add c zero)"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq c (add c zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c c"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq c c"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : Logic.eq (modu x y) (sub x (mul (divu x y) y))",
                "H0 : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (add (mul (divu x y) y) (modu x y))"
            ]
        },
        {
            "tactic_sig": "apply modu_divu_Euclid .",
            "tactic_args": [
                "_goal : Logic.eq x (add (mul (divu x y) y) (modu x y))"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq y zero)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq y zero)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq x (add (mul (divs x y) y) (mods x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (add (mul (divs x y) y) (mods x y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold add , mul , divs , mods .",
            "tactic_args": [
                "_goal : Logic.eq x (add (mul (divs x y) y) (mods x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.rem (signed x) (signed y))))))"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq x\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.rem (signed x) (signed y))))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (repr (signed x))",
                "_goal : Logic.eq (repr (signed x))\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.rem (signed x) (signed y))))))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.eq x (repr (signed x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed x))\n  (repr\n     (Z.add\n        (unsigned\n           (repr\n              (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n                 (unsigned y))))\n        (unsigned (repr (Z.rem (signed x) (signed y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (signed x)\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n              (unsigned y))))\n     (unsigned (repr (Z.rem (signed x) (signed y)))))"
            ]
        },
        {
            "tactic_sig": "set ( x' := signed _ ) .",
            "tactic_args": [
                "_goal : eqm (signed x)\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.quot (signed x) (signed y))))\n              (unsigned y))))\n     (unsigned (repr (Z.rem (signed x) (signed y)))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.quot x' (signed y)))) (unsigned y))))\n     (unsigned (repr (Z.rem x' (signed y)))))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( y' := signed _ ) .",
            "tactic_args": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr\n           (Z.mul (unsigned (repr (Z.quot x' (signed y)))) (unsigned y))))\n     (unsigned (repr (Z.rem x' (signed y)))))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))\n     (unsigned (repr (Z.rem x' y'))))",
                "y' : Z"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( ( Z.quot _ _ ) * _ + Z.rem _ _ ) .",
            "tactic_args": [
                "_goal : eqm x'\n  (Z.add\n     (unsigned\n        (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))\n     (unsigned (repr (Z.rem x' y'))))",
                "x' : Z",
                "y' : Z",
                "y' : Z",
                "x' : Z",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : eqm x' (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))",
                "_goal : eqm (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))\n  (Z.add\n     (unsigned\n        (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))\n     (unsigned (repr (Z.rem x' y'))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm x' (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mul_comm .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.add (Z.mul y' (Z.quot x' y')) (Z.rem x' y'))"
            ]
        },
        {
            "tactic_sig": "apply Z.quot_rem' .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul y' (Z.quot x' y')) (Z.rem x' y'))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.mul (Z.quot x' y') y') (Z.rem x' y'))\n  (Z.add\n     (unsigned\n        (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))\n     (unsigned (repr (Z.rem x' y'))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (Z.quot x' y') y')\n  (unsigned\n     (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))",
                "_goal : eqm (Z.rem x' y') (unsigned (repr (Z.rem x' y')))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.rem x' y') (unsigned (repr (Z.rem x' y')))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_r .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Z.quot x' y') y')\n  (unsigned\n     (repr (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (Z.quot x' y') y')\n  (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_mult .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Z.quot x' y') y')\n  (Z.mul (unsigned (repr (Z.quot x' y'))) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.quot x' y') (unsigned (repr (Z.quot x' y')))",
                "_goal : eqm y' (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.quot x' y') (unsigned (repr (Z.quot x' y')))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : eqm y' (unsigned y)",
                "y' : Z"
            ],
            "tactic_res": [
                "_goal : eqm (signed y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed y) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (mods x y) (sub x (mul (divs x y) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mods x y) (sub x (mul (divs x y) y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( forall a b c , a = add b c -> c = sub a b ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)",
                "H : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (sub a b)",
                "H : Logic.eq a (add b c)",
                "a : int",
                "b : int",
                "c : int"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq c (sub a b)",
                "a : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (sub (add b c) b)"
            ]
        },
        {
            "tactic_sig": "rewrite sub_add_l .",
            "tactic_args": [
                "_goal : Logic.eq c (sub (add b c) b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add (sub b b) c)"
            ]
        },
        {
            "tactic_sig": "rewrite sub_idem .",
            "tactic_args": [
                "_goal : Logic.eq c (add (sub b b) c)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add zero c)"
            ]
        },
        {
            "tactic_sig": "rewrite add_commut .",
            "tactic_args": [
                "_goal : Logic.eq c (add zero c)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c (add c zero)"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq c (add c zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq c c"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq c c"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : Logic.eq (mods x y) (sub x (mul (divs x y) y))",
                "H : forall (a b c : int) (_ : Logic.eq a (add b c)), Logic.eq c (sub a b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (add (mul (divs x y) y) (mods x y))"
            ]
        },
        {
            "tactic_sig": "apply mods_divs_Euclid .",
            "tactic_args": [
                "_goal : Logic.eq x (add (mul (divs x y) y) (mods x y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold divu .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (divu x one) x"
            ],
            "tactic_res": [
                "_goal : forall x : int, Logic.eq (repr (Z.div (unsigned x) (unsigned one))) x"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (repr (Z.div (unsigned x) (unsigned one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (unsigned one))) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (unsigned one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (Zpos xH))) x"
            ]
        },
        {
            "tactic_sig": "rewrite Zdiv_1_r .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (Zpos xH))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold divs .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Z.gt zwordsize (Zpos xH)),\nLogic.eq (divs x one) x"
            ],
            "tactic_res": [
                "_goal : forall (x : int) (_ : Z.gt zwordsize (Zpos xH)),\nLogic.eq (repr (Z.quot (signed x) (signed one))) x"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Z.gt zwordsize (Zpos xH)),\nLogic.eq (repr (Z.quot (signed x) (signed one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed one))) x",
                "H : Z.gt zwordsize (Zpos xH)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite signed_one .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zpos xH))) x",
                "_goal : Z.gt zwordsize (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.quot_1_r .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zpos xH))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_signed .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed x)) x"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.gt zwordsize (Zpos xH)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (modu x one) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x one) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite modu_divu .",
            "tactic_args": [
                "_goal : Logic.eq (modu x one) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (mul (divu x one) one)) zero",
                "_goal : Logic.not (Logic.eq one zero)"
            ]
        },
        {
            "tactic_sig": "rewrite divu_one .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (mul (divu x one) one)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (mul x one)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (mul x one)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x x) zero"
            ]
        },
        {
            "tactic_sig": "apply sub_idem .",
            "tactic_args": [
                "_goal : Logic.eq (sub x x) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply one_not_zero .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq one zero)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold divs , neg .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (divs x mone) (neg x)"
            ],
            "tactic_res": [
                "_goal : forall x : int,\nLogic.eq (repr (Z.quot (signed x) (signed mone)))\n  (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.eq (repr (Z.quot (signed x) (signed mone)))\n  (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed mone)))\n  (repr (Z.opp (unsigned x)))",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite signed_mone .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed mone)))\n  (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zneg xH)))\n  (repr (Z.opp (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "replace ( Z.quot ( signed _ ) ( - 1 ) ) with ( - ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zneg xH)))\n  (repr (Z.opp (unsigned x)))",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.opp (signed x))) (repr (Z.opp (unsigned x)))",
                "_goal : Logic.eq (Z.opp (signed x)) (Z.quot (signed x) (Zneg xH))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.opp (signed x))) (repr (Z.opp (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (signed x)) (Z.opp (unsigned x))"
            ]
        },
        {
            "tactic_sig": "apply eqm_neg .",
            "tactic_args": [
                "_goal : eqm (Z.opp (signed x)) (Z.opp (unsigned x))"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( x' := signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.opp (signed x)) (Z.quot (signed x) (Zneg xH))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.opp x') (Z.quot x' (Zneg xH))",
                "x' : Z"
            ]
        },
        {
            "tactic_sig": "set ( one := 1 ) .",
            "tactic_args": [],
            "tactic_res": [
                "one : Z"
            ]
        },
        {
            "tactic_sig": "change ( - 1 ) with ( - _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.opp x') (Z.quot x' (Zneg xH))",
                "one : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.opp x') (Z.quot x' (Z.opp one))"
            ]
        },
        {
            "tactic_sig": "rewrite Zquot_opp_r .",
            "tactic_args": [
                "_goal : Logic.eq (Z.opp x') (Z.quot x' (Z.opp one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.opp x') (Z.opp (Z.quot x' one))"
            ]
        },
        {
            "tactic_sig": "assert ( Z.quot _ _ = _ ) .",
            "tactic_args": [
                "x' : Z",
                "one : Z",
                "x' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.quot x' one) x'",
                "H : Logic.eq (Z.quot x' one) x'"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.quot x' one) x'"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.quot x' one)"
            ]
        },
        {
            "tactic_sig": "apply Zquot_unique_full with 0 .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.quot x' one)"
            ],
            "tactic_res": [
                "_goal : Zquot.Remainder x' one Z0",
                "_goal : Logic.eq x' (Z.add (Z.mul one x') Z0)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Zquot.Remainder x' one Z0"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.and (Z.le Z0 x')\n     (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Z.abs one))))\n  (Logic.and (Z.le x' Z0)\n     (Logic.and (Z.lt (Z.opp (Z.abs one)) Z0) (Z.le Z0 Z0)))"
            ]
        },
        {
            "tactic_sig": "change ( Z.abs _ ) with 1 .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.and (Z.le Z0 x')\n     (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Z.abs one))))\n  (Logic.and (Z.le x' Z0)\n     (Logic.and (Z.lt (Z.opp (Z.abs one)) Z0) (Z.le Z0 Z0)))",
                "one : Z"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.and (Z.le Z0 x') (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Zpos xH))))\n  (Logic.and (Z.le x' Z0)\n     (Logic.and (Z.lt (Z.opp (Zpos xH)) Z0) (Z.le Z0 Z0)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zle 0 _ ) .",
            "tactic_args": [
                "x' : Z"
            ],
            "tactic_res": [
                "l : Z.le Z0 x'",
                "g : Z.gt Z0 x'"
            ]
        },
        {
            "tactic_sig": "left .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 x') (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 x') (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "right .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.and (Z.le Z0 x') (Logic.and (Z.le Z0 Z0) (Z.lt Z0 (Zpos xH))))\n  (Logic.and (Z.le x' Z0)\n     (Logic.and (Z.lt (Z.opp (Zpos xH)) Z0) (Z.le Z0 Z0)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le x' Z0)\n  (Logic.and (Z.lt (Z.opp (Zpos xH)) Z0) (Z.le Z0 Z0))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le x' Z0)\n  (Logic.and (Z.lt (Z.opp (Zpos xH)) Z0) (Z.le Z0 Z0))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul one x') Z0)",
                "one : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Zpos xH) x') Z0)"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq x' (Z.add (Z.mul (Zpos xH) x') Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (Z.opp x') (Z.opp (Z.quot x' one))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (mods x mone) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mods x mone) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite mods_divs .",
            "tactic_args": [
                "_goal : Logic.eq (mods x mone) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (mul (divs x mone) mone)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite divs_mone .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (mul (divs x mone) mone)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (mul (neg x) mone)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- neg_mul_distr_l .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (mul (neg x) mone)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (neg (mul x mone))) zero"
            ]
        },
        {
            "tactic_sig": "rewrite mul_mone .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (neg (mul x mone))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x (neg (neg x))) zero"
            ]
        },
        {
            "tactic_sig": "rewrite neg_involutive .",
            "tactic_args": [
                "_goal : Logic.eq (sub x (neg (neg x))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x x) zero"
            ]
        },
        {
            "tactic_sig": "apply sub_idem .",
            "tactic_args": [
                "_goal : Logic.eq (sub x x) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold divmodu2 , divu , modu .",
            "tactic_args": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero)),\nLogic.eq (divmodu2 zero n d) (Some (pair (divu n d) (modu n d)))"
            ],
            "tactic_res": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero)),\nLogic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n        (unsigned d) in\n    if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero)),\nLogic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n        (unsigned d) in\n    if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n        (unsigned d) in\n    if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))",
                "H : Logic.not (Logic.eq d zero)",
                "n : int",
                "d : int"
            ]
        },
        {
            "tactic_sig": "rewrite dec_eq_false by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n        (unsigned d) in\n    if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) :=\n     Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n       (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))"
            ]
        },
        {
            "tactic_sig": "set ( N := unsigned zero * modulus + unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) :=\n     Z.div_eucl (Z.add (Z.mul (unsigned zero) modulus) (unsigned n))\n       (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))",
                "N : Z"
            ]
        },
        {
            "tactic_sig": "assert ( E1 : unsigned _ = _ ) by ( unfold _ ; rewrite unsigned_zero ; ring ) .",
            "tactic_args": [
                "n : int",
                "N : Z",
                "N : Z"
            ],
            "tactic_res": [
                "E1 : Logic.eq (unsigned n) N"
            ]
        },
        {
            "tactic_sig": "rewrite ! _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div (unsigned n) (unsigned d)))\n        (repr (Z.modulo (unsigned n) (unsigned d)))))",
                "E1 : Logic.eq (unsigned n) N"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div N (unsigned d)))\n        (repr (Z.modulo N (unsigned d)))))"
            ]
        },
        {
            "tactic_sig": "set ( D := unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N (unsigned d) in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some\n     (pair (repr (Z.div N (unsigned d)))\n        (repr (Z.modulo N (unsigned d)))))",
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr (Z.div N D)) (repr (Z.modulo N D))))",
                "D : Z"
            ]
        },
        {
            "tactic_sig": "set ( Q := _ / _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr (Z.div N D)) (repr (Z.modulo N D))))",
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr Q) (repr (Z.modulo N D))))",
                "Q : Z"
            ]
        },
        {
            "tactic_sig": "set ( R := _ mod _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr Q) (repr (Z.modulo N D))))",
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr Q) (repr R)))",
                "R : Z"
            ]
        },
        {
            "tactic_sig": "assert ( E2 : Z.div_eucl _ _ = ( _ , _ ) ) .",
            "tactic_args": [
                "N : Z",
                "D : Z",
                "Q : Z",
                "R : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div_eucl N D) (pair Q R)",
                "E2 : Logic.eq (Z.div_eucl N D) (pair Q R)"
            ]
        },
        {
            "tactic_sig": "unfold _ , _ , Z.div , Z.modulo .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div_eucl N D) (pair Q R)",
                "Q : Z",
                "R : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.div_eucl N D)\n  (pair (let (q, _) := Z.div_eucl N D in q)\n     (let (_, r) := Z.div_eucl N D in r))"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.div_eucl _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.div_eucl N D)\n  (pair (let (q, _) := Z.div_eucl N D in q)\n     (let (_, r) := Z.div_eucl N D in r))",
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (pair z z0) (pair z z0)",
                "z : Z",
                "z0 : Z"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (pair z z0) (pair z z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.div_eucl N D in\n   if zle q max_unsigned then Some (pair (repr q) (repr r)) else None)\n  (Some (pair (repr Q) (repr R)))",
                "E2 : Logic.eq (Z.div_eucl N D) (pair Q R)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zle Q max_unsigned then Some (pair (repr Q) (repr R)) else None)\n  (Some (pair (repr Q) (repr R)))"
            ]
        },
        {
            "tactic_sig": "rewrite zle_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zle Q max_unsigned then Some (pair (repr Q) (repr R)) else None)\n  (Some (pair (repr Q) (repr R)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (pair (repr Q) (repr R)))\n  (Some (pair (repr Q) (repr R)))",
                "_goal : Z.le Q max_unsigned"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Some (pair (repr Q) (repr R)))\n  (Some (pair (repr Q) (repr R)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( unsigned _ <> 0 ) .",
            "tactic_args": [
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (unsigned d) Z0)",
                "H0 : Logic.not (Logic.eq (unsigned d) Z0)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned d) Z0)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned d) Z0, False"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned d) Z0, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H0 : Logic.eq (unsigned d) Z0"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : False",
                "H : Logic.not (Logic.eq d zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq d zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq d zero",
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned d)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned d)) zero",
                "H0 : Logic.eq (unsigned d) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr Z0) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr Z0) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( 0 < _ ) .",
            "tactic_args": [
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 D",
                "H1 : Z.lt Z0 D"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Z.lt Z0 D",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 (unsigned d)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.lt Z0 (unsigned d)",
                "d : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned d)) (Z.lt (unsigned d) modulus),\nZ.lt Z0 (unsigned d)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned d)) (Z.lt (unsigned d) modulus),\nZ.lt Z0 (unsigned d)"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 (unsigned d)",
                "H1 : Logic.and (Z.le Z0 (unsigned d)) (Z.lt (unsigned d) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt Z0 (unsigned d)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( 0 <= _ <= max_unsigned ) .",
            "tactic_args": [
                "Q : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 Q) (Z.le Q max_unsigned)",
                "H2 : Logic.and (Z.le Z0 Q) (Z.le Q max_unsigned)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 Q) (Z.le Q max_unsigned)",
                "Q : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.div N D)) (Z.le (Z.div N D) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "apply Zdiv_interval_2 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.div N D)) (Z.le (Z.div N D) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 N) (Z.le N max_unsigned)",
                "_goal : Z.le Z0 Z0",
                "_goal : Z.ge max_unsigned Z0",
                "_goal : Z.gt D Z0"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 N) (Z.le N max_unsigned)",
                "E1 : Logic.eq (unsigned n) N"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.le (unsigned n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_range_2 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.le (unsigned n) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Z.ge max_unsigned Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.sub modulus (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "generalize modulus_pos .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub modulus (Zpos xH)) Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt modulus Z0, Z.ge (Z.sub modulus (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt modulus Z0, Z.ge (Z.sub modulus (Zpos xH)) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.gt D Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Q max_unsigned"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : int,\nLogic.eq (unsigned n)\n  (if lt n zero then Z.add (signed n) modulus else signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if lt n zero then Z.add (signed n) modulus else signed n)",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if lt n zero then Z.add (signed n) modulus else signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (signed n) (signed zero) then true else false\n   then Z.add (signed n) modulus\n   else signed n)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (signed n) (signed zero) then true else false\n   then Z.add (signed n) modulus\n   else signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (signed n) Z0 then true else false\n   then Z.add (signed n) modulus\n   else signed n)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (signed n) Z0 then true else false\n   then Z.add (signed n) modulus\n   else signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) modulus) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) modulus) modulus\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) modulus)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) modulus) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) modulus) modulus\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) modulus)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) modulus) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) modulus) modulus\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_modulus .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) modulus) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) modulus) modulus\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) modulus)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)),\nLogic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)),\nLogic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))",
                "H : Logic.and (Z.le Z0 (unsigned n))\n  (Z.lt (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if\n    if\n     zlt\n       (if zlt (unsigned n) half_modulus\n        then unsigned n\n        else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add\n      (if zlt (unsigned n) half_modulus\n       then unsigned n\n       else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else\n    if zlt (unsigned n) half_modulus\n    then unsigned n\n    else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (unsigned n) Z0 then true else false\n   then Z.add (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)\n   else unsigned n)",
                "_goal : Logic.eq (unsigned n)\n  (if\n    if zlt (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))",
                "l : Z.lt (unsigned n) half_modulus",
                "g : Z.ge (unsigned n) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if if zlt (unsigned n) Z0 then true else false\n   then Z.add (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)\n   else unsigned n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n) (unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n) (unsigned n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (if\n    if zlt (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus)) Z0\n    then true\n    else false\n   then\n    Z.add (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n      (Z.mul (Zpos (xO xH)) half_modulus)\n   else Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n)\n  (Z.add (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.mul (Zpos (xO xH)) half_modulus))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n)\n  (Z.add (Z.sub (unsigned n) (Z.mul (Zpos (xO xH)) half_modulus))\n     (Z.mul (Zpos (xO xH)) half_modulus))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold divmods2 , divs , mods .",
            "tactic_args": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero))\n  (_ : Logic.or (Logic.not (Logic.eq n (repr min_signed)))\n         (Logic.not (Logic.eq d mone))),\nLogic.eq (divmods2 (if lt n zero then mone else zero) n d)\n  (Some (pair (divs n d) (mods n d)))"
            ],
            "tactic_res": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero))\n  (_ : Logic.or (Logic.not (Logic.eq n (repr min_signed)))\n         (Logic.not (Logic.eq d mone))),\nLogic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.quotrem\n        (Z.add\n           (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n           (unsigned n)) (signed d) in\n    if andb (zle min_signed q) (zle q max_signed)\n    then Some (pair (repr q) (repr r))\n    else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n d : int) (_ : Logic.not (Logic.eq d zero))\n  (_ : Logic.or (Logic.not (Logic.eq n (repr min_signed)))\n         (Logic.not (Logic.eq d mone))),\nLogic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.quotrem\n        (Z.add\n           (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n           (unsigned n)) (signed d) in\n    if andb (zle min_signed q) (zle q max_signed)\n    then Some (pair (repr q) (repr r))\n    else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.quotrem\n        (Z.add\n           (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n           (unsigned n)) (signed d) in\n    if andb (zle min_signed q) (zle q max_signed)\n    then Some (pair (repr q) (repr r))\n    else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))",
                "H0 : Logic.or (Logic.not (Logic.eq n (repr min_signed)))\n  (Logic.not (Logic.eq d mone))",
                "H : Logic.not (Logic.eq d zero)",
                "n : int",
                "d : int"
            ]
        },
        {
            "tactic_sig": "rewrite dec_eq_false by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if eq_dec d zero\n   then None\n   else\n    let (q, r) :=\n      Z.quotrem\n        (Z.add\n           (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n           (unsigned n)) (signed d) in\n    if andb (zle min_signed q) (zle q max_signed)\n    then Some (pair (repr q) (repr r))\n    else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) :=\n     Z.quotrem\n       (Z.add\n          (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n          (unsigned n)) (signed d) in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))"
            ]
        },
        {
            "tactic_sig": "set ( N := signed ( if lt _ zero then mone else zero ) * modulus + unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) :=\n     Z.quotrem\n       (Z.add\n          (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n          (unsigned n)) (signed d) in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))",
                "n : int",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.quotrem N (signed d) in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))",
                "N : Z"
            ]
        },
        {
            "tactic_sig": "set ( D := signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.quotrem N (signed d) in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some\n     (pair (repr (Z.quot (signed n) (signed d)))\n        (repr (Z.rem (signed n) (signed d)))))",
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (let (q, r) := Z.quotrem N D in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))",
                "D : Z"
            ]
        },
        {
            "tactic_sig": "assert ( _ <> 0 ) .",
            "tactic_args": [
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq D Z0)",
                "H1 : Logic.not (Logic.eq D Z0)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq D Z0)",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (signed d) Z0)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (signed d) Z0)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (signed d) Z0, False"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (signed d) Z0, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H1 : Logic.eq (signed d) Z0"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : False",
                "H : Logic.not (Logic.eq d zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq d zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq d zero",
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed d)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed d)) zero",
                "H1 : Logic.eq (signed d) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr Z0) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr Z0) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( _ = signed _ ) .",
            "tactic_args": [
                "N : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq N (signed n)",
                "H2 : Logic.eq N (signed n)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq N (signed n)",
                "N : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n     (unsigned n)) (signed n)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_signed .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n     (unsigned n)) (signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n     (if lt n zero then Z.add (signed n) modulus else signed n))\n  (signed n)"
            ]
        },
        {
            "tactic_sig": "destruct ( lt _ zero ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed (if lt n zero then mone else zero)) modulus)\n     (if lt n zero then Z.add (signed n) modulus else signed n))\n  (signed n)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed mone) modulus) (Z.add (signed n) modulus))\n  (signed n)",
                "_goal : Logic.eq (Z.add (Z.mul (signed zero) modulus) (signed n)) (signed n)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_mone .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.mul (signed mone) modulus) (Z.add (signed n) modulus))\n  (signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.mul (Zneg xH) modulus) (Z.add (signed n) modulus))\n  (signed n)"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.mul (Zneg xH) modulus) (Z.add (signed n) modulus))\n  (signed n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.mul (signed zero) modulus) (signed n)) (signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.mul Z0 modulus) (signed n)) (signed n)"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.mul Z0 modulus) (signed n)) (signed n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( Q := Z.quot _ _ ) .",
            "tactic_args": [
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "Q : Z"
            ]
        },
        {
            "tactic_sig": "set ( R := Z.rem _ _ ) .",
            "tactic_args": [
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "R : Z"
            ]
        },
        {
            "tactic_sig": "assert ( E2 : Z.quotrem _ _ = ( _ , _ ) ) .",
            "tactic_args": [
                "N : Z",
                "D : Z",
                "Q : Z",
                "R : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.quotrem N D) (pair Q R)",
                "E2 : Logic.eq (Z.quotrem N D) (pair Q R)"
            ]
        },
        {
            "tactic_sig": "unfold _ , _ , Z.quot , Z.rem .",
            "tactic_args": [
                "_goal : Logic.eq (Z.quotrem N D) (pair Q R)",
                "Q : Z",
                "R : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.quotrem N D)\n  (pair (fst (Z.quotrem N D)) (snd (Z.quotrem N D)))"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.quotrem _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.quotrem N D)\n  (pair (fst (Z.quotrem N D)) (snd (Z.quotrem N D)))",
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (pair z z0) (pair (fst (pair z z0)) (snd (pair z z0)))",
                "z : Z",
                "z0 : Z"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (pair z z0) (pair (fst (pair z z0)) (snd (pair z z0)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (let (q, r) := Z.quotrem N D in\n   if andb (zle min_signed q) (zle q max_signed)\n   then Some (pair (repr q) (repr r))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))",
                "E2 : Logic.eq (Z.quotrem N D) (pair Q R)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if andb (zle min_signed Q) (zle Q max_signed)\n   then Some (pair (repr Q) (repr R))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "assert ( min_signed <= _ <= max_signed ) by ( rewrite _ ; apply signed_range ) .",
            "tactic_args": [
                "N : Z",
                "H2 : Logic.eq N (signed n)"
            ],
            "tactic_res": [
                "H3 : Logic.and (Z.le min_signed N) (Z.le N max_signed)"
            ]
        },
        {
            "tactic_sig": "assert ( min_signed <= _ <= max_signed ) .",
            "tactic_args": [
                "Q : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed Q) (Z.le Q max_signed)",
                "H4 : Logic.and (Z.le min_signed Q) (Z.le Q max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed Q) (Z.le Q max_signed)",
                "Q : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N D)) (Z.le (Z.quot N D) max_signed)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq _ 1 ) ; [ | destruct ( zeq _ ( - 1 ) ) ] .",
            "tactic_args": [
                "D : Z",
                "D : Z"
            ],
            "tactic_res": [
                "e : Logic.eq D (Zpos xH)",
                "e : Logic.eq D (Zneg xH)",
                "n0 : Logic.not (Logic.eq D (Zpos xH))",
                "n1 : Logic.not (Logic.eq D (Zneg xH))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "e : Logic.eq D (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Zpos xH)))\n  (Z.le (Z.quot N (Zpos xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.quot_1_r .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Zpos xH)))\n  (Z.le (Z.quot N (Zpos xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed N) (Z.le N max_signed)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed N) (Z.le N max_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "e : Logic.eq D (Zneg xH)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Zneg xH)))\n  (Z.le (Z.quot N (Zneg xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "change ( - 1 ) with ( Z.opp 1 ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Zneg xH)))\n  (Z.le (Z.quot N (Zneg xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Z.opp (Zpos xH))))\n  (Z.le (Z.quot N (Z.opp (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.quot_opp_r by omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N (Z.opp (Zpos xH))))\n  (Z.le (Z.quot N (Z.opp (Zpos xH))) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.opp (Z.quot N (Zpos xH))))\n  (Z.le (Z.opp (Z.quot N (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.quot_1_r .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.opp (Z.quot N (Zpos xH))))\n  (Z.le (Z.opp (Z.quot N (Zpos xH))) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.opp N)) (Z.le (Z.opp N) max_signed)"
            ]
        },
        {
            "tactic_sig": "assert ( _ <> min_signed ) .",
            "tactic_args": [
                "N : Z"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq N min_signed)",
                "H4 : Logic.not (Logic.eq N min_signed)"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq N min_signed)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq N min_signed, False"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq N min_signed, False"
            ],
            "tactic_res": [
                "_goal : False",
                "H4 : Logic.eq N min_signed"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "H0 : Logic.or (Logic.not (Logic.eq n (repr min_signed)))\n  (Logic.not (Logic.eq d mone))"
            ],
            "tactic_res": [
                "H0 : Logic.not (Logic.eq n (repr min_signed))",
                "H0 : Logic.not (Logic.eq d mone)"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "H0 : Logic.not (Logic.eq n (repr min_signed))"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (repr min_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq n (repr min_signed)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed n)) (repr min_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed n)) (repr min_signed)",
                "H2 : Logic.eq N (signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr N) (repr min_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr N) (repr min_signed)",
                "H4 : Logic.eq N min_signed"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr min_signed) (repr min_signed)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr min_signed) (repr min_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : False",
                "H0 : Logic.not (Logic.eq d mone)"
            ],
            "tactic_res": [
                "_goal : Logic.eq d mone"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq d mone",
                "d : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed d)) mone"
            ]
        },
        {
            "tactic_sig": "unfold _ in _ .",
            "tactic_args": [
                "D : Z",
                "e : Logic.eq D (Zneg xH)"
            ],
            "tactic_res": [
                "e : Logic.eq (signed d) (Zneg xH)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed d)) mone",
                "e : Logic.eq (signed d) (Zneg xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Zneg xH)) mone"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Zneg xH)) mone"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold min_signed , max_signed in * .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.opp N)) (Z.le (Z.opp N) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.opp N))\n  (Z.le (Z.opp N) (Z.sub half_modulus (Zpos xH)))",
                "H4 : Logic.not (Logic.eq N (Z.opp half_modulus))",
                "H3 : Logic.and (Z.le (Z.opp half_modulus) N)\n  (Z.le N (Z.sub half_modulus (Zpos xH)))",
                "H0 : Logic.or (Logic.not (Logic.eq n (repr (Z.opp half_modulus))))\n  (Logic.not (Logic.eq d mone))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.opp N))\n  (Z.le (Z.opp N) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( Z.abs ( Z.quot _ _ ) < half_modulus ) .",
            "tactic_args": [
                "N : Z",
                "D : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.abs (Z.quot N D)) half_modulus",
                "H4 : Z.lt (Z.abs (Z.quot N D)) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite <- Z.quot_abs by omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.abs (Z.quot N D)) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.quot (Z.abs N) (Z.abs D)) half_modulus"
            ]
        },
        {
            "tactic_sig": "apply Zquot_lt_upper_bound .",
            "tactic_args": [
                "_goal : Z.lt (Z.quot (Z.abs N) (Z.abs D)) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.abs N)",
                "_goal : Z.lt Z0 (Z.abs D)",
                "_goal : Z.lt (Z.abs N) (Z.mul half_modulus (Z.abs D))"
            ]
        },
        {
            "tactic_sig": "xomega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.abs N)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "xomega .",
            "tactic_args": [
                "_goal : Z.lt Z0 (Z.abs D)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z.le_lt_trans with ( half_modulus * 1 ) .",
            "tactic_args": [
                "_goal : Z.lt (Z.abs N) (Z.mul half_modulus (Z.abs D))"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.abs N) (Z.mul half_modulus (Zpos xH))",
                "_goal : Z.lt (Z.mul half_modulus (Zpos xH)) (Z.mul half_modulus (Z.abs D))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mul_1_r .",
            "tactic_args": [
                "_goal : Z.le (Z.abs N) (Z.mul half_modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.abs N) half_modulus"
            ]
        },
        {
            "tactic_sig": "unfold min_signed , max_signed in _ .",
            "tactic_args": [
                "H3 : Logic.and (Z.le min_signed N) (Z.le N max_signed)"
            ],
            "tactic_res": [
                "H3 : Logic.and (Z.le (Z.opp half_modulus) N)\n  (Z.le N (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "xomega .",
            "tactic_args": [
                "_goal : Z.le (Z.abs N) half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Zmult_lt_compat_l .",
            "tactic_args": [
                "_goal : Z.lt (Z.mul half_modulus (Zpos xH)) (Z.mul half_modulus (Z.abs D))"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 half_modulus",
                "_goal : Z.lt (Zpos xH) (Z.abs D)"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos .",
            "tactic_args": [
                "_goal : Z.lt Z0 half_modulus"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt Z0 half_modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt half_modulus Z0, Z.lt Z0 half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "xomega .",
            "tactic_args": [
                "_goal : Z.lt (Zpos xH) (Z.abs D)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.abs_lt in _ .",
            "tactic_args": [
                "H4 : Z.lt (Z.abs (Z.quot N D)) half_modulus"
            ],
            "tactic_res": [
                "H4 : Logic.and (Z.lt (Z.opp half_modulus) (Z.quot N D))\n  (Z.lt (Z.quot N D) half_modulus)"
            ]
        },
        {
            "tactic_sig": "unfold min_signed , max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.quot N D)) (Z.le (Z.quot N D) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.quot N D))\n  (Z.le (Z.quot N D) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.quot N D))\n  (Z.le (Z.quot N D) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if andb (zle min_signed Q) (zle Q max_signed)\n   then Some (pair (repr Q) (repr R))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    andb (if zle min_signed Q then true else false)\n      (if zle Q max_signed then true else false)\n   then Some (pair (repr Q) (repr R))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "rewrite ! zle_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    andb (if zle min_signed Q then true else false)\n      (if zle Q max_signed then true else false)\n   then Some (pair (repr Q) (repr R))\n   else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if andb true true then Some (pair (repr Q) (repr R)) else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if andb true true then Some (pair (repr Q) (repr R)) else None)\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (pair (repr Q) (repr R)))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "unfold _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (Some (pair (repr Q) (repr R)))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))",
                "Q : Z",
                "R : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (pair (repr (Z.quot N D)) (repr (Z.rem N D))))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Some (pair (repr (Z.quot N D)) (repr (Z.rem N D))))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))",
                "H2 : Logic.eq N (signed n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))\n  (Some (pair (repr (Z.quot (signed n) D)) (repr (Z.rem (signed n) D))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (repr x) i) (Z.testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr x) i) (Z.testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "x : Z",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr x) i) (Z.testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (repr x)) i) (Z.testbit x i)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eqm .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (repr x)) i) (Z.testbit x i)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr x)) x",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr x)) x"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit x i) (testbit y i)), Logic.eq x y"
            ],
            "tactic_res": [
                "_goal : Logic.eq x y",
                "H : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) (testbit y i)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq x y",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) y"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) y",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) (repr (unsigned y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) (repr (unsigned y))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_same_bits .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Z) (_ : Z.ge i zwordsize),\nLogic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) false",
                "H : Z.ge i zwordsize",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_above with wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))",
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Z) (_ : Z.lt i Z0), Logic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) false",
                "H : Z.lt i Z0",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Z.testbit_neg_r .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Z.lt i Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt i Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall i : Z, Logic.eq (testbit zero i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit zero i) false",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (testbit zero i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned zero) i) false"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned zero) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit Z0 i) false"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_0 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit Z0 i) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : forall n : Z, Logic.eq (testbit one n) (zeq n Z0)"
            ],
            "tactic_res": [
                "_goal : forall n : Z, Logic.eq (Z.testbit (unsigned one) n) (zeq n Z0)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : Z, Logic.eq (Z.testbit (unsigned one) n) (zeq n Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned one) n) (zeq n Z0)",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned one) n) (zeq n Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Zpos xH) n) (zeq n Z0)"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_1 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Zpos xH) n) (zeq n Z0)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit mone i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit mone i) true",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "unfold mone .",
            "tactic_args": [
                "_goal : Logic.eq (testbit mone i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Zneg xH)) i) true"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Zneg xH)) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Zneg xH) i) true",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Ztestbit_m1 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Zneg xH) i) true"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (if zlt (unsigned x) half_modulus then false else true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (if zlt (unsigned x) half_modulus then false else true)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (if zlt (unsigned x) half_modulus then false else true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub zwordsize (Zpos xH)))\n  (if zlt (unsigned x) half_modulus then false else true)"
            ]
        },
        {
            "tactic_sig": "set ( ws1 := Init.Nat.pred wordsize ) .",
            "tactic_args": [],
            "tactic_res": [
                "ws1 : nat"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize - 1 = Z.of_nat _ ) .",
            "tactic_args": [
                "ws1 : nat"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.of_nat ws1)",
                "H : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.of_nat ws1)"
            ]
        },
        {
            "tactic_sig": "unfold zwordsize , _ , wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.of_nat ws1)",
                "ws1 : nat"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.of_nat WS.wordsize) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred WS.wordsize))"
            ]
        },
        {
            "tactic_sig": "destruct WS.wordsize as [ ] eqn : E .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.of_nat WS.wordsize) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred WS.wordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.of_nat O) (Zpos xH)) (Z.of_nat (Init.Nat.pred O))",
                "_goal : Logic.eq (Z.sub (Z.of_nat (S n)) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred (S n)))",
                "E : Logic.eq WS.wordsize O",
                "E : Logic.eq WS.wordsize (S n)",
                "n : nat"
            ]
        },
        {
            "tactic_sig": "elim WS.wordsize_not_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.of_nat O) (Zpos xH)) (Z.of_nat (Init.Nat.pred O))"
            ],
            "tactic_res": [
                "_goal : Logic.eq WS.wordsize O"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq WS.wordsize O"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Nat2Z.inj_succ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.of_nat (S n)) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred (S n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.succ (Z.of_nat n)) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred (S n)))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.succ (Z.of_nat n)) (Zpos xH))\n  (Z.of_nat (Init.Nat.pred (S n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.succ (Z.of_nat n)) (Zpos xH)) (Z.of_nat n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.succ (Z.of_nat n)) (Zpos xH)) (Z.of_nat n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( half_modulus = two_power_nat _ ) .",
            "tactic_args": [
                "ws1 : nat"
            ],
            "tactic_res": [
                "_goal : Logic.eq half_modulus (two_power_nat ws1)",
                "H0 : Logic.eq half_modulus (two_power_nat ws1)"
            ]
        },
        {
            "tactic_sig": "rewrite two_power_nat_two_p .",
            "tactic_args": [
                "_goal : Logic.eq half_modulus (two_power_nat ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq half_modulus (two_p (Z.of_nat ws1))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq half_modulus (two_p (Z.of_nat ws1))",
                "H : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.of_nat ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq half_modulus (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "apply half_modulus_power .",
            "tactic_args": [
                "_goal : Logic.eq half_modulus (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub zwordsize (Zpos xH)))\n  (if zlt (unsigned x) half_modulus then false else true)",
                "H : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.of_nat ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.of_nat ws1))\n  (if zlt (unsigned x) half_modulus then false else true)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.of_nat ws1))\n  (if zlt (unsigned x) half_modulus then false else true)",
                "H0 : Logic.eq half_modulus (two_power_nat ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.of_nat ws1))\n  (if zlt (unsigned x) (two_power_nat ws1) then false else true)"
            ]
        },
        {
            "tactic_sig": "apply Zsign_bit .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.of_nat ws1))\n  (if zlt (unsigned x) (two_power_nat ws1) then false else true)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat (S ws1)))"
            ]
        },
        {
            "tactic_sig": "rewrite two_power_nat_S .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat (S ws1)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (Z.mul (Zpos (xO xH)) (two_power_nat ws1)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (Z.mul (Zpos (xO xH)) (two_power_nat ws1)))",
                "H0 : Logic.eq half_modulus (two_power_nat ws1)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (Z.mul (Zpos (xO xH)) half_modulus))"
            ]
        },
        {
            "tactic_sig": "rewrite <- half_modulus_modulus .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (Z.mul (Zpos (xO xH)) half_modulus))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Z) (_ : Z.le Z0 i),\nLogic.eq (Z.testbit (signed x) i)\n  (testbit x (if zlt i zwordsize then i else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (signed x) i)\n  (testbit x (if zlt i zwordsize then i else Z.sub zwordsize (Zpos xH)))",
                "H : Z.le Z0 i",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (signed x) i)\n  (testbit x (if zlt i zwordsize then i else Z.sub zwordsize (Zpos xH)))",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (signed x) i) (testbit x i)",
                "_goal : Logic.eq (Z.testbit (signed x) i)\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt i zwordsize",
                "g : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eqm .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (signed x) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (signed x) i)\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) i)\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite sign_bit_of_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) i)\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) i)\n  (if zlt (unsigned x) half_modulus then false else true)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (if zlt (unsigned x) half_modulus\n      then unsigned x\n      else Z.sub (unsigned x) modulus) i)\n  (if zlt (unsigned x) half_modulus then false else true)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) false",
                "_goal : Logic.eq (Z.testbit (Z.sub (unsigned x) modulus) i) true",
                "l : Z.lt (unsigned x) half_modulus",
                "g0 : Z.ge (unsigned x) half_modulus"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_above with wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))",
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Ztestbit_above_neg with wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.sub (unsigned x) modulus) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_power_nat wordsize)) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)",
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ]
        },
        {
            "tactic_sig": "fold modulus .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_power_nat wordsize)) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp modulus) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp modulus) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le (Z.opp modulus) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le (Z.opp modulus) (Z.sub (unsigned x) modulus))\n  (Z.lt (Z.sub (unsigned x) modulus) Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i (Z.of_nat wordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n         (_ : Logic.eq (testbit x i) true), Logic.eq (testbit y i) true),\nZ.le (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Z.le (unsigned x) (unsigned y)",
                "H : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit x i) true), Logic.eq (testbit y i) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_le .",
            "tactic_args": [
                "_goal : Z.le (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (unsigned y)",
                "_goal : forall (i : Z) (_ : Z.le Z0 i)\n  (_ : Logic.eq (Z.testbit (unsigned x) i) true),\nLogic.eq (Z.testbit (unsigned y) i) true"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned y)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Z.le Z0 i)\n  (_ : Logic.eq (Z.testbit (unsigned x) i) true),\nLogic.eq (Z.testbit (unsigned y) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned y) i) true",
                "H1 : Logic.eq (Z.testbit (unsigned x) i) true",
                "H0 : Z.le Z0 i",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned y) i) true",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit y i) true"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "l : Z.lt i zwordsize",
                "g : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "H : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit x i) true), Logic.eq (testbit y i) true"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.eq (testbit x i) true"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold ( testbit _ _ ) in _ .",
            "tactic_args": [
                "x : int",
                "i : Z",
                "H1 : Logic.eq (Z.testbit (unsigned x) i) true"
            ],
            "tactic_res": [
                "H1 : Logic.eq (testbit x i) true"
            ]
        },
        {
            "tactic_sig": "rewrite bits_above in _ .",
            "tactic_args": [
                "H1 : Logic.eq (testbit x i) true"
            ],
            "tactic_res": [
                "_goal : Z.ge i zwordsize",
                "H1 : Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (testbit y i) true"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold and .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.land (unsigned x) (unsigned y))) i)\n  (andb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.land (unsigned x) (unsigned y))) i)\n  (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.land (unsigned x) (unsigned y)) i)\n  (andb (testbit x i) (testbit y i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.land_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.land (unsigned x) (unsigned y)) i)\n  (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (andb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : Logic.eq (andb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.lor (unsigned x) (unsigned y))) i)\n  (orb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.lor (unsigned x) (unsigned y))) i)\n  (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.lor (unsigned x) (unsigned y)) i)\n  (orb (testbit x i) (testbit y i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.lor_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.lor (unsigned x) (unsigned y)) i)\n  (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (orb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold xor .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.lxor (unsigned x) (unsigned y))) i)\n  (xorb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.lxor (unsigned x) (unsigned y))) i)\n  (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.lxor (unsigned x) (unsigned y)) i)\n  (xorb (testbit x i) (testbit y i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.lxor_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.lxor (unsigned x) (unsigned y)) i)\n  (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (xorb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (Z.testbit (unsigned x) i) (Z.testbit (unsigned y) i))\n  (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (not x) i) (negb (testbit x i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (not x) i) (negb (testbit x i))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold not .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (not x) i) (negb (testbit x i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (xor x mone) i) (negb (testbit x i))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_xor .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (xor x mone) i) (negb (testbit x i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit mone i)) (negb (testbit x i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_mone .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit mone i)) (negb (testbit x i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) true) (negb (testbit x i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) true) (negb (testbit x i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (and x y) (and y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (and (and x y) z) (and x (and y z))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and x zero) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) false) false",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply andb_b_false .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and zero x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and zero x) zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite and_commut .",
            "tactic_args": [
                "_goal : Logic.eq (and zero x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and x zero) zero"
            ]
        },
        {
            "tactic_sig": "apply and_zero .",
            "tactic_args": [
                "_goal : Logic.eq (and x zero) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and x mone) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) true) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply andb_b_true .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) true) (testbit x i)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and mone x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and mone x) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite and_commut .",
            "tactic_args": [
                "_goal : Logic.eq (and mone x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and x mone) x"
            ]
        },
        {
            "tactic_sig": "apply and_mone .",
            "tactic_args": [
                "_goal : Logic.eq (and x mone) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and x x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) (testbit x i)) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) (testbit x i)) (testbit x i)",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb true true) true",
                "_goal : Logic.eq (andb false false) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb true true) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb false false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (or x y) (or y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (or (or x y) z) (or x (or y z))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (or x zero) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (or zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or zero x) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite or_commut .",
            "tactic_args": [
                "_goal : Logic.eq (or zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or x zero) x"
            ]
        },
        {
            "tactic_sig": "apply or_zero .",
            "tactic_args": [
                "_goal : Logic.eq (or x zero) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (or x mone) mone"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (or x x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit x i) (testbit x i)) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit x i) (testbit x i)) (testbit x i)",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb true true) true",
                "_goal : Logic.eq (orb false false) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb true true) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (and x (or y z)) (or (and x y) (and x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) (orb (testbit y i) (testbit z i)))\n  (orb (andb (testbit x i) (testbit y i))\n     (andb (testbit x i) (testbit z i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply demorgan1 .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) (orb (testbit y i) (testbit z i)))\n  (orb (andb (testbit x i) (testbit y i))\n     (andb (testbit x i) (testbit z i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (and (or x y) z) (or (and x z) (and y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (or x y) z) (or (and x z) (and y z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite ( and_commut ( or _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (and (or x y) z) (or (and x z) (and y z))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and z (or x y)) (or (and x z) (and y z))"
            ]
        },
        {
            "tactic_sig": "rewrite and_or_distrib .",
            "tactic_args": [
                "_goal : Logic.eq (and z (or x y)) (or (and x z) (and y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (and z x) (and z y)) (or (and x z) (and y z))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (or (and z x) (and z y)) (or (and x z) (and y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and z x) (and x z)",
                "_goal : Logic.eq (and z y) (and y z)"
            ]
        },
        {
            "tactic_sig": "apply and_commut .",
            "tactic_args": [
                "_goal : Logic.eq (and z x) (and x z)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply and_commut .",
            "tactic_args": [
                "_goal : Logic.eq (and z y) (and y z)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (or x (and y z)) (and (or x y) (or x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit x i) (andb (testbit y i) (testbit z i)))\n  (andb (orb (testbit x i) (testbit y i))\n     (orb (testbit x i) (testbit z i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply orb_andb_distrib_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit x i) (andb (testbit y i) (testbit z i)))\n  (andb (orb (testbit x i) (testbit y i))\n     (orb (testbit x i) (testbit z i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (or (and x y) z) (and (or x z) (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (and x y) z) (and (or x z) (or y z))",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite ( or_commut ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (or (and x y) z) (and (or x z) (or y z))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or z (and x y)) (and (or x z) (or y z))"
            ]
        },
        {
            "tactic_sig": "rewrite or_and_distrib .",
            "tactic_args": [
                "_goal : Logic.eq (or z (and x y)) (and (or x z) (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (or z x) (or z y)) (and (or x z) (or y z))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (and (or z x) (or z y)) (and (or x z) (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or z x) (or x z)",
                "_goal : Logic.eq (or z y) (or y z)"
            ]
        },
        {
            "tactic_sig": "apply or_commut .",
            "tactic_args": [
                "_goal : Logic.eq (or z x) (or x z)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply or_commut .",
            "tactic_args": [
                "_goal : Logic.eq (or z y) (or y z)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (and x (or x y)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) (orb (testbit x i) (testbit y i)))\n  (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( forall a b , a && ( a || b ) = a ) by destr_bool .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : forall a b : bool, Logic.eq (andb a (orb a b)) a"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) (orb (testbit x i) (testbit y i)))\n  (testbit x i)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (or x (and x y)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit x i) (andb (testbit x i) (testbit y i)))\n  (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( forall a b , a || ( a && b ) = a ) by destr_bool .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : forall a b : bool, Logic.eq (orb a (andb a b)) a"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit x i) (andb (testbit x i) (testbit y i)))\n  (testbit x i)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (xor x y) (xor y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i))\n  (xorb (testbit y i) (testbit x i))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply xorb_comm .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i))\n  (xorb (testbit y i) (testbit x i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int, Logic.eq (xor (xor x y) z) (xor x (xor y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (xorb (testbit x i) (testbit y i)) (testbit z i))\n  (xorb (testbit x i) (xorb (testbit y i) (testbit z i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply xorb_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (xorb (testbit x i) (testbit y i)) (testbit z i))\n  (xorb (testbit x i) (xorb (testbit y i) (testbit z i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (xor x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) false) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply xorb_false .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) false) (testbit x i)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (xor zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor zero x) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite xor_commut .",
            "tactic_args": [
                "_goal : Logic.eq (xor zero x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor x zero) x"
            ]
        },
        {
            "tactic_sig": "apply xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq (xor x zero) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (xor x x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit x i)) false",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply xorb_nilpotent .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit x i)) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "rewrite xor_commut .",
            "tactic_args": [
                "_goal : Logic.eq (xor zero one) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor one zero) one"
            ]
        },
        {
            "tactic_sig": "apply xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq (xor one zero) one"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "apply xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (xor one one) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (xor x y) zero), Logic.eq x y"
            ],
            "tactic_res": [
                "_goal : Logic.eq x y",
                "H : Logic.eq (xor x y) zero",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq x y"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) (testbit y i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) (testbit y i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (testbit y i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "assert ( xorb ( testbit _ _ ) ( testbit _ _ ) = false ) .",
            "tactic_args": [
                "x : int",
                "i : Z",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i)) false",
                "H1 : Logic.eq (xorb (testbit x i) (testbit y i)) false"
            ]
        },
        {
            "tactic_sig": "rewrite <- bits_xor .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (xor x y) i) false",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (xor x y) i) false",
                "H : Logic.eq (xor x y) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit zero i) false"
            ]
        },
        {
            "tactic_sig": "apply bits_zero .",
            "tactic_args": [
                "_goal : Logic.eq (testbit zero i) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (testbit y i)",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (testbit y i)",
                "_goal : Logic.eq false (testbit y i)",
                "H1 : Logic.eq (xorb true (testbit y i)) false",
                "H1 : Logic.eq (xorb false (testbit y i)) false"
            ]
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq true (testbit y i)",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "_goal : Logic.eq true false",
                "H1 : Logic.eq (xorb true true) false",
                "H1 : Logic.eq (xorb true false) false"
            ]
        },
        {
            "tactic_sig": "reflexivity || discriminate .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "reflexivity || discriminate .",
            "tactic_args": [
                "_goal : Logic.eq true false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit y i)",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "_goal : Logic.eq false false",
                "H1 : Logic.eq (xorb false true) false",
                "H1 : Logic.eq (xorb false false) false"
            ]
        },
        {
            "tactic_sig": "reflexivity || discriminate .",
            "tactic_args": [
                "_goal : Logic.eq false true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "reflexivity || discriminate .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (eq (xor x y) zero) (eq x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq (xor x y) zero) (eq x y)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "predSpec eq eq_spec ( xor _ _ ) zero .",
            "tactic_args": [
                "_goal : Logic.eq (eq (xor x y) zero) (eq x y)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (eq x y)",
                "_goal : Logic.eq false (eq x y)",
                "H : Logic.eq (xor x y) zero",
                "H : Logic.not (Logic.eq (xor x y) zero)"
            ]
        },
        {
            "tactic_sig": "apply xor_zero_equal in _ .",
            "tactic_args": [
                "H : Logic.eq (xor x y) zero"
            ],
            "tactic_res": [
                "H : Logic.eq x y"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq true (eq x y)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (eq x x)"
            ]
        },
        {
            "tactic_sig": "rewrite eq_true .",
            "tactic_args": [
                "_goal : Logic.eq true (eq x x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "predSpec eq eq_spec _ _ .",
            "tactic_args": [
                "_goal : Logic.eq false (eq x y)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "_goal : Logic.eq false false",
                "H0 : Logic.eq x y",
                "H0 : Logic.not (Logic.eq x y)"
            ]
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : Logic.eq false true",
                "H : Logic.not (Logic.eq (xor x y) zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor x y) zero"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq (xor x y) zero",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor x x) zero",
                "H : Logic.not (Logic.eq (xor x x) zero)"
            ]
        },
        {
            "tactic_sig": "apply xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (xor x x) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y z : int,\nLogic.eq (and x (xor y z)) (xor (and x y) (and x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x i) (xorb (testbit y i) (testbit z i)))\n  (xorb (andb (testbit x i) (testbit y i))\n     (andb (testbit x i) (testbit z i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "assert ( forall a b c , a && ( xorb b c ) = xorb ( a && b ) ( a && c ) ) by destr_bool .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : forall a b c : bool,\nLogic.eq (andb a (xorb b c)) (xorb (andb a b) (andb a c))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x i) (xorb (testbit y i) (testbit z i)))\n  (xorb (andb (testbit x i) (testbit y i))\n     (andb (testbit x i) (testbit z i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Z.le (unsigned (and x y)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : Z.le (unsigned (and x y)) (unsigned x)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply bits_le .",
            "tactic_args": [
                "_goal : Z.le (unsigned (and x y)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit (and x y) i) true),\nLogic.eq (testbit x i) true"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit (and x y) i) true),\nLogic.eq (testbit x i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) true",
                "H0 : Logic.eq (testbit (and x y) i) true",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and in _ .",
            "tactic_args": [
                "H0 : Logic.eq (testbit (and x y) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "H0 : Logic.eq (andb (testbit x i) (testbit y i)) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite andb_true_iff in _ .",
            "tactic_args": [
                "H0 : Logic.eq (andb (testbit x i) (testbit y i)) true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Logic.eq (testbit x i) true) (Logic.eq (testbit y i) true)"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) true"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Z.le (unsigned x) (unsigned (or x y))"
            ],
            "tactic_res": [
                "_goal : Z.le (unsigned x) (unsigned (or x y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply bits_le .",
            "tactic_args": [
                "_goal : Z.le (unsigned x) (unsigned (or x y))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit x i) true), Logic.eq (testbit (or x y) i) true"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize))\n  (_ : Logic.eq (testbit x i) true), Logic.eq (testbit (or x y) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (or x y) i) true",
                "H0 : Logic.eq (testbit x i) true",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or x y) i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit x i) (testbit y i)) true",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit x i) (testbit y i)) true",
                "H0 : Logic.eq (testbit x i) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb true (testbit y i)) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb true (testbit y i)) true"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (not (not x)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not (not x)) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold not .",
            "tactic_args": [
                "_goal : Logic.eq (not (not x)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (xor x mone) mone) x"
            ]
        },
        {
            "tactic_sig": "rewrite xor_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (xor (xor x mone) mone) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor x (xor mone mone)) x"
            ]
        },
        {
            "tactic_sig": "rewrite xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (xor x (xor mone mone)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor x zero) x"
            ]
        },
        {
            "tactic_sig": "apply xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq (xor x zero) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold not .",
            "tactic_args": [
                "_goal : Logic.eq (not zero) mone"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor zero mone) mone"
            ]
        },
        {
            "tactic_sig": "rewrite xor_commut .",
            "tactic_args": [
                "_goal : Logic.eq (xor zero mone) mone"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor mone zero) mone"
            ]
        },
        {
            "tactic_sig": "apply xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq (xor mone zero) mone"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "rewrite <- ( not_involutive zero ) .",
            "tactic_args": [
                "_goal : Logic.eq (not mone) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not mone) (not (not zero))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (not mone) (not (not zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not (not zero)) (not mone)"
            ]
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (not (not zero)) (not mone)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not zero) mone"
            ]
        },
        {
            "tactic_sig": "apply not_zero .",
            "tactic_args": [
                "_goal : Logic.eq (not zero) mone"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (not (or x y)) (and (not x) (not y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (orb (testbit x i) (testbit y i)))\n  (andb (negb (testbit x i)) (negb (testbit y i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply negb_orb .",
            "tactic_args": [
                "_goal : Logic.eq (negb (orb (testbit x i) (testbit y i)))\n  (andb (negb (testbit x i)) (negb (testbit y i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (not (and x y)) (or (not x) (not y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (andb (testbit x i) (testbit y i)))\n  (orb (negb (testbit x i)) (negb (testbit y i)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply negb_andb .",
            "tactic_args": [
                "_goal : Logic.eq (negb (andb (testbit x i) (testbit y i)))\n  (orb (negb (testbit x i)) (negb (testbit y i)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (and x (not x)) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (or x (not x)) mone"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (xor x (not x)) mone"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (negb (testbit x i))) true",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (negb (testbit x i))) true",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb true (negb true)) true",
                "_goal : Logic.eq (xorb false (negb false)) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb true (negb true)) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false (negb false)) true"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.eq (unsigned (not x)) (Z.sub max_unsigned (unsigned x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (not x)) (Z.sub max_unsigned (unsigned x))",
                "x : int"
            ]
        },
        {
            "tactic_sig": "transitivity ( unsigned ( repr ( - unsigned _ - 1 ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (not x)) (Z.sub max_unsigned (unsigned x))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (not x))\n  (unsigned (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))))",
                "_goal : Logic.eq (unsigned (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))))\n  (Z.sub max_unsigned (unsigned x))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (not x))\n  (unsigned (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not x) (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (not x) (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (testbit x i))\n  (testbit (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))) i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (negb (testbit x i))\n  (testbit (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (testbit x i))\n  (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (negb (testbit x i))\n  (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (negb (testbit x i))"
            ]
        },
        {
            "tactic_sig": "apply Z_one_complement .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (negb (testbit x i))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (Z.opp (unsigned x)) (Zpos xH))))\n  (Z.sub max_unsigned (unsigned x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub (Z.opp (unsigned x)) (Zpos xH)) modulus)\n  (Z.sub max_unsigned (unsigned x))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub (Z.opp (unsigned x)) (Zpos xH)) modulus)\n  (Z.sub max_unsigned (unsigned x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.sub max_unsigned (unsigned x)))",
                "_goal : Logic.and (Z.le Z0 (Z.sub max_unsigned (unsigned x)))\n  (Z.lt (Z.sub max_unsigned (unsigned x)) modulus)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.sub max_unsigned (unsigned x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub max_unsigned (unsigned x)))\n  (Z.lt (Z.sub max_unsigned (unsigned x)) modulus)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (Z.sub max_unsigned (unsigned x)))\n  (Z.lt (Z.sub max_unsigned (unsigned x)) modulus)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (Z.sub max_unsigned (unsigned x)))\n  (Z.lt (Z.sub max_unsigned (unsigned x)) modulus)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)))\n  (Z.lt (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)))\n  (Z.lt (Z.sub (Z.sub modulus (Zpos xH)) (unsigned x)) modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (not x) (add (neg x) mone)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (testbit x i)) (testbit (add (neg x) mone) i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) at 1 .",
            "tactic_args": [
                "_goal : Logic.eq (negb (testbit x i)) (testbit (add (neg x) mone) i)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (testbit (repr (unsigned x)) i))\n  (testbit (add (neg x) mone) i)"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (negb (testbit (repr (unsigned x)) i))\n  (testbit (add (neg x) mone) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (testbit (repr (unsigned x)) i))\n  (testbit (repr (Z.add (unsigned (neg x)) (unsigned mone))) i)"
            ]
        },
        {
            "tactic_sig": "rewrite !testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (negb (testbit (repr (unsigned x)) i))\n  (testbit (repr (Z.add (unsigned (neg x)) (unsigned mone))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (Z.testbit (unsigned x) i))\n  (Z.testbit (Z.add (unsigned (neg x)) (unsigned mone)) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( Z.testbit ( - unsigned _ - 1 ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Z.testbit (unsigned x) i))\n  (Z.testbit (Z.add (unsigned (neg x)) (unsigned mone)) i)",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (Z.testbit (unsigned x) i))\n  (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)",
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (Z.testbit (Z.add (unsigned (neg x)) (unsigned mone)) i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Z.testbit (unsigned x) i))\n  (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (negb (Z.testbit (unsigned x) i))"
            ]
        },
        {
            "tactic_sig": "apply Z_one_complement .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (negb (Z.testbit (unsigned x) i))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eqm .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.sub (Z.opp (unsigned x)) (Zpos xH)) i)\n  (Z.testbit (Z.add (unsigned (neg x)) (unsigned mone)) i)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (unsigned (neg x)) (unsigned mone))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( - unsigned _ - 1 ) with ( - unsigned _ + ( - 1 ) ) by omega .",
            "tactic_args": [
                "_goal : eqm (Z.sub (Z.opp (unsigned x)) (Zpos xH))\n  (Z.add (unsigned (neg x)) (unsigned mone))",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (Z.opp (unsigned x)) (Zneg xH))\n  (Z.add (unsigned (neg x)) (unsigned mone))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.opp (unsigned x)) (Zneg xH))\n  (Z.add (unsigned (neg x)) (unsigned mone))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned x)) (unsigned (neg x))",
                "_goal : eqm (Zneg xH) (unsigned mone)"
            ]
        },
        {
            "tactic_sig": "unfold neg .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned x)) (unsigned (neg x))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.opp (unsigned x)) (unsigned (repr (Z.opp (unsigned x))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (Z.opp (unsigned x)) (unsigned (repr (Z.opp (unsigned x))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_mone .",
            "tactic_args": [
                "_goal : eqm (Zneg xH) (unsigned mone)"
            ],
            "tactic_res": [
                "_goal : eqm (Zneg xH) (Z.sub modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "exists ( - 1 ) .",
            "tactic_args": [
                "_goal : eqm (Zneg xH) (Z.sub modulus (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Zneg xH)\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Zneg xH)\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (neg x) (add (not x) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg x) (add (not x) one)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite not_neg .",
            "tactic_args": [
                "_goal : Logic.eq (neg x) (add (not x) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg x) (add (add (neg x) mone) one)"
            ]
        },
        {
            "tactic_sig": "rewrite add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (neg x) (add (add (neg x) mone) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg x) (add (neg x) (add mone one))"
            ]
        },
        {
            "tactic_sig": "replace ( add mone one ) with zero .",
            "tactic_args": [
                "_goal : Logic.eq (neg x) (add (neg x) (add mone one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg x) (add (neg x) zero)",
                "_goal : Logic.eq zero (add mone one)"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq (neg x) (add (neg x) zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (neg x) (neg x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (neg x) (neg x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq zero (add mone one)"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (Z.add (unsigned mone) (unsigned one))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_mone .",
            "tactic_args": [
                "_goal : eqm Z0 (Z.add (unsigned mone) (unsigned one))"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (Z.add (Z.sub modulus (Zpos xH)) (unsigned one))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : eqm Z0 (Z.add (Z.sub modulus (Zpos xH)) (unsigned one))"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (Z.add (Z.sub modulus (Zpos xH)) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "exists ( - 1 ) .",
            "tactic_args": [
                "_goal : eqm Z0 (Z.add (Z.sub modulus (Zpos xH)) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq Z0\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.add (Z.sub modulus (Zpos xH)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq Z0\n  (Z.add (Z.mul (Zneg xH) modulus)\n     (Z.add (Z.sub modulus (Zpos xH)) (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (sub x y) (add (add x (not y)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub x y) (add (add x (not y)) one)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (sub x y) (add (add x (not y)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (neg y)) (add (add x (not y)) one)"
            ]
        },
        {
            "tactic_sig": "rewrite neg_not .",
            "tactic_args": [
                "_goal : Logic.eq (add x (neg y)) (add (add x (not y)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (not y) one)) (add (add x (not y)) one)"
            ]
        },
        {
            "tactic_sig": "rewrite ! add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (not y) one)) (add (add x (not y)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (not y) one)) (add x (add (not y) one))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (not y) one)) (add x (add (not y) one))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y b : int) (_ : Logic.or (Logic.eq b zero) (Logic.eq b one)),\nLogic.eq (sub (sub x y) b) (add (add x (not y)) (xor b one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (sub x y) b) (add (add x (not y)) (xor b one))",
                "H : Logic.or (Logic.eq b zero) (Logic.eq b one)",
                "x : int",
                "y : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "rewrite ! sub_add_not .",
            "tactic_args": [
                "_goal : Logic.eq (sub (sub x y) b) (add (add x (not y)) (xor b one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (add (add (add x (not y)) one) (not b)) one)\n  (add (add x (not y)) (xor b one))"
            ]
        },
        {
            "tactic_sig": "rewrite ! add_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (add (add (add (add x (not y)) one) (not b)) one)\n  (add (add x (not y)) (xor b one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (add (not y) (add one (add (not b) one))))\n  (add x (add (not y) (xor b one)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (add x (add (not y) (add one (add (not b) one))))\n  (add x (add (not y) (xor b one)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (not y) (add one (add (not b) one)))\n  (add (not y) (xor b one))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (add (not y) (add one (add (not b) one)))\n  (add (not y) (xor b one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add one (add (not b) one)) (xor b one)"
            ]
        },
        {
            "tactic_sig": "rewrite <- neg_not .",
            "tactic_args": [
                "_goal : Logic.eq (add one (add (not b) one)) (xor b one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add one (neg b)) (xor b one)"
            ]
        },
        {
            "tactic_sig": "rewrite <- sub_add_opp .",
            "tactic_args": [
                "_goal : Logic.eq (add one (neg b)) (xor b one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub one b) (xor b one)"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "H : Logic.or (Logic.eq b zero) (Logic.eq b one)"
            ],
            "tactic_res": [
                "H : Logic.eq b zero",
                "H : Logic.eq b one"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub one zero) (xor zero one)"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq (sub one b) (xor b one)",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub one one) (xor one one)"
            ]
        },
        {
            "tactic_sig": "rewrite xor_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq (sub one zero) (xor zero one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub one zero) one"
            ]
        },
        {
            "tactic_sig": "rewrite sub_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq (sub one zero) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq one one"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq one one"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (sub one one) (xor one one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub one one) zero"
            ]
        },
        {
            "tactic_sig": "rewrite sub_idem .",
            "tactic_args": [
                "_goal : Logic.eq (sub one one) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq zero zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq zero zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y b : int) (_ : Logic.or (Logic.eq b zero) (Logic.eq b one)),\nLogic.eq (sub_borrow x y b) (xor (add_carry x (not y) (xor b one)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub_borrow x y b) (xor (add_carry x (not y) (xor b one)) one)",
                "H : Logic.or (Logic.eq b zero) (Logic.eq b one)",
                "x : int",
                "y : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "unfold sub_borrow , add_carry .",
            "tactic_args": [
                "_goal : Logic.eq (sub_borrow x y b) (xor (add_carry x (not y) (xor b one)) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (unsigned (not y)))\n            (unsigned (xor b one))) modulus\n      then zero\n      else one) one)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_not .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (unsigned (not y)))\n            (unsigned (xor b one))) modulus\n      then zero\n      else one) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (unsigned (xor b one))) modulus\n      then zero\n      else one) one)"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned ( xor _ one ) ) with ( 1 - unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (unsigned (xor b one))) modulus\n      then zero\n      else one) one)",
                "b : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)",
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned b)) (unsigned (xor b one))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ - unsigned _ - unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0\n   then one\n   else zero)\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)",
                "x : int",
                "y : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq one\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)",
                "_goal : Logic.eq zero\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)",
                "l : Z.lt (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0",
                "g : Z.ge (Z.sub (Z.sub (unsigned x) (unsigned y)) (unsigned b)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq one\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq one (xor zero one)",
                "_goal : Z.lt\n  (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite xor_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq one (xor zero one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq one one"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq one one"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (Z.add\n     (Z.add (unsigned x) (Z.sub (Z.sub modulus (Zpos xH)) (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add\n     (Z.add (unsigned x) (Z.sub (Z.sub modulus (Zpos xH)) (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq zero\n  (xor\n     (if\n       zlt\n         (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n            (Z.sub (Zpos xH) (unsigned b))) modulus\n      then zero\n      else one) one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq zero (xor one one)",
                "_goal : Z.ge\n  (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq zero (xor one one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq zero zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq zero zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add (Z.add (unsigned x) (Z.sub max_unsigned (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ],
            "tactic_res": [
                "_goal : Z.ge\n  (Z.add\n     (Z.add (unsigned x) (Z.sub (Z.sub modulus (Zpos xH)) (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add\n     (Z.add (unsigned x) (Z.sub (Z.sub modulus (Zpos xH)) (unsigned y)))\n     (Z.sub (Zpos xH) (unsigned b))) modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "H : Logic.or (Logic.eq b zero) (Logic.eq b one)"
            ],
            "tactic_res": [
                "H : Logic.eq b zero",
                "H : Logic.eq b one"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned zero)) (unsigned (xor zero one))"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned b)) (unsigned (xor b one))",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned one)) (unsigned (xor one one))"
            ]
        },
        {
            "tactic_sig": "rewrite xor_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned zero)) (unsigned (xor zero one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned zero)) (unsigned one)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one , unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned zero)) (unsigned one)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) Z0) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) Z0) (Zpos xH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned one)) (unsigned (xor one one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned one)) (unsigned zero)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one , unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (unsigned one)) (unsigned zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Zpos xH) (Zpos xH)) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros i0 POS0 .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Z.le Z0 i) (x y : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\n       Logic.eq (andb (Z.testbit x j) (Z.testbit y j)) false),\nLogic.eq (Z.testbit (Z.add x y) i)\n  (orb (Z.testbit x i) (Z.testbit y i))"
            ],
            "tactic_res": [
                "_goal : forall (x y : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i0)),\n       Logic.eq (andb (Z.testbit x j) (Z.testbit y j)) false),\nLogic.eq (Z.testbit (Z.add x y) i0)\n  (orb (Z.testbit x i0) (Z.testbit y i0))",
                "POS0 : Z.le Z0 i0",
                "i0 : Z"
            ]
        },
        {
            "tactic_sig": "pattern _ .",
            "tactic_args": [
                "_goal : forall (x y : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i0)),\n       Logic.eq (andb (Z.testbit x j) (Z.testbit y j)) false),\nLogic.eq (Z.testbit (Z.add x y) i0)\n  (orb (Z.testbit x i0) (Z.testbit y i0))",
                "i0 : Z"
            ],
            "tactic_res": [
                "_goal : (fun z : Z =>\n forall (x y : Z)\n   (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j z)),\n        Logic.eq (andb (Z.testbit x j) (Z.testbit y j)) false),\n Logic.eq (Z.testbit (Z.add x y) z)\n   (orb (Z.testbit x z) (Z.testbit y z))) i0"
            ]
        },
        {
            "tactic_sig": "apply Zlt_0_ind .",
            "tactic_args": [
                "_goal : (fun z : Z =>\n forall (x y : Z)\n   (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j z)),\n        Logic.eq (andb (Z.testbit x j) (Z.testbit y j)) false),\n Logic.eq (Z.testbit (Z.add x y) z)\n   (orb (Z.testbit x z) (Z.testbit y z))) i0"
            ],
            "tactic_res": [
                "_goal : forall (x : Z)\n  (_ : forall (y : Z) (_ : Logic.and (Z.le Z0 y) (Z.lt y x))\n         (x0 y0 : Z)\n         (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j y)),\n              Logic.eq (andb (Z.testbit x0 j) (Z.testbit y0 j)) false),\n       Logic.eq (Z.testbit (Z.add x0 y0) y)\n         (orb (Z.testbit x0 y) (Z.testbit y0 y))) \n  (_ : Z.le Z0 x) (x0 y : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j x)),\n       Logic.eq (andb (Z.testbit x0 j) (Z.testbit y j)) false),\nLogic.eq (Z.testbit (Z.add x0 y) x)\n  (orb (Z.testbit x0 x) (Z.testbit y x))",
                "_goal : Z.le Z0 i0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 i0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros i IND POS x y EXCL .",
            "tactic_args": [
                "_goal : forall (x : Z)\n  (_ : forall (y : Z) (_ : Logic.and (Z.le Z0 y) (Z.lt y x))\n         (x0 y0 : Z)\n         (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j y)),\n              Logic.eq (andb (Z.testbit x0 j) (Z.testbit y0 j)) false),\n       Logic.eq (Z.testbit (Z.add x0 y0) y)\n         (orb (Z.testbit x0 y) (Z.testbit y0 y))) \n  (_ : Z.le Z0 x) (x0 y : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j x)),\n       Logic.eq (andb (Z.testbit x0 j) (Z.testbit y j)) false),\nLogic.eq (Z.testbit (Z.add x0 y) x)\n  (orb (Z.testbit x0 x) (Z.testbit y x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.add x y) i)\n  (orb (Z.testbit x i) (Z.testbit y i))",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq (andb (Z.testbit x j) (Z.testbit y j)) false",
                "x : Z",
                "y : Z",
                "POS : Z.le Z0 i",
                "IND : forall (y : Z) (_ : Logic.and (Z.le Z0 y) (Z.lt y i)) \n  (x y0 : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j y)),\n       Logic.eq (andb (Z.testbit x j) (Z.testbit y0 j)) false),\nLogic.eq (Z.testbit (Z.add x y0) y)\n  (orb (Z.testbit x y) (Z.testbit y0 y))",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite ( Zdecomp _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.add x y) i)\n  (orb (Z.testbit x i) (Z.testbit y i))",
                "x : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.add (Zshiftin (Z.odd x) (Z.div2 x)) y) i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i) (Z.testbit y i))",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) j) (Z.testbit y j))\n  false"
            ]
        },
        {
            "tactic_sig": "rewrite ( Zdecomp _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.add (Zshiftin (Z.odd x) (Z.div2 x)) y) i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i) (Z.testbit y i))",
                "y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n        (Zshiftin (Z.odd y) (Z.div2 y))) i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) i))",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) j)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "transitivity ( Z.testbit ( Zshiftin ( Z.odd _ || Z.odd _ ) ( Z.div2 _ + Z.div2 _ ) ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n        (Zshiftin (Z.odd y) (Z.div2 y))) i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) i))",
                "x : Z",
                "y : Z",
                "x : Z",
                "y : Z",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n        (Zshiftin (Z.odd y) (Z.div2 y))) i)\n  (Z.testbit\n     (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))\n     i)",
                "_goal : Logic.eq\n  (Z.testbit\n     (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))\n     i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) i))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n        (Zshiftin (Z.odd y) (Z.div2 y))) i)\n  (Z.testbit\n     (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n     (Zshiftin (Z.odd y) (Z.div2 y)))\n  (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))"
            ]
        },
        {
            "tactic_sig": "rewrite !Zshiftin_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Zshiftin (Z.odd x) (Z.div2 x))\n     (Zshiftin (Z.odd y) (Z.div2 y)))\n  (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))"
            ]
        },
        {
            "tactic_sig": "exploit ( _ 0 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) j)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) j)) false"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 Z0) (Z.le Z0 i)",
                "_goal : forall\n  _ : Logic.eq\n        (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) Z0)\n           (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) Z0)) false,\nLogic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 Z0) (Z.le Z0 i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !Ztestbit_shiftin_base .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq\n        (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) Z0)\n           (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) Z0)) false,\nLogic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (andb (Z.odd x) (Z.odd y)) false,\nLogic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (andb (Z.odd x) (Z.odd y)) false,\nLogic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))",
                "H : Logic.eq (andb (Z.odd x) (Z.odd y)) false"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.odd _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x))\n        (if Z.odd x then Zpos xH else Z0))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb (Z.odd x) (Z.odd y) then Zpos xH else Z0))",
                "x : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true (Z.odd y) then Zpos xH else Z0))",
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false (Z.odd y) then Zpos xH else Z0))",
                "H : Logic.eq (andb true (Z.odd y)) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin true (Z.div2 x)) j)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) j)) false",
                "H : Logic.eq (andb false (Z.odd y)) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin false (Z.div2 x)) j)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.odd _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true (Z.odd y) then Zpos xH else Z0))",
                "y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true true then Zpos xH else Z0))",
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true false then Zpos xH else Z0))",
                "H : Logic.eq (andb true true) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin true (Z.div2 x)) j)\n     (Z.testbit (Zshiftin true (Z.div2 y)) j)) false",
                "H : Logic.eq (andb true false) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin true (Z.div2 x)) j)\n     (Z.testbit (Zshiftin false (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true true then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))",
                "H : Logic.eq true false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Z.succ_double (Z.div2 x)) j)\n     (Z.testbit (Z.succ_double (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "discriminate || ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb true false then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))",
                "H : Logic.eq false false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Z.succ_double (Z.div2 x)) j)\n     (Z.testbit (Z.double (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "discriminate || ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) (Zpos xH))\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( Z.odd _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y))\n        (if Z.odd y then Zpos xH else Z0)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false (Z.odd y) then Zpos xH else Z0))",
                "y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false true then Zpos xH else Z0))",
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false false then Zpos xH else Z0))",
                "H : Logic.eq (andb false true) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin false (Z.div2 x)) j)\n     (Z.testbit (Zshiftin true (Z.div2 y)) j)) false",
                "H : Logic.eq (andb false false) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin false (Z.div2 x)) j)\n     (Z.testbit (Zshiftin false (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false true then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))",
                "H : Logic.eq false false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Z.double (Z.div2 x)) j)\n     (Z.testbit (Z.succ_double (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "discriminate || ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) (Zpos xH)))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y)))\n     (if orb false false then Zpos xH else Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) Z0)",
                "H : Logic.eq false false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Z.double (Z.div2 x)) j)\n     (Z.testbit (Z.double (Z.div2 y)) j)) false"
            ]
        },
        {
            "tactic_sig": "discriminate || ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 x)) Z0)\n     (Z.add (Z.mul (Zpos (xO xH)) (Z.div2 y)) Z0))\n  (Z.add (Z.mul (Zpos (xO xH)) (Z.add (Z.div2 x) (Z.div2 y))) Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !Ztestbit_shiftin .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Zshiftin (orb (Z.odd x) (Z.odd y)) (Z.add (Z.div2 x) (Z.div2 y)))\n     i)\n  (orb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) i)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zeq i Z0\n   then orb (Z.odd x) (Z.odd y)\n   else Z.testbit (Z.add (Z.div2 x) (Z.div2 y)) (Z.pred i))\n  (orb (if zeq i Z0 then Z.odd x else Z.testbit (Z.div2 x) (Z.pred i))\n     (if zeq i Z0 then Z.odd y else Z.testbit (Z.div2 y) (Z.pred i)))",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq _ 0 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zeq i Z0\n   then orb (Z.odd x) (Z.odd y)\n   else Z.testbit (Z.add (Z.div2 x) (Z.div2 y)) (Z.pred i))\n  (orb (if zeq i Z0 then Z.odd x else Z.testbit (Z.div2 x) (Z.pred i))\n     (if zeq i Z0 then Z.odd y else Z.testbit (Z.div2 y) (Z.pred i)))",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (Z.odd x) (Z.odd y)) (orb (Z.odd x) (Z.odd y))",
                "_goal : Logic.eq (Z.testbit (Z.add (Z.div2 x) (Z.div2 y)) (Z.pred i))\n  (orb (Z.testbit (Z.div2 x) (Z.pred i))\n     (Z.testbit (Z.div2 y) (Z.pred i)))",
                "e : Logic.eq i Z0",
                "n : Logic.not (Logic.eq i Z0)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Z.odd x) (Z.odd y)) (orb (Z.odd x) (Z.odd y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.add (Z.div2 x) (Z.div2 y)) (Z.pred i))\n  (orb (Z.testbit (Z.div2 x) (Z.pred i))\n     (Z.testbit (Z.div2 y) (Z.pred i)))",
                "IND : forall (y : Z) (_ : Logic.and (Z.le Z0 y) (Z.lt y i)) \n  (x y0 : Z)\n  (_ : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j y)),\n       Logic.eq (andb (Z.testbit x j) (Z.testbit y0 j)) false),\nLogic.eq (Z.testbit (Z.add x y0) y)\n  (orb (Z.testbit x y) (Z.testbit y0 y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.pred i)) (Z.lt (Z.pred i) i)",
                "_goal : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j (Z.pred i))),\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.pred i)) (Z.lt (Z.pred i) i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j (Z.pred i))),\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false",
                "H : Logic.and (Z.le Z0 j) (Z.le j (Z.pred i))",
                "j : Z"
            ]
        },
        {
            "tactic_sig": "exploit ( _ ( Z.succ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false",
                "EXCL : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq\n  (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) j)\n     (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) j)) false",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.succ j)) (Z.le (Z.succ j) i)",
                "_goal : forall\n  _ : Logic.eq\n        (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) (Z.succ j))\n           (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) (Z.succ j)))\n        false,\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.succ j)) (Z.le (Z.succ j) i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !Ztestbit_shiftin_succ .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq\n        (andb (Z.testbit (Zshiftin (Z.odd x) (Z.div2 x)) (Z.succ j))\n           (Z.testbit (Zshiftin (Z.odd y) (Z.div2 y)) (Z.succ j)))\n        false,\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j))\n        false,\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false",
                "_goal : Z.le Z0 j",
                "_goal : Z.le Z0 j"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j))\n        false,\nLogic.eq (andb (Z.testbit (Z.div2 x) j) (Z.testbit (Z.div2 y) j)) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 j"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (and x y) zero),\nLogic.eq (add x y) (or x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (add x y) i) (orb (testbit x i) (testbit y i))",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Logic.eq (and x y) zero",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (add x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.add (unsigned x) (unsigned y))) i)\n  (orb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.add (unsigned x) (unsigned y))) i)\n  (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.add (unsigned x) (unsigned y)) i)\n  (orb (testbit x i) (testbit y i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z_add_is_or .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.add (unsigned x) (unsigned y)) i)\n  (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i",
                "_goal : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq (andb (Z.testbit (unsigned x) j) (Z.testbit (unsigned y) j))\n  false"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (j : Z) (_ : Logic.and (Z.le Z0 j) (Z.le j i)),\nLogic.eq (andb (Z.testbit (unsigned x) j) (Z.testbit (unsigned y) j))\n  false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (Z.testbit (unsigned x) j) (Z.testbit (unsigned y) j))\n  false",
                "H1 : Logic.and (Z.le Z0 j) (Z.le j i)",
                "j : Z"
            ]
        },
        {
            "tactic_sig": "assert ( testbit ( and _ _ ) _ = testbit zero _ ) by congruence .",
            "tactic_args": [
                "x : int",
                "y : int",
                "j : Z",
                "j : Z"
            ],
            "tactic_res": [
                "H2 : Logic.eq (testbit (and x y) j) (testbit zero j)"
            ]
        },
        {
            "tactic_sig": "autorewrite with ints in _ .",
            "tactic_args": [
                "H2 : Logic.eq (testbit (and x y) j) (testbit zero j)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 j) (Z.lt j zwordsize)",
                "H2 : Logic.eq (andb (testbit x j) (testbit y j)) false",
                "H2 : Logic.eq (testbit (and x y) j) false"
            ]
        },
        {
            "tactic_sig": "assumption .",
            "tactic_args": [
                "_goal : Logic.eq (andb (Z.testbit (unsigned x) j) (Z.testbit (unsigned y) j))\n  false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 j) (Z.lt j zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (and x y) zero),\nLogic.eq (xor x y) (or x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i))\n  (orb (testbit x i) (testbit y i))",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Logic.eq (and x y) zero",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( testbit ( and _ _ ) _ = testbit zero _ ) by congruence .",
            "tactic_args": [
                "x : int",
                "y : int",
                "i : Z",
                "i : Z"
            ],
            "tactic_res": [
                "H1 : Logic.eq (testbit (and x y) i) (testbit zero i)"
            ]
        },
        {
            "tactic_sig": "autorewrite with ints in _ .",
            "tactic_args": [
                "H1 : Logic.eq (testbit (and x y) i) (testbit zero i)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "H1 : Logic.eq (andb (testbit x i) (testbit y i)) false",
                "H1 : Logic.eq (testbit (and x y) i) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit x i) (testbit y i))\n  (orb (testbit x i) (testbit y i))",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb true (testbit y i)) (orb true (testbit y i))",
                "_goal : Logic.eq (xorb false (testbit y i)) (orb false (testbit y i))",
                "H1 : Logic.eq (andb true (testbit y i)) false",
                "H1 : Logic.eq (andb false (testbit y i)) false"
            ]
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (xorb true (testbit y i)) (orb true (testbit y i))",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb true true) (orb true true)",
                "_goal : Logic.eq (xorb true false) (orb true false)",
                "H1 : Logic.eq (andb true true) false",
                "H1 : Logic.eq (andb true false) false"
            ]
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq (xorb true true) (orb true true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "H1 : Logic.eq true false"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq false true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq (xorb true false) (orb true false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "H1 : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false (testbit y i)) (orb false (testbit y i))",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb false true) (orb false true)",
                "_goal : Logic.eq (xorb false false) (orb false false)",
                "H1 : Logic.eq (andb false true) false",
                "H1 : Logic.eq (andb false false) false"
            ]
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false true) (orb false true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "H1 : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl in * .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false false) (orb false false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "H1 : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (and x y) zero),\nLogic.eq (add x y) (xor x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x y) (xor x y)",
                "H : Logic.eq (and x y) zero",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite xor_is_or .",
            "tactic_args": [
                "_goal : Logic.eq (add x y) (xor x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x y) (or x y)",
                "_goal : Logic.eq (and x y) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (and x y) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply add_is_or .",
            "tactic_args": [
                "_goal : Logic.eq (add x y) (or x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and x y) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (and x y) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (and y z) zero),\nLogic.eq (add (and x y) (and x z)) (and x (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (and x y) (and x z)) (and x (or y z))",
                "H : Logic.eq (and y z) zero",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite add_is_or .",
            "tactic_args": [
                "_goal : Logic.eq (add (and x y) (and x z)) (and x (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (and x y) (and x z)) (and x (or y z))",
                "_goal : Logic.eq (and (and x y) (and x z)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite and_or_distrib .",
            "tactic_args": [
                "_goal : Logic.eq (or (and x y) (and x z)) (and x (or y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (and x y) (and x z)) (or (and x y) (and x z))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (or (and x y) (and x z)) (or (and x y) (and x z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( and_commut _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (and (and x y) (and x z)) zero",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (and y x) (and x z)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite and_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (and (and y x) (and x z)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and y (and x (and x z))) zero"
            ]
        },
        {
            "tactic_sig": "repeat rewrite <- ( and_assoc _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (and y (and x (and x z))) zero",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and y (and (and x x) z)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite ( and_commut ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (and y (and (and x x) z)) zero",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and y (and z (and x x))) zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- and_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (and y (and z (and x x))) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (and y z) (and x x)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (and (and y z) (and x x)) zero",
                "H : Logic.eq (and y z) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and zero (and x x)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite and_commut .",
            "tactic_args": [
                "_goal : Logic.eq (and zero (and x x)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (and x x) zero) zero"
            ]
        },
        {
            "tactic_sig": "apply and_zero .",
            "tactic_args": [
                "_goal : Logic.eq (and (and x x) zero) zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl x y) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl x y) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shl .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl x y) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftl (unsigned x) (unsigned y))) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftl (unsigned x) (unsigned y))) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i)\n  (if zlt i (unsigned y)\n   then false\n   else testbit x (Z.sub i (unsigned y)))",
                "i : Z",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i) false",
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i)\n  (testbit x (Z.sub i (unsigned y)))",
                "l : Z.lt i (unsigned y)",
                "g : Z.ge i (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply Z.shiftl_spec_low .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i) false"
            ],
            "tactic_res": [
                "_goal : Z.lt i (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt i (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z.shiftl_spec_high .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (unsigned y)) i)\n  (testbit x (Z.sub i (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i",
                "_goal : Z.le (unsigned y) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (unsigned y) i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru x y) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru x y) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru x y) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (unsigned x) (unsigned y))) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (unsigned x) (unsigned y))) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (unsigned x) (unsigned y)) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (unsigned x) (unsigned y)) i)\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (unsigned y)))\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ ( _ + unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (unsigned y)))\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)",
                "x : int",
                "i : Z",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y)))\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y)))\n  (if zlt (Z.add i (unsigned y)) zwordsize\n   then testbit x (Z.add i (unsigned y))\n   else false)",
                "i : Z",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y)))\n  (testbit x (Z.add i (unsigned y)))",
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y))) false",
                "l : Z.lt (Z.add i (unsigned y)) zwordsize",
                "g : Z.ge (Z.add i (unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y)))\n  (testbit x (Z.add i (unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_above .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned y))) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add i (unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (unsigned y)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr x y) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x y) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x y) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (signed x) (unsigned y))) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (signed x) (unsigned y))) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (signed x) (unsigned y)) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (signed x) (unsigned y)) i)\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (signed x) (Z.add i (unsigned y)))\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "apply bits_signed .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (signed x) (Z.add i (unsigned y)))\n  (testbit x\n     (if zlt (Z.add i (unsigned y)) zwordsize\n      then Z.add i (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.add i (unsigned y))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.add i (unsigned y))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (Z.add i (unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (Z.add i (unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shl x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned zero)\n   then false\n   else testbit x (Z.sub i (unsigned zero))) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned zero)\n   then false\n   else testbit x (Z.sub i (unsigned zero))) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i Z0 then false else testbit x (Z.sub i Z0))\n  (testbit x i)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i Z0 then false else testbit x (Z.sub i Z0))\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i Z0)) (testbit x i)",
                "_goal : Z.ge i Z0"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i Z0)) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i Z0) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i Z0) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (f : forall (_ : int) (_ : int), int)\n  (f' : forall (_ : bool) (_ : bool), bool) (x y n : int)\n  (_ : forall (x0 y0 : int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit (f x0 y0) i)\n         (f' (testbit x0 i) (testbit y0 i)))\n  (_ : Logic.eq (f' false false) false),\nLogic.eq (f (shl x n) (shl y n)) (shl (f x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (shl x n) (shl y n)) (shl (f x y) n)",
                "H0 : Logic.eq (f' false false) false",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))",
                "x : int",
                "y : int",
                "n : int",
                "f' : forall (_ : bool) (_ : bool), bool",
                "f : forall (_ : int) (_ : int), int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (f (shl x n) (shl y n)) (shl (f x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shl x n) (shl y n)) i)\n  (testbit (shl (f x y) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shl x n) (shl y n)) i)\n  (testbit (shl (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (f (shl x n) (shl y n)) i)\n  (testbit (shl (f x y) n) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (f (shl x n) (shl y n)) i)\n  (testbit (shl (f x y) n) i)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f' (testbit (shl x n) i) (testbit (shl y n) i))\n  (testbit (shl (f x y) n) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq (f' (testbit (shl x n) i) (testbit (shl y n) i))\n  (testbit (shl (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f'\n     (if zlt i (unsigned n)\n      then false\n      else testbit x (Z.sub i (unsigned n)))\n     (if zlt i (unsigned n)\n      then false\n      else testbit y (Z.sub i (unsigned n))))\n  (if zlt i (unsigned n)\n   then false\n   else testbit (f x y) (Z.sub i (unsigned n)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f'\n     (if zlt i (unsigned n)\n      then false\n      else testbit x (Z.sub i (unsigned n)))\n     (if zlt i (unsigned n)\n      then false\n      else testbit y (Z.sub i (unsigned n))))\n  (if zlt i (unsigned n)\n   then false\n   else testbit (f x y) (Z.sub i (unsigned n)))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f' false false) false",
                "_goal : Logic.eq\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))\n  (testbit (f x y) (Z.sub i (unsigned n)))",
                "l : Z.lt i (unsigned n)",
                "g : Z.ge i (unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (f' false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))\n  (testbit (f x y) (Z.sub i (unsigned n)))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))",
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))\n  (f' (testbit x (Z.sub i (unsigned n)))\n     (testbit y (Z.sub i (unsigned n))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (and (shl x n) (shl y n)) (shl (and x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shl x n) (shl y n)) (shl (and x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shl with andb .",
            "tactic_args": [
                "_goal : Logic.eq (and (shl x n) (shl y n)) (shl (and x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (andb false false) false"
            ]
        },
        {
            "tactic_sig": "exact bits_and .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb false false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int, Logic.eq (or (shl x n) (shl y n)) (shl (or x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (shl x n) (shl y n)) (shl (or x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shl with orb .",
            "tactic_args": [
                "_goal : Logic.eq (or (shl x n) (shl y n)) (shl (or x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (orb false false) false"
            ]
        },
        {
            "tactic_sig": "exact bits_or .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (xor (shl x n) (shl y n)) (shl (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (shl x n) (shl y n)) (shl (xor x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shl with xorb .",
            "tactic_args": [
                "_goal : Logic.eq (xor (shl x n) (shl y n)) (shl (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (xorb false false) false"
            ]
        },
        {
            "tactic_sig": "exact bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (ltu x y) true),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int)\n  (_ : Logic.eq (if zlt (unsigned x) (unsigned y) then true else false)\n         true),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : Logic.eq (if zlt (unsigned x) (unsigned y) then true else false)\n         true),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))",
                "H : Logic.eq (if zlt (unsigned x) (unsigned y) then true else false) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "H : Logic.eq true true",
                "l : Z.lt (unsigned x) (unsigned y)",
                "H : Logic.eq false true",
                "g : Z.ge (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Z.le Z0 (unsigned x)",
                "_goal : Z.lt (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt (unsigned x) (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "discriminate .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Logic.eq (ltu x iwordsize) true),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)",
                "H : Logic.eq (ltu x iwordsize) true",
                "x : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)",
                "H : Logic.eq (ltu x iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x))\n        (Z.lt (unsigned x) (unsigned iwordsize)),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x))\n        (Z.lt (unsigned x) (unsigned iwordsize)),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true)\n  (_ : Logic.eq (ltu (add y z) iwordsize) true),\nLogic.eq (shl (shl x y) z) (shl x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (shl x y) z) (shl x (add y z))",
                "H1 : Logic.eq (ltu (add y z) iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_iwordsize_inv _ _ ) ( ltu_iwordsize_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl (shl x y) z) (shl x (add y z))",
                "H : Logic.eq (ltu y iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shl (shl x y) z) (shl x (add y z))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shl (shl x y) z) (shl x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (shl x y) z) (shl x (add y z))",
                "H3 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)",
                "H2 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned ( add _ _ ) = unsigned _ + unsigned _ ) .",
            "tactic_args": [
                "y : int",
                "z : int",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))",
                "H4 : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize two_wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl (shl x y) z) (shl x (add y z))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (shl x y) z) i) (testbit (shl x (add y z)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (shl x y) z) i) (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (shl x y) z) i) (testbit (shl x (add y z)) i)",
                "H5 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (shl x y) z) i) (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned z)\n   then false\n   else testbit (shl x y) (Z.sub i (unsigned z)))\n  (testbit (shl x (add y z)) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned z)\n   then false\n   else testbit (shl x y) (Z.sub i (unsigned z)))\n  (testbit (shl x (add y z)) i)",
                "i : Z",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (testbit (shl x (add y z)) i)",
                "_goal : Logic.eq (testbit (shl x y) (Z.sub i (unsigned z)))\n  (testbit (shl x (add y z)) i)",
                "l : Z.lt i (unsigned z)",
                "g : Z.ge i (unsigned z)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.lt i (unsigned (add y z))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i (unsigned (add y z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl x y) (Z.sub i (unsigned z)))\n  (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned z)) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit (shl x (add y z)) i)",
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned z)))\n  (Z.lt (Z.sub i (unsigned z)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned z)) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit (shl x (add y z)) i)",
                "i : Z",
                "z : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (testbit (shl x (add y z)) i)",
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit (shl x (add y z)) i)",
                "l : Z.lt (Z.sub i (unsigned z)) (unsigned y)",
                "g0 : Z.ge (Z.sub i (unsigned z)) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.lt i (unsigned (add y z))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i (unsigned (add y z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit (shl x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (if zlt i (unsigned (add y z))\n   then false\n   else testbit x (Z.sub i (unsigned (add y z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit x (Z.sub i (unsigned (add y z))))",
                "_goal : Z.ge i (unsigned (add y z))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.sub i (unsigned z)) (unsigned y)))\n  (testbit x (Z.sub i (unsigned (add y z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub i (unsigned z)) (unsigned y))\n  (Z.sub i (unsigned (add y z)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub i (unsigned z)) (unsigned y))\n  (Z.sub i (unsigned (add y z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i (unsigned (add y z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned z)))\n  (Z.lt (Z.sub i (unsigned z)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (ltu x y) true),\nLogic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))",
                "H : Logic.eq (ltu x y) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))",
                "x : int",
                "y : int",
                "H : Logic.eq (ltu x y) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y)),\nLogic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y)),\nLogic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))",
                "H0 : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned y) (unsigned x)))\n  (Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub (unsigned y) (unsigned x))",
                "_goal : Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub (unsigned y) (unsigned x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.sub (unsigned y) (unsigned x)) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shru x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned zero)) zwordsize\n   then testbit x (Z.add i (unsigned zero))\n   else false) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned zero)) zwordsize\n   then testbit x (Z.add i (unsigned zero))\n   else false) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z0) zwordsize then testbit x (Z.add i Z0) else false)\n  (testbit x i)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z0) zwordsize then testbit x (Z.add i Z0) else false)\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i Z0)) (testbit x i)",
                "_goal : Z.lt (Z.add i Z0) zwordsize"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i Z0)) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i Z0) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i Z0) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i Z0) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (f : forall (_ : int) (_ : int), int)\n  (f' : forall (_ : bool) (_ : bool), bool) (x y n : int)\n  (_ : forall (x0 y0 : int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit (f x0 y0) i)\n         (f' (testbit x0 i) (testbit y0 i)))\n  (_ : Logic.eq (f' false false) false),\nLogic.eq (f (shru x n) (shru y n)) (shru (f x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (shru x n) (shru y n)) (shru (f x y) n)",
                "H0 : Logic.eq (f' false false) false",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))",
                "x : int",
                "y : int",
                "n : int",
                "f' : forall (_ : bool) (_ : bool), bool",
                "f : forall (_ : int) (_ : int), int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (f (shru x n) (shru y n)) (shru (f x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shru x n) (shru y n)) i)\n  (testbit (shru (f x y) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shru x n) (shru y n)) i)\n  (testbit (shru (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (f (shru x n) (shru y n)) i)\n  (testbit (shru (f x y) n) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (f (shru x n) (shru y n)) i)\n  (testbit (shru (f x y) n) i)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f' (testbit (shru x n) i) (testbit (shru y n) i))\n  (testbit (shru (f x y) n) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (f' (testbit (shru x n) i) (testbit (shru y n) i))\n  (testbit (shru (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f'\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit x (Z.add i (unsigned n))\n      else false)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit y (Z.add i (unsigned n))\n      else false))\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit (f x y) (Z.add i (unsigned n))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f'\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit x (Z.add i (unsigned n))\n      else false)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit y (Z.add i (unsigned n))\n      else false))\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit (f x y) (Z.add i (unsigned n))\n   else false)",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))\n  (testbit (f x y) (Z.add i (unsigned n)))",
                "_goal : Logic.eq (f' false false) false",
                "l : Z.lt (Z.add i (unsigned n)) zwordsize",
                "g : Z.ge (Z.add i (unsigned n)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (f' false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))\n  (testbit (f x y) (Z.add i (unsigned n)))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))",
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))\n  (f' (testbit x (Z.add i (unsigned n)))\n     (testbit y (Z.add i (unsigned n))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (and (shru x n) (shru y n)) (shru (and x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shru x n) (shru y n)) (shru (and x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shru with andb .",
            "tactic_args": [
                "_goal : Logic.eq (and (shru x n) (shru y n)) (shru (and x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (andb false false) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exact bits_and .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (or (shru x n) (shru y n)) (shru (or x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (shru x n) (shru y n)) (shru (or x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shru with orb .",
            "tactic_args": [
                "_goal : Logic.eq (or (shru x n) (shru y n)) (shru (or x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (orb false false) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exact bits_or .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (xor (shru x n) (shru y n)) (shru (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (shru x n) (shru y n)) (shru (xor x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shru with xorb .",
            "tactic_args": [
                "_goal : Logic.eq (xor (shru x n) (shru y n)) (shru (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))",
                "_goal : Logic.eq (xorb false false) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exact bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true)\n  (_ : Logic.eq (ltu (add y z) iwordsize) true),\nLogic.eq (shru (shru x y) z) (shru x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shru x y) z) (shru x (add y z))",
                "H1 : Logic.eq (ltu (add y z) iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_iwordsize_inv _ _ ) ( ltu_iwordsize_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shru x y) z) (shru x (add y z))",
                "H : Logic.eq (ltu y iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shru (shru x y) z) (shru x (add y z))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shru (shru x y) z) (shru x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shru x y) z) (shru x (add y z))",
                "H3 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)",
                "H2 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned ( add _ _ ) = unsigned _ + unsigned _ ) .",
            "tactic_args": [
                "y : int",
                "z : int",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))",
                "H4 : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize two_wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shru x y) z) (shru x (add y z))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru (shru x y) z) i) (testbit (shru x (add y z)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru (shru x y) z) i) (testbit (shru x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru (shru x y) z) i) (testbit (shru x (add y z)) i)",
                "H5 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru (shru x y) z) i) (testbit (shru x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (shru x y) (Z.add i (unsigned z))\n   else false) (testbit (shru x (add y z)) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (shru x y) (Z.add i (unsigned z))\n   else false) (testbit (shru x (add y z)) i)",
                "i : Z",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru x y) (Z.add i (unsigned z)))\n  (testbit (shru x (add y z)) i)",
                "_goal : Logic.eq false (testbit (shru x (add y z)) i)",
                "l : Z.lt (Z.add i (unsigned z)) zwordsize",
                "g : Z.ge (Z.add i (unsigned z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru x y) (Z.add i (unsigned z)))\n  (testbit (shru x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then testbit x (Z.add (Z.add i (unsigned z)) (unsigned y))\n   else false) (testbit (shru x (add y z)) i)",
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then testbit x (Z.add (Z.add i (unsigned z)) (unsigned y))\n   else false) (testbit (shru x (add y z)) i)",
                "i : Z",
                "z : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (testbit (shru x (add y z)) i)",
                "l0 : Z.lt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize",
                "g : Z.ge (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (testbit (shru x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (testbit x (Z.add i (unsigned (add y z))))",
                "_goal : Z.lt (Z.add i (unsigned (add y z))) zwordsize"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add (Z.add i (unsigned z)) (unsigned y)))\n  (testbit x (Z.add i (unsigned (add y z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.add i (unsigned z)) (unsigned y))\n  (Z.add i (unsigned (add y z)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.add i (unsigned z)) (unsigned y))\n  (Z.add i (unsigned (add y z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i (unsigned (add y z))) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit (shru x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then testbit x (Z.add i (unsigned (add y z)))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shr x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (unsigned zero)) zwordsize\n      then Z.add i (unsigned zero)\n      else Z.sub zwordsize (Zpos xH))) (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (unsigned zero)) zwordsize\n      then Z.add i (unsigned zero)\n      else Z.sub zwordsize (Zpos xH))) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i Z0) zwordsize\n      then Z.add i Z0\n      else Z.sub zwordsize (Zpos xH))) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i Z0) zwordsize\n      then Z.add i Z0\n      else Z.sub zwordsize (Zpos xH))) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i Z0)) (testbit x i)",
                "_goal : Z.lt (Z.add i Z0) zwordsize"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i Z0)) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i Z0) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i Z0) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i Z0) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (f : forall (_ : int) (_ : int), int)\n  (f' : forall (_ : bool) (_ : bool), bool) (x y n : int)\n  (_ : forall (x0 y0 : int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit (f x0 y0) i)\n         (f' (testbit x0 i) (testbit y0 i))),\nLogic.eq (f (shr x n) (shr y n)) (shr (f x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (shr x n) (shr y n)) (shr (f x y) n)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))",
                "x : int",
                "y : int",
                "n : int",
                "f' : forall (_ : bool) (_ : bool), bool",
                "f : forall (_ : int) (_ : int), int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (f (shr x n) (shr y n)) (shr (f x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shr x n) (shr y n)) i)\n  (testbit (shr (f x y) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f (shr x n) (shr y n)) i)\n  (testbit (shr (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (f (shr x n) (shr y n)) i)\n  (testbit (shr (f x y) n) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (f (shr x n) (shr y n)) i)\n  (testbit (shr (f x y) n) i)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f' (testbit (shr x n) i) (testbit (shr y n) i))\n  (testbit (shr (f x y) n) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shr .",
            "tactic_args": [
                "_goal : Logic.eq (f' (testbit (shr x n) i) (testbit (shr y n) i))\n  (testbit (shr (f x y) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))\n  (testbit (f x y)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))\n  (testbit (f x y)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))",
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))\n  (f'\n     (testbit x\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH)))\n     (testbit y\n        (if zlt (Z.add i (unsigned n)) zwordsize\n         then Z.add i (unsigned n)\n         else Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)",
                "l : Z.lt (Z.add i (unsigned n)) zwordsize",
                "g : Z.ge (Z.add i (unsigned n)) zwordsize"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (and (shr x n) (shr y n)) (shr (and x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shr x n) (shr y n)) (shr (and x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shr with andb .",
            "tactic_args": [
                "_goal : Logic.eq (and (shr x n) (shr y n)) (shr (and x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_and .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int, Logic.eq (or (shr x n) (shr y n)) (shr (or x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (shr x n) (shr y n)) (shr (or x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shr with orb .",
            "tactic_args": [
                "_goal : Logic.eq (or (shr x n) (shr y n)) (shr (or x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_or .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (xor (shr x n) (shr y n)) (shr (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (shr x n) (shr y n)) (shr (xor x y) n)",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_shr with xorb .",
            "tactic_args": [
                "_goal : Logic.eq (xor (shr x n) (shr y n)) (shr (xor x y) n)"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true)\n  (_ : Logic.eq (ltu (add y z) iwordsize) true),\nLogic.eq (shr (shr x y) z) (shr x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shr x y) z) (shr x (add y z))",
                "H1 : Logic.eq (ltu (add y z) iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_iwordsize_inv _ _ ) ( ltu_iwordsize_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shr x y) z) (shr x (add y z))",
                "H : Logic.eq (ltu y iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shr (shr x y) z) (shr x (add y z))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (shr (shr x y) z) (shr x (add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shr x y) z) (shr x (add y z))",
                "H3 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)",
                "H2 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned ( add _ _ ) = unsigned _ + unsigned _ ) .",
            "tactic_args": [
                "y : int",
                "z : int",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))",
                "H4 : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z))))\n  (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize two_wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shr x y) z) (shr x (add y z))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (shr x y) z) i) (testbit (shr x (add y z)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (shr x y) z) i) (testbit (shr x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr (shr x y) z) i) (testbit (shr x (add y z)) i)",
                "H5 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite !bits_shr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr (shr x y) z) i) (testbit (shr x (add y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt (Z.add i (unsigned z)) zwordsize\n             then Z.add i (unsigned z)\n             else Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n      then\n       Z.add\n         (if zlt (Z.add i (unsigned z)) zwordsize\n          then Z.add i (unsigned z)\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x\n     (if zlt (Z.add i (unsigned (add y z))) zwordsize\n      then Z.add i (unsigned (add y z))\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt (Z.add i (unsigned z)) zwordsize\n             then Z.add i (unsigned z)\n             else Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n      then\n       Z.add\n         (if zlt (Z.add i (unsigned z)) zwordsize\n          then Z.add i (unsigned z)\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x\n     (if zlt (Z.add i (unsigned (add y z))) zwordsize\n      then Z.add i (unsigned (add y z))\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (if zlt (Z.add i (unsigned z)) zwordsize\n          then Z.add i (unsigned z)\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then\n    Z.add\n      (if zlt (Z.add i (unsigned z)) zwordsize\n       then Z.add i (unsigned z)\n       else Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (if zlt (Z.add i (unsigned z)) zwordsize\n          then Z.add i (unsigned z)\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then\n    Z.add\n      (if zlt (Z.add i (unsigned z)) zwordsize\n       then Z.add i (unsigned z)\n       else Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))",
                "i : Z",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))",
                "l : Z.lt (Z.add i (unsigned z)) zwordsize",
                "g : Z.ge (Z.add i (unsigned z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))",
                "H4 : Logic.eq (unsigned (add y z)) (Z.add (unsigned y) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (Z.add (unsigned y) (unsigned z))) zwordsize\n   then Z.add i (Z.add (unsigned y) (unsigned z))\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "replace ( _ + ( unsigned _ + unsigned _ ) ) with ( _ + unsigned _ + unsigned _ ) by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (Z.add (unsigned y) (unsigned z))) zwordsize\n   then Z.add i (Z.add (unsigned y) (unsigned z))\n   else Z.sub zwordsize (Zpos xH))",
                "i : Z",
                "y : int",
                "z : int",
                "i : Z",
                "z : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add (Z.add i (unsigned z)) (unsigned y)) zwordsize\n   then Z.add (Z.add i (unsigned z)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( zlt_false _ ( _ + unsigned ( add _ _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH))\n  (if zlt (Z.add i (unsigned (add y z))) zwordsize\n   then Z.add i (unsigned (add y z))\n   else Z.sub zwordsize (Zpos xH))",
                "i : Z",
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))",
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( zwordsize - 1 + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize\n   then Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)\n   else Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y))\n  (Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))",
                "l : Z.lt (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize",
                "g0 : Z.ge (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub zwordsize (Zpos xH)) (unsigned y))\n  (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (unsigned (add y z))) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)",
                "i : Z",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)",
                "l : Z.lt (Z.add i (unsigned z)) zwordsize",
                "g : Z.ge (Z.add i (unsigned z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y z : int,\nLogic.eq (and (shr x z) (shru y z)) (shru (and x y) z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shr x z) (shru y z)) (shru (and x y) z)",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (and (shr x z) (shru y z)) (shru (and x y) z)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and (shr x z) (shru y z)) i)\n  (testbit (shru (and x y) z) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and (shr x z) (shru y z)) i)\n  (testbit (shru (and x y) z) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (and (shr x z) (shru y z)) i)\n  (testbit (shru (and x y) z) i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (and (shr x z) (shru y z)) i)\n  (testbit (shru (and x y) z) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit (shr x z) i) (testbit (shru y z) i))\n  (testbit (shru (and x y) z) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shr .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit (shr x z) i) (testbit (shru y z) i))\n  (testbit (shru (and x y) z) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb\n     (testbit x\n        (if zlt (Z.add i (unsigned z)) zwordsize\n         then Z.add i (unsigned z)\n         else Z.sub zwordsize (Zpos xH))) (testbit (shru y z) i))\n  (testbit (shru (and x y) z) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb\n     (testbit x\n        (if zlt (Z.add i (unsigned z)) zwordsize\n         then Z.add i (unsigned z)\n         else Z.sub zwordsize (Zpos xH))) (testbit (shru y z) i))\n  (testbit (shru (and x y) z) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb\n     (testbit x\n        (if zlt (Z.add i (unsigned z)) zwordsize\n         then Z.add i (unsigned z)\n         else Z.sub zwordsize (Zpos xH)))\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then testbit y (Z.add i (unsigned z))\n      else false))\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (and x y) (Z.add i (unsigned z))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb\n     (testbit x\n        (if zlt (Z.add i (unsigned z)) zwordsize\n         then Z.add i (unsigned z)\n         else Z.sub zwordsize (Zpos xH)))\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then testbit y (Z.add i (unsigned z))\n      else false))\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (and x y) (Z.add i (unsigned z))\n   else false)",
                "i : Z",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))\n  (testbit (and x y) (Z.add i (unsigned z)))",
                "_goal : Logic.eq (andb (testbit x (Z.sub zwordsize (Zpos xH))) false) false",
                "l : Z.lt (Z.add i (unsigned z)) zwordsize",
                "g : Z.ge (Z.add i (unsigned z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))\n  (testbit (and x y) (Z.add i (unsigned z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))",
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))\n  (andb (testbit x (Z.add i (unsigned z)))\n     (testbit y (Z.add i (unsigned z))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)",
                "z : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) modulus),\nLogic.and (Z.le Z0 (Z.add i (unsigned z)))\n  (Z.lt (Z.add i (unsigned z)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x (Z.sub zwordsize (Zpos xH))) false) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (shru (shl z y) y) z),\nLogic.eq (and (shr x y) z) (and (shru x y) z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shr x y) z) (and (shru x y) z)",
                "H : Logic.eq (shru (shl z y) y) z",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (and (shr x y) z) (and (shru x y) z)",
                "H : Logic.eq (shru (shl z y) y) z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shr x y) (shru (shl z y) y))\n  (and (shru x y) (shru (shl z y) y))"
            ]
        },
        {
            "tactic_sig": "rewrite and_shru .",
            "tactic_args": [
                "_goal : Logic.eq (and (shr x y) (shru (shl z y) y))\n  (and (shru x y) (shru (shl z y) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (shr x y) (shru (shl z y) y)) (shru (and x (shl z y)) y)"
            ]
        },
        {
            "tactic_sig": "rewrite and_shr_shru .",
            "tactic_args": [
                "_goal : Logic.eq (and (shr x y) (shru (shl z y) y)) (shru (and x (shl z y)) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (and x (shl z y)) y) (shru (and x (shl z y)) y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shru (and x (shl z y)) y) (shru (and x (shl z y)) y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.eq (shru x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then one else zero)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then one else zero)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then one else zero) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then one else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then one else zero) i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then one else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n      zwordsize\n   then\n    testbit x (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n   else false) (testbit (if lt x zero then one else zero) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n      zwordsize\n   then\n    testbit x (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n   else false) (testbit (if lt x zero then one else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n   then testbit x (Z.add i (Z.sub zwordsize (Zpos xH)))\n   else false) (testbit (if lt x zero then one else zero) i)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq _ 0 ) .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "e : Logic.eq i Z0",
                "n : Logic.not (Logic.eq i Z0)"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add Z0 (Z.sub zwordsize (Zpos xH))) zwordsize\n   then testbit x (Z.add Z0 (Z.sub zwordsize (Zpos xH)))\n   else false) (testbit (if lt x zero then one else zero) Z0)",
                "H : Logic.and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.add_0_l .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add Z0 (Z.sub zwordsize (Zpos xH))) zwordsize\n   then testbit x (Z.add Z0 (Z.sub zwordsize (Zpos xH)))\n   else false) (testbit (if lt x zero then one else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) zwordsize\n   then testbit x (Z.sub zwordsize (Zpos xH))\n   else false) (testbit (if lt x zero then one else zero) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) zwordsize\n   then testbit x (Z.sub zwordsize (Zpos xH))\n   else false) (testbit (if lt x zero then one else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then one else zero) Z0)",
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite sign_bit_of_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then one else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit (if lt x zero then one else zero) Z0)"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit (if lt x zero then one else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) (signed zero) then true else false\n      then one\n      else zero) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) (signed zero) then true else false\n      then one\n      else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) Z0 then true else false then one else zero)\n     Z0)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) Z0 then true else false then one else zero)\n     Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if\n       if\n        zlt\n          (if zlt (unsigned x) half_modulus\n           then unsigned x\n           else Z.sub (unsigned x) modulus) Z0\n       then true\n       else false\n      then one\n      else zero) Z0)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if\n       if\n        zlt\n          (if zlt (unsigned x) half_modulus\n           then unsigned x\n           else Z.sub (unsigned x) modulus) Z0\n       then true\n       else false\n      then one\n      else zero) Z0)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (testbit\n     (if if zlt (unsigned x) Z0 then true else false then one else zero)\n     Z0)",
                "_goal : Logic.eq true\n  (testbit\n     (if if zlt (Z.sub (unsigned x) modulus) Z0 then true else false\n      then one\n      else zero) Z0)",
                "l : Z.lt (unsigned x) half_modulus",
                "g : Z.ge (unsigned x) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (testbit\n     (if if zlt (unsigned x) Z0 then true else false then one else zero)\n     Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (testbit zero Z0)",
                "_goal : Z.ge (unsigned x) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit zero Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.ge (unsigned x) Z0",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.ge (unsigned x) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.ge (unsigned x) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq true\n  (testbit\n     (if if zlt (Z.sub (unsigned x) modulus) Z0 then true else false\n      then one\n      else zero) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (testbit one Z0)",
                "_goal : Z.lt (Z.sub (unsigned x) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "unfold one .",
            "tactic_args": [
                "_goal : Logic.eq true (testbit one Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (testbit (repr (Zpos xH)) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq true (testbit (repr (Zpos xH)) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (Z.testbit (Zpos xH) Z0)",
                "_goal : Logic.and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true (Z.testbit (Zpos xH) Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 Z0) (Z.lt Z0 zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub (unsigned x) modulus) Z0",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt (Z.sub (unsigned x) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt (Z.sub (unsigned x) modulus) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n   then testbit x (Z.add i (Z.sub zwordsize (Zpos xH)))\n   else false) (testbit (if lt x zero then one else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (testbit (if lt x zero then one else zero) i)",
                "_goal : Z.ge (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit (if lt x zero then one else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (Z.testbit (unsigned (if lt x zero then one else zero)) i)"
            ]
        },
        {
            "tactic_sig": "rewrite Ztestbit_eq .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (Z.testbit (unsigned (if lt x zero then one else zero)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zeq i Z0\n   then Z.odd (unsigned (if lt x zero then one else zero))\n   else\n    Z.testbit (Z.div2 (unsigned (if lt x zero then one else zero)))\n      (Z.pred i))",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_false .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zeq i Z0\n   then Z.odd (unsigned (if lt x zero then one else zero))\n   else\n    Z.testbit (Z.div2 (unsigned (if lt x zero then one else zero)))\n      (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (Z.testbit (Z.div2 (unsigned (if lt x zero then one else zero)))\n     (Z.pred i))",
                "_goal : Logic.not (Logic.eq i Z0)"
            ]
        },
        {
            "tactic_sig": "destruct ( lt _ zero ) .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (Z.testbit (Z.div2 (unsigned (if lt x zero then one else zero)))\n     (Z.pred i))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 (unsigned one)) (Z.pred i))",
                "_goal : Logic.eq false (Z.testbit (Z.div2 (unsigned zero)) (Z.pred i))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 (unsigned one)) (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 (Zpos xH)) (Z.pred i))"
            ]
        },
        {
            "tactic_sig": "simpl Z.div2 .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 (Zpos xH)) (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (Z.testbit Z0 (Z.pred i))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.testbit_0_l .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit Z0 (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 (unsigned zero)) (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 Z0) (Z.pred i))"
            ]
        },
        {
            "tactic_sig": "simpl Z.div2 .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit (Z.div2 Z0) (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (Z.testbit Z0 (Z.pred i))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.testbit_0_l .",
            "tactic_args": [
                "_goal : Logic.eq false (Z.testbit Z0 (Z.pred i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq i Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.eq (shr x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then mone else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then mone else zero)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr x (repr (Z.sub zwordsize (Zpos xH))))\n  (if lt x zero then mone else zero)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then mone else zero) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then mone else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then mone else zero) i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x (repr (Z.sub zwordsize (Zpos xH)))) i)\n  (testbit (if lt x zero then mone else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n         zwordsize\n      then Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt (Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH)))))\n         zwordsize\n      then Z.add i (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n      then Z.add i (Z.sub zwordsize (Zpos xH))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "transitivity ( testbit _ ( zwordsize - 1 ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n      then Z.add i (Z.sub zwordsize (Zpos xH))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n      then Z.add i (Z.sub zwordsize (Zpos xH))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n      then Z.add i (Z.sub zwordsize (Zpos xH))\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n   then Z.add i (Z.sub zwordsize (Zpos xH))\n   else Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + ( zwordsize - 1 ) ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize\n   then Z.add i (Z.sub zwordsize (Zpos xH))\n   else Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.sub zwordsize (Zpos xH)))\n  (Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))",
                "l : Z.lt (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize",
                "g : Z.ge (Z.add i (Z.sub zwordsize (Zpos xH))) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.sub zwordsize (Zpos xH)))\n  (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub zwordsize (Zpos xH)) (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite sign_bit_of_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit (if lt x zero then mone else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit (if lt x zero then mone else zero) i)"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit (if lt x zero then mone else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) (signed zero) then true else false\n      then mone\n      else zero) i)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) (signed zero) then true else false\n      then mone\n      else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) Z0 then true else false then mone else zero)\n     i)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if if zlt (signed x) Z0 then true else false then mone else zero)\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if\n       if\n        zlt\n          (if zlt (unsigned x) half_modulus\n           then unsigned x\n           else Z.sub (unsigned x) modulus) Z0\n       then true\n       else false\n      then mone\n      else zero) i)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) half_modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned x) half_modulus then false else true)\n  (testbit\n     (if\n       if\n        zlt\n          (if zlt (unsigned x) half_modulus\n           then unsigned x\n           else Z.sub (unsigned x) modulus) Z0\n       then true\n       else false\n      then mone\n      else zero) i)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (testbit\n     (if if zlt (unsigned x) Z0 then true else false\n      then mone\n      else zero) i)",
                "_goal : Logic.eq true\n  (testbit\n     (if if zlt (Z.sub (unsigned x) modulus) Z0 then true else false\n      then mone\n      else zero) i)",
                "l : Z.lt (unsigned x) half_modulus",
                "g : Z.ge (unsigned x) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (testbit\n     (if if zlt (unsigned x) Z0 then true else false\n      then mone\n      else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (testbit zero i)",
                "_goal : Z.ge (unsigned x) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit zero i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.ge (unsigned x) Z0",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.ge (unsigned x) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.ge (unsigned x) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq true\n  (testbit\n     (if if zlt (Z.sub (unsigned x) modulus) Z0 then true else false\n      then mone\n      else zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (testbit mone i)",
                "_goal : Z.lt (Z.sub (unsigned x) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite bits_mone .",
            "tactic_args": [
                "_goal : Logic.eq true (testbit mone i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub (unsigned x) modulus) Z0",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt (Z.sub (unsigned x) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt (Z.sub (unsigned x) modulus) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (rol x y) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (rol x y) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold rol .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (rol x y) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftl (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftr (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "exploit ( Z_div_mod_eq ( unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftl (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftr (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize))\n           (Z.modulo (unsigned y) zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftl (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftr (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( j := unsigned _ mod zwordsize ) .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize))\n           (Z.modulo (unsigned y) zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftl (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftr (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize)) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "j : Z"
            ]
        },
        {
            "tactic_sig": "set ( k := unsigned _ / zwordsize ) .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize)) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "k : Z"
            ]
        },
        {
            "tactic_sig": "intros EQ .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ]
        },
        {
            "tactic_sig": "exploit ( Z_mod_lt ( unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned y) zwordsize))\n        (Z.lt (Z.modulo (unsigned y) zwordsize) zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned y) zwordsize))\n        (Z.lt (Z.modulo (unsigned y) zwordsize) zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 j) (Z.lt j zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "intros RANGE .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 j) (Z.lt j zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "RANGE : Logic.and (Z.le Z0 j) (Z.lt j zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftl (unsigned x) j)\n           (Z.shiftr (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftl (unsigned x) j)\n        (Z.shiftr (unsigned x) (Z.sub zwordsize j))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.lor_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftl (unsigned x) j)\n        (Z.shiftr (unsigned x) (Z.sub zwordsize j))) i)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftl (unsigned x) j) i)\n     (Z.testbit (Z.shiftr (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftl (unsigned x) j) i)\n     (Z.testbit (Z.shiftr (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftl (unsigned x) j) i)\n     (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "i : Z",
                "j : Z"
            ],
            "tactic_res": [
                "l : Z.lt i j",
                "g : Z.ge i j"
            ]
        },
        {
            "tactic_sig": "rewrite Z.shiftl_spec_low .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "_goal : Z.lt i j"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt i j"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j)))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j)))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j)))\n  (Z.testbit (unsigned x) (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j)))\n  (Z.testbit (unsigned x) (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.sub zwordsize j))\n  (Z.modulo (Z.sub i (unsigned y)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.sub zwordsize j))\n  (Z.modulo (Z.sub i (unsigned y)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned y)) zwordsize)\n  (Z.add i (Z.sub zwordsize j))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - _ - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned y)) zwordsize)\n  (Z.add i (Z.sub zwordsize j))",
                "k : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (unsigned y))\n  (Z.add (Z.mul (Z.sub (Z.opp k) (Zpos xH)) zwordsize)\n     (Z.add i (Z.sub zwordsize j)))",
                "_goal : Logic.and (Z.le Z0 (Z.add i (Z.sub zwordsize j)))\n  (Z.lt (Z.add i (Z.sub zwordsize j)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (unsigned y))\n  (Z.add (Z.mul (Z.sub (Z.opp k) (Zpos xH)) zwordsize)\n     (Z.add i (Z.sub zwordsize j)))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.sub (Z.opp k) (Zpos xH)) zwordsize)\n     (Z.add i (Z.sub zwordsize j)))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.sub (Z.opp k) (Zpos xH)) zwordsize)\n     (Z.add i (Z.sub zwordsize j)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (Z.sub zwordsize j)))\n  (Z.lt (Z.add i (Z.sub zwordsize j)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftl_spec_high .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftl (unsigned x) j) i)\n     (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.sub i j))\n     (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "_goal : Z.le Z0 i",
                "_goal : Z.le j i"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ ( _ + ( zwordsize - _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.sub i j))\n     (Z.testbit (unsigned x) (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "x : int",
                "i : Z",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.sub i j))\n     (testbit x (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_above .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.sub i j))\n     (testbit x (Z.add i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) (Z.sub i j)) false)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "_goal : Z.ge (Z.add i (Z.sub zwordsize j)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) (Z.sub i j)) false)\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i j))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ ( _ - _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i j))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))",
                "x : int",
                "i : Z",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i j))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i j))\n  (testbit x (Z.modulo (Z.sub i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i j) (Z.modulo (Z.sub i (unsigned y)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i j) (Z.modulo (Z.sub i (unsigned y)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned y)) zwordsize) (Z.sub i j)"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned y)) zwordsize) (Z.sub i j)",
                "k : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (unsigned y))\n  (Z.add (Z.mul (Z.opp k) zwordsize) (Z.sub i j))",
                "_goal : Logic.and (Z.le Z0 (Z.sub i j)) (Z.lt (Z.sub i j) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (unsigned y))\n  (Z.add (Z.mul (Z.opp k) zwordsize) (Z.sub i j))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.opp k) zwordsize) (Z.sub i j))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.opp k) zwordsize) (Z.sub i j))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i j)) (Z.lt (Z.sub i j) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (Z.sub zwordsize j)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le j i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ror x y) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ror x y) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold ror .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ror x y) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "exploit ( Z_div_mod_eq ( unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize))\n           (Z.modulo (unsigned y) zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( j := unsigned _ mod zwordsize ) .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize))\n           (Z.modulo (unsigned y) zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned y) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned y) zwordsize))))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize)) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "j : Z"
            ]
        },
        {
            "tactic_sig": "set ( k := unsigned _ / zwordsize ) .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (unsigned y)\n        (Z.add (Z.mul zwordsize (Z.div (unsigned y) zwordsize)) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "k : Z"
            ]
        },
        {
            "tactic_sig": "intros EQ .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ]
        },
        {
            "tactic_sig": "exploit ( Z_mod_lt ( unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned y) zwordsize))\n        (Z.lt (Z.modulo (unsigned y) zwordsize) zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned y) zwordsize))\n        (Z.lt (Z.modulo (unsigned y) zwordsize) zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 j) (Z.lt j zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "intros RANGE .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 j) (Z.lt j zwordsize),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "RANGE : Logic.and (Z.le Z0 j) (Z.lt j zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor (Z.shiftr (unsigned x) j)\n           (Z.shiftl (unsigned x) (Z.sub zwordsize j)))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftr (unsigned x) j)\n        (Z.shiftl (unsigned x) (Z.sub zwordsize j))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.lor_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftr (unsigned x) j)\n        (Z.shiftl (unsigned x) (Z.sub zwordsize j))) i)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftr (unsigned x) j) i)\n     (Z.testbit (Z.shiftl (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Z.shiftr (unsigned x) j) i)\n     (Z.testbit (Z.shiftl (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.add i j))\n     (Z.testbit (Z.shiftl (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "i : Z",
                "j : Z"
            ],
            "tactic_res": [
                "l : Z.lt (Z.add i j) zwordsize",
                "g : Z.ge (Z.add i j) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite Z.shiftl_spec_low .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) (Z.add i j)) false)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "_goal : Z.lt i (Z.sub zwordsize j)"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Z.testbit (unsigned x) (Z.add i j)) false)\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i j))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i j))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i j))\n  (Z.testbit (unsigned x) (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i j))\n  (Z.testbit (unsigned x) (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i j) (Z.modulo (Z.add i (unsigned y)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i j) (Z.modulo (Z.add i (unsigned y)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize) (Z.add i j)"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize) (Z.add i j)",
                "k : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned y)) (Z.add (Z.mul k zwordsize) (Z.add i j))",
                "_goal : Logic.and (Z.le Z0 (Z.add i j)) (Z.lt (Z.add i j) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned y)) (Z.add (Z.mul k zwordsize) (Z.add i j))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul k zwordsize) (Z.add i j))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul k zwordsize) (Z.add i j))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i j)) (Z.lt (Z.add i j) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i (Z.sub zwordsize j)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftl_spec_high .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.add i j))\n     (Z.testbit (Z.shiftl (unsigned x) (Z.sub zwordsize j)) i))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.add i j))\n     (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "_goal : Z.le Z0 i",
                "_goal : Z.le (Z.sub zwordsize j) i"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ ( _ + _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (unsigned x) (Z.add i j))\n     (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "x : int",
                "i : Z",
                "j : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (testbit x (Z.add i j))\n     (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_above .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (testbit x (Z.add i j))\n     (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))",
                "_goal : Z.ge (Z.add i j) zwordsize"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j))))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j)))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j)))\n  (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j)))\n  (Z.testbit (unsigned x) (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.sub i (Z.sub zwordsize j)))\n  (Z.testbit (unsigned x) (Z.modulo (Z.add i (unsigned y)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub zwordsize j))\n  (Z.modulo (Z.add i (unsigned y)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub zwordsize j))\n  (Z.modulo (Z.add i (unsigned y)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.sub i (Z.sub zwordsize j))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( _ + 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.sub i (Z.sub zwordsize j))",
                "k : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned y))\n  (Z.add (Z.mul (Z.add k (Zpos xH)) zwordsize)\n     (Z.sub i (Z.sub zwordsize j)))",
                "_goal : Logic.and (Z.le Z0 (Z.sub i (Z.sub zwordsize j)))\n  (Z.lt (Z.sub i (Z.sub zwordsize j)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned y))\n  (Z.add (Z.mul (Z.add k (Zpos xH)) zwordsize)\n     (Z.sub i (Z.sub zwordsize j)))",
                "EQ : Logic.eq (unsigned y) (Z.add (Z.mul zwordsize k) j)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.add k (Zpos xH)) zwordsize)\n     (Z.sub i (Z.sub zwordsize j)))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.add (Z.mul zwordsize k) j))\n  (Z.add (Z.mul (Z.add k (Zpos xH)) zwordsize)\n     (Z.sub i (Z.sub zwordsize j)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i (Z.sub zwordsize j)))\n  (Z.lt (Z.sub i (Z.sub zwordsize j)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i j) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.sub zwordsize j) i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (shl x n) (rolm x n (shl mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x n) (rolm x n (shl mone n))",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl x n) (rolm x n (shl mone n))",
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (unsigned iwordsize)),\nLogic.eq (shl x n) (rolm x n (shl mone n))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (unsigned iwordsize)),\nLogic.eq (shl x n) (rolm x n (shl mone n))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize),\nLogic.eq (shl x n) (rolm x n (shl mone n))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize),\nLogic.eq (shl x n) (rolm x n (shl mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x n) (rolm x n (shl mone n))",
                "H0 : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold rolm .",
            "tactic_args": [
                "_goal : Logic.eq (shl x n) (rolm x n (shl mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x n) (and (rol x n) (shl mone n))"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl x n) (and (rol x n) (shl mone n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl x n) i) (testbit (and (rol x n) (shl mone n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl x n) i) (testbit (and (rol x n) (shl mone n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl x n) i) (testbit (and (rol x n) (shl mone n)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl x n) i) (testbit (and (rol x n) (shl mone n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl x n) i)\n  (andb (testbit (rol x n) i) (testbit (shl mone n) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl x n) i)\n  (andb (testbit (rol x n) i) (testbit (shl mone n) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit x (Z.sub i (unsigned n)))\n  (andb (testbit (rol x n) i)\n     (if zlt i (unsigned n)\n      then false\n      else testbit mone (Z.sub i (unsigned n))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_rol .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit x (Z.sub i (unsigned n)))\n  (andb (testbit (rol x n) i)\n     (if zlt i (unsigned n)\n      then false\n      else testbit mone (Z.sub i (unsigned n))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (if zlt i (unsigned n)\n      then false\n      else testbit mone (Z.sub i (unsigned n))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (if zlt i (unsigned n)\n      then false\n      else testbit mone (Z.sub i (unsigned n))))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize)) false)",
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))",
                "l : Z.lt i (unsigned n)",
                "g : Z.ge i (unsigned n)"
            ]
        },
        {
            "tactic_sig": "rewrite andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize)) false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))",
                "H2 : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_mone .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit mone (Z.sub i (unsigned n))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize)) true)",
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite andb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (andb (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize)) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (unsigned n))\n  (Z.modulo (Z.sub i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (unsigned n))\n  (Z.modulo (Z.sub i (unsigned n)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned n)) zwordsize)\n  (Z.sub i (unsigned n))"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned n)) zwordsize)\n  (Z.sub i (unsigned n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i (unsigned n)))\n  (Z.lt (Z.sub i (unsigned n)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))",
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (unsigned iwordsize)),\nLogic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n))\n        (Z.lt (unsigned n) (unsigned iwordsize)),\nLogic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize),\nLogic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize),\nLogic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))",
                "H0 : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold rolm .",
            "tactic_args": [
                "_goal : Logic.eq (shru x n) (rolm x (sub iwordsize n) (shru mone n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x n) (and (rol x (sub iwordsize n)) (shru mone n))"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru x n) (and (rol x (sub iwordsize n)) (shru mone n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru x n) i)\n  (testbit (and (rol x (sub iwordsize n)) (shru mone n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru x n) i)\n  (testbit (and (rol x (sub iwordsize n)) (shru mone n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru x n) i)\n  (testbit (and (rol x (sub iwordsize n)) (shru mone n)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru x n) i)\n  (testbit (and (rol x (sub iwordsize n)) (shru mone n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru x n) i)\n  (andb (testbit (rol x (sub iwordsize n)) i) (testbit (shru mone n) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru x n) i)\n  (andb (testbit (rol x (sub iwordsize n)) i) (testbit (shru mone n) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (andb (testbit (rol x (sub iwordsize n)) i)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit mone (Z.add i (unsigned n))\n      else false))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_rol .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (andb (testbit (rol x (sub iwordsize n)) i)\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit mone (Z.add i (unsigned n))\n      else false))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit mone (Z.add i (unsigned n))\n      else false))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then testbit mone (Z.add i (unsigned n))\n      else false))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))",
                "_goal : Logic.eq false\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     false)",
                "l : Z.lt (Z.add i (unsigned n)) zwordsize",
                "g : Z.ge (Z.add i (unsigned n)) zwordsize"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus),\nLogic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))",
                "H2 : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_mone .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     (testbit mone (Z.add i (unsigned n))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     true)",
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite andb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (unsigned n)))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo\n     (Z.sub i\n        (unsigned (repr (Z.sub (unsigned iwordsize) (unsigned n)))))\n     zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo\n     (Z.sub i\n        (unsigned (repr (Z.sub (unsigned iwordsize) (unsigned n)))))\n     zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (Z.sub (unsigned iwordsize) (unsigned n)))\n     zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned iwordsize) (unsigned n)))\n  (Z.le (Z.sub (unsigned iwordsize) (unsigned n)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (Z.sub (unsigned iwordsize) (unsigned n)))\n     zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned n))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned n))\n  (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned n))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned n))) zwordsize)\n  (Z.add i (unsigned n))"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned n))) zwordsize)\n  (Z.add i (unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub zwordsize (unsigned n)))\n  (Z.add (Z.mul (Zneg xH) zwordsize) (Z.add i (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub zwordsize (unsigned n)))\n  (Z.add (Z.mul (Zneg xH) zwordsize) (Z.add i (unsigned n)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned iwordsize) (unsigned n)))\n  (Z.le (Z.sub (unsigned iwordsize) (unsigned n)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (unsigned n)))\n  (Z.le (Z.sub zwordsize (unsigned n)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (unsigned n)))\n  (Z.le (Z.sub zwordsize (unsigned n)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned n)))\n  (Z.le (Z.sub zwordsize (unsigned n)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned n)))\n  (Z.le (Z.sub zwordsize (unsigned n)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned n)))\n  (Z.lt (Z.add i (unsigned n)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (andb\n     (testbit x\n        (Z.modulo (Z.sub i (unsigned (sub iwordsize n))) zwordsize))\n     false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (rol x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.sub i (unsigned zero)) zwordsize))\n  (testbit x i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.sub i (unsigned zero)) zwordsize))\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned zero)) zwordsize) i"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i (unsigned zero)) zwordsize) i"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub i Z0) zwordsize) i"
            ]
        },
        {
            "tactic_sig": "rewrite Z.sub_0_r .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub i Z0) zwordsize) i"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo i zwordsize) i"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo i zwordsize) i"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (f : forall (_ : int) (_ : int), int)\n  (f' : forall (_ : bool) (_ : bool), bool) (x y n : int)\n  (_ : forall (x0 y0 : int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit (f x0 y0) i)\n         (f' (testbit x0 i) (testbit y0 i))),\nLogic.eq (rol (f x y) n) (f (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rol (f x y) n) (f (rol x n) (rol y n))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))",
                "x : int",
                "y : int",
                "n : int",
                "f' : forall (_ : bool) (_ : bool), bool",
                "f : forall (_ : int) (_ : int), int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (rol (f x y) n) (f (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (rol (f x y) n) i)\n  (testbit (f (rol x n) (rol y n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (rol (f x y) n) i)\n  (testbit (f (rol x n) (rol y n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (rol (f x y) n) i)\n  (testbit (f (rol x n) (rol y n)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (rol (f x y) n) i)\n  (testbit (f (rol x n) (rol y n)) i)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (rol (f x y) n) i)\n  (f' (testbit (rol x n) i) (testbit (rol y n) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_rol .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (rol (f x y) n) i)\n  (f' (testbit (rol x n) i) (testbit (rol y n) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (f x y) (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (f x y) (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f x y) i) (f' (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))",
                "_goal : Logic.and (Z.le Z0 (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (unsigned n)) zwordsize) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))\n  (f' (testbit x (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n     (testbit y (Z.modulo (Z.sub i (unsigned n)) zwordsize)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z_mod_lt .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.modulo (Z.sub i (unsigned n)) zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (unsigned n)) zwordsize) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (rol (and x y) n) (and (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rol (and x y) n) (and (rol x n) (rol y n))",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_rol with andb .",
            "tactic_args": [
                "_goal : Logic.eq (rol (and x y) n) (and (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_and .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int, Logic.eq (rol (or x y) n) (or (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rol (or x y) n) (or (rol x n) (rol y n))",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_rol with orb .",
            "tactic_args": [
                "_goal : Logic.eq (rol (or x y) n) (or (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_or .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y n : int,\nLogic.eq (rol (xor x y) n) (xor (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rol (xor x y) n) (xor (rol x n) (rol y n))",
                "x : int",
                "y : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply bitwise_binop_rol with xorb .",
            "tactic_args": [
                "_goal : Logic.eq (rol (xor x y) n) (xor (rol x n) (rol y n))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ]
        },
        {
            "tactic_sig": "exact bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (x n m : int) (_ : Z.divide zwordsize modulus),\nLogic.eq (rol (rol x n) m) (rol x (modu (add n m) iwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.modulo\n        (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n        zwordsize))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (modu (add n m) iwordsize)))\n        zwordsize))",
                "_goal : Logic.and (Z.le Z0 (Z.modulo (Z.sub i (unsigned m)) zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (unsigned m)) zwordsize) zwordsize)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Z.divide zwordsize modulus",
                "x : int",
                "n : int",
                "m : int"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.modulo\n        (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n        zwordsize))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (modu (add n m) iwordsize)))\n        zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.modulo\n     (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n     zwordsize)\n  (Z.modulo (Z.sub i (unsigned (modu (add n m) iwordsize))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.modulo\n     (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n     zwordsize)\n  (Z.modulo (Z.sub i (unsigned (modu (add n m) iwordsize))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : eqmod zwordsize\n  (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( M := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqmod zwordsize\n  (Z.sub (Z.modulo (Z.sub i (unsigned m)) zwordsize) (unsigned n))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "m : int"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) (unsigned n))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "M : Z"
            ]
        },
        {
            "tactic_sig": "set ( N := unsigned _ ) .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) (unsigned n))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) N)\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "N : Z"
            ]
        },
        {
            "tactic_sig": "apply eqmod_trans with ( _ - _ - _ ) .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) N)\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "i : Z",
                "M : Z",
                "N : Z"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) N)\n  (Z.sub (Z.sub i M) N)",
                "_goal : eqmod zwordsize (Z.sub (Z.sub i M) N)\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_sub .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub (Z.modulo (Z.sub i M) zwordsize) N)\n  (Z.sub (Z.sub i M) N)"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.sub i M) zwordsize) (Z.sub i M)",
                "_goal : eqmod zwordsize N N"
            ]
        },
        {
            "tactic_sig": "apply eqmod_sym .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.sub i M) zwordsize) (Z.sub i M)"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.sub i M) (Z.modulo (Z.sub i M) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub i M) (Z.modulo (Z.sub i M) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_refl .",
            "tactic_args": [
                "_goal : eqmod zwordsize N N"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( _ - _ - _ ) with ( _ - ( _ + _ ) ) by omega .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub (Z.sub i M) N)\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))",
                "i : Z",
                "M : Z",
                "N : Z",
                "i : Z",
                "M : Z",
                "N : Z"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.sub i (Z.add M N))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_sub .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub i (Z.add M N))\n  (Z.sub i (unsigned (modu (add n m) iwordsize)))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize i i",
                "_goal : eqmod zwordsize (Z.add M N) (unsigned (modu (add n m) iwordsize))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_refl .",
            "tactic_args": [
                "_goal : eqmod zwordsize i i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_trans with ( Z.modulo ( unsigned _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add M N) (unsigned (modu (add n m) iwordsize))",
                "n : int",
                "m : int"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.add M N)\n  (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)",
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)\n  (unsigned (modu (add n m) iwordsize))"
            ]
        },
        {
            "tactic_sig": "replace ( _ + _ ) with ( _ + _ ) by omega .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add M N)\n  (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)",
                "M : Z",
                "N : Z",
                "N : Z",
                "M : Z"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.add N M)\n  (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add N M)\n  (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold modu , add .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)\n  (unsigned (modu (add n m) iwordsize))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add (unsigned n) (unsigned m))))\n           (unsigned iwordsize))))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) (unsigned m)) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add (unsigned n) (unsigned m))))\n           (unsigned iwordsize))))",
                "M : Z"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) M) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add (unsigned n) M)))\n           (unsigned iwordsize))))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add (unsigned n) M) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add (unsigned n) M)))\n           (unsigned iwordsize))))",
                "N : Z"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add N M))) (unsigned iwordsize))))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (unsigned\n     (repr\n        (Z.modulo (unsigned (repr (Z.add N M))) (unsigned iwordsize))))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (unsigned (repr (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)))"
            ]
        },
        {
            "tactic_sig": "assert ( forall a , eqmod zwordsize a ( unsigned ( repr a ) ) ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall a : Z, eqmod zwordsize a (unsigned (repr a))",
                "H1 : forall a : Z, eqmod zwordsize a (unsigned (repr a))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a : Z, eqmod zwordsize a (unsigned (repr a))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize a (unsigned (repr a))",
                "a : Z"
            ]
        },
        {
            "tactic_sig": "eapply eqmod_divides .",
            "tactic_args": [
                "_goal : eqmod zwordsize a (unsigned (repr a))"
            ],
            "tactic_res": [
                "_goal : eqmod ?n a (unsigned (repr a))",
                "_goal : Z.divide zwordsize ?n"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqmod ?n a (unsigned (repr a))",
                "_goal : Z.divide zwordsize ?n"
            ],
            "tactic_res": [
                "_goal : Z.divide zwordsize modulus"
            ]
        },
        {
            "tactic_sig": "assumption .",
            "tactic_args": [
                "_goal : Z.divide zwordsize modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "eapply eqmod_trans .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (unsigned (repr (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize) ?y",
                "_goal : eqmod zwordsize ?y\n  (unsigned (repr (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)))"
            ]
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize) ?y",
                "_goal : eqmod zwordsize ?y\n  (unsigned (repr (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)))",
                "H1 : forall a : Z, eqmod zwordsize a (unsigned (repr a))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_refl2 .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.modulo (Z.add N M) zwordsize)\n  (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add N M) zwordsize)\n  (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add N M) zwordsize)\n  (Z.modulo (unsigned (repr (Z.add N M))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : eqmod zwordsize (Z.add N M) (unsigned (repr (Z.add N M)))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add N M) (unsigned (repr (Z.add N M)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z_mod_lt .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.modulo (Z.sub i (unsigned m)) zwordsize))\n  (Z.lt (Z.modulo (Z.sub i (unsigned m)) zwordsize) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x m : int, Logic.eq (rolm x zero m) (and x m)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rolm x zero m) (and x m)",
                "x : int",
                "m : int"
            ]
        },
        {
            "tactic_sig": "unfold rolm .",
            "tactic_args": [
                "_goal : Logic.eq (rolm x zero m) (and x m)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (rol x zero) m) (and x m)"
            ]
        },
        {
            "tactic_sig": "rewrite rol_zero .",
            "tactic_args": [
                "_goal : Logic.eq (and (rol x zero) m) (and x m)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and x m) (and x m)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (and x m) (and x m)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n1 m1 n2 m2 : int) (_ : Z.divide zwordsize modulus),\nLogic.eq (rolm (rolm x n1 m1) n2 m2)\n  (rolm x (modu (add n1 n2) iwordsize) (and (rol m1 n2) m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (rolm (rolm x n1 m1) n2 m2)\n  (rolm x (modu (add n1 n2) iwordsize) (and (rol m1 n2) m2))",
                "H : Z.divide zwordsize modulus",
                "x : int",
                "n1 : int",
                "m1 : int",
                "n2 : int",
                "m2 : int"
            ]
        },
        {
            "tactic_sig": "unfold rolm .",
            "tactic_args": [
                "_goal : Logic.eq (rolm (rolm x n1 m1) n2 m2)\n  (rolm x (modu (add n1 n2) iwordsize) (and (rol m1 n2) m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (rol (and (rol x n1) m1) n2) m2)\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ]
        },
        {
            "tactic_sig": "rewrite rol_and .",
            "tactic_args": [
                "_goal : Logic.eq (and (rol (and (rol x n1) m1) n2) m2)\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (and (rol (rol x n1) n2) (rol m1 n2)) m2)\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ]
        },
        {
            "tactic_sig": "rewrite and_assoc .",
            "tactic_args": [
                "_goal : Logic.eq (and (and (rol (rol x n1) n2) (rol m1 n2)) m2)\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (rol (rol x n1) n2) (and (rol m1 n2) m2))\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ]
        },
        {
            "tactic_sig": "rewrite rol_rol .",
            "tactic_args": [
                "_goal : Logic.eq (and (rol (rol x n1) n2) (and (rol m1 n2) m2))\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))",
                "_goal : Z.divide zwordsize modulus"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))\n  (and (rol x (modu (add n1 n2) iwordsize)) (and (rol m1 n2) m2))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.divide zwordsize modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x n m1 m2 : int,\nLogic.eq (or (rolm x n m1) (rolm x n m2)) (rolm x n (or m1 m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (rolm x n m1) (rolm x n m2)) (rolm x n (or m1 m2))",
                "x : int",
                "n : int",
                "m1 : int",
                "m2 : int"
            ]
        },
        {
            "tactic_sig": "unfold rolm .",
            "tactic_args": [
                "_goal : Logic.eq (or (rolm x n m1) (rolm x n m2)) (rolm x n (or m1 m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (and (rol x n) m1) (and (rol x n) m2))\n  (and (rol x n) (or m1 m2))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (or (and (rol x n) m1) (and (rol x n) m2))\n  (and (rol x n) (or m1 m2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (rol x n) (or m1 m2))\n  (or (and (rol x n) m1) (and (rol x n) m2))"
            ]
        },
        {
            "tactic_sig": "apply and_or_distrib .",
            "tactic_args": [
                "_goal : Logic.eq (and (rol x n) (or m1 m2))\n  (or (and (rol x n) m1) (and (rol x n) m2))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (ltu y iwordsize) true),\nLogic.eq (ror x y) (rol x (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x y) (rol x (sub iwordsize y))",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_iwordsize_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (ror x y) (rol x (sub iwordsize y))",
                "H : Logic.eq (ltu y iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize),\nLogic.eq (ror x y) (rol x (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize),\nLogic.eq (ror x y) (rol x (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x y) (rol x (sub iwordsize y))",
                "H0 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (ror x y) (rol x (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ror x y) i) (testbit (rol x (sub iwordsize y)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ror x y) i) (testbit (rol x (sub iwordsize y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ror x y) i) (testbit (rol x (sub iwordsize y)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ror .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ror x y) i) (testbit (rol x (sub iwordsize y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit (rol x (sub iwordsize y)) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_rol .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit (rol x (sub iwordsize y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (sub iwordsize y))) zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit x\n     (Z.modulo (Z.sub i (unsigned (sub iwordsize y))) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (unsigned (sub iwordsize y))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (unsigned (sub iwordsize y))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo\n     (Z.sub i\n        (unsigned (repr (Z.sub (unsigned iwordsize) (unsigned y)))))\n     zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo\n     (Z.sub i\n        (unsigned (repr (Z.sub (unsigned iwordsize) (unsigned y)))))\n     zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (Z.sub (unsigned iwordsize) (unsigned y)))\n     zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned iwordsize) (unsigned y)))\n  (Z.le (Z.sub (unsigned iwordsize) (unsigned y)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (Z.sub (unsigned iwordsize) (unsigned y)))\n     zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned y))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (Z.sub zwordsize (unsigned y))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : eqmod zwordsize (Z.add i (unsigned y))\n  (Z.sub i (Z.sub zwordsize (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "apply wordsize_pos .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exists 1 .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add i (unsigned y))\n  (Z.sub i (Z.sub zwordsize (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned y))\n  (Z.add (Z.mul (Zpos xH) zwordsize)\n     (Z.sub i (Z.sub zwordsize (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned y))\n  (Z.add (Z.mul (Zpos xH) zwordsize)\n     (Z.sub i (Z.sub zwordsize (unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (unsigned iwordsize) (unsigned y)))\n  (Z.le (Z.sub (unsigned iwordsize) (unsigned y)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.le zwordsize max_unsigned) (_ : Z.gt zwordsize Z0),\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.le zwordsize max_unsigned) (_ : Z.gt zwordsize Z0),\nLogic.and (Z.le Z0 (Z.sub zwordsize (unsigned y)))\n  (Z.le (Z.sub zwordsize (unsigned y)) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Z.divide zwordsize modulus),\nLogic.eq (ror x y) (rol x (neg y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x y) (rol x (neg y))",
                "H : Z.divide zwordsize modulus",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (ror x y) (rol x (neg y))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ror x y) i) (testbit (rol x (neg y)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ror x y) i) (testbit (rol x (neg y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ror x y) i) (testbit (rol x (neg y)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ror by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ror x y) i) (testbit (rol x (neg y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit (rol x (neg y)) i)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_rol by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit (rol x (neg y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit x (Z.modulo (Z.sub i (unsigned (neg y))) zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.modulo (Z.add i (unsigned y)) zwordsize))\n  (testbit x (Z.modulo (Z.sub i (unsigned (neg y))) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (unsigned (neg y))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.add i (unsigned y)) zwordsize)\n  (Z.modulo (Z.sub i (unsigned (neg y))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize Z0",
                "_goal : eqmod zwordsize (Z.add i (unsigned y)) (Z.sub i (unsigned (neg y)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.gt zwordsize Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_trans with ( _ - ( - unsigned _ ) ) .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add i (unsigned y)) (Z.sub i (unsigned (neg y)))",
                "i : Z",
                "y : int"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize (Z.add i (unsigned y)) (Z.sub i (Z.opp (unsigned y)))",
                "_goal : eqmod zwordsize (Z.sub i (Z.opp (unsigned y)))\n  (Z.sub i (unsigned (neg y)))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_refl2 .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.add i (unsigned y)) (Z.sub i (Z.opp (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (unsigned y)) (Z.sub i (Z.opp (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (unsigned y)) (Z.sub i (Z.opp (unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_sub .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.sub i (Z.opp (unsigned y)))\n  (Z.sub i (unsigned (neg y)))"
            ],
            "tactic_res": [
                "_goal : eqmod zwordsize i i",
                "_goal : eqmod zwordsize (Z.opp (unsigned y)) (unsigned (neg y))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_refl .",
            "tactic_args": [
                "_goal : eqmod zwordsize i i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_divides with modulus .",
            "tactic_args": [
                "_goal : eqmod zwordsize (Z.opp (unsigned y)) (unsigned (neg y))"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (Z.opp (unsigned y)) (unsigned (neg y))",
                "_goal : Z.divide zwordsize modulus"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqmod modulus (Z.opp (unsigned y)) (unsigned (neg y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.divide zwordsize modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true)\n  (_ : Logic.eq (add y z) iwordsize),\nLogic.eq (ror x z) (or (shl x y) (shru x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x z) (or (shl x y) (shru x z))",
                "H1 : Logic.eq (add y z) iwordsize",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_iwordsize_inv _ _ ) ( ltu_iwordsize_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (ror x z) (or (shl x y) (shru x z))",
                "H : Logic.eq (ltu y iwordsize) true",
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (ror x z) (or (shl x y) (shru x z))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize))\n  (_ : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)),\nLogic.eq (ror x z) (or (shl x y) (shru x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x z) (or (shl x y) (shru x z))",
                "H3 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)",
                "H2 : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold ror , or , shl , shru .",
            "tactic_args": [
                "_goal : Logic.eq (ror x z) (or (shl x y) (shru x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.lor (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))))\n  (repr\n     (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))))"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.lor (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))))\n  (repr\n     (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))))) i)\n  (testbit\n     (repr\n        (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n           (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))))) i)\n  (testbit\n     (repr\n        (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n           (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))))) i)\n  (testbit\n     (repr\n        (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n           (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))))) i)",
                "H4 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite !testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (repr\n        (Z.lor\n           (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n           (Z.shiftl (unsigned x)\n              (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))))) i)\n  (testbit\n     (repr\n        (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n           (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))) i)\n  (Z.testbit\n     (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !Z.lor_spec .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.lor (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))) i)\n  (Z.testbit\n     (Z.lor (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (Z.testbit\n        (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize)) i)\n     (Z.testbit\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i))\n  (orb\n     (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        i)\n     (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))\n        i))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_comm .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (Z.testbit\n        (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize)) i)\n     (Z.testbit\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i))\n  (orb\n     (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        i)\n     (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))\n        i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (Z.testbit\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i)\n     (Z.testbit\n        (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize)) i))\n  (orb\n     (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        i)\n     (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))\n        i))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (Z.testbit\n        (Z.shiftl (unsigned x)\n           (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i)\n     (Z.testbit\n        (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize)) i))\n  (orb\n     (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))\n        i)\n     (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))\n        i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.shiftl (unsigned x)\n        (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i)\n  (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y)))) i)",
                "_goal : Logic.eq\n  (Z.testbit (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n     i)\n  (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))) i)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eqm .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit\n     (Z.shiftl (unsigned x)\n        (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))) i)\n  (Z.testbit (unsigned (repr (Z.shiftl (unsigned x) (unsigned y)))) i)"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eqm .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n     i)\n  (Z.testbit (unsigned (repr (Z.shiftr (unsigned x) (unsigned z)))) i)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_r .",
            "tactic_args": [
                "_goal : eqm\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (unsigned (repr (Z.shiftl (unsigned x) (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (Z.shiftl (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (Z.shiftl (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (Z.shiftl (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.shiftl (unsigned x)\n     (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize)))\n  (Z.shiftl (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))\n  (unsigned y)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub zwordsize (Z.modulo (unsigned z) zwordsize))\n  (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub zwordsize (unsigned z)) (unsigned y)",
                "_goal : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( unsigned ( add _ _ ) = zwordsize ) .",
            "tactic_args": [
                "y : int",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (add y z)) zwordsize",
                "H5 : Logic.eq (unsigned (add y z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (add y z)) zwordsize",
                "H1 : Logic.eq (add y z) iwordsize"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned iwordsize) zwordsize"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned iwordsize) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold add in _ .",
            "tactic_args": [
                "H5 : Logic.eq (unsigned (add y z)) zwordsize"
            ],
            "tactic_res": [
                "H5 : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z)))) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr in _ .",
            "tactic_args": [
                "H5 : Logic.eq (unsigned (repr (Z.add (unsigned y) (unsigned z)))) zwordsize"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)",
                "H5 : Logic.eq (Z.add (unsigned y) (unsigned z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub zwordsize (unsigned z)) (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize two_wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Z.le (Z.sub (Z.mul (Zpos (xO xH)) zwordsize) (Zpos xH))\n        max_unsigned,\nLogic.and (Z.le Z0 (Z.add (unsigned y) (unsigned z)))\n  (Z.le (Z.add (unsigned y) (unsigned z)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_r .",
            "tactic_args": [
                "_goal : eqm (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (unsigned (repr (Z.shiftr (unsigned x) (unsigned z))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (Z.shiftr (unsigned x) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (Z.shiftr (unsigned x) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (Z.shiftr (unsigned x) (unsigned z))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Z.shiftr (unsigned x) (Z.modulo (unsigned z) zwordsize))\n  (Z.shiftr (unsigned x) (unsigned z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (unsigned z) zwordsize) (unsigned z)"
            ]
        },
        {
            "tactic_sig": "apply Z.mod_small .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (unsigned z) zwordsize) (unsigned z)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold is_power2 .",
            "tactic_args": [
                "_goal : forall (n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))"
            ],
            "tactic_res": [
                "_goal : forall (n logn : int)\n  (_ : Logic.eq\n         match Z_is_power2 (unsigned n) with\n         | Some i => Some (repr i)\n         | None => None\n         end (Some logn)),\nLogic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n logn : int)\n  (_ : Logic.eq\n         match Z_is_power2 (unsigned n) with\n         | Some i => Some (repr i)\n         | None => None\n         end (Some logn)),\nLogic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "H : Logic.eq\n  match Z_is_power2 (unsigned n) with\n  | Some i => Some (repr i)\n  | None => None\n  end (Some logn)",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "destruct ( Z_is_power2 ( unsigned _ ) ) as [ i| ] eqn : E .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.and (Logic.eq (Some i) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "_goal : Logic.and (Logic.eq None (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "H : Logic.eq (Some (repr i)) (Some logn)",
                "E : Logic.eq (Z_is_power2 (unsigned n)) (Some i)",
                "i : Z",
                "H : Logic.eq None (Some logn)",
                "E : Logic.eq (Z_is_power2 (unsigned n)) None"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq (Some i) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "H : Logic.eq (Some (repr i)) (Some logn)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Logic.eq (Some i) (Some (unsigned (repr i))))\n  (Logic.and (Z.le Z0 (unsigned (repr i)))\n     (Z.lt (unsigned (repr i)) zwordsize))"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq None (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))",
                "H : Logic.eq None (Some logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize ) .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z_is_power2_range with ( unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 zwordsize",
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) (two_p zwordsize))",
                "_goal : Logic.eq (Z_is_power2 (unsigned n)) (Some i)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 zwordsize"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite <- modulus_power .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) (two_p zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z_is_power2 (unsigned n)) (Some i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq (Some i) (Some (unsigned (repr i))))\n  (Logic.and (Z.le Z0 (unsigned (repr i)))\n     (Z.lt (unsigned (repr i)) zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Logic.eq (Some i) (Some i))\n  (Logic.and (Z.le Z0 i) (Z.lt i zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.le i max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq (Some i) (Some i))\n  (Logic.and (Z.le Z0 i) (Z.lt i zwordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.le i max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 i) (Z.le i max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 i) (Z.le i max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize)",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "apply ( is_power2_inv _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize)",
                "n : int",
                "logn : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2 n) (Some logn)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (ltu logn iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu logn iwordsize) true",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu logn iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned logn) (unsigned iwordsize) then true else false)\n  true"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned logn) (unsigned iwordsize) then true else false)\n  true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (unsigned logn) zwordsize then true else false) true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (unsigned logn) zwordsize then true else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned logn) zwordsize"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_rng _ _ _ ) .",
            "tactic_args": [
                "_goal : Z.lt (unsigned logn) zwordsize",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned logn))\n        (Z.lt (unsigned logn) zwordsize),\nZ.lt (unsigned logn) zwordsize"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned logn))\n        (Z.lt (unsigned logn) zwordsize),\nZ.lt (unsigned logn) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n) (two_p (unsigned logn))",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "apply is_power2_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "H : Logic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))"
            ]
        },
        {
            "tactic_sig": "destruct _ as [ P Q ] .",
            "tactic_args": [
                "H : Logic.and (Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn)))\n  (Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize))"
            ],
            "tactic_res": [
                "Q : Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize)",
                "P : Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn))"
            ]
        },
        {
            "tactic_sig": "apply Z_is_power2_sound in _ .",
            "tactic_args": [
                "P : Logic.eq (Z_is_power2 (unsigned n)) (Some (unsigned logn))"
            ],
            "tactic_res": [
                "P : Logic.and (Logic.eq (unsigned n) (two_p (unsigned logn)))\n  (Logic.eq (unsigned logn) (Z.log2 (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)),\nLogic.and (Z.le Z0 (two_p n)) (Z.le (two_p n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (two_p n)) (Z.le (two_p n) max_unsigned)",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p n)) (Z.le (two_p n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (two_p n)",
                "_goal : Z.le (two_p n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "assert ( two_p _ > 0 ) .",
            "tactic_args": [
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p n) Z0",
                "H0 : Z.gt (two_p n) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p n) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (two_p n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( two_p_monotone_strict _ _ _ ) .",
            "tactic_args": [
                "_goal : Z.le (two_p n) max_unsigned",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (two_p n) (two_p zwordsize),\nZ.le (two_p n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "unfold zwordsize .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (two_p n) (two_p zwordsize),\nZ.le (two_p n) max_unsigned"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (two_p n) (two_p (Z.of_nat wordsize)),\nZ.le (two_p n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_power_nat_two_p .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (two_p n) (two_p (Z.of_nat wordsize)),\nZ.le (two_p n) max_unsigned"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (two_p n) (two_power_nat wordsize),\nZ.le (two_p n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned , modulus .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (two_p n) (two_power_nat wordsize),\nZ.le (two_p n) max_unsigned"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (two_p n) (two_power_nat wordsize),\nZ.le (two_p n) (Z.sub (two_power_nat wordsize) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (two_p n) (two_power_nat wordsize),\nZ.le (two_p n) (Z.sub (two_power_nat wordsize) (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)),\nLogic.eq (is_power2 (repr (two_p n))) (Some (repr n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2 (repr (two_p n))) (Some (repr n))",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "unfold is_power2 .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2 (repr (two_p n))) (Some (repr n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match Z_is_power2 (unsigned (repr (two_p n))) with\n  | Some i => Some (repr i)\n  | None => None\n  end (Some (repr n))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  match Z_is_power2 (unsigned (repr (two_p n))) with\n  | Some i => Some (repr i)\n  | None => None\n  end (Some (repr n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match Z_is_power2 (two_p n) with\n  | Some i => Some (repr i)\n  | None => None\n  end (Some (repr n))",
                "_goal : Logic.and (Z.le Z0 (two_p n)) (Z.le (two_p n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite Z_is_power2_complete by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  match Z_is_power2 (two_p n) with\n  | Some i => Some (repr i)\n  | None => None\n  end (Some (repr n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (repr n)) (Some (repr n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Some (repr n)) (Some (repr n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply two_p_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p n)) (Z.le (two_p n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (shl x y) (mul x (repr (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x y) (mul x (repr (two_p (unsigned y))))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shl , mul .",
            "tactic_args": [
                "_goal : Logic.eq (shl x y) (mul x (repr (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned y)))\n  (repr (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned y)))\n  (repr (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.shiftl (unsigned x) (unsigned y))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zshiftl_mul_two_p .",
            "tactic_args": [
                "_goal : eqm (Z.shiftl (unsigned x) (unsigned y))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y)))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (two_p (unsigned y)))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y)))))",
                "_goal : Z.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (two_p (unsigned y)))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned y)))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned y)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (shl x y) (mul x (shl one y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x y) (mul x (shl one y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( shl one _ = repr ( two_p ( unsigned _ ) ) ) .",
            "tactic_args": [
                "y : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl one y) (repr (two_p (unsigned y)))",
                "H : Logic.eq (shl one y) (repr (two_p (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl one y) (repr (two_p (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul one (repr (two_p (unsigned y))))\n  (repr (two_p (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul one (repr (two_p (unsigned y))))\n  (repr (two_p (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (repr (two_p (unsigned y))) one)\n  (repr (two_p (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (mul (repr (two_p (unsigned y))) one)\n  (repr (two_p (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (two_p (unsigned y))) (repr (two_p (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (two_p (unsigned y))) (repr (two_p (unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shl x y) (mul x (shl one y))",
                "H : Logic.eq (shl one y) (repr (two_p (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl x y) (mul x (repr (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "apply shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl x y) (mul x (repr (two_p (unsigned y))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (mul x n) (shl x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (shl x logn)",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "x : int",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_correct _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (shl x logn)",
                "n : int",
                "logn : int",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (mul x n) (shl x logn)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (mul x n) (shl x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (shl x logn)",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (shl x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (mul x (repr (two_p (unsigned logn))))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (mul x (repr (two_p (unsigned logn))))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (mul x (repr (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (mul x (repr (unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (mul x n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (mul x n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (n : Z)\n  (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize))\n  (_ : Z.lt (unsigned y) (two_p n)),\nLogic.eq (or (shl x (repr n)) y)\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (shl x (repr n)) y)\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))",
                "H0 : Z.lt (unsigned y) (two_p n)",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "n : Z",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- add_is_or .",
            "tactic_args": [
                "_goal : Logic.eq (or (shl x (repr n)) y)\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (shl x (repr n)) y)\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))",
                "_goal : Logic.eq (and (shl x (repr n)) y) zero"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (add (shl x (repr n)) y)\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (unsigned (shl x (repr n))) (unsigned y)))\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (unsigned (shl x (repr n))) (unsigned y)))\n  (repr (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned (shl x (repr n))) (unsigned y))\n  (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned (shl x (repr n))) (unsigned y))\n  (Z.add (Z.mul (unsigned x) (two_p n)) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (shl x (repr n))) (Z.mul (unsigned x) (two_p n))",
                "_goal : eqm (unsigned y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned y) (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : eqm (unsigned (shl x (repr n))) (Z.mul (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (mul x (repr (two_p (unsigned (repr n))))))\n  (Z.mul (unsigned x) (two_p n))"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : eqm (unsigned (mul x (repr (two_p (unsigned (repr n))))))\n  (Z.mul (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (unsigned\n     (repr\n        (Z.mul (unsigned x)\n           (unsigned (repr (two_p (unsigned (repr n))))))))\n  (Z.mul (unsigned x) (two_p n))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : eqm\n  (unsigned\n     (repr\n        (Z.mul (unsigned x)\n           (unsigned (repr (two_p (unsigned (repr n))))))))\n  (Z.mul (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned (repr n))))))\n  (Z.mul (unsigned x) (two_p n))"
            ]
        },
        {
            "tactic_sig": "apply eqm_mult .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (unsigned (repr (two_p (unsigned (repr n))))))\n  (Z.mul (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned x)",
                "_goal : eqm (unsigned (repr (two_p (unsigned (repr n))))) (two_p n)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (two_p (unsigned (repr n))))) (two_p n)"
            ],
            "tactic_res": [
                "_goal : eqm (two_p (unsigned (repr n))) (two_p n)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl2 .",
            "tactic_args": [
                "_goal : eqm (two_p (unsigned (repr n))) (two_p n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p (unsigned (repr n))) (two_p n)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (two_p (unsigned (repr n))) (two_p n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p n) (two_p n)",
                "_goal : Logic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (two_p n) (two_p n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (and (shl x (repr n)) y) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb\n     (if zlt i (unsigned (repr n))\n      then false\n      else testbit x (Z.sub i (unsigned (repr n)))) \n     (testbit y i)) false",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb\n     (if zlt i (unsigned (repr n))\n      then false\n      else testbit x (Z.sub i (unsigned (repr n)))) \n     (testbit y i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (andb (if zlt i n then false else testbit x (Z.sub i n))\n     (testbit y i)) false",
                "_goal : Logic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (andb (if zlt i n then false else testbit x (Z.sub i n))\n     (testbit y i)) false",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb false (testbit y i)) false",
                "_goal : Logic.eq (andb (testbit x (Z.sub i n)) (testbit y i)) false",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (andb false (testbit y i)) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( testbit _ _ ) with false .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x (Z.sub i n)) (testbit y i)) false",
                "y : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit x (Z.sub i n)) false) false",
                "_goal : Logic.eq false (testbit y i)"
            ]
        },
        {
            "tactic_sig": "apply andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit x (Z.sub i n)) false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq false (testbit y i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit y i) false"
            ]
        },
        {
            "tactic_sig": "unfold testbit .",
            "tactic_args": [
                "_goal : Logic.eq (testbit y i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned y) i) false"
            ]
        },
        {
            "tactic_sig": "assert ( EQ : Z.of_nat ( Z.to_nat _ ) = _ ) by ( apply Z2Nat.id ; omega ) .",
            "tactic_args": [
                "n : Z",
                "n : Z"
            ],
            "tactic_res": [
                "EQ : Logic.eq (Z.of_nat (Z.to_nat n)) n"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_above with ( Z.to_nat _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned y) i) false",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned y))\n  (Z.lt (unsigned y) (two_power_nat (Z.to_nat n)))",
                "_goal : Z.ge i (Z.of_nat (Z.to_nat n))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ in _ .",
            "tactic_args": [
                "EQ : Logic.eq (Z.of_nat (Z.to_nat n)) n",
                "H0 : Z.lt (unsigned y) (two_p n)"
            ],
            "tactic_res": [
                "H0 : Z.lt (unsigned y) (two_p (Z.of_nat (Z.to_nat n)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_power_nat_two_p in _ .",
            "tactic_args": [
                "H0 : Z.lt (unsigned y) (two_p (Z.of_nat (Z.to_nat n)))"
            ],
            "tactic_res": [
                "H0 : Z.lt (unsigned y) (two_power_nat (Z.to_nat n))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned y))\n  (Z.lt (unsigned y) (two_power_nat (Z.to_nat n)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nLogic.and (Z.le Z0 (unsigned y))\n  (Z.lt (unsigned y) (two_power_nat (Z.to_nat n)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nLogic.and (Z.le Z0 (unsigned y))\n  (Z.lt (unsigned y) (two_power_nat (Z.to_nat n)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.ge i (Z.of_nat (Z.to_nat n))",
                "EQ : Logic.eq (Z.of_nat (Z.to_nat n)) n"
            ],
            "tactic_res": [
                "_goal : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 n) (Z.le n max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (shru x y) (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x y) (repr (Z.div (unsigned x) (two_p (unsigned y))))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shru .",
            "tactic_args": [
                "_goal : Logic.eq (shru x y) (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned y)))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zshiftr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned y)))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))",
                "_goal : Z.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned y)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (divu x n) (shru x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divu x n) (shru x logn)",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "x : int",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_correct _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (divu x n) (shru x logn)",
                "n : int",
                "logn : int",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (divu x n) (shru x logn)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (divu x n) (shru x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divu x n) (shru x logn)",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (divu x n) (shru x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x logn) (divu x n)"
            ]
        },
        {
            "tactic_sig": "unfold divu .",
            "tactic_args": [
                "_goal : Logic.eq (shru x logn) (divu x n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x logn) (repr (Z.div (unsigned x) (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shru x logn) (repr (Z.div (unsigned x) (unsigned n)))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru x logn)\n  (repr (Z.div (unsigned x) (two_p (unsigned logn))))"
            ]
        },
        {
            "tactic_sig": "apply shru_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shru x logn)\n  (repr (Z.div (unsigned x) (two_p (unsigned logn))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (shr x y) (repr (Z.div (signed x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x y) (repr (Z.div (signed x) (two_p (unsigned y))))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold shr .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y) (repr (Z.div (signed x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y)))\n  (repr (Z.div (signed x) (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zshiftr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y)))\n  (repr (Z.div (signed x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y))))\n  (repr (Z.div (signed x) (two_p (unsigned y))))",
                "_goal : Z.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y))))\n  (repr (Z.div (signed x) (two_p (unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned y)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nZ.le Z0 (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (divs x n) (shrx x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (shrx x logn)",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "x : int",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_correct _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (shrx x logn)",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (divs x n) (shrx x logn)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (divs x n) (shrx x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (shrx x logn)",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ]
        },
        {
            "tactic_sig": "unfold shrx .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (shrx x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x (shl one logn))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x (shl one logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x (mul one (repr (two_p (unsigned logn)))))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x (mul one (repr (two_p (unsigned logn)))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x (mul (repr (two_p (unsigned logn))) one))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x (mul (repr (two_p (unsigned logn))) one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x (repr (two_p (unsigned logn))))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x (repr (two_p (unsigned logn))))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x (repr (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x (repr (unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x n) (divs x n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (divs x n) (divs x n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n logn : int) (_ : Logic.eq (is_power2 n) (Some logn)),\nLogic.eq (modu x n) (and x (sub n one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))",
                "H : Logic.eq (is_power2 n) (Some logn)",
                "x : int",
                "n : int",
                "logn : int"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_correct _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (modu x n) (and x (sub n one))"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (unsigned logn)),\nLogic.eq (modu x n) (and x (sub n one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2_rng _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))",
                "H : Logic.eq (is_power2 n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned logn))\n        (Z.lt (unsigned logn) zwordsize),\nLogic.eq (modu x n) (and x (sub n one))"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned logn))\n        (Z.lt (unsigned logn) zwordsize),\nLogic.eq (modu x n) (and x (sub n one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))",
                "H1 : Logic.and (Z.le Z0 (unsigned logn)) (Z.lt (unsigned logn) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (modu x n) (and x (sub n one))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (modu x n) i) (testbit (and x (sub n one)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (modu x n) i) (testbit (and x (sub n one)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i) (testbit (and x (sub n one)) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i) (testbit (and x (sub n one)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i) (testbit (sub n one) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i) (testbit (sub n one) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (testbit (repr (Z.sub (unsigned n) (unsigned one))) i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (testbit (repr (Z.sub (unsigned n) (unsigned one))) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i) (Z.testbit (Z.sub (unsigned n) (unsigned one)) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i) (Z.testbit (Z.sub (unsigned n) (unsigned one)) i))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (unsigned one)) i))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (unsigned one)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ]
        },
        {
            "tactic_sig": "unfold modu .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (modu x n) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.modulo (unsigned x) (unsigned n))) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.modulo (unsigned x) (unsigned n))) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.modulo (unsigned x) (unsigned n)) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.modulo (unsigned x) (unsigned n)) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))",
                "H0 : Logic.eq (unsigned n) (two_p (unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.modulo (unsigned x) (two_p (unsigned logn))) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ]
        },
        {
            "tactic_sig": "rewrite Ztestbit_mod_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.modulo (unsigned x) (two_p (unsigned logn))) i)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned logn) then Z.testbit (unsigned x) i else false)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))",
                "_goal : Z.le Z0 (unsigned logn)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "rewrite Ztestbit_two_p_m1 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned logn) then Z.testbit (unsigned x) i else false)\n  (andb (testbit x i)\n     (Z.testbit (Z.sub (two_p (unsigned logn)) (Zpos xH)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned logn) then Z.testbit (unsigned x) i else false)\n  (andb (testbit x i) (if zlt i (unsigned logn) then true else false))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned logn) then Z.testbit (unsigned x) i else false)\n  (andb (testbit x i) (if zlt i (unsigned logn) then true else false))",
                "i : Z",
                "logn : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (andb (testbit x i) true)",
                "_goal : Logic.eq false (andb (testbit x i) false)",
                "l : Z.lt i (unsigned logn)",
                "g : Z.ge i (unsigned logn)"
            ]
        },
        {
            "tactic_sig": "rewrite andb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (andb (testbit x i) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (testbit x i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq false (andb (testbit x i) false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Z.gt zwordsize (Zpos xH)),\nLogic.eq (shrx x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x zero) x",
                "H : Z.gt zwordsize (Zpos xH)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shrx .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (shl one zero)) x"
            ]
        },
        {
            "tactic_sig": "rewrite shl_zero .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (shl one zero)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x one) x"
            ]
        },
        {
            "tactic_sig": "unfold divs .",
            "tactic_args": [
                "_goal : Logic.eq (divs x one) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed one))) x"
            ]
        },
        {
            "tactic_sig": "rewrite signed_one by auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed one))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zpos xH))) x"
            ]
        },
        {
            "tactic_sig": "rewrite Z.quot_1_r .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (Zpos xH))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_signed .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true),\nLogic.eq (shrx x y)\n  (shr (if lt x zero then add x (sub (shl one y) one) else x) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x y)\n  (shr (if lt x zero then add x (sub (shl one y) one) else x) y)",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "set ( uy := unsigned _ ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "uy : Z"
            ]
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize - 1 ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H0 : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x y)\n  (shr (if lt x zero then add x (sub (shl one y) one) else x) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x y)\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "unfold shrx .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x y)\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (shl one y))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "unfold divs .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (shl one y))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed (shl one y))))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "assert ( shl one _ = repr ( two_p _ ) ) .",
            "tactic_args": [
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl one y) (repr (two_p uy))",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "transitivity ( mul one ( repr ( two_p _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl one y) (repr (two_p uy))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl one y) (mul one (repr (two_p uy)))",
                "_goal : Logic.eq (mul one (repr (two_p uy))) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (shl one y) (mul one (repr (two_p uy)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul one (repr (two_p uy))) (shl one y)"
            ]
        },
        {
            "tactic_sig": "apply mul_pow2 .",
            "tactic_args": [
                "_goal : Logic.eq (mul one (repr (two_p uy))) (shl one y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some y)"
            ]
        },
        {
            "tactic_sig": "replace _ with ( repr _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some y)",
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some (repr uy))",
                "_goal : Logic.eq (repr uy) y"
            ]
        },
        {
            "tactic_sig": "apply is_power2_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some (repr uy))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr uy) y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul one (repr (two_p uy))) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (repr (two_p uy)) one) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "apply mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (mul (repr (two_p uy)) one) (repr (two_p uy))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ > 0 ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p uy) Z0",
                "H2 : Z.gt (two_p uy) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 uy"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 uy"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < half_modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) half_modulus",
                "H3 : Z.lt (two_p uy) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) modulus",
                "H4 : Z.lt (two_p uy) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( unsigned ( shl one _ ) = two_p _ ) .",
            "tactic_args": [
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (shl one y)) (two_p uy)",
                "H5 : Logic.eq (unsigned (shl one y)) (two_p uy)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (shl one y)) (two_p uy)",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (two_p uy))) (two_p uy)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (two_p uy))) (two_p uy)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( signed ( shl one _ ) = two_p _ ) .",
            "tactic_args": [
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (shl one y)) (two_p uy)",
                "H6 : Logic.eq (signed (shl one y)) (two_p uy)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (signed (shl one y)) (two_p uy)",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr (two_p uy))) (two_p uy)"
            ]
        },
        {
            "tactic_sig": "apply signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr (two_p uy))) (two_p uy)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (two_p uy)) (Z.le (two_p uy) max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (two_p uy)) (Z.le (two_p uy) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (two_p uy))\n  (Z.le (two_p uy) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize min_signed_neg .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (two_p uy))\n  (Z.le (two_p uy) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (two_p uy))\n  (Z.le (two_p uy) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (two_p uy))\n  (Z.le (two_p uy) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (signed (shl one y))))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))",
                "H6 : Logic.eq (signed (shl one y)) (two_p uy)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zquot_Zdiv .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.quot (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))",
                "_goal : Z.gt (two_p uy) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (if lt x zero then add x (sub (shl one y) one) else x))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (if if zlt (signed x) (signed zero) then true else false\n            then add x (sub (shl one y) one)\n            else x)) (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (if if zlt (signed x) (signed zero) then true else false\n            then add x (sub (shl one y) one)\n            else x)) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (if if zlt (signed x) Z0 then true else false\n            then add x (sub (shl one y) one)\n            else x)) (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( signed _ ) 0 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (if zlt (signed x) Z0\n      then\n       Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)\n      else Z.div (signed x) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (if if zlt (signed x) Z0 then true else false\n            then add x (sub (shl one y) one)\n            else x)) (two_p (unsigned y))))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div (signed (add x (sub (shl one y) one))) (two_p (unsigned y))))",
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p uy)))\n  (repr (Z.div (signed x) (two_p (unsigned y))))",
                "l : Z.lt (signed x) Z0",
                "g : Z.ge (signed x) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p uy)))\n  (repr (Z.div (signed x) (two_p (unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite add_signed .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div (signed (add x (sub (shl one y) one))) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (repr (Z.add (signed x) (signed (sub (shl one y) one)))))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "assert ( signed ( sub ( shl one _ ) one ) = two_p _ - 1 ) .",
            "tactic_args": [
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (sub (shl one y) one)) (Z.sub (two_p uy) (Zpos xH))",
                "H7 : Logic.eq (signed (sub (shl one y) one)) (Z.sub (two_p uy) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (signed (sub (shl one y) one)) (Z.sub (two_p uy) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr (Z.sub (unsigned (shl one y)) (unsigned one))))\n  (Z.sub (two_p uy) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr (Z.sub (unsigned (shl one y)) (unsigned one))))\n  (Z.sub (two_p uy) (Zpos xH))",
                "H5 : Logic.eq (unsigned (shl one y)) (two_p uy)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr (Z.sub (two_p uy) (unsigned one))))\n  (Z.sub (two_p uy) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr (Z.sub (two_p uy) (unsigned one))))\n  (Z.sub (two_p uy) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (repr (Z.sub (two_p uy) (Zpos xH))))\n  (Z.sub (two_p uy) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "apply signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq (signed (repr (Z.sub (two_p uy) (Zpos xH))))\n  (Z.sub (two_p uy) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "generalize min_signed_neg .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div\n        (signed\n           (repr (Z.add (signed x) (signed (sub (shl one y) one)))))\n        (two_p (unsigned y))))",
                "H7 : Logic.eq (signed (sub (shl one y) one)) (Z.sub (two_p uy) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (repr (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div\n        (signed (repr (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))\n        (two_p (unsigned y))))",
                "_goal : Logic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy)))\n  (repr\n     (Z.div (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))\n        (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy))\n  (Z.div (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))\n     (two_p (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.div (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH)) (two_p uy))\n  (Z.div (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))\n     (two_p (unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH))\n  (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add (signed x) (two_p uy)) (Zpos xH))\n  (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( signed_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed x))\n        (Z.le (signed x) max_signed),\nLogic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed x))\n        (Z.le (signed x) max_signed),\nLogic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)",
                "H8 : Logic.and (Z.le min_signed (signed x)) (Z.le (signed x) max_signed)"
            ]
        },
        {
            "tactic_sig": "assert ( two_p _ - 1 <= max_signed ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed",
                "H9 : Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed"
            ]
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add (signed x) (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true),\nLogic.eq (shrx x y)\n  (shr\n     (add x\n        (shru (shr x (repr (Z.sub zwordsize (Zpos xH))))\n           (sub iwordsize y))) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x y)\n  (shr\n     (add x\n        (shru (shr x (repr (Z.sub zwordsize (Zpos xH))))\n           (sub iwordsize y))) y)",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite shrx_shr by auto .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x y)\n  (shr\n     (add x\n        (shru (shr x (repr (Z.sub zwordsize (Zpos xH))))\n           (sub iwordsize y))) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (shr\n     (add x\n        (shru (shr x (repr (Z.sub zwordsize (Zpos xH))))\n           (sub iwordsize y))) y)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (shr\n     (add x\n        (shru (shr x (repr (Z.sub zwordsize (Zpos xH))))\n           (sub iwordsize y))) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if lt x zero then add x (sub (shl one y) one) else x)\n  (add x\n     (shru (shr x (repr (Z.sub zwordsize (Zpos xH)))) (sub iwordsize y)))"
            ]
        },
        {
            "tactic_sig": "rewrite shr_lt_zero .",
            "tactic_args": [
                "_goal : Logic.eq (if lt x zero then add x (sub (shl one y) one) else x)\n  (add x\n     (shru (shr x (repr (Z.sub zwordsize (Zpos xH)))) (sub iwordsize y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if lt x zero then add x (sub (shl one y) one) else x)\n  (add x (shru (if lt x zero then mone else zero) (sub iwordsize y)))"
            ]
        },
        {
            "tactic_sig": "destruct ( lt _ zero ) .",
            "tactic_args": [
                "_goal : Logic.eq (if lt x zero then add x (sub (shl one y) one) else x)\n  (add x (shru (if lt x zero then mone else zero) (sub iwordsize y)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))",
                "_goal : Logic.eq x (add x (shru zero (sub iwordsize y)))"
            ]
        },
        {
            "tactic_sig": "set ( uy := unsigned _ ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "uy : Z"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nLogic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus),\nLogic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 uy) (Z.lt uy modulus),\nLogic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 uy) (Z.lt uy modulus),\nLogic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))",
                "H0 : Logic.and (Z.le Z0 uy) (Z.lt uy modulus)"
            ]
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize - 1 ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H1 : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) modulus",
                "H2 : Z.lt (two_p uy) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (add x (sub (shl one y) one))\n  (add x (shru mone (sub iwordsize y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (shl one y) one) (shru mone (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (sub (shl one y) one) (shru mone (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (mul one (repr (two_p (unsigned y)))) one)\n  (shru mone (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq (sub (mul one (repr (two_p (unsigned y)))) one)\n  (shru mone (sub iwordsize y))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (mul one (repr (two_p uy))) one)\n  (shru mone (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (sub (mul one (repr (two_p uy))) one)\n  (shru mone (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (mul (repr (two_p uy)) one) one)\n  (shru mone (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (sub (mul (repr (two_p uy)) one) one)\n  (shru mone (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (repr (two_p uy)) one) (shru mone (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub (repr (two_p uy)) one) (shru mone (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (unsigned one)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (unsigned one)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (Zpos xH)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (Zpos xH)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))",
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub (unsigned iwordsize) (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub zwordsize (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub zwordsize (unsigned y))))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub zwordsize uy)))"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (two_p uy) (Zpos xH)))\n  (shru mone (repr (Z.sub zwordsize uy)))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (testbit (shru mone (repr (Z.sub zwordsize uy))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (testbit (shru mone (repr (Z.sub zwordsize uy))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (testbit (shru mone (repr (Z.sub zwordsize uy))) i)",
                "H3 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (testbit (shru mone (repr (Z.sub zwordsize uy))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.sub (two_p uy) (Zpos xH))) i)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.sub (two_p uy) (Zpos xH)) i)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite Ztestbit_two_p_m1 by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.sub (two_p uy) (Zpos xH)) i)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i uy then true else false)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr by ( generalize wordsize_max_unsigned ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i uy then true else false)\n  (if zlt (Z.add i (unsigned (repr (Z.sub zwordsize uy)))) zwordsize\n   then testbit mone (Z.add i (unsigned (repr (Z.sub zwordsize uy))))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i uy then true else false)\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i uy then true else false)\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)",
                "i : Z",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq true\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)",
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)",
                "l : Z.lt i uy",
                "g : Z.ge i uy"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq true\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (testbit mone (Z.add i (Z.sub zwordsize uy)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_mone by omega .",
            "tactic_args": [
                "_goal : Logic.eq true (testbit mone (Z.add i (Z.sub zwordsize uy)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub zwordsize uy)) zwordsize\n   then testbit mone (Z.add i (Z.sub zwordsize uy))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ > 0 ) by ( apply two_p_gt_ZERO ; omega ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "H3 : Z.gt (two_p uy) Z0"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( shru zero ( sub iwordsize _ ) ) with zero .",
            "tactic_args": [
                "_goal : Logic.eq x (add x (shru zero (sub iwordsize y)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (add x zero)",
                "_goal : Logic.eq zero (shru zero (sub iwordsize y))"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq x (add x zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq x x"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq x x"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq zero (shru zero (sub iwordsize y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (sub iwordsize y))) zwordsize\n   then false\n   else false)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned ( sub iwordsize _ ) ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (unsigned (sub iwordsize y))) zwordsize\n   then false\n   else false)",
                "i : Z",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq false false",
                "l : Z.lt (Z.add i (unsigned (sub iwordsize y))) zwordsize",
                "g : Z.ge (Z.add i (unsigned (sub iwordsize y))) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int)\n  (_ : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true),\nLogic.eq (shrx x y) (add (shr x y) (shr_carry x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x y) (add (shr x y) (shr_carry x y))",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite shrx_shr .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x y) (add (shr x y) (shr_carry x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (add (shr x y) (shr_carry x y))",
                "_goal : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shr_carry .",
            "tactic_args": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (add (shr x y) (shr_carry x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (add (shr x y)\n     (if\n       andb (lt x zero) (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (shr (if lt x zero then add x (sub (shl one y) one) else x) y)\n  (add (shr x y)\n     (if\n       andb (lt x zero) (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt (signed x) (signed zero) then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt (signed x) (signed zero) then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "set ( sx := signed _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt (signed x) (signed zero) then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt (signed x) (signed zero) then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt sx (signed zero) then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt sx (signed zero) then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))",
                "sx : Z"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt sx (signed zero) then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt sx (signed zero) then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt sx Z0 then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt sx Z0 then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ 0 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (shr\n     (if if zlt sx Z0 then true else false\n      then add x (sub (shl one y) one)\n      else x) y)\n  (add (shr x y)\n     (if\n       andb (if zlt sx Z0 then true else false)\n         (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))",
                "sx : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if andb true (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))",
                "_goal : Logic.eq (shr x y)\n  (add (shr x y)\n     (if andb false (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))",
                "l : Z.lt sx Z0",
                "g : Z.ge sx Z0"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if andb true (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if negb (eq (and x (sub (shl one y) one)) zero)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y)\n  (add (shr x y)\n     (if andb false (negb (eq (and x (sub (shl one y) one)) zero))\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x y) (add (shr x y) zero)"
            ]
        },
        {
            "tactic_sig": "rewrite add_zero .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y) (add (shr x y) zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x y) (shr x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y) (shr x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( uy := unsigned _ ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "uy : Z"
            ]
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize - 1 ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H0 : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( ltu_inv _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "H : Logic.eq (ltu y (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y)\n           (unsigned (repr (Z.sub zwordsize (Zpos xH))))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned y))\n        (Z.lt (unsigned y) (Z.sub zwordsize (Zpos xH))),\nLogic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt zwordsize Z0) (_ : Z.le zwordsize max_unsigned),\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.le (Z.sub zwordsize (Zpos xH)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( shl one _ = repr ( two_p _ ) ) .",
            "tactic_args": [
                "y : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl one y) (repr (two_p uy))",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl one y) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul one (repr (two_p (unsigned y)))) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul one (repr (two_p (unsigned y)))) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (repr (two_p (unsigned y))) one) (repr (two_p uy))"
            ]
        },
        {
            "tactic_sig": "apply mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (mul (repr (two_p (unsigned y))) one) (repr (two_p uy))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( and _ ( sub ( shl one _ ) one ) = modu _ ( repr ( two_p _ ) ) ) .",
            "tactic_args": [
                "x : int",
                "y : int",
                "x : int",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and x (sub (shl one y) one)) (modu x (repr (two_p uy)))",
                "H2 : Logic.eq (and x (sub (shl one y) one)) (modu x (repr (two_p uy)))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (and x (sub (shl one y) one)) (modu x (repr (two_p uy)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x (repr (two_p uy))) (and x (sub (shl one y) one))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (modu x (repr (two_p uy))) (and x (sub (shl one y) one))",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (modu x (repr (two_p uy))) (and x (sub (repr (two_p uy)) one))"
            ]
        },
        {
            "tactic_sig": "apply modu_and with ( logn := _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (modu x (repr (two_p uy))) (and x (sub (repr (two_p uy)) one))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some y)"
            ]
        },
        {
            "tactic_sig": "rewrite is_power2_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2 (repr (two_p uy))) (Some y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (repr uy)) (Some y)",
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (Some (repr uy)) (Some y)",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some (repr (unsigned y))) (Some y)"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Some (repr (unsigned y))) (Some y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Some y) (Some y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Some y) (Some y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if negb (eq (and x (sub (shl one y) one)) zero)\n      then one\n      else zero))",
                "H2 : Logic.eq (and x (sub (shl one y) one)) (modu x (repr (two_p uy)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shr (add x (sub (shl one y) one)) y)\n  (add (shr x y)\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "H1 : Logic.eq (shl one y) (repr (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (add x (sub (repr (two_p uy)) one)) y)\n  (add (shr x y)\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "repeat rewrite shr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shr (add x (sub (repr (two_p uy)) one)) y)\n  (add (shr x y)\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (sub (repr (two_p uy)) one)))\n        (two_p (unsigned y))))\n  (add (repr (Z.div (signed x) (two_p (unsigned y))))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (sub (repr (two_p uy)) one)))\n        (two_p (unsigned y))))\n  (add (repr (Z.div (signed x) (two_p (unsigned y))))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "sx : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (sub (repr (two_p uy)) one)))\n        (two_p (unsigned y))))\n  (add (repr (Z.div sx (two_p (unsigned y))))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (sub (repr (two_p uy)) one)))\n        (two_p (unsigned y))))\n  (add (repr (Z.div sx (two_p (unsigned y))))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (signed (add x (sub (repr (two_p uy)) one))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "assert ( two_p _ > 0 ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p uy) Z0",
                "H3 : Z.gt (two_p uy) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 uy"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 uy"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) modulus",
                "H4 : Z.lt (two_p uy) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < half_modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) half_modulus",
                "H5 : Z.lt (two_p uy) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite half_modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) half_modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( two_p _ < modulus ) .",
            "tactic_args": [
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) modulus",
                "H6 : Z.lt (two_p uy) modulus"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_power .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) modulus"
            ],
            "tactic_res": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone_strict .",
            "tactic_args": [
                "_goal : Z.lt (two_p uy) (two_p zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 uy) (Z.lt uy zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( sub ( repr ( two_p _ ) ) one = repr ( two_p _ - 1 ) ) .",
            "tactic_args": [
                "uy : Z",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (repr (two_p uy)) one)\n  (repr (Z.sub (two_p uy) (Zpos xH)))",
                "H7 : Logic.eq (sub (repr (two_p uy)) one)\n  (repr (Z.sub (two_p uy) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub (repr (two_p uy)) one)\n  (repr (Z.sub (two_p uy) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (unsigned one)))\n  (repr (Z.sub (two_p uy) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.sub (unsigned (repr (two_p uy))) (unsigned one)))\n  (repr (Z.sub (two_p uy) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (unsigned (repr (two_p uy))) (unsigned one))\n  (Z.sub (two_p uy) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "apply eqm_sub .",
            "tactic_args": [
                "_goal : eqm (Z.sub (unsigned (repr (two_p uy))) (unsigned one))\n  (Z.sub (two_p uy) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (two_p uy))) (two_p uy)",
                "_goal : eqm (unsigned one) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (two_p uy))) (two_p uy)"
            ],
            "tactic_res": [
                "_goal : eqm (two_p uy) (unsigned (repr (two_p uy)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (two_p uy) (unsigned (repr (two_p uy)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : eqm (unsigned one) (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : eqm (Zpos xH) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Zpos xH) (Zpos xH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (signed (add x (sub (repr (two_p uy)) one))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "H7 : Logic.eq (sub (repr (two_p uy)) one)\n  (repr (Z.sub (two_p uy) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (repr (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite add_signed .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (add x (repr (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div\n        (signed\n           (repr\n              (Z.add (signed x)\n                 (signed (repr (Z.sub (two_p uy) (Zpos xH)))))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div\n        (signed\n           (repr\n              (Z.add (signed x)\n                 (signed (repr (Z.sub (two_p uy) (Zpos xH)))))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "sx : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div\n        (signed\n           (repr\n              (Z.add sx (signed (repr (Z.sub (two_p uy) (Zpos xH)))))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite ( signed_repr ( two_p _ - 1 ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div\n        (signed\n           (repr\n              (Z.add sx (signed (repr (Z.sub (two_p uy) (Zpos xH)))))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (repr (Z.add sx (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "_goal : Logic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.div (signed (repr (Z.add sx (Z.sub (two_p uy) (Zpos xH)))))\n        (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))",
                "_goal : Logic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold modu .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (modu x (repr (two_p uy))) zero) then one else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (eq\n            (repr (Z.modulo (unsigned x) (unsigned (repr (two_p uy)))))\n            zero)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (eq\n            (repr (Z.modulo (unsigned x) (unsigned (repr (two_p uy)))))\n            zero)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (repr (Z.modulo (unsigned x) (two_p uy))) zero)\n      then one\n      else zero))",
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "unfold eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (eq (repr (Z.modulo (unsigned x) (two_p uy))) zero)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if\n           zeq (unsigned (repr (Z.modulo (unsigned x) (two_p uy))))\n             (unsigned zero)\n          then true\n          else false)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if\n           zeq (unsigned (repr (Z.modulo (unsigned x) (two_p uy))))\n             (unsigned zero)\n          then true\n          else false)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if\n           zeq (unsigned (repr (Z.modulo (unsigned x) (two_p uy)))) Z0\n          then true\n          else false)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if\n           zeq (unsigned (repr (Z.modulo (unsigned x) (two_p uy)))) Z0\n          then true\n          else false)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if zeq (Z.modulo (unsigned x) (two_p uy)) Z0\n          then true\n          else false)\n      then one\n      else zero))",
                "_goal : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned _ mod two_p _ = _ mod two_p _ ) .",
            "tactic_args": [
                "x : int",
                "uy : Z",
                "sx : Z",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (unsigned x) (two_p uy)) (Z.modulo sx (two_p uy))",
                "H8 : Logic.eq (Z.modulo (unsigned x) (two_p uy)) (Z.modulo sx (two_p uy))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (unsigned x) (two_p uy)) (Z.modulo sx (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p uy) Z0",
                "_goal : eqmod (two_p uy) (unsigned x) sx"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_divides with modulus .",
            "tactic_args": [
                "_goal : eqmod (two_p uy) (unsigned x) sx"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (unsigned x) sx",
                "_goal : Z.divide (two_p uy) modulus"
            ]
        },
        {
            "tactic_sig": "fold eqm .",
            "tactic_args": [
                "_goal : eqmod modulus (unsigned x) sx"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) sx"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : eqm (unsigned x) sx",
                "sx : Z"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (signed x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (signed x)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold modulus .",
            "tactic_args": [
                "_goal : Z.divide (two_p uy) modulus"
            ],
            "tactic_res": [
                "_goal : Z.divide (two_p uy) (two_power_nat wordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite two_power_nat_two_p .",
            "tactic_args": [
                "_goal : Z.divide (two_p uy) (two_power_nat wordsize)"
            ],
            "tactic_res": [
                "_goal : Z.divide (two_p uy) (two_p (Z.of_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "exists ( two_p ( zwordsize - _ ) ) .",
            "tactic_args": [
                "_goal : Z.divide (two_p uy) (two_p (Z.of_nat wordsize))",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (Z.mul (two_p (Z.sub zwordsize uy)) (two_p uy))"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_p_is_exp .",
            "tactic_args": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (Z.mul (two_p (Z.sub zwordsize uy)) (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (two_p (Z.add (Z.sub zwordsize uy) uy))",
                "_goal : Z.le Z0 (Z.sub zwordsize uy)",
                "_goal : Z.le Z0 uy"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (two_p (Z.add (Z.sub zwordsize uy) uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.of_nat wordsize) (Z.add (Z.sub zwordsize uy) uy)"
            ]
        },
        {
            "tactic_sig": "fold zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq (Z.of_nat wordsize) (Z.add (Z.sub zwordsize uy) uy)"
            ],
            "tactic_res": [
                "_goal : Logic.eq zwordsize (Z.add (Z.sub zwordsize uy) uy)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq zwordsize (Z.add (Z.sub zwordsize uy) uy)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize uy)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 uy"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if\n       negb\n         (if zeq (Z.modulo (unsigned x) (two_p uy)) Z0\n          then true\n          else false)\n      then one\n      else zero))",
                "H8 : Logic.eq (Z.modulo (unsigned x) (two_p uy)) (Z.modulo sx (two_p uy))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "rewrite Zdiv_shift .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.div (Z.add sx (Z.sub (two_p uy) (Zpos xH))) (two_p uy)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.div sx (two_p uy))\n        (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))",
                "_goal : Z.gt (two_p uy) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.div sx (two_p uy))\n        (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)))\n  (add (repr (Z.div sx (two_p uy)))\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.div sx (two_p uy))\n        (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)))\n  (repr\n     (Z.add (unsigned (repr (Z.div sx (two_p uy))))\n        (unsigned\n           (if\n             negb\n               (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n            then one\n            else zero))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.div sx (two_p uy))\n        (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)))\n  (repr\n     (Z.add (unsigned (repr (Z.div sx (two_p uy))))\n        (unsigned\n           (if\n             negb\n               (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n            then one\n            else zero))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add (Z.div sx (two_p uy))\n     (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH))\n  (Z.add (unsigned (repr (Z.div sx (two_p uy))))\n     (unsigned\n        (if\n          negb\n            (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n         then one\n         else zero)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add (Z.div sx (two_p uy))\n     (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH))\n  (Z.add (unsigned (repr (Z.div sx (two_p uy))))\n     (unsigned\n        (if\n          negb\n            (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n         then one\n         else zero)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.div sx (two_p uy)) (unsigned (repr (Z.div sx (two_p uy))))",
                "_goal : eqm (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)\n  (unsigned\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (Z.div sx (two_p uy)) (unsigned (repr (Z.div sx (two_p uy))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( _ mod two_p _ ) 0 ) .",
            "tactic_args": [
                "_goal : eqm (if zeq (Z.modulo sx (two_p uy)) Z0 then Z0 else Zpos xH)\n  (unsigned\n     (if negb (if zeq (Z.modulo sx (two_p uy)) Z0 then true else false)\n      then one\n      else zero))",
                "sx : Z",
                "uy : Z"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (unsigned (if negb true then one else zero))",
                "_goal : eqm (Zpos xH) (unsigned (if negb false then one else zero))",
                "e : Logic.eq (Z.modulo sx (two_p uy)) Z0",
                "n : Logic.not (Logic.eq (Z.modulo sx (two_p uy)) Z0)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : eqm Z0 (unsigned (if negb true then one else zero))"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (unsigned zero)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : eqm (Zpos xH) (unsigned (if negb false then one else zero))"
            ],
            "tactic_res": [
                "_goal : eqm (Zpos xH) (unsigned one)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : eqm Z0 (unsigned zero)"
            ],
            "tactic_res": [
                "_goal : eqm Z0 Z0"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm Z0 Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_one .",
            "tactic_args": [
                "_goal : eqm (Zpos xH) (unsigned one)"
            ],
            "tactic_res": [
                "_goal : eqm (Zpos xH) (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Zpos xH) (Zpos xH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( Z_mod_lt ( unsigned _ ) ( two_p _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) max_unsigned)",
                "x : int",
                "uy : Z",
                "H3 : Z.gt (two_p uy) Z0"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n        (Z.lt (Z.modulo (unsigned x) (two_p uy)) (two_p uy)),\nLogic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n        (Z.lt (Z.modulo (unsigned x) (two_p uy)) (two_p uy)),\nLogic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n        (Z.lt (Z.modulo (unsigned x) (two_p uy)) (two_p uy)),\nLogic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n        (Z.lt (Z.modulo (unsigned x) (two_p uy)) (two_p uy)),\nLogic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p uy)))\n  (Z.le (Z.modulo (unsigned x) (two_p uy)) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy)) (Z.le (two_p uy) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (two_p uy))\n  (Z.le (two_p uy) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( signed_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed x))\n        (Z.le (signed x) max_signed),\nLogic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed x))\n        (Z.le (signed x) max_signed),\nLogic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)",
                "sx : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le min_signed sx) (Z.le sx max_signed),\nLogic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le min_signed sx) (Z.le sx max_signed),\nLogic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)",
                "H8 : Logic.and (Z.le min_signed sx) (Z.le sx max_signed)"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH))))\n  (Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed)"
            ],
            "tactic_res": [
                "_goal : Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH)))",
                "_goal : Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le min_signed (Z.add sx (Z.sub (two_p uy) (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH))) max_signed"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH)))\n  (Z.sub half_modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.add sx (Z.sub (two_p uy) (Zpos xH)))\n  (Z.sub half_modulus (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize min_signed_neg .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold max_signed .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) max_signed)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0,\nLogic.and (Z.le min_signed (Z.sub (two_p uy) (Zpos xH)))\n  (Z.le (Z.sub (two_p uy) (Zpos xH)) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Z.ge (signed x) Z0),\nLogic.eq (shr x y) (shru x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x y) (shru x y)",
                "H : Z.ge (signed x) Z0",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite shr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y) (shru x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y)))) (shru x y)"
            ]
        },
        {
            "tactic_sig": "rewrite shru_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y)))) (shru x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite signed_eq_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (signed x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))",
                "_goal : Z.le (unsigned x) max_signed"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (unsigned y))))\n  (repr (Z.div (unsigned x) (two_p (unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply signed_positive .",
            "tactic_args": [
                "_goal : Z.le (unsigned x) max_signed"
            ],
            "tactic_res": [
                "_goal : Z.ge (signed x) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge (signed x) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Z.ge (signed y) Z0), Z.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (signed (and x y)) Z0",
                "H : Z.ge (signed y) Z0",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned _ < half_modulus ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned y) half_modulus",
                "H0 : Z.lt (unsigned y) half_modulus"
            ]
        },
        {
            "tactic_sig": "rewrite signed_positive in _ .",
            "tactic_args": [
                "H : Z.ge (signed y) Z0"
            ],
            "tactic_res": [
                "H : Z.le (unsigned y) max_signed"
            ]
        },
        {
            "tactic_sig": "unfold max_signed in _ .",
            "tactic_args": [
                "H : Z.le (unsigned y) max_signed"
            ],
            "tactic_res": [
                "H : Z.le (unsigned y) (Z.sub half_modulus (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (unsigned y) half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( sign_bit_of_unsigned _ ) .",
            "tactic_args": [
                "_goal : Z.ge (signed (and x y)) Z0",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH)))\n        (if zlt (unsigned y) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH)))\n        (if zlt (unsigned y) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH))) false,\nZ.ge (signed (and x y)) Z0",
                "_goal : Z.lt (unsigned y) half_modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt (unsigned y) half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros A .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH))) false,\nZ.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (signed (and x y)) Z0",
                "A : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH))) false"
            ]
        },
        {
            "tactic_sig": "generalize ( sign_bit_of_unsigned ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Z.ge (signed (and x y)) Z0",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (testbit (and x y) (Z.sub zwordsize (Zpos xH)))\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (testbit (and x y) (Z.sub zwordsize (Zpos xH)))\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq\n        (andb (testbit x (Z.sub zwordsize (Zpos xH)))\n           (testbit y (Z.sub zwordsize (Zpos xH))))\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq\n        (andb (testbit x (Z.sub zwordsize (Zpos xH)))\n           (testbit y (Z.sub zwordsize (Zpos xH))))\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0",
                "A : Logic.eq (testbit y (Z.sub zwordsize (Zpos xH))) false"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (andb (testbit x (Z.sub zwordsize (Zpos xH))) false)\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite andb_false_r .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (andb (testbit x (Z.sub zwordsize (Zpos xH))) false)\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq false\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq false\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq false\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge\n  (if zlt (unsigned (and x y)) half_modulus\n   then unsigned (and x y)\n   else Z.sub (unsigned (and x y)) modulus) Z0"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned ( and _ _ ) ) half_modulus ) .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq false\n        (if zlt (unsigned (and x y)) half_modulus then false else true),\nZ.ge\n  (if zlt (unsigned (and x y)) half_modulus\n   then unsigned (and x y)\n   else Z.sub (unsigned (and x y)) modulus) Z0",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq false false, Z.ge (unsigned (and x y)) Z0",
                "_goal : forall _ : Logic.eq false true,\nZ.ge (Z.sub (unsigned (and x y)) modulus) Z0",
                "l : Z.lt (unsigned (and x y)) half_modulus",
                "g : Z.ge (unsigned (and x y)) half_modulus"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq false false, Z.ge (unsigned (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (unsigned (and x y)) Z0",
                "H1 : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Z.ge (unsigned (and x y)) Z0",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (and x y)))\n        (Z.lt (unsigned (and x y)) modulus),\nZ.ge (unsigned (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (and x y)))\n        (Z.lt (unsigned (and x y)) modulus),\nZ.ge (unsigned (and x y)) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq false true,\nZ.ge (Z.sub (unsigned (and x y)) modulus) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0,\nLogic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (lt y zero) false),\nLogic.eq (shr (and x y) z) (shru (and x y) z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (and x y) z) (shru (and x y) z)",
                "H : Logic.eq (lt y zero) false",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply shr_shru_positive .",
            "tactic_args": [
                "_goal : Logic.eq (shr (and x y) z) (shru (and x y) z)"
            ],
            "tactic_res": [
                "_goal : Z.ge (signed (and x y)) Z0"
            ]
        },
        {
            "tactic_sig": "apply and_positive .",
            "tactic_args": [
                "_goal : Z.ge (signed (and x y)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.ge (signed y) Z0"
            ]
        },
        {
            "tactic_sig": "unfold lt in _ .",
            "tactic_args": [
                "H : Logic.eq (lt y zero) false"
            ],
            "tactic_res": [
                "H : Logic.eq (if zlt (signed y) (signed zero) then true else false) false"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero in _ .",
            "tactic_args": [
                "H : Logic.eq (if zlt (signed y) (signed zero) then true else false) false"
            ],
            "tactic_res": [
                "H : Logic.eq (if zlt (signed y) Z0 then true else false) false"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( signed _ ) 0 ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "H : Logic.eq true false",
                "l : Z.lt (signed y) Z0",
                "H : Logic.eq false false",
                "g : Z.ge (signed y) Z0"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge (signed y) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (i : Z) (_ : Z.le Z0 i),\nLogic.eq (testbit (zero_ext n x) i)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (zero_ext n x) i)\n  (if zlt i n then testbit x i else false)",
                "H : Z.le Z0 i",
                "i : Z",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "unfold zero_ext .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext n x) i)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Zzero_ext n (unsigned x))) i)\n  (if zlt i n then testbit x i else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "l : Z.lt i zwordsize",
                "g : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Zzero_ext n (unsigned x)) i)\n  (if zlt i n then testbit x i else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Zzero_ext_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Zzero_ext n (unsigned x)) i)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then Z.testbit (unsigned x) i else false)\n  (if zlt i n then testbit x i else false)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then Z.testbit (unsigned x) i else false)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !bits_above .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Zzero_ext n (unsigned x))) i)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "_goal : Z.ge i zwordsize",
                "_goal : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq false false",
                "l : Z.lt i n",
                "g0 : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext n x) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "unfold sign_ext .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Zsign_ext n (unsigned x))) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Zsign_ext n (unsigned x))) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Zsign_ext n (unsigned x)) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Zsign_ext_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Zsign_ext n (unsigned x)) i)\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.ge n zwordsize),\nLogic.eq (zero_ext n x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x) x",
                "H : Z.ge n zwordsize",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x) x"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (zero_ext n x) i) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (zero_ext n x) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (zero_ext n x) i) (testbit x i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext n x) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) (testbit x i)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Z.lt i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.le n Z0), Logic.eq (zero_ext n x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x) zero",
                "H : Z.le n Z0",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) false",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) false",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) false",
                "_goal : Logic.eq false false",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_below .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Z.lt i Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.ge n zwordsize),\nLogic.eq (sign_ext n x) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) x",
                "H : Z.ge n zwordsize",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) x"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext n x) i) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext n x) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) i) (testbit x i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "unfold sign_ext .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Zsign_ext n (unsigned x))) i) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Zsign_ext n (unsigned x))) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Zsign_ext n (unsigned x)) i) (testbit x i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Zsign_ext_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Zsign_ext n (unsigned x)) i) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.testbit (unsigned x) (if zlt i n then i else Z.sub n (Zpos xH)))\n  (testbit x i)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.testbit (unsigned x) (if zlt i n then i else Z.sub n (Zpos xH)))\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (testbit x i)",
                "_goal : Z.lt i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) i) (testbit x i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.le n Z0), Logic.eq (sign_ext n x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) zero",
                "H : Z.le n Z0",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH))) false",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "apply bits_below .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH))) false"
            ],
            "tactic_res": [
                "_goal : Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) Z0"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) Z0",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt i Z0",
                "_goal : Z.lt (Z.sub n (Zpos xH)) Z0",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub n (Zpos xH)) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.le Z0 n),\nLogic.eq (zero_ext n x) (and x (repr (Z.sub (two_p n) (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (testbit (repr (Z.sub (two_p n) (Zpos xH))) i))",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Z.le Z0 n",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (testbit (repr (Z.sub (two_p n) (Zpos xH))) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (Z.testbit (Z.sub (two_p n) (Zpos xH)) i))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Ztestbit_two_p_m1 .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (Z.testbit (Z.sub (two_p n) (Zpos xH)) i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (if zlt i n then true else false))",
                "_goal : Z.le Z0 n"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt i zwordsize",
                "H1 : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (andb (testbit x i) (if zlt i n then true else false))",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (andb (testbit x i) true)",
                "_goal : Logic.eq false (andb (testbit x i) false)",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "rewrite andb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (andb (testbit x i) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (testbit x i)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (testbit x i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite andb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq false (andb (testbit x i) false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)),\nLogic.eq (unsigned (zero_ext n x)) (Z.modulo (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (zero_ext n x)) (Z.modulo (unsigned x) (two_p n))",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply equal_same_bits .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (zero_ext n x)) (Z.modulo (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Z.le Z0 i),\nLogic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (Z.testbit (Z.modulo (unsigned x) (two_p n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Z.le Z0 i),\nLogic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (Z.testbit (Z.modulo (unsigned x) (two_p n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (Z.testbit (Z.modulo (unsigned x) (two_p n)) i)",
                "H0 : Z.le Z0 i",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite Ztestbit_mod_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (Z.testbit (Z.modulo (unsigned x) (two_p n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (if zlt i n then Z.testbit (unsigned x) i else false)",
                "_goal : Z.le Z0 n",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold ( testbit ( zero_ext _ _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (zero_ext n x)) i)\n  (if zlt i n then Z.testbit (unsigned x) i else false)",
                "n : Z",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (zero_ext n x) i)\n  (if zlt i n then Z.testbit (unsigned x) i else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "i : Z"
            ],
            "tactic_res": [
                "l : Z.lt i zwordsize",
                "g : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (if zlt i n then Z.testbit (unsigned x) i else false)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (if zlt i n then Z.testbit (unsigned x) i else false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_above .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext n x) i)\n  (if zlt i n then Z.testbit (unsigned x) i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (if zlt i n then Z.testbit (unsigned x) i else false)",
                "_goal : Z.ge i zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq false (if zlt i n then Z.testbit (unsigned x) i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.le Z0 n) (Z.le n n')),\nLogic.eq (zero_ext n' (zero_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i n' then if zlt i n then testbit x i else false else false)\n  (if zlt i n then testbit x i else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Logic.and (Z.le Z0 n) (Z.le n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i n' then if zlt i n then testbit x i else false else false)\n  (if zlt i n then testbit x i else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n' then testbit x i else false) (testbit x i)",
                "_goal : Logic.eq (if zlt i n' then false else false) false",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n' then testbit x i else false) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Z.lt i n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n'"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n' then false else false) false",
                "i : Z",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq false false",
                "l : Z.lt i n'",
                "g0 : Z.ge i n'"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.lt Z0 n) (Z.le n n')),\nLogic.eq (sign_ext n' (sign_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n' (sign_ext n x)) (sign_ext n x)",
                "H : Logic.and (Z.lt Z0 n) (Z.le n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "n' : Z"
            ],
            "tactic_res": [
                "l : Z.lt n' zwordsize",
                "g : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (if zlt i n' then i else Z.sub n' (Zpos xH)) n\n      then if zlt i n' then i else Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (Z.lt (if zlt i n' then i else Z.sub n' (Zpos xH)) zwordsize)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (if zlt i n' then i else Z.sub n' (Zpos xH)) n\n      then if zlt i n' then i else Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "i : Z",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n' (Zpos xH)) n\n      then Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "l0 : Z.lt i n'",
                "g : Z.ge i n'"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( zlt_false _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n' (Zpos xH)) n\n      then Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n' (Zpos xH)) n\n      then Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub n (Zpos xH)))",
                "_goal : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - 1 ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n' (Zpos xH)) n\n      then Z.sub n' (Zpos xH)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub n (Zpos xH)))",
                "n' : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub n' (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))",
                "_goal : Logic.eq (testbit x (Z.sub n (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))",
                "l0 : Z.lt (Z.sub n' (Zpos xH)) n",
                "g0 : Z.ge (Z.sub n' (Zpos xH)) n"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub n' (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub n' (Zpos xH)) (Z.sub n (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub n' (Zpos xH)) (Z.sub n (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub n (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (Z.lt (if zlt i n' then i else Z.sub n' (Zpos xH)) zwordsize)",
                "i : Z",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub n' (Zpos xH)))\n  (Z.lt (Z.sub n' (Zpos xH)) zwordsize)",
                "l0 : Z.lt i n'",
                "g : Z.ge i n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub n' (Zpos xH)))\n  (Z.lt (Z.sub n' (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply sign_ext_above .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n' (sign_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge n' zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.le Z0 n) (Z.lt n n')),\nLogic.eq (sign_ext n' (zero_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n' (zero_ext n x)) (zero_ext n x)",
                "H : Logic.and (Z.le Z0 n) (Z.lt n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "n' : Z"
            ],
            "tactic_res": [
                "l : Z.lt n' zwordsize",
                "g : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (if zlt i n' then i else Z.sub n' (Zpos xH)) n\n   then testbit x (if zlt i n' then i else Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 (if zlt i n' then i else Z.sub n' (Zpos xH))",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (if zlt i n' then i else Z.sub n' (Zpos xH)) n\n   then testbit x (if zlt i n' then i else Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)",
                "i : Z",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (if zlt i n then testbit x i else false)",
                "_goal : Logic.eq\n  (if zlt (Z.sub n' (Zpos xH)) n\n   then testbit x (Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)",
                "l0 : Z.lt i n'",
                "g : Z.ge i n'"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false)\n  (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub n' (Zpos xH)) n\n   then testbit x (Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Z.ge i n",
                "_goal : Z.ge (Z.sub n' (Zpos xH)) n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub n' (Zpos xH)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (if zlt i n' then i else Z.sub n' (Zpos xH))",
                "i : Z",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 (Z.sub n' (Zpos xH))",
                "l0 : Z.lt i n'",
                "g : Z.ge i n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub n' (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply sign_ext_above .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n' (zero_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge n' zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.le Z0 n) (Z.le n n')),\nLogic.eq (zero_ext n (zero_ext n' x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i n then if zlt i n' then testbit x i else false else false)\n  (if zlt i n then testbit x i else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "H : Logic.and (Z.le Z0 n) (Z.le n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i n then if zlt i n' then testbit x i else false else false)\n  (if zlt i n then testbit x i else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n' then testbit x i else false) (testbit x i)",
                "_goal : Logic.eq false false",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n' then testbit x i else false) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Z.lt i n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n'"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.lt Z0 n) (Z.le n n')),\nLogic.eq (sign_ext n (sign_ext n' x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n (sign_ext n' x)) (sign_ext n x)",
                "H : Logic.and (Z.lt Z0 n) (Z.le n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "n : Z"
            ],
            "tactic_res": [
                "l : Z.lt n zwordsize",
                "g : Z.ge n zwordsize"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (if zlt i n then i else Z.sub n (Zpos xH)) n'\n      then if zlt i n then i else Z.sub n (Zpos xH)\n      else Z.sub n' (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (if zlt i n then i else Z.sub n (Zpos xH)) n'\n      then if zlt i n then i else Z.sub n (Zpos xH)\n      else Z.sub n' (Zpos xH)))\n  (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (testbit x i)",
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n (Zpos xH)) n'\n      then Z.sub n (Zpos xH)\n      else Z.sub n' (Zpos xH))) (testbit x (Z.sub n (Zpos xH)))",
                "l0 : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n' then i else Z.sub n' (Zpos xH)) i"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n' then i else Z.sub n' (Zpos xH)) i"
            ],
            "tactic_res": [
                "_goal : Z.lt i n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n'"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub n (Zpos xH)) n'\n      then Z.sub n (Zpos xH)\n      else Z.sub n' (Zpos xH))) (testbit x (Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub n (Zpos xH)) n'\n   then Z.sub n (Zpos xH)\n   else Z.sub n' (Zpos xH)) (Z.sub n (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub n (Zpos xH)) n'\n   then Z.sub n (Zpos xH)\n   else Z.sub n' (Zpos xH)) (Z.sub n (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub n (Zpos xH)) n'"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub n (Zpos xH)) n'"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)",
                "l0 : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( sign_ext_above _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n (sign_ext n' x)) (sign_ext n x)",
                "n' : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n x)",
                "_goal : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge n' zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n n' : Z) (_ : Logic.and (Z.lt Z0 n) (Z.le n n')),\nLogic.eq (zero_ext n (sign_ext n' x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n (sign_ext n' x)) (zero_ext n x)",
                "H : Logic.and (Z.lt Z0 n) (Z.le n n')",
                "n : Z",
                "n' : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "n' : Z"
            ],
            "tactic_res": [
                "l : Z.lt n' zwordsize",
                "g : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i n\n   then testbit x (if zlt i n' then i else Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i n\n   then testbit x (if zlt i n' then i else Z.sub n' (Zpos xH))\n   else false) (if zlt i n then testbit x i else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (testbit x i)",
                "_goal : Logic.eq false false",
                "l0 : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (if zlt i n' then i else Z.sub n' (Zpos xH)))\n  (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (testbit x i)",
                "_goal : Z.lt i n'"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (testbit x i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n'"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite sign_ext_above .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n (sign_ext n' x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x) (zero_ext n x)",
                "_goal : Z.ge n' zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x) (zero_ext n x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge n' zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.le Z0 n),\nLogic.eq (zero_ext n (zero_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n (zero_ext n x)) (zero_ext n x)",
                "H : Z.le Z0 n",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply zero_ext_widen .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n (zero_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 n) (Z.le n n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.le n n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.lt Z0 n),\nLogic.eq (sign_ext n (sign_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n (sign_ext n x)) (sign_ext n x)",
                "H : Z.lt Z0 n",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply sign_ext_widen .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n (sign_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.le n n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.le n n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.lt Z0 n),\nLogic.eq (sign_ext n (zero_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n x)",
                "H : Z.lt Z0 n",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ zwordsize ) .",
            "tactic_args": [
                "n : Z"
            ],
            "tactic_res": [
                "l : Z.lt n zwordsize",
                "g : Z.ge n zwordsize"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (if zlt i n then i else Z.sub n (Zpos xH)) n\n   then testbit x (if zlt i n then i else Z.sub n (Zpos xH))\n   else false) (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "_goal : Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH))",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (if zlt i n then i else Z.sub n (Zpos xH)) n\n   then testbit x (if zlt i n then i else Z.sub n (Zpos xH))\n   else false) (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) (testbit x i)",
                "_goal : Logic.eq\n  (if zlt (Z.sub n (Zpos xH)) n\n   then testbit x (Z.sub n (Zpos xH))\n   else false) (testbit x (Z.sub n (Zpos xH)))",
                "l0 : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i n then testbit x i else false) (testbit x i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (testbit x i)",
                "_goal : Z.lt i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (testbit x i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub n (Zpos xH)) n\n   then testbit x (Z.sub n (Zpos xH))\n   else false) (testbit x (Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub n (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))",
                "_goal : Z.lt (Z.sub n (Zpos xH)) n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub n (Zpos xH)))\n  (testbit x (Z.sub n (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub n (Zpos xH)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH))",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 (Z.sub n (Zpos xH))",
                "l0 : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub n (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zero_ext_above .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n x)",
                "_goal : Z.ge n zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge n zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Z.lt Z0 n),\nLogic.eq (zero_ext n (sign_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n (sign_ext n x)) (zero_ext n x)",
                "H : Z.lt Z0 n",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply zero_sign_ext_narrow .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n (sign_ext n x)) (zero_ext n x)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.le n n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.le n n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x y : int) (_ : Z.lt Z0 n)\n  (_ : Logic.eq (zero_ext n x) (zero_ext n y)),\nLogic.eq (sign_ext n x) (sign_ext n y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n y)",
                "H0 : Logic.eq (zero_ext n x) (zero_ext n y)",
                "H : Z.lt Z0 n",
                "x : int",
                "y : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( sign_ext_zero_ext _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext n y)",
                "n : Z",
                "x : int",
                "H : Z.lt Z0 n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n y)"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( sign_ext_zero_ext _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n y)",
                "n : Z",
                "y : int",
                "H : Z.lt Z0 n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n (zero_ext n y))"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n (zero_ext n x)) (sign_ext n (zero_ext n y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true),\nLogic.eq (shru (shl x y) z)\n  (if ltu z y\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if ltu z y\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu y iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if ltu z y\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt (unsigned z) (unsigned y) then true else false\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))"
            ]
        },
        {
            "tactic_sig": "set ( Y := unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt (unsigned z) (unsigned y) then true else false\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt (unsigned z) Y then true else false\n   then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))",
                "H : Logic.and (Z.le Z0 Y) (Z.lt Y zwordsize)",
                "Y : Z"
            ]
        },
        {
            "tactic_sig": "set ( Z := unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt (unsigned z) Y then true else false\n   then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n   else zero_ext (Z.sub zwordsize (unsigned z)) (shru x (sub z y)))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt Z Y then true else false\n   then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n   else zero_ext (Z.sub zwordsize Z) (shru x (sub z y)))",
                "H0 : Logic.and (Z.le Z0 Z) (Z.lt Z zwordsize)",
                "Z : Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shl x y) z)\n  (if if zlt Z Y then true else false\n   then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n   else zero_ext (Z.sub zwordsize Z) (shru x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (shl x y) (Z.add i (unsigned z))\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned z)) zwordsize\n   then testbit (shl x y) (Z.add i (unsigned z))\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)",
                "Z : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit (shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)) i)",
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit (zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)",
                "l : Z.lt Z Y",
                "g : Z.ge Z Y"
            ]
        },
        {
            "tactic_sig": "assert ( A : unsigned ( sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "y : int",
                "z : int",
                "Y : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)",
                "A : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit (shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)) i)\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (zero_ext (Z.sub zwordsize Y) x) (sub y z)) i)\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)",
                "A : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit (shl x y) (Z.add i Z))",
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  false",
                "l0 : Z.lt (Z.add i Z) zwordsize",
                "g : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit (shl x y) (Z.add i Z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (unsigned y)))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (unsigned y)))",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ - _ ) ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))",
                "i : Z",
                "Y : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))",
                "g : Z.ge i (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then testbit x (Z.sub i (Z.sub Y Z))\n   else false) (testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then testbit x (Z.sub i (Z.sub Y Z))\n   else false) (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub Y Z)) (Z.sub (Z.add i Z) Y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub Y Z)) (Z.sub (Z.add i Z) Y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else\n    if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n    then testbit x (Z.sub i (Z.sub Y Z))\n    else false) false"
            ]
        },
        {
            "tactic_sig": "rewrite ! zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else\n    if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n    then testbit x (Z.sub i (Z.sub Y Z))\n    else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( A : unsigned ( sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "z : int",
                "y : int",
                "Z : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)",
                "A : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext , bits_shru , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (testbit (zero_ext (Z.sub zwordsize Z) (shru x (sub z y))) i)",
                "A : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (if zlt i (Z.sub zwordsize Z)\n   then\n    if zlt (Z.add i (Z.sub Z Y)) zwordsize\n    then testbit x (Z.add i (Z.sub Z Y))\n    else false\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl x y) (Z.add i Z)\n   else false)\n  (if zlt i (Z.sub zwordsize Z)\n   then\n    if zlt (Z.add i (Z.sub Z Y)) zwordsize\n    then testbit x (Z.add i (Z.sub Z Y))\n    else false\n   else false)",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl x y) (Z.add i Z))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "l : Z.lt (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl x y) (Z.add i Z))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (unsigned y)))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) (unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (unsigned y)))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "i : Z",
                "Z : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "l0 : Z.lt (Z.add i Z) Y",
                "g0 : Z.ge (Z.add i Z) Y"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (testbit x (Z.add i (Z.sub Z Y)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (testbit x (Z.add i (Z.sub Z Y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)),\nlet y := repr (Z.sub zwordsize n) in\nLogic.eq (zero_ext n x) (shru (shl x y) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x) (shru (shl x y) y)",
                "y : int",
                "H : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "assert ( A : unsigned _ = zwordsize - _ ) .",
            "tactic_args": [
                "y : int",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned y) (Z.sub zwordsize n)",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned y) (Z.sub zwordsize n)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( B : ltu _ iwordsize = true ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y iwordsize) true",
                "B : Logic.eq (ltu y iwordsize) true"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) (unsigned iwordsize) then true else false) true"
            ]
        },
        {
            "tactic_sig": "rewrite _ , unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) (unsigned iwordsize) then true else false) true",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (Z.sub zwordsize n) zwordsize then true else false)\n  true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (Z.sub zwordsize n) zwordsize then true else false)\n  true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub zwordsize n) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize n) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shru_shl by auto .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x) (shru (shl x y) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x)\n  (if ltu y y\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x)\n  (if ltu y y\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x)\n  (if if zlt (unsigned y) (unsigned y) then true else false\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x)\n  (if if zlt (unsigned y) (unsigned y) then true else false\n   then shl (zero_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x)\n  (zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "rewrite sub_idem , shru_zero .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x)\n  (zero_ext (Z.sub zwordsize (unsigned y)) (shru x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext n x) (zero_ext (Z.sub zwordsize (unsigned y)) x)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext n x) (zero_ext (Z.sub zwordsize (unsigned y)) x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (Z.sub zwordsize (unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq n (Z.sub zwordsize (unsigned y))",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (Z.sub zwordsize (Z.sub zwordsize n))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq n (Z.sub zwordsize (Z.sub zwordsize n))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y z : int) (_ : Logic.eq (ltu y iwordsize) true)\n  (_ : Logic.eq (ltu z iwordsize) true),\nLogic.eq (shr (shl x y) z)\n  (if ltu z y\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if ltu z y\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))",
                "H0 : Logic.eq (ltu z iwordsize) true",
                "H : Logic.eq (ltu y iwordsize) true",
                "x : int",
                "y : int",
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu y iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H0 : Logic.eq (ltu z iwordsize) true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (unsigned z)) (Z.lt (unsigned z) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if ltu z y\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt (unsigned z) (unsigned y) then true else false\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))"
            ]
        },
        {
            "tactic_sig": "set ( Y := unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt (unsigned z) (unsigned y) then true else false\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt (unsigned z) Y then true else false\n   then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))",
                "H : Logic.and (Z.le Z0 Y) (Z.lt Y zwordsize)",
                "Y : Z"
            ]
        },
        {
            "tactic_sig": "set ( Z := unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt (unsigned z) Y then true else false\n   then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n   else sign_ext (Z.sub zwordsize (unsigned z)) (shr x (sub z y)))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt Z Y then true else false\n   then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n   else sign_ext (Z.sub zwordsize Z) (shr x (sub z y)))",
                "H0 : Logic.and (Z.le Z0 Z) (Z.lt Z zwordsize)",
                "Z : Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shl x y) z)\n  (if if zlt Z Y then true else false\n   then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n   else sign_ext (Z.sub zwordsize Z) (shr x (sub z y)))"
            ],
            "tactic_res": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr (shl x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shl x y)\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shl x y)\n     (if zlt (Z.add i (unsigned z)) zwordsize\n      then Z.add i (unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shl x y)\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shl x y)\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) (unsigned y)\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) (unsigned y)\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) (unsigned y)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "Z : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)) i)",
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)",
                "l : Z.lt Z Y",
                "g : Z.ge Z Y"
            ]
        },
        {
            "tactic_sig": "assert ( A : unsigned ( sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "y : int",
                "z : int",
                "Y : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)",
                "A : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shl , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shl (sign_ext (Z.sub zwordsize Y) x) (sub y z)) i)",
                "A : Logic.eq (unsigned (sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ - _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "i : Z",
                "Y : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y)) false",
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "l0 : Z.lt i (Z.sub Y Z)",
                "g : Z.ge i (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y)) false"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (if zlt (Z.add i Z) zwordsize\n   then Z.add i Z\n   else Z.sub zwordsize (Zpos xH)) Y"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Z.lt\n  (if zlt (Z.add i Z) zwordsize\n   then Z.add i Z\n   else Z.sub zwordsize (Zpos xH)) Y",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add i Z) Y",
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) Y",
                "l1 : Z.lt (Z.add i Z) zwordsize",
                "g : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i Z) Y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) Y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n      then Z.sub i (Z.sub Y Z)\n      else Z.sub (Z.sub zwordsize Y) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n      then Z.sub i (Z.sub Y Z)\n      else Z.sub (Z.sub zwordsize Y) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "l0 : Z.lt (Z.add i Z) zwordsize",
                "g0 : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.sub i (Z.sub Y Z))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.sub i (Z.sub Y Z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( A : unsigned ( sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "z : int",
                "y : int",
                "Z : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)",
                "A : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Z) (shr x (sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shr x (sub z y))\n     (if zlt i (Z.sub zwordsize Z)\n      then i\n      else Z.sub (Z.sub zwordsize Z) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr by ( destruct ( zlt _ ( zwordsize - _ ) ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shr x (sub z y))\n     (if zlt i (Z.sub zwordsize Z)\n      then i\n      else Z.sub (Z.sub zwordsize Z) (Zpos xH)))",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n            (unsigned (sub z y))) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n         (unsigned (sub z y))\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n            (unsigned (sub z y))) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n         (unsigned (sub z y))\n      else Z.sub zwordsize (Zpos xH)))",
                "A : Logic.eq (unsigned (sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt\n      (Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)) zwordsize\n   then\n    Z.add\n      (if zlt i (Z.sub zwordsize Z)\n       then i\n       else Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt\n      (Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)) zwordsize\n   then\n    Z.add\n      (if zlt i (Z.sub zwordsize Z)\n       then i\n       else Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "i : Z",
                "Z : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then Z.add i (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "l : Z.lt i (Z.sub zwordsize Z)",
                "g0 : Z.ge i (Z.sub zwordsize Z)"
            ]
        },
        {
            "tactic_sig": "rewrite ! zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then Z.add i (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)),\nlet y := repr (Z.sub zwordsize n) in\nLogic.eq (sign_ext n x) (shr (shl x y) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) (shr (shl x y) y)",
                "y : int",
                "H : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "assert ( A : unsigned _ = zwordsize - _ ) .",
            "tactic_args": [
                "y : int",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned y) (Z.sub zwordsize n)",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned y) (Z.sub zwordsize n)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( B : ltu _ iwordsize = true ) .",
            "tactic_args": [
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y iwordsize) true",
                "B : Logic.eq (ltu y iwordsize) true"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) (unsigned iwordsize) then true else false) true"
            ]
        },
        {
            "tactic_sig": "rewrite _ , unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) (unsigned iwordsize) then true else false) true",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (Z.sub zwordsize n) zwordsize then true else false)\n  true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (Z.sub zwordsize n) zwordsize then true else false)\n  true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub zwordsize n) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize n) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shr_shl by auto .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) (shr (shl x y) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x)\n  (if ltu y y\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x)\n  (if ltu y y\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x)\n  (if if zlt (unsigned y) (unsigned y) then true else false\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x)\n  (if if zlt (unsigned y) (unsigned y) then true else false\n   then shl (sign_ext (Z.sub zwordsize (unsigned y)) x) (sub y y)\n   else sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x)\n  (sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ]
        },
        {
            "tactic_sig": "rewrite sub_idem , shr_zero .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x)\n  (sign_ext (Z.sub zwordsize (unsigned y)) (shr x (sub y y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext (Z.sub zwordsize (unsigned y)) x)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext n x) (sign_ext (Z.sub zwordsize (unsigned y)) x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (Z.sub zwordsize (unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq n (Z.sub zwordsize (unsigned y))",
                "A : Logic.eq (unsigned y) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (Z.sub zwordsize (Z.sub zwordsize n))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq n (Z.sub zwordsize (Z.sub zwordsize n))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)),\nLogic.and (Z.le Z0 (unsigned (zero_ext n x)))\n  (Z.lt (unsigned (zero_ext n x)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (zero_ext n x)))\n  (Z.lt (unsigned (zero_ext n x)) (two_p n))",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite zero_ext_mod .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (zero_ext n x)))\n  (Z.lt (unsigned (zero_ext n x)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p n)))\n  (Z.lt (Z.modulo (unsigned x) (two_p n)) (two_p n))",
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z_mod_lt .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.modulo (unsigned x) (two_p n)))\n  (Z.lt (Z.modulo (unsigned x) (two_p n)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p n) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p n) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)),\neqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x)",
                "H : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite zero_ext_mod .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (unsigned (zero_ext n x)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (Z.modulo (unsigned x) (two_p n)) (unsigned x)",
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_sym .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (Z.modulo (unsigned x) (two_p n)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (unsigned x) (Z.modulo (unsigned x) (two_p n))"
            ]
        },
        {
            "tactic_sig": "apply eqmod_mod .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (unsigned x) (Z.modulo (unsigned x) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p n) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p n) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)),\nLogic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH)))) (signed (sign_ext n x)))\n  (Z.lt (signed (sign_ext n x)) (two_p (Z.sub n (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH)))) (signed (sign_ext n x)))\n  (Z.lt (signed (sign_ext n x)) (two_p (Z.sub n (Zpos xH))))",
                "H : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "rewrite sign_ext_shr_shl .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH)))) (signed (sign_ext n x)))\n  (Z.lt (signed (sign_ext n x)) (two_p (Z.sub n (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed\n        (shr (shl x (repr (Z.sub zwordsize n)))\n           (repr (Z.sub zwordsize n)))))\n  (Z.lt\n     (signed\n        (shr (shl x (repr (Z.sub zwordsize n)))\n           (repr (Z.sub zwordsize n)))) (two_p (Z.sub n (Zpos xH))))",
                "_goal : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( X := shl _ ( repr ( zwordsize - _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed\n        (shr (shl x (repr (Z.sub zwordsize n)))\n           (repr (Z.sub zwordsize n)))))\n  (Z.lt\n     (signed\n        (shr (shl x (repr (Z.sub zwordsize n)))\n           (repr (Z.sub zwordsize n)))) (two_p (Z.sub n (Zpos xH))))",
                "x : int",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed (shr X (repr (Z.sub zwordsize n)))))\n  (Z.lt (signed (shr X (repr (Z.sub zwordsize n))))\n     (two_p (Z.sub n (Zpos xH))))",
                "X : int"
            ]
        },
        {
            "tactic_sig": "assert ( two_p ( _ - 1 ) > 0 ) by ( apply two_p_gt_ZERO ; omega ) .",
            "tactic_args": [
                "n : Z"
            ],
            "tactic_res": [
                "H0 : Z.gt (two_p (Z.sub n (Zpos xH))) Z0"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned ( repr ( zwordsize - _ ) ) = zwordsize - _ ) .",
            "tactic_args": [
                "n : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)",
                "H1 : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize n))\n  (Z.le (Z.sub zwordsize n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)",
                "_goal : Z.le (Z.sub zwordsize n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Z.le (Z.sub zwordsize n) max_unsigned"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nZ.le (Z.sub zwordsize n) max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nZ.le (Z.sub zwordsize n) max_unsigned"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed (shr X (repr (Z.sub zwordsize n)))))\n  (Z.lt (signed (shr X (repr (Z.sub zwordsize n))))\n     (two_p (Z.sub n (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed\n        (repr\n           (Z.div (signed X)\n              (two_p (unsigned (repr (Z.sub zwordsize n))))))))\n  (Z.lt\n     (signed\n        (repr\n           (Z.div (signed X)\n              (two_p (unsigned (repr (Z.sub zwordsize n)))))))\n     (two_p (Z.sub n (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (signed\n        (repr\n           (Z.div (signed X)\n              (two_p (unsigned (repr (Z.sub zwordsize n))))))))\n  (Z.lt\n     (signed\n        (repr\n           (Z.div (signed X)\n              (two_p (unsigned (repr (Z.sub zwordsize n)))))))\n     (two_p (Z.sub n (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n))))))\n  (Z.lt\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n)))))\n     (two_p (Z.sub n (Zpos xH))))",
                "_goal : Logic.and\n  (Z.le min_signed\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n))))))\n  (Z.le\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n)))))\n     max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n))))))\n  (Z.lt\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n)))))\n     (two_p (Z.sub n (Zpos xH))))",
                "H1 : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (Z.div (signed X) (two_p (Z.sub zwordsize n))))\n  (Z.lt (Z.div (signed X) (two_p (Z.sub zwordsize n)))\n     (two_p (Z.sub n (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "apply Zdiv_interval_1 .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.sub n (Zpos xH))))\n     (Z.div (signed X) (two_p (Z.sub zwordsize n))))\n  (Z.lt (Z.div (signed X) (two_p (Z.sub zwordsize n)))\n     (two_p (Z.sub n (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.opp (two_p (Z.sub n (Zpos xH)))) Z0",
                "_goal : Z.gt (two_p (Z.sub n (Zpos xH))) Z0",
                "_goal : Z.gt (two_p (Z.sub zwordsize n)) Z0",
                "_goal : Logic.and\n  (Z.le\n     (Z.mul (Z.opp (two_p (Z.sub n (Zpos xH))))\n        (two_p (Z.sub zwordsize n))) (signed X))\n  (Z.lt (signed X)\n     (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Z.opp (two_p (Z.sub n (Zpos xH)))) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.gt (two_p (Z.sub n (Zpos xH))) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p (Z.sub zwordsize n)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( - two_p ( _ - 1 ) * two_p ( zwordsize - _ ) ) with ( - ( two_p ( _ - 1 ) * two_p ( zwordsize - _ ) ) ) by ring .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le\n     (Z.mul (Z.opp (two_p (Z.sub n (Zpos xH))))\n        (two_p (Z.sub zwordsize n))) (signed X))\n  (Z.lt (signed X)\n     (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))",
                "n : Z",
                "n : Z",
                "n : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le\n     (Z.opp\n        (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))\n     (signed X))\n  (Z.lt (signed X)\n     (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_p_is_exp .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le\n     (Z.opp\n        (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))\n     (signed X))\n  (Z.lt (signed X)\n     (Z.mul (two_p (Z.sub n (Zpos xH))) (two_p (Z.sub zwordsize n))))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.add (Z.sub n (Zpos xH)) (Z.sub zwordsize n))))\n     (signed X))\n  (Z.lt (signed X)\n     (two_p (Z.add (Z.sub n (Zpos xH)) (Z.sub zwordsize n))))",
                "_goal : Z.le Z0 (Z.sub n (Zpos xH))",
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "replace ( _ - 1 + ( zwordsize - _ ) ) with ( zwordsize - 1 ) by omega .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le (Z.opp (two_p (Z.add (Z.sub n (Zpos xH)) (Z.sub zwordsize n))))\n     (signed X))\n  (Z.lt (signed X)\n     (two_p (Z.add (Z.sub n (Zpos xH)) (Z.sub zwordsize n))))",
                "n : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp (two_p (Z.sub zwordsize (Zpos xH)))) (signed X))\n  (Z.lt (signed X) (two_p (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "rewrite <- half_modulus_power .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp (two_p (Z.sub zwordsize (Zpos xH)))) (signed X))\n  (Z.lt (signed X) (two_p (Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)"
            ]
        },
        {
            "tactic_sig": "generalize ( signed_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)",
                "X : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed X))\n        (Z.le (signed X) max_signed),\nLogic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)"
            ]
        },
        {
            "tactic_sig": "unfold min_signed , max_signed .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le min_signed (signed X))\n        (Z.le (signed X) max_signed),\nLogic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le (Z.opp half_modulus) (signed X))\n        (Z.le (signed X) (Z.sub half_modulus (Zpos xH))),\nLogic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le (Z.opp half_modulus) (signed X))\n        (Z.le (signed X) (Z.sub half_modulus (Zpos xH))),\nLogic.and (Z.le (Z.opp half_modulus) (signed X))\n  (Z.lt (signed X) half_modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub n (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Zdiv_interval_2 .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n))))))\n  (Z.le\n     (Z.div (signed X) (two_p (unsigned (repr (Z.sub zwordsize n)))))\n     max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le min_signed (signed X)) (Z.le (signed X) max_signed)",
                "_goal : Z.le min_signed Z0",
                "_goal : Z.ge max_signed Z0",
                "_goal : Z.gt (two_p (unsigned (repr (Z.sub zwordsize n)))) Z0"
            ]
        },
        {
            "tactic_sig": "apply signed_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (signed X)) (Z.le (signed X) max_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize min_signed_neg .",
            "tactic_args": [
                "_goal : Z.le min_signed Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt min_signed Z0, Z.le min_signed Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.lt min_signed Z0, Z.le min_signed Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize max_signed_pos .",
            "tactic_args": [
                "_goal : Z.ge max_signed Z0"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.ge max_signed Z0, Z.ge max_signed Z0"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.ge max_signed Z0, Z.ge max_signed Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.gt (two_p (unsigned (repr (Z.sub zwordsize n)))) Z0",
                "H1 : Logic.eq (unsigned (repr (Z.sub zwordsize n))) (Z.sub zwordsize n)"
            ],
            "tactic_res": [
                "_goal : Z.gt (two_p (Z.sub zwordsize n)) Z0"
            ]
        },
        {
            "tactic_sig": "apply two_p_gt_ZERO .",
            "tactic_args": [
                "_goal : Z.gt (two_p (Z.sub zwordsize n)) Z0"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)),\neqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x)",
                "H : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "set ( N := Z.to_nat _ ) .",
            "tactic_args": [
                "n : Z"
            ],
            "tactic_res": [
                "N : nat"
            ]
        },
        {
            "tactic_sig": "assert ( Z.of_nat _ = _ ) by ( apply Z2Nat.id ; omega ) .",
            "tactic_args": [
                "N : nat",
                "n : Z"
            ],
            "tactic_res": [
                "H0 : Logic.eq (Z.of_nat N) n"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x)",
                "H0 : Logic.eq (Z.of_nat N) n"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p (Z.of_nat N)) (unsigned (sign_ext (Z.of_nat N) x))\n  (unsigned x)"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_power_nat_two_p .",
            "tactic_args": [
                "_goal : eqmod (two_p (Z.of_nat N)) (unsigned (sign_ext (Z.of_nat N) x))\n  (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_power_nat N) (unsigned (sign_ext (Z.of_nat N) x))\n  (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_same_bits .",
            "tactic_args": [
                "_goal : eqmod (two_power_nat N) (unsigned (sign_ext (Z.of_nat N) x))\n  (unsigned x)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat N))),\nLogic.eq (Z.testbit (unsigned (sign_ext (Z.of_nat N) x)) i)\n  (Z.testbit (unsigned x) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat N))),\nLogic.eq (Z.testbit (unsigned (sign_ext (Z.of_nat N) x)) i)\n  (Z.testbit (unsigned x) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (sign_ext (Z.of_nat N) x)) i)\n  (Z.testbit (unsigned x) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat N))",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ in _ .",
            "tactic_args": [
                "H0 : Logic.eq (Z.of_nat N) n",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat N))"
            ],
            "tactic_res": [
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i n)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (sign_ext (Z.of_nat N) x)) i)\n  (Z.testbit (unsigned x) i)",
                "H0 : Logic.eq (Z.of_nat N) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (sign_ext n x)) i)\n  (Z.testbit (unsigned x) i)"
            ]
        },
        {
            "tactic_sig": "fold ( testbit ( sign_ext _ _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (sign_ext n x)) i)\n  (Z.testbit (unsigned x) i)",
                "n : Z",
                "x : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) i) (Z.testbit (unsigned x) i)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) i) (Z.testbit (unsigned x) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.testbit (unsigned x) i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.testbit (unsigned x) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) (Z.testbit (unsigned x) i)",
                "_goal : Z.lt i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) (Z.testbit (unsigned x) i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (x : int) (_ : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)),\neqmod (two_p n) (signed (sign_ext n x)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (signed (sign_ext n x)) (unsigned x)",
                "H : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply eqmod_trans with ( unsigned ( sign_ext _ _ ) ) .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (signed (sign_ext n x)) (unsigned x)",
                "n : Z",
                "x : int"
            ],
            "tactic_res": [
                "_goal : eqmod (two_p n) (signed (sign_ext n x)) (unsigned (sign_ext n x))",
                "_goal : eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqmod_divides with modulus .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (signed (sign_ext n x)) (unsigned (sign_ext n x))"
            ],
            "tactic_res": [
                "_goal : eqmod modulus (signed (sign_ext n x)) (unsigned (sign_ext n x))",
                "_goal : Z.divide (two_p n) modulus"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqmod modulus (signed (sign_ext n x)) (unsigned (sign_ext n x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exists ( two_p ( zwordsize - _ ) ) .",
            "tactic_args": [
                "_goal : Z.divide (two_p n) modulus",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq modulus (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ]
        },
        {
            "tactic_sig": "unfold modulus .",
            "tactic_args": [
                "_goal : Logic.eq modulus (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_power_nat wordsize)\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ]
        },
        {
            "tactic_sig": "rewrite two_power_nat_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (two_power_nat wordsize)\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ]
        },
        {
            "tactic_sig": "fold zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq (two_p (Z.of_nat wordsize))\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p zwordsize)\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ]
        },
        {
            "tactic_sig": "rewrite <- two_p_is_exp .",
            "tactic_args": [
                "_goal : Logic.eq (two_p zwordsize)\n  (Z.mul (two_p (Z.sub zwordsize n)) (two_p n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_p zwordsize) (two_p (Z.add (Z.sub zwordsize n) n))",
                "_goal : Z.le Z0 (Z.sub zwordsize n)",
                "_goal : Z.le Z0 n"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (two_p zwordsize) (two_p (Z.add (Z.sub zwordsize n) n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq zwordsize (Z.add (Z.sub zwordsize n) n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq zwordsize (Z.add (Z.sub zwordsize n) n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.sub zwordsize n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqmod_sign_ext' .",
            "tactic_args": [
                "_goal : eqmod (two_p n) (unsigned (sign_ext n x)) (unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.lt Z0 n) (Z.lt n zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m x : int) (_ : Z.le Z0 n),\nLogic.eq (shl (zero_ext n x) m)\n  (zero_ext (Z.add n (unsigned m)) (shl x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (zero_ext n x) m)\n  (zero_ext (Z.add n (unsigned m)) (shl x m))",
                "H : Z.le Z0 n",
                "m : int",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl (zero_ext n x) m)\n  (zero_ext (Z.add n (unsigned m)) (shl x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (unsigned m)) (shl x m)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext , ! bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (zero_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (Z.add n (unsigned m))\n   then\n    if zlt i (unsigned m)\n    then false\n    else testbit x (Z.sub i (unsigned m))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (zero_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (Z.add n (unsigned m))\n   then\n    if zlt i (unsigned m)\n    then false\n    else testbit x (Z.sub i (unsigned m))\n   else false)",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false (if zlt i (Z.add n (unsigned m)) then false else false)",
                "_goal : Logic.eq (testbit (zero_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (Z.add n (unsigned m))\n   then testbit x (Z.sub i (unsigned m))\n   else false)",
                "l : Z.lt i (unsigned m)",
                "g : Z.ge i (unsigned m)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq false (if zlt i (Z.add n (unsigned m)) then false else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (Z.add n (unsigned m))\n   then testbit x (Z.sub i (unsigned m))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then testbit x (Z.sub i (unsigned m))\n   else false)\n  (if zlt i (Z.add n (unsigned m))\n   then testbit x (Z.sub i (unsigned m))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - unsigned _ ) _ ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then testbit x (Z.sub i (unsigned m))\n   else false)\n  (if zlt i (Z.add n (unsigned m))\n   then testbit x (Z.sub i (unsigned m))\n   else false)",
                "i : Z",
                "m : int",
                "n : Z"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m x : int) (_ : Z.lt Z0 n),\nLogic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))",
                "H : Z.lt Z0 n",
                "m : int",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))",
                "m : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nLogic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nLogic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))",
                "H0 : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext n x) m)\n  (sign_ext (Z.add n (unsigned m)) (shl x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (unsigned m)) (shl x m)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , ! bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (unsigned m)) (shl x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m)\n     (if zlt i (Z.add n (unsigned m))\n      then i\n      else Z.sub (Z.add n (unsigned m)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ + unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m)\n     (if zlt i (Z.add n (unsigned m))\n      then i\n      else Z.sub (Z.add n (unsigned m)) (Zpos xH)))",
                "i : Z",
                "n : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) i)",
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) (Z.sub (Z.add n (unsigned m)) (Zpos xH)))",
                "l : Z.lt i (Z.add n (unsigned m))",
                "g : Z.ge i (Z.add n (unsigned m))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (unsigned m)\n   then false\n   else testbit x (Z.sub i (unsigned m)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (if zlt i (unsigned m)\n   then false\n   else testbit x (Z.sub i (unsigned m)))",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit x (Z.sub i (unsigned m)))",
                "l0 : Z.lt i (unsigned m)",
                "g : Z.ge i (unsigned m)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit x (Z.sub i (unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned m)) n\n      then Z.sub i (unsigned m)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub i (unsigned m)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned m)) n\n      then Z.sub i (unsigned m)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub i (unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then Z.sub i (unsigned m)\n   else Z.sub n (Zpos xH)) (Z.sub i (unsigned m))"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then Z.sub i (unsigned m)\n   else Z.sub n (Zpos xH)) (Z.sub i (unsigned m))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub i (unsigned m)) n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub i (unsigned m)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) (Z.sub (Z.add n (unsigned m)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) (Z.sub (Z.add n (unsigned m)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit (shl x m) (Z.sub (Z.add n (unsigned m)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (if zlt (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)\n   then false\n   else\n    testbit x\n      (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (if zlt (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)\n   then false\n   else\n    testbit x\n      (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (unsigned m)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned m)) n\n      then Z.sub i (unsigned m)\n      else Z.sub n (Zpos xH)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned m)) n\n      then Z.sub i (unsigned m)\n      else Z.sub n (Zpos xH)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then Z.sub i (unsigned m)\n   else Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned m)) n\n   then Z.sub i (unsigned m)\n   else Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (unsigned m)) (Zpos xH)) (unsigned m))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m x : int) (_ : Z.le Z0 n),\nLogic.eq (shru (zero_ext (Z.add n (unsigned m)) x) m)\n  (zero_ext n (shru x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (zero_ext (Z.add n (unsigned m)) x) m)\n  (zero_ext n (shru x m))",
                "H : Z.le Z0 n",
                "m : int",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (shru (zero_ext (Z.add n (unsigned m)) x) m)\n  (zero_ext n (shru x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false)\n  (if zlt i n\n   then\n    if zlt (Z.add i (unsigned m)) zwordsize\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false)",
                "_goal : Z.le Z0 (Z.add i (unsigned m))",
                "_goal : Z.le Z0 i",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false)\n  (if zlt i n\n   then\n    if zlt (Z.add i (unsigned m)) zwordsize\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false)",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then testbit x (Z.add i (unsigned m))\n   else false)\n  (if zlt i n then testbit x (Z.add i (unsigned m)) else false)",
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "l : Z.lt (Z.add i (unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then testbit x (Z.add i (unsigned m))\n   else false)\n  (if zlt i n then testbit x (Z.add i (unsigned m)) else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq false false",
                "l : Z.lt i n",
                "g0 : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.add i (unsigned m))",
                "m : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nZ.le Z0 (Z.add i (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nZ.le Z0 (Z.add i (unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m x : int) (_ : Z.le n (unsigned m)),\nLogic.eq (shru (zero_ext n x) m) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (zero_ext n x) m) zero",
                "H : Z.le n (unsigned m)",
                "m : int",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (shru (zero_ext n x) m) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (unsigned m)) n\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false) false",
                "_goal : Z.le Z0 (Z.add i (unsigned m))",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (unsigned m)) n\n    then testbit x (Z.add i (unsigned m))\n    else false\n   else false) false",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) n\n   then testbit x (Z.add i (unsigned m))\n   else false) false",
                "_goal : Logic.eq false false",
                "l : Z.lt (Z.add i (unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) n\n   then testbit x (Z.add i (unsigned m))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add i (unsigned m)) n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (unsigned m)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.add i (unsigned m))",
                "m : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nZ.le Z0 (Z.add i (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nZ.le Z0 (Z.add i (unsigned m))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m x : int) (_ : Z.lt Z0 n)\n  (_ : Z.lt (Z.add n (unsigned m)) zwordsize),\nLogic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))",
                "H0 : Z.lt (Z.add n (unsigned m)) zwordsize",
                "H : Z.lt Z0 n",
                "m : int",
                "x : int",
                "n : Z"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))",
                "m : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nLogic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus),\nLogic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))",
                "H1 : Logic.and (Z.le Z0 (unsigned m)) (Z.lt (unsigned m) modulus)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr (sign_ext (Z.add n (unsigned m)) x) m)\n  (sign_ext n (shr x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (sign_ext (Z.add n (unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr (sign_ext (Z.add n (unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr (sign_ext (Z.add n (unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr x m)) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , bits_shr by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr (sign_ext (Z.add n (unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (sign_ext (Z.add n (unsigned m)) x)\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (shr x m) (if zlt i n then i else Z.sub n (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , bits_shr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (sign_ext (Z.add n (unsigned m)) x)\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (shr x m) (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (if zlt (Z.add i (unsigned m)) zwordsize\n          then Z.add i (unsigned m)\n          else Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n      then\n       if zlt (Z.add i (unsigned m)) zwordsize\n       then Z.add i (unsigned m)\n       else Z.sub zwordsize (Zpos xH)\n      else Z.sub (Z.add n (unsigned m)) (Zpos xH)))\n  (testbit x\n     (if\n       zlt\n         (Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m))\n         zwordsize\n      then\n       Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (if zlt (Z.add i (unsigned m)) zwordsize\n          then Z.add i (unsigned m)\n          else Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n      then\n       if zlt (Z.add i (unsigned m)) zwordsize\n       then Z.add i (unsigned m)\n       else Z.sub zwordsize (Zpos xH)\n      else Z.sub (Z.add n (unsigned m)) (Zpos xH)))\n  (testbit x\n     (if\n       zlt\n         (Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m))\n         zwordsize\n      then\n       Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i (unsigned m)) zwordsize\n       then Z.add i (unsigned m)\n       else Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then\n    if zlt (Z.add i (unsigned m)) zwordsize\n    then Z.add i (unsigned m)\n    else Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if\n    zlt (Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m))\n      zwordsize\n   then Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) , ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i (unsigned m)) zwordsize\n       then Z.add i (unsigned m)\n       else Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then\n    if zlt (Z.add i (unsigned m)) zwordsize\n    then Z.add i (unsigned m)\n    else Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if\n    zlt (Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m))\n      zwordsize\n   then Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "i : Z",
                "n : Z",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then Z.add i (unsigned m)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH)) (Z.add i (unsigned m))",
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then Z.add i (unsigned m)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "l0 : Z.lt (Z.add i (unsigned m)) zwordsize",
                "l : Z.lt i n",
                "g : Z.ge (Z.add i (unsigned m)) zwordsize",
                "l : Z.lt (Z.add i (unsigned m)) zwordsize",
                "g : Z.ge i n",
                "g0 : Z.ge (Z.add i (unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then Z.add i (unsigned m)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH)) (Z.add i (unsigned m))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add i (unsigned m)) (Z.add n (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i (unsigned m)) (Z.add n (unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned m)) (Z.add n (unsigned m))\n   then Z.add i (unsigned m)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "i : Z",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (unsigned m)) zwordsize\n      then Z.add i (unsigned m)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)",
                "i : Z",
                "m : int"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned m)))\n  (Z.lt (Z.add i (unsigned m)) zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)",
                "l : Z.lt (Z.add i (unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (unsigned m)))\n  (Z.lt (Z.add i (unsigned m)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shru x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shru x n))",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int",
                "s : Z"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z.min_case_strong .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shru x n))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (unsigned n)),\nLogic.eq (zero_ext s (shru x n)) (zero_ext s (shru x n))",
                "_goal : forall _ : Z.le (Z.sub zwordsize (unsigned n)) s,\nLogic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.sub zwordsize (unsigned n)) (shru x n))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (unsigned n)),\nLogic.eq (zero_ext s (shru x n)) (zero_ext s (shru x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru x n)) (zero_ext s (shru x n))",
                "H0 : Z.le s (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru x n)) (zero_ext s (shru x n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le (Z.sub zwordsize (unsigned n)) s,\nLogic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.sub zwordsize (unsigned n)) (shru x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.sub zwordsize (unsigned n)) (shru x n))",
                "H0 : Z.le (Z.sub zwordsize (unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru x n))\n  (zero_ext (Z.sub zwordsize (unsigned n)) (shru x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)\n  (if zlt i (Z.sub zwordsize (unsigned n))\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "try omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "try omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)\n  (if zlt i (Z.sub zwordsize (unsigned n))\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)",
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false) false",
                "l : Z.lt i (Z.sub zwordsize (unsigned n))",
                "g : Z.ge i (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false)\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (unsigned n)) zwordsize\n    then testbit x (Z.add i (unsigned n))\n    else false\n   else false) false",
                "i : Z",
                "s : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false) false",
                "_goal : Logic.eq false false",
                "l : Z.lt i s",
                "g0 : Z.ge i s"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned n)) zwordsize\n   then testbit x (Z.add i (unsigned n))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shr x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shr x n))",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int",
                "s : Z"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.min_comm .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) (shr x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.min (Z.sub zwordsize (unsigned n)) s) (shr x n))"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.min_spec ( zwordsize - unsigned _ ) _ ) as [ [ A B ] | [ A B ] ] .",
            "tactic_args": [
                "n : int",
                "s : Z"
            ],
            "tactic_res": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))",
                "A : Z.lt (Z.sub zwordsize (unsigned n)) s",
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s) s",
                "A : Z.le s (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.min (Z.sub zwordsize (unsigned n)) s) (shr x n))",
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr x n)) (sign_ext s (shr x n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr x n)) (sign_ext s (shr x n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr x n))\n  (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext s (shr x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext s (shr x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext s (shr x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_sign_ext by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext s (shr x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) (shr x n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n)\n     (if zlt i (Z.sub zwordsize (unsigned n))\n      then i\n      else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n)\n     (if zlt i (Z.sub zwordsize (unsigned n))\n      then i\n      else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n) i)",
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))",
                "l : Z.lt i (Z.sub zwordsize (unsigned n))",
                "g : Z.ge i (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x n) i) (testbit (shr x n) i)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) i) (testbit (shr x n) i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( C : testbit ( shr _ _ ) ( zwordsize - unsigned _ - 1 ) = testbit _ ( zwordsize - 1 ) ) .",
            "tactic_args": [
                "x : int",
                "n : int",
                "n : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "C : Logic.eq\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n            (unsigned n)) zwordsize\n      then\n       Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n         (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n            (unsigned n)) zwordsize\n      then\n       Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n         (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n        (unsigned n))) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))\n        (unsigned n))) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)) (unsigned n))\n  (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)) (unsigned n))\n  (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))",
                "C : Logic.eq\n  (testbit (shr x n) (Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "i : Z",
                "s : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr x n) i) (testbit x (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.eq (testbit (shr x n) (Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt i s",
                "g0 : Z.ge i s"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) i) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr x n) (Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add (Z.sub s (Zpos xH)) (unsigned n)) zwordsize\n      then Z.add (Z.sub s (Zpos xH)) (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (unsigned n)) zwordsize\n      then Z.add i (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add (Z.sub s (Zpos xH)) (unsigned n)) zwordsize\n      then Z.add (Z.sub s (Zpos xH)) (unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int",
                "s : Z"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z.min_case_strong .",
            "tactic_args": [
                "_goal : Logic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (unsigned n)),\nLogic.eq (shl (zero_ext s x) n) (shl (zero_ext s x) n)",
                "_goal : forall _ : Z.le (Z.sub zwordsize (unsigned n)) s,\nLogic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (unsigned n)),\nLogic.eq (shl (zero_ext s x) n) (shl (zero_ext s x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (zero_ext s x) n) (shl (zero_ext s x) n)",
                "H0 : Z.le s (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shl (zero_ext s x) n) (shl (zero_ext s x) n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le (Z.sub zwordsize (unsigned n)) s,\nLogic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n)",
                "H0 : Z.le (Z.sub zwordsize (unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl (zero_ext s x) n)\n  (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (zero_ext s x) n) i)\n  (testbit (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (zero_ext s x) n) i)\n  (testbit (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (zero_ext s x) n) i)\n  (testbit (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_shl by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (zero_ext s x) n) i)\n  (testbit (shl (zero_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit (zero_ext s x) (Z.sub i (unsigned n)))\n  (if zlt i (unsigned n)\n   then false\n   else\n    testbit (zero_ext (Z.sub zwordsize (unsigned n)) x)\n      (Z.sub i (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit (zero_ext s x) (Z.sub i (unsigned n)))\n  (if zlt i (unsigned n)\n   then false\n   else\n    testbit (zero_ext (Z.sub zwordsize (unsigned n)) x)\n      (Z.sub i (unsigned n)))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (zero_ext s x) (Z.sub i (unsigned n)))\n  (testbit (zero_ext (Z.sub zwordsize (unsigned n)) x)\n     (Z.sub i (unsigned n)))",
                "l : Z.lt i (unsigned n)",
                "g : Z.ge i (unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext s x) (Z.sub i (unsigned n)))\n  (testbit (zero_ext (Z.sub zwordsize (unsigned n)) x)\n     (Z.sub i (unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned n)) s\n   then testbit x (Z.sub i (unsigned n))\n   else false)\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - unsigned _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned n)) s\n   then testbit x (Z.sub i (unsigned n))\n   else false)\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)",
                "i : Z",
                "n : int",
                "s : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)",
                "_goal : Logic.eq false\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)",
                "l : Z.lt (Z.sub i (unsigned n)) s",
                "g0 : Z.ge (Z.sub i (unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (testbit x (Z.sub i (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (unsigned n)))\n  (testbit x (Z.sub i (unsigned n)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then testbit x (Z.sub i (unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x n : int) (_ : Logic.eq (ltu n iwordsize) true),\nLogic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)",
                "H : Logic.eq (ltu n iwordsize) true",
                "x : int",
                "n : int",
                "s : Z"
            ]
        },
        {
            "tactic_sig": "apply ltu_iwordsize_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu n iwordsize) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (unsigned n)) (Z.lt (unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.min_comm .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.min s (Z.sub zwordsize (unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.min (Z.sub zwordsize (unsigned n)) s) x) n)"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.min_spec ( zwordsize - unsigned _ ) _ ) as [ [ A B ] | [ A B ] ] .",
            "tactic_args": [
                "n : int",
                "s : Z"
            ],
            "tactic_res": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))",
                "A : Z.lt (Z.sub zwordsize (unsigned n)) s",
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s) s",
                "A : Z.le s (Z.sub zwordsize (unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.min (Z.sub zwordsize (unsigned n)) s) x) n)",
                "B : Logic.eq (Z.min (Z.sub zwordsize (unsigned n)) s)\n  (Z.sub zwordsize (unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (sign_ext s x) n) (shl (sign_ext s x) n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext s x) n) (shl (sign_ext s x) n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl (sign_ext s x) n)\n  (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (sign_ext s x) n) i)\n  (testbit (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl (sign_ext s x) n) i)\n  (testbit (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl (sign_ext s x) n) i)\n  (testbit (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_shl by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl (sign_ext s x) n) i)\n  (testbit (shl (sign_ext (Z.sub zwordsize (unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit (sign_ext s x) (Z.sub i (unsigned n)))\n  (if zlt i (unsigned n)\n   then false\n   else\n    testbit (sign_ext (Z.sub zwordsize (unsigned n)) x)\n      (Z.sub i (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (unsigned n)\n   then false\n   else testbit (sign_ext s x) (Z.sub i (unsigned n)))\n  (if zlt i (unsigned n)\n   then false\n   else\n    testbit (sign_ext (Z.sub zwordsize (unsigned n)) x)\n      (Z.sub i (unsigned n)))",
                "i : Z",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (sign_ext s x) (Z.sub i (unsigned n)))\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) x)\n     (Z.sub i (unsigned n)))",
                "l : Z.lt i (unsigned n)",
                "g : Z.ge i (unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext s x) (Z.sub i (unsigned n)))\n  (testbit (sign_ext (Z.sub zwordsize (unsigned n)) x)\n     (Z.sub i (unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned n)) s\n      then Z.sub i (unsigned n)\n      else Z.sub s (Zpos xH)))\n  (testbit x\n     (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n      then Z.sub i (unsigned n)\n      else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (unsigned n)) s\n      then Z.sub i (unsigned n)\n      else Z.sub s (Zpos xH)))\n  (testbit x\n     (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n      then Z.sub i (unsigned n)\n      else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned n)) s\n   then Z.sub i (unsigned n)\n   else Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - unsigned _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (unsigned n)) s\n   then Z.sub i (unsigned n)\n   else Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))",
                "i : Z",
                "n : int",
                "s : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (unsigned n))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))",
                "_goal : Logic.eq (Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))",
                "l : Z.lt (Z.sub i (unsigned n)) s",
                "g0 : Z.ge (Z.sub i (unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (unsigned n))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (unsigned n)) (Z.sub i (unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (unsigned n)) (Z.sub i (unsigned n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omegaContradiction .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (unsigned n)) (Z.sub zwordsize (unsigned n))\n   then Z.sub i (unsigned n)\n   else Z.sub (Z.sub zwordsize (unsigned n)) (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "assert ( A : forall p , 0 <= p < zwordsize -> ltu ( repr p ) iwordsize = true ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall (p : Z) (_ : Logic.and (Z.le Z0 p) (Z.lt p zwordsize)),\nLogic.eq (ltu (repr p) iwordsize) true",
                "A : forall (p : Z) (_ : Logic.and (Z.le Z0 p) (Z.lt p zwordsize)),\nLogic.eq (ltu (repr p) iwordsize) true"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (p : Z) (_ : Logic.and (Z.le Z0 p) (Z.lt p zwordsize)),\nLogic.eq (ltu (repr p) iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu (repr p) iwordsize) true",
                "H : Logic.and (Z.le Z0 p) (Z.lt p zwordsize)",
                "p : Z"
            ]
        },
        {
            "tactic_sig": "unfold ltu , iwordsize .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (repr p) iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr p)) (unsigned (repr zwordsize))\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned (repr p)) (unsigned (repr zwordsize))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned (repr p)) (unsigned (repr zwordsize))"
            ]
        },
        {
            "tactic_sig": "repeat rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Z.lt (unsigned (repr p)) (unsigned (repr zwordsize))"
            ],
            "tactic_res": [
                "_goal : Z.lt p zwordsize",
                "_goal : Logic.and (Z.le Z0 zwordsize) (Z.le zwordsize max_unsigned)",
                "_goal : Logic.and (Z.le Z0 p) (Z.le p max_unsigned)"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.lt p zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 zwordsize) (Z.le zwordsize max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 zwordsize) (Z.le zwordsize max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 zwordsize) (Z.le zwordsize max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 p) (Z.le p max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 p) (Z.le p max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le zwordsize max_unsigned,\nLogic.and (Z.le Z0 p) (Z.le p max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold one_bits .",
            "tactic_args": [
                "_goal : forall (x i : int) (_ : In i (one_bits x)),\nLogic.eq (ltu i iwordsize) true"
            ],
            "tactic_res": [
                "_goal : forall (x i : int)\n  (_ : In i (map repr (Z_one_bits wordsize (unsigned x) Z0))),\nLogic.eq (ltu i iwordsize) true"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x i : int)\n  (_ : In i (map repr (Z_one_bits wordsize (unsigned x) Z0))),\nLogic.eq (ltu i iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu i iwordsize) true",
                "H : In i (map repr (Z_one_bits wordsize (unsigned x) Z0))",
                "x : int",
                "i : int"
            ]
        },
        {
            "tactic_sig": "destruct ( list_in_map_inv _ _ _ _ ) as [ i0 [ EQ IN ] ] .",
            "tactic_args": [
                "H : In i (map repr (Z_one_bits wordsize (unsigned x) Z0))"
            ],
            "tactic_res": [
                "IN : In i0 (Z_one_bits wordsize (unsigned x) Z0)",
                "EQ : Logic.eq i (repr i0)",
                "i0 : Z"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.eq (ltu i iwordsize) true",
                "i : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu (repr i0) iwordsize) true",
                "H : In (repr i0) (map repr (Z_one_bits wordsize (unsigned x) Z0))"
            ]
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (repr i0) iwordsize) true",
                "A : forall (p : Z) (_ : Logic.and (Z.le Z0 p) (Z.lt p zwordsize)),\nLogic.eq (ltu (repr p) iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i0) (Z.lt i0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z_one_bits_range with ( unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i0) (Z.lt i0 zwordsize)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : In i0 (Z_one_bits wordsize (unsigned x) Z0)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : In i0 (Z_one_bits wordsize (unsigned x) Z0)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq x (int_of_one_bits (one_bits x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (int_of_one_bits (one_bits x))",
                "x : int"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( powerserie ( Z_one_bits wordsize ( unsigned _ ) 0 ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq x (int_of_one_bits (one_bits x))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))",
                "_goal : Logic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (one_bits x))"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq x (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (repr (unsigned x))",
                "_goal : Logic.eq (repr (unsigned x))\n  (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.eq x (repr (unsigned x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x))\n  (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned x)\n  (powerserie (Z_one_bits wordsize (unsigned x) Z0))"
            ]
        },
        {
            "tactic_sig": "apply Z_one_bits_powerserie .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned x)\n  (powerserie (Z_one_bits wordsize (unsigned x) Z0))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold one_bits .",
            "tactic_args": [
                "_goal : Logic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (one_bits x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (map repr (Z_one_bits wordsize (unsigned x) Z0)))"
            ]
        },
        {
            "tactic_sig": "generalize ( Z_one_bits_range wordsize ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (map repr (Z_one_bits wordsize (unsigned x) Z0)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (Z_one_bits wordsize (unsigned x) Z0)),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (map repr (Z_one_bits wordsize (unsigned x) Z0)))"
            ]
        },
        {
            "tactic_sig": "generalize ( Z_one_bits wordsize ( unsigned _ ) 0 ) .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (Z_one_bits wordsize (unsigned x) Z0)),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))\n  (int_of_one_bits (map repr (Z_one_bits wordsize (unsigned x) Z0)))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))),\nLogic.eq (repr (powerserie l)) (int_of_one_bits (map repr l))"
            ]
        },
        {
            "tactic_sig": "induction l .",
            "tactic_args": [
                "_goal : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))),\nLogic.eq (repr (powerserie l)) (int_of_one_bits (map repr l))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i nil),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie nil)) (int_of_one_bits (map repr nil))",
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (cons a l)),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie (cons a l)))\n  (int_of_one_bits (map repr (cons a l)))",
                "IHl : forall\n  _ : forall (i : Z) (_ : In i l),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie l)) (int_of_one_bits (map repr l))",
                "l : list Z",
                "a : Z"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i nil),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie nil)) (int_of_one_bits (map repr nil))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (powerserie nil)) (int_of_one_bits (map repr nil))",
                "H : forall (i : Z) (_ : In i nil),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq (repr (powerserie nil)) (int_of_one_bits (map repr nil))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (cons a l)),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie (cons a l)))\n  (int_of_one_bits (map repr (cons a l)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (powerserie (cons a l)))\n  (int_of_one_bits (map repr (cons a l)))",
                "H : forall (i : Z) (_ : In i (cons a l)),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (repr (powerserie (cons a l)))\n  (int_of_one_bits (map repr (cons a l)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (add (shl one (repr a)) (int_of_one_bits (map repr l)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (add (shl one (repr a)) (int_of_one_bits (map repr l)))",
                "IHl : forall\n  _ : forall (i : Z) (_ : In i l),\n      Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize)),\nLogic.eq (repr (powerserie l)) (int_of_one_bits (map repr l))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (add (shl one (repr a)) (repr (powerserie l)))",
                "_goal : forall (i : Z) (_ : In i l),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (add (shl one (repr a)) (repr (powerserie l)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (repr\n     (Z.add (unsigned (shl one (repr a)))\n        (unsigned (repr (powerserie l)))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (two_p a) (powerserie l)))\n  (repr\n     (Z.add (unsigned (shl one (repr a)))\n        (unsigned (repr (powerserie l)))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (two_p a) (powerserie l))\n  (Z.add (unsigned (shl one (repr a))) (unsigned (repr (powerserie l))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (two_p a) (powerserie l))\n  (Z.add (unsigned (shl one (repr a))) (unsigned (repr (powerserie l))))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (unsigned (shl one (repr a)))",
                "_goal : eqm (powerserie l) (unsigned (repr (powerserie l)))"
            ]
        },
        {
            "tactic_sig": "rewrite shl_mul_two_p .",
            "tactic_args": [
                "_goal : eqm (two_p a) (unsigned (shl one (repr a)))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (unsigned (mul one (repr (two_p (unsigned (repr a))))))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : eqm (two_p a) (unsigned (mul one (repr (two_p (unsigned (repr a))))))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (unsigned (mul (repr (two_p (unsigned (repr a)))) one))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : eqm (two_p a) (unsigned (mul (repr (two_p (unsigned (repr a)))) one))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (unsigned (repr (two_p (unsigned (repr a)))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_r .",
            "tactic_args": [
                "_goal : eqm (two_p a) (unsigned (repr (two_p (unsigned (repr a)))))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (two_p (unsigned (repr a)))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (two_p a) (two_p (unsigned (repr a)))"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (two_p a)",
                "_goal : Logic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (two_p a) (two_p a)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( _ _ ( in_eq _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 a) (Z.le a max_unsigned)",
                "H : forall (i : Z) (_ : In i (cons a l)),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))",
                "a : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a (Z.of_nat wordsize)),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ]
        },
        {
            "tactic_sig": "change ( Z.of_nat wordsize ) with zwordsize .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a (Z.of_nat wordsize)),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.le zwordsize max_unsigned)\n  (_ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize)),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Z.le zwordsize max_unsigned)\n  (_ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize)),\nLogic.and (Z.le Z0 a) (Z.le a max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : eqm (powerserie l) (unsigned (repr (powerserie l)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : In i l),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))",
                "H0 : In i l",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))",
                "H : forall (i : Z) (_ : In i (cons a l)),\nLogic.and (Z.le Z0 i) (Z.lt i (Z.of_nat wordsize))"
            ],
            "tactic_res": [
                "_goal : In i (cons a l)"
            ]
        },
        {
            "tactic_sig": "auto with coqlib .",
            "tactic_args": [
                "_goal : In i (cons a l)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y : int),\nLogic.eq (cmp (negate_comparison c) x y) (negb (cmp c x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmp (negate_comparison c) x y) (negb (cmp c x y))",
                "x : int",
                "y : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison c) x y) (negb (cmp c x y))",
                "c : comparison"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmp (negate_comparison Ceq) x y) (negb (cmp Ceq x y))",
                "_goal : Logic.eq (cmp (negate_comparison Cne) x y) (negb (cmp Cne x y))",
                "_goal : Logic.eq (cmp (negate_comparison Clt) x y) (negb (cmp Clt x y))",
                "_goal : Logic.eq (cmp (negate_comparison Cle) x y) (negb (cmp Cle x y))",
                "_goal : Logic.eq (cmp (negate_comparison Cgt) x y) (negb (cmp Cgt x y))",
                "_goal : Logic.eq (cmp (negate_comparison Cge) x y) (negb (cmp Cge x y))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Ceq) x y) (negb (cmp Ceq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Cne) x y) (negb (cmp Cne x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (negb (negb (eq x y)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (negb (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Clt) x y) (negb (cmp Clt x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt x y)) (negb (lt x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt x y)) (negb (lt x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Cle) x y) (negb (cmp Cle x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (negb (negb (lt y x)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (negb (negb (lt y x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Cgt) x y) (negb (cmp Cgt x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt y x)) (negb (lt y x))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt y x)) (negb (lt y x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (negate_comparison Cge) x y) (negb (cmp Cge x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt x y) (negb (negb (lt x y)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (lt x y) (negb (negb (lt x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt x y) (lt x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (lt x y) (lt x y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y : int),\nLogic.eq (cmpu (negate_comparison c) x y) (negb (cmpu c x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmpu (negate_comparison c) x y) (negb (cmpu c x y))",
                "x : int",
                "y : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison c) x y) (negb (cmpu c x y))",
                "c : comparison"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmpu (negate_comparison Ceq) x y) (negb (cmpu Ceq x y))",
                "_goal : Logic.eq (cmpu (negate_comparison Cne) x y) (negb (cmpu Cne x y))",
                "_goal : Logic.eq (cmpu (negate_comparison Clt) x y) (negb (cmpu Clt x y))",
                "_goal : Logic.eq (cmpu (negate_comparison Cle) x y) (negb (cmpu Cle x y))",
                "_goal : Logic.eq (cmpu (negate_comparison Cgt) x y) (negb (cmpu Cgt x y))",
                "_goal : Logic.eq (cmpu (negate_comparison Cge) x y) (negb (cmpu Cge x y))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Ceq) x y) (negb (cmpu Ceq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Cne) x y) (negb (cmpu Cne x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (negb (negb (eq x y)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (negb (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Clt) x y) (negb (cmpu Clt x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu x y)) (negb (ltu x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu x y)) (negb (ltu x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Cle) x y) (negb (cmpu Cle x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (negb (negb (ltu y x)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (negb (negb (ltu y x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Cgt) x y) (negb (cmpu Cgt x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu y x)) (negb (ltu y x))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu y x)) (negb (ltu y x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (negate_comparison Cge) x y) (negb (cmpu Cge x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu x y) (negb (negb (ltu x y)))"
            ]
        },
        {
            "tactic_sig": "try rewrite negb_elim .",
            "tactic_args": [
                "_goal : Logic.eq (ltu x y) (negb (negb (ltu x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu x y) (ltu x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu x y) (ltu x y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y : int),\nLogic.eq (cmp (swap_comparison c) x y) (cmp c y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmp (swap_comparison c) x y) (cmp c y x)",
                "x : int",
                "y : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison c) x y) (cmp c y x)",
                "c : comparison"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmp (swap_comparison Ceq) x y) (cmp Ceq y x)",
                "_goal : Logic.eq (cmp (swap_comparison Cne) x y) (cmp Cne y x)",
                "_goal : Logic.eq (cmp (swap_comparison Clt) x y) (cmp Clt y x)",
                "_goal : Logic.eq (cmp (swap_comparison Cle) x y) (cmp Cle y x)",
                "_goal : Logic.eq (cmp (swap_comparison Cgt) x y) (cmp Cgt y x)",
                "_goal : Logic.eq (cmp (swap_comparison Cge) x y) (cmp Cge y x)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Ceq) x y) (cmp Ceq y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Cne) x y) (cmp Cne y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq y x))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Clt) x y) (cmp Clt y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Cle) x y) (cmp Cle y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt x y)) (negb (lt x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt x y)) (negb (lt x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Cgt) x y) (cmp Cgt y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt x y) (lt x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (lt x y) (lt x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmp (swap_comparison Cge) x y) (cmp Cge y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt y x)) (negb (lt y x))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt y x)) (negb (lt y x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq y x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ]
        },
        {
            "tactic_sig": "apply eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y : int),\nLogic.eq (cmpu (swap_comparison c) x y) (cmpu c y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmpu (swap_comparison c) x y) (cmpu c y x)",
                "x : int",
                "y : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "destruct _ .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison c) x y) (cmpu c y x)",
                "c : comparison"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmpu (swap_comparison Ceq) x y) (cmpu Ceq y x)",
                "_goal : Logic.eq (cmpu (swap_comparison Cne) x y) (cmpu Cne y x)",
                "_goal : Logic.eq (cmpu (swap_comparison Clt) x y) (cmpu Clt y x)",
                "_goal : Logic.eq (cmpu (swap_comparison Cle) x y) (cmpu Cle y x)",
                "_goal : Logic.eq (cmpu (swap_comparison Cgt) x y) (cmpu Cgt y x)",
                "_goal : Logic.eq (cmpu (swap_comparison Cge) x y) (cmpu Cge y x)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Ceq) x y) (cmpu Ceq y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Cne) x y) (cmpu Cne y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq y x))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Clt) x y) (cmpu Clt y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Cle) x y) (cmpu Cle y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu x y)) (negb (ltu x y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu x y)) (negb (ltu x y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Cgt) x y) (cmpu Cgt y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu x y) (ltu x y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu x y) (ltu x y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu (swap_comparison Cge) x y) (cmpu Cge y x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu y x)) (negb (ltu y x))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu y x)) (negb (ltu y x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "decEq .",
            "tactic_args": [
                "_goal : Logic.eq (negb (eq x y)) (negb (eq y x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ]
        },
        {
            "tactic_sig": "apply eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (eq y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y d : int, Logic.eq (eq (add x d) (add y d)) (eq x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq (add x d) (add y d)) (eq x y)",
                "x : int",
                "y : int",
                "d : int"
            ]
        },
        {
            "tactic_sig": "unfold eq .",
            "tactic_args": [
                "_goal : Logic.eq (eq (add x d) (add y d)) (eq x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) (if zeq (unsigned x) (unsigned y) then true else false)"
            ]
        },
        {
            "tactic_sig": "case ( zeq ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) (if zeq (unsigned x) (unsigned y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned x) (unsigned y),\nLogic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) true",
                "_goal : forall _ : Logic.not (Logic.eq (unsigned x) (unsigned y)),\nLogic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) false"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned x) (unsigned y),\nLogic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) true",
                "e : Logic.eq (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq (unsigned x) (unsigned y)),\nLogic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) false",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zeq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zeq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) true",
                "e : Logic.eq (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zeq (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "apply zeq_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zeq (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zeq_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zeq (unsigned (add x d)) (unsigned (add y d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (unsigned (add x d)) (unsigned (add y d)))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned (add x d)) (unsigned (add y d)))"
            ],
            "tactic_res": [
                "_goal : Logic.not\n  (Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n     (unsigned (repr (Z.add (unsigned y) (unsigned d)))))"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : Logic.not\n  (Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n     (unsigned (repr (Z.add (unsigned y) (unsigned d)))))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n        (unsigned (repr (Z.add (unsigned y) (unsigned d)))), False"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n        (unsigned (repr (Z.add (unsigned y) (unsigned d)))), False"
            ],
            "tactic_res": [
                "_goal : False",
                "H : Logic.eq (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n  (unsigned (repr (Z.add (unsigned y) (unsigned d))))"
            ]
        },
        {
            "tactic_sig": "apply _ .",
            "tactic_args": [
                "_goal : False",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_small_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned y)",
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)",
                "_goal : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( unsigned _ ) with ( ( unsigned _ + unsigned _ ) - unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned y)",
                "x : int",
                "x : int",
                "d : int",
                "d : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d)) (unsigned y)",
                "_goal : Logic.eq (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d))\n  (unsigned x)"
            ]
        },
        {
            "tactic_sig": "replace ( unsigned _ ) with ( ( unsigned _ + unsigned _ ) - unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d)) (unsigned y)",
                "y : int",
                "y : int",
                "d : int",
                "d : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d))\n  (Z.sub (Z.add (unsigned y) (unsigned d)) (unsigned d))",
                "_goal : Logic.eq (Z.sub (Z.add (unsigned y) (unsigned d)) (unsigned d))\n  (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sub .",
            "tactic_args": [
                "_goal : eqm (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d))\n  (Z.sub (Z.add (unsigned y) (unsigned d)) (unsigned d))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned x) (unsigned d)) (Z.add (unsigned y) (unsigned d))",
                "_goal : eqm (unsigned d) (unsigned d)"
            ]
        },
        {
            "tactic_sig": "apply eqm_trans with ( unsigned ( repr ( unsigned _ + unsigned _ ) ) ) .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned x) (unsigned d)) (Z.add (unsigned y) (unsigned d))",
                "x : int",
                "d : int"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (unsigned x) (unsigned d))\n  (unsigned (repr (Z.add (unsigned x) (unsigned d))))",
                "_goal : eqm (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n  (Z.add (unsigned y) (unsigned d))"
            ]
        },
        {
            "tactic_sig": "eauto with ints .",
            "tactic_args": [
                "_goal : eqm (Z.add (unsigned x) (unsigned d))\n  (unsigned (repr (Z.add (unsigned x) (unsigned d))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_trans with ( unsigned ( repr ( unsigned _ + unsigned _ ) ) ) .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n  (Z.add (unsigned y) (unsigned d))",
                "y : int",
                "d : int"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n  (unsigned (repr (Z.add (unsigned y) (unsigned d))))",
                "_goal : eqm (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n  (Z.add (unsigned y) (unsigned d))"
            ]
        },
        {
            "tactic_sig": "eauto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n  (unsigned (repr (Z.add (unsigned y) (unsigned d))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "eauto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n  (Z.add (unsigned y) (unsigned d))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "eauto with ints .",
            "tactic_args": [
                "_goal : eqm (unsigned d) (unsigned d)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add (unsigned y) (unsigned d)) (unsigned d))\n  (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add (unsigned x) (unsigned d)) (unsigned d))\n  (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y d : int)\n  (_ : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n         (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned))\n  (_ : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n         (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)),\nLogic.eq (ltu (add x d) (add y d)) (ltu x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu (add x d) (add y d)) (ltu x y)",
                "H0 : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)",
                "H : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)",
                "x : int",
                "y : int",
                "d : int"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (add x d) (add y d)) (ltu x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ltu (repr (Z.add (unsigned x) (unsigned d)))\n     (repr (Z.add (unsigned y) (unsigned d)))) (ltu x y)"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ltu (repr (Z.add (unsigned x) (unsigned d)))\n     (repr (Z.add (unsigned y) (unsigned d)))) (ltu x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) (if zlt (unsigned x) (unsigned y) then true else false)"
            ]
        },
        {
            "tactic_sig": "repeat rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (unsigned (repr (Z.add (unsigned x) (unsigned d))))\n      (unsigned (repr (Z.add (unsigned y) (unsigned d))))\n   then true\n   else false) (if zlt (unsigned x) (unsigned y) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) (if zlt (unsigned x) (unsigned y) then true else false)",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "case ( zlt ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) (if zlt (unsigned x) (unsigned y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (unsigned x) (unsigned y),\nLogic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) true",
                "_goal : forall _ : Z.ge (unsigned x) (unsigned y),\nLogic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) false"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (unsigned x) (unsigned y),\nLogic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) true",
                "l : Z.lt (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.ge (unsigned x) (unsigned y),\nLogic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) false",
                "g : Z.ge (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add (unsigned x) (unsigned d))\n  (Z.add (unsigned y) (unsigned d))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add (unsigned x) (unsigned d))\n  (Z.add (unsigned y) (unsigned d))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (unsigned x) (unsigned d))\n      (Z.add (unsigned y) (unsigned d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add (unsigned x) (unsigned d))\n  (Z.add (unsigned y) (unsigned d))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add (unsigned x) (unsigned d))\n  (Z.add (unsigned y) (unsigned d))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y d : int)\n  (_ : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n         (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned))\n  (_ : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n         (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)),\nLogic.eq (cmpu c (add x d) (add y d)) (cmpu c x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmpu c (add x d) (add y d)) (cmpu c x y)",
                "H0 : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)",
                "H : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)",
                "x : int",
                "y : int",
                "d : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "unfold cmpu .",
            "tactic_args": [
                "_goal : Logic.eq (cmpu c (add x d) (add y d)) (cmpu c x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq (add x d) (add y d)\n  | Cne => negb (eq (add x d) (add y d))\n  | Clt => ltu (add x d) (add y d)\n  | Cle => negb (ltu (add y d) (add x d))\n  | Cgt => ltu (add y d) (add x d)\n  | Cge => negb (ltu (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end"
            ]
        },
        {
            "tactic_sig": "rewrite translate_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq (add x d) (add y d)\n  | Cne => negb (eq (add x d) (add y d))\n  | Clt => ltu (add x d) (add y d)\n  | Cle => negb (ltu (add y d) (add x d))\n  | Cgt => ltu (add y d) (add x d)\n  | Cge => negb (ltu (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu (add x d) (add y d)\n  | Cle => negb (ltu (add y d) (add x d))\n  | Cgt => ltu (add y d) (add x d)\n  | Cge => negb (ltu (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end"
            ]
        },
        {
            "tactic_sig": "repeat rewrite translate_ltu .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu (add x d) (add y d)\n  | Cle => negb (ltu (add y d) (add x d))\n  | Cgt => ltu (add y d) (add x d)\n  | Cge => negb (ltu (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)",
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => ltu x y\n  | Cle => negb (ltu y x)\n  | Cgt => ltu y x\n  | Cge => negb (ltu x y)\n  end"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned x) (unsigned d)))\n  (Z.le (Z.add (unsigned x) (unsigned d)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (unsigned y) (unsigned d)))\n  (Z.le (Z.add (unsigned y) (unsigned d)) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y d : int)\n  (_ : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n         (Z.le (Z.add (signed x) (signed d)) max_signed))\n  (_ : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n         (Z.le (Z.add (signed y) (signed d)) max_signed)),\nLogic.eq (lt (add x d) (add y d)) (lt x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt (add x d) (add y d)) (lt x y)",
                "H0 : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)",
                "H : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)",
                "x : int",
                "y : int",
                "d : int"
            ]
        },
        {
            "tactic_sig": "repeat rewrite add_signed .",
            "tactic_args": [
                "_goal : Logic.eq (lt (add x d) (add y d)) (lt x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (lt (repr (Z.add (signed x) (signed d)))\n     (repr (Z.add (signed y) (signed d)))) (lt x y)"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq\n  (lt (repr (Z.add (signed x) (signed d)))\n     (repr (Z.add (signed y) (signed d)))) (lt x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (signed (repr (Z.add (signed x) (signed d))))\n      (signed (repr (Z.add (signed y) (signed d))))\n   then true\n   else false) (if zlt (signed x) (signed y) then true else false)"
            ]
        },
        {
            "tactic_sig": "repeat rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (signed (repr (Z.add (signed x) (signed d))))\n      (signed (repr (Z.add (signed y) (signed d))))\n   then true\n   else false) (if zlt (signed x) (signed y) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) (if zlt (signed x) (signed y) then true else false)",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "case ( zlt ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) (if zlt (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.lt (signed x) (signed y),\nLogic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) true",
                "_goal : forall _ : Z.ge (signed x) (signed y),\nLogic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) false"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.lt (signed x) (signed y),\nLogic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) true",
                "l : Z.lt (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Z.ge (signed x) (signed y),\nLogic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) false",
                "g : Z.ge (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add (signed x) (signed d)) (Z.add (signed y) (signed d))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (c : comparison) (x y d : int)\n  (_ : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n         (Z.le (Z.add (signed x) (signed d)) max_signed))\n  (_ : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n         (Z.le (Z.add (signed y) (signed d)) max_signed)),\nLogic.eq (cmp c (add x d) (add y d)) (cmp c x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (cmp c (add x d) (add y d)) (cmp c x y)",
                "H0 : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)",
                "H : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)",
                "x : int",
                "y : int",
                "d : int",
                "c : comparison"
            ]
        },
        {
            "tactic_sig": "unfold cmp .",
            "tactic_args": [
                "_goal : Logic.eq (cmp c (add x d) (add y d)) (cmp c x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq (add x d) (add y d)\n  | Cne => negb (eq (add x d) (add y d))\n  | Clt => lt (add x d) (add y d)\n  | Cle => negb (lt (add y d) (add x d))\n  | Cgt => lt (add y d) (add x d)\n  | Cge => negb (lt (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end"
            ]
        },
        {
            "tactic_sig": "rewrite translate_eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq (add x d) (add y d)\n  | Cne => negb (eq (add x d) (add y d))\n  | Clt => lt (add x d) (add y d)\n  | Cle => negb (lt (add y d) (add x d))\n  | Cgt => lt (add y d) (add x d)\n  | Cge => negb (lt (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt (add x d) (add y d)\n  | Cle => negb (lt (add y d) (add x d))\n  | Cgt => lt (add y d) (add x d)\n  | Cge => negb (lt (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end"
            ]
        },
        {
            "tactic_sig": "repeat rewrite translate_lt .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt (add x d) (add y d)\n  | Cle => negb (lt (add y d) (add x d))\n  | Cgt => lt (add y d) (add x d)\n  | Cge => negb (lt (add x d) (add y d))\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)",
                "_goal : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end\n  match c with\n  | Ceq => eq x y\n  | Cne => negb (eq x y)\n  | Clt => lt x y\n  | Cle => negb (lt y x)\n  | Cgt => lt y x\n  | Cge => negb (lt x y)\n  end"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add (signed x) (signed d)))\n  (Z.le (Z.add (signed x) (signed d)) max_signed)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.add (signed y) (signed d)))\n  (Z.le (Z.add (signed y) (signed d)) max_signed)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold is_false , is_true , notbool .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : is_false x), is_true (notbool x)"
            ],
            "tactic_res": [
                "_goal : forall (x : int) (_ : Logic.eq x zero),\nLogic.not (Logic.eq (if eq x zero then one else zero) zero)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Logic.eq x zero),\nLogic.not (Logic.eq (if eq x zero then one else zero) zero)"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (if eq x zero then one else zero) zero)",
                "H : Logic.eq x zero",
                "x : int"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (if eq x zero then one else zero) zero)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq (if eq zero zero then one else zero) zero)"
            ]
        },
        {
            "tactic_sig": "rewrite eq_true .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (if eq zero zero then one else zero) zero)"
            ],
            "tactic_res": [
                "_goal : Logic.not (Logic.eq one zero)"
            ]
        },
        {
            "tactic_sig": "apply one_not_zero .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq one zero)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold is_false , is_true , notbool .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : is_true x), is_false (notbool x)"
            ],
            "tactic_res": [
                "_goal : forall (x : int) (_ : Logic.not (Logic.eq x zero)),\nLogic.eq (if eq x zero then one else zero) zero"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (_ : Logic.not (Logic.eq x zero)),\nLogic.eq (if eq x zero then one else zero) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if eq x zero then one else zero) zero",
                "H : Logic.not (Logic.eq x zero)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "generalize ( eq_spec _ zero ) .",
            "tactic_args": [
                "_goal : Logic.eq (if eq x zero then one else zero) zero",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : if eq x zero\n      then Logic.eq x zero\n      else Logic.not (Logic.eq x zero),\nLogic.eq (if eq x zero then one else zero) zero"
            ]
        },
        {
            "tactic_sig": "case ( eq _ zero ) .",
            "tactic_args": [
                "_goal : forall\n  _ : if eq x zero\n      then Logic.eq x zero\n      else Logic.not (Logic.eq x zero),\nLogic.eq (if eq x zero then one else zero) zero",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq x zero, Logic.eq one zero",
                "_goal : forall _ : Logic.not (Logic.eq x zero), Logic.eq zero zero"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq x zero, Logic.eq one zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq one zero",
                "H0 : Logic.eq x zero"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.not (Logic.eq x zero), Logic.eq zero zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq zero zero",
                "H0 : Logic.not (Logic.eq x zero)"
            ]
        },
        {
            "tactic_sig": "contradiction .",
            "tactic_args": [
                "_goal : Logic.eq one zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq zero zero"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : int) (_ : Logic.eq (ltu x y) true)\n  (_ : Z.le (unsigned y) max_signed),\nLogic.and (Z.le Z0 (signed x)) (Z.lt (signed x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (signed x)) (Z.lt (signed x) (unsigned y))",
                "H0 : Z.le (unsigned y) max_signed",
                "H : Logic.eq (ltu x y) true",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold ltu in _ .",
            "tactic_args": [
                "H : Logic.eq (ltu x y) true"
            ],
            "tactic_res": [
                "H : Logic.eq (if zlt (unsigned x) (unsigned y) then true else false) true"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "H : Logic.eq true true",
                "l : Z.lt (unsigned x) (unsigned y)",
                "H : Logic.eq false true",
                "g : Z.ge (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "try discriminate .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite signed_eq_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (signed x)) (Z.lt (signed x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))",
                "_goal : Z.le (unsigned x) max_signed"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (unsigned x) max_signed"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (xor (sub_overflow x y zero) (negative (sub x y)))\n  (if lt x y then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (sub_overflow x y zero) (negative (sub x y)))\n  (if lt x y then one else zero)",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold negative , sub_overflow , lt .",
            "tactic_args": [
                "_goal : Logic.eq (xor (sub_overflow x y zero) (negative (sub x y)))\n  (if lt x y then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (zle min_signed\n            (Z.sub (Z.sub (signed x) (signed y)) (signed zero)))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) (signed zero))\n            max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (sub x y)) (signed zero) then true else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite sub_signed .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (zle min_signed\n            (Z.sub (Z.sub (signed x) (signed y)) (signed zero)))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) (signed zero))\n            max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (sub x y)) (signed zero) then true else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (zle min_signed\n            (Z.sub (Z.sub (signed x) (signed y)) (signed zero)))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) (signed zero))\n            max_signed)\n      then zero\n      else one)\n     (if\n       if\n        zlt (signed (repr (Z.sub (signed x) (signed y)))) (signed zero)\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite signed_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (zle min_signed\n            (Z.sub (Z.sub (signed x) (signed y)) (signed zero)))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) (signed zero))\n            max_signed)\n      then zero\n      else one)\n     (if\n       if\n        zlt (signed (repr (Z.sub (signed x) (signed y)))) (signed zero)\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (Z.sub (signed x) (signed y)) Z0))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) Z0) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.sub_0_r .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (Z.sub (signed x) (signed y)) Z0))\n         (zle (Z.sub (Z.sub (signed x) (signed y)) Z0) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (signed x) (signed y)))\n         (zle (Z.sub (signed x) (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "generalize ( signed_range _ ) ( signed_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (signed x) (signed y)))\n         (zle (Z.sub (signed x) (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le min_signed (signed x))\n         (Z.le (signed x) max_signed))\n  (_ : Logic.and (Z.le min_signed (signed y))\n         (Z.le (signed y) max_signed)),\nLogic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (signed x) (signed y)))\n         (zle (Z.sub (signed x) (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "set ( X := signed _ ) .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le min_signed (signed x))\n         (Z.le (signed x) max_signed))\n  (_ : Logic.and (Z.le min_signed (signed y))\n         (Z.le (signed y) max_signed)),\nLogic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub (signed x) (signed y)))\n         (zle (Z.sub (signed x) (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub (signed x) (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt (signed x) (signed y) then true else false\n   then one\n   else zero)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le min_signed X) (Z.le X max_signed))\n  (_ : Logic.and (Z.le min_signed (signed y))\n         (Z.le (signed y) max_signed)),\nLogic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub X (signed y)))\n         (zle (Z.sub X (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub X (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt X (signed y) then true else false then one else zero)",
                "X : Z"
            ]
        },
        {
            "tactic_sig": "set ( Y := signed _ ) .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le min_signed X) (Z.le X max_signed))\n  (_ : Logic.and (Z.le min_signed (signed y))\n         (Z.le (signed y) max_signed)),\nLogic.eq\n  (xor\n     (if\n       andb (zle min_signed (Z.sub X (signed y)))\n         (zle (Z.sub X (signed y)) max_signed)\n      then zero\n      else one)\n     (if\n       if zlt (signed (repr (Z.sub X (signed y)))) Z0\n       then true\n       else false\n      then one\n      else zero))\n  (if if zlt X (signed y) then true else false then one else zero)",
                "y : int"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le min_signed X) (Z.le X max_signed))\n  (_ : Logic.and (Z.le min_signed Y) (Z.le Y max_signed)),\nLogic.eq\n  (xor\n     (if andb (zle min_signed (Z.sub X Y)) (zle (Z.sub X Y) max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "Y : Z"
            ]
        },
        {
            "tactic_sig": "intros RX RY .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le min_signed X) (Z.le X max_signed))\n  (_ : Logic.and (Z.le min_signed Y) (Z.le Y max_signed)),\nLogic.eq\n  (xor\n     (if andb (zle min_signed (Z.sub X Y)) (zle (Z.sub X Y) max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if andb (zle min_signed (Z.sub X Y)) (zle (Z.sub X Y) max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "RY : Logic.and (Z.le min_signed Y) (Z.le Y max_signed)",
                "RX : Logic.and (Z.le min_signed X) (Z.le X max_signed)"
            ]
        },
        {
            "tactic_sig": "unfold min_signed , max_signed in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if andb (zle min_signed (Z.sub X Y)) (zle (Z.sub X Y) max_signed)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "RY : Logic.and (Z.le (Z.opp half_modulus) Y)\n  (Z.le Y (Z.sub half_modulus (Zpos xH)))",
                "RX : Logic.and (Z.le (Z.opp half_modulus) X)\n  (Z.le X (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize half_modulus_pos half_modulus_modulus .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : forall (_ : Z.gt half_modulus Z0)\n  (_ : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus)),\nLogic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "intros HM MM .",
            "tactic_args": [
                "_goal : forall (_ : Z.gt half_modulus Z0)\n  (_ : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus)),\nLogic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "MM : Logic.eq modulus (Z.mul (Zpos (xO xH)) half_modulus)",
                "HM : Z.gt half_modulus Z0"
            ]
        },
        {
            "tactic_sig": "destruct ( zle 0 ( _ - _ ) ) .",
            "tactic_args": [
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "l : Z.le Z0 (Z.sub X Y)",
                "g : Z.gt Z0 (Z.sub X Y)"
            ]
        },
        {
            "tactic_sig": "unfold proj_sumbool at 1 .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (if zle (Z.opp half_modulus) (Z.sub X Y) then true else false)\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite zle_true at 1 by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb\n         (if zle (Z.opp half_modulus) (Z.sub X Y) then true else false)\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if andb true (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if andb true (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite ( zlt_false _ _ ) by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "X : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - _ ) half_modulus ) .",
            "tactic_args": [
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "l0 : Z.lt (Z.sub X Y) half_modulus",
                "g : Z.ge (Z.sub X Y) half_modulus"
            ]
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n       then true\n       else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite zle_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n       then true\n       else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (Z.sub X Y) Z0 then true else false then one else zero))\n  zero",
                "_goal : Logic.and (Z.le min_signed (Z.sub X Y)) (Z.le (Z.sub X Y) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (Z.sub X Y) Z0 then true else false then one else zero))\n  zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor zero zero) zero"
            ]
        },
        {
            "tactic_sig": "apply xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (xor zero zero) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold min_signed , max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.sub X Y)) (Z.le (Z.sub X Y) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub X Y))\n  (Z.le (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub X Y))\n  (Z.le (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n       then true\n       else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite zle_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n       then true\n       else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero"
            ]
        },
        {
            "tactic_sig": "replace ( signed ( repr ( _ - _ ) ) ) with ( _ - _ - modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) zero",
                "X : Z",
                "Y : Z",
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (Z.sub (Z.sub X Y) modulus) Z0 then true else false\n      then one\n      else zero)) zero",
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus) (signed (repr (Z.sub X Y)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (Z.sub (Z.sub X Y) modulus) Z0 then true else false\n      then one\n      else zero)) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor one one) zero"
            ]
        },
        {
            "tactic_sig": "apply xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq (xor one one) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite signed_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus) (signed (repr (Z.sub X Y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus)\n  (if zlt (Z.modulo (Z.sub X Y) modulus) half_modulus\n   then Z.modulo (Z.sub X Y) modulus\n   else Z.sub (Z.modulo (Z.sub X Y) modulus) modulus)"
            ]
        },
        {
            "tactic_sig": "replace ( ( _ - _ ) mod modulus ) with ( _ - _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus)\n  (if zlt (Z.modulo (Z.sub X Y) modulus) half_modulus\n   then Z.modulo (Z.sub X Y) modulus\n   else Z.sub (Z.modulo (Z.sub X Y) modulus) modulus)",
                "X : Z",
                "Y : Z",
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus)\n  (if zlt (Z.sub X Y) half_modulus\n   then Z.sub X Y\n   else Z.sub (Z.sub X Y) modulus)",
                "_goal : Logic.eq (Z.sub X Y) (Z.modulo (Z.sub X Y) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus)\n  (if zlt (Z.sub X Y) half_modulus\n   then Z.sub X Y\n   else Z.sub (Z.sub X Y) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus) (Z.sub (Z.sub X Y) modulus)",
                "_goal : Z.ge (Z.sub X Y) half_modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub X Y) modulus) (Z.sub (Z.sub X Y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge (Z.sub X Y) half_modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub X Y) (Z.modulo (Z.sub X Y) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub X Y) modulus) (Z.sub X Y)"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with 0 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub X Y) modulus) (Z.sub X Y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub X Y) (Z.add (Z.mul Z0 modulus) (Z.sub X Y))",
                "_goal : Logic.and (Z.le Z0 (Z.sub X Y)) (Z.lt (Z.sub X Y) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub X Y) (Z.add (Z.mul Z0 modulus) (Z.sub X Y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub X Y)) (Z.lt (Z.sub X Y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold proj_sumbool at 2 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n          then true\n          else false)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite zle_true at 1 by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if\n       andb (zle (Z.opp half_modulus) (Z.sub X Y))\n         (if zle (Z.sub X Y) (Z.sub half_modulus (Zpos xH))\n          then true\n          else false)\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if andb (zle (Z.opp half_modulus) (Z.sub X Y)) true\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite andb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if andb (zle (Z.opp half_modulus) (Z.sub X Y)) true\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.opp half_modulus) (Z.sub X Y))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite ( zlt_true _ _ ) by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.opp half_modulus) (Z.sub X Y))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero))\n  (if if zlt X Y then true else false then one else zero)",
                "X : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.opp half_modulus) (Z.sub X Y))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - _ ) ( - half_modulus ) ) .",
            "tactic_args": [
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "l : Z.lt (Z.sub X Y) (Z.opp half_modulus)",
                "g0 : Z.ge (Z.sub X Y) (Z.opp half_modulus)"
            ]
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if if zle (Z.opp half_modulus) (Z.sub X Y) then true else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ]
        },
        {
            "tactic_sig": "rewrite zle_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if if zle (Z.opp half_modulus) (Z.sub X Y) then true else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ]
        },
        {
            "tactic_sig": "replace ( signed ( repr ( _ - _ ) ) ) with ( _ - _ + modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one",
                "X : Z",
                "Y : Z",
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (Z.add (Z.sub X Y) modulus) Z0 then true else false\n      then one\n      else zero)) one",
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (signed (repr (Z.sub X Y)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor one\n     (if if zlt (Z.add (Z.sub X Y) modulus) Z0 then true else false\n      then one\n      else zero)) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor one zero) one"
            ]
        },
        {
            "tactic_sig": "apply xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq (xor one zero) one"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite signed_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (signed (repr (Z.sub X Y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus)\n  (if zlt (Z.modulo (Z.sub X Y) modulus) half_modulus\n   then Z.modulo (Z.sub X Y) modulus\n   else Z.sub (Z.modulo (Z.sub X Y) modulus) modulus)"
            ]
        },
        {
            "tactic_sig": "replace ( ( _ - _ ) mod modulus ) with ( _ - _ + modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus)\n  (if zlt (Z.modulo (Z.sub X Y) modulus) half_modulus\n   then Z.modulo (Z.sub X Y) modulus\n   else Z.sub (Z.modulo (Z.sub X Y) modulus) modulus)",
                "X : Z",
                "Y : Z",
                "X : Z",
                "Y : Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus)\n  (if zlt (Z.add (Z.sub X Y) modulus) half_modulus\n   then Z.add (Z.sub X Y) modulus\n   else Z.sub (Z.add (Z.sub X Y) modulus) modulus)",
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (Z.modulo (Z.sub X Y) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus)\n  (if zlt (Z.add (Z.sub X Y) modulus) half_modulus\n   then Z.add (Z.sub X Y) modulus\n   else Z.sub (Z.add (Z.sub X Y) modulus) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (Z.add (Z.sub X Y) modulus)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (Z.add (Z.sub X Y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub X Y) modulus) (Z.modulo (Z.sub X Y) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo (Z.sub X Y) modulus) (Z.add (Z.sub X Y) modulus)"
            ]
        },
        {
            "tactic_sig": "apply Zmod_unique with ( - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo (Z.sub X Y) modulus) (Z.add (Z.sub X Y) modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub X Y)\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.add (Z.sub X Y) modulus))",
                "_goal : Logic.and (Z.le Z0 (Z.add (Z.sub X Y) modulus))\n  (Z.lt (Z.add (Z.sub X Y) modulus) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub X Y)\n  (Z.add (Z.mul (Zneg xH) modulus) (Z.add (Z.sub X Y) modulus))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add (Z.sub X Y) modulus))\n  (Z.lt (Z.add (Z.sub X Y) modulus) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if proj_sumbool (zle (Z.opp half_modulus) (Z.sub X Y))\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor\n     (if if zle (Z.opp half_modulus) (Z.sub X Y) then true else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ]
        },
        {
            "tactic_sig": "rewrite zle_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor\n     (if if zle (Z.opp half_modulus) (Z.sub X Y) then true else false\n      then zero\n      else one)\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ]
        },
        {
            "tactic_sig": "rewrite signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (signed (repr (Z.sub X Y))) Z0 then true else false\n      then one\n      else zero)) one"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (Z.sub X Y) Z0 then true else false then one else zero))\n  one",
                "_goal : Logic.and (Z.le min_signed (Z.sub X Y)) (Z.le (Z.sub X Y) max_signed)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (xor zero\n     (if if zlt (Z.sub X Y) Z0 then true else false then one else zero))\n  one"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor zero one) one"
            ]
        },
        {
            "tactic_sig": "apply xor_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq (xor zero one) one"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold min_signed , max_signed .",
            "tactic_args": [
                "_goal : Logic.and (Z.le min_signed (Z.sub X Y)) (Z.le (Z.sub X Y) max_signed)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub X Y))\n  (Z.le (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le (Z.opp half_modulus) (Z.sub X Y))\n  (Z.le (Z.sub X Y) (Z.sub half_modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (eq x y) (zeq (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (eq x y) (zeq (signed x) (signed y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold eq .",
            "tactic_args": [
                "_goal : Logic.eq (eq x y) (zeq (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (zeq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (zeq (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (if zeq (signed x) (signed y) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (if zeq (unsigned x) (unsigned y) then true else false)\n  (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true (if zeq (signed x) (signed y) then true else false)",
                "_goal : Logic.eq false (if zeq (signed x) (signed y) then true else false)",
                "e : Logic.eq (unsigned x) (unsigned y)",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq true (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq true true",
                "_goal : Logic.eq true false",
                "e0 : Logic.eq (signed x) (signed y)",
                "n : Logic.not (Logic.eq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq true true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq false (if zeq (signed x) (signed y) then true else false)",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false true",
                "_goal : Logic.eq false false",
                "e : Logic.eq (signed x) (signed y)",
                "n0 : Logic.not (Logic.eq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : Logic.eq true false",
                "n : Logic.not (Logic.eq (signed x) (signed y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "unfold signed .",
            "tactic_args": [
                "_goal : Logic.eq (signed x) (signed y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus)\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned x) half_modulus\n   then unsigned x\n   else Z.sub (unsigned x) modulus)\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)",
                "e : Logic.eq (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)\n  (if zlt (unsigned y) half_modulus\n   then unsigned y\n   else Z.sub (unsigned y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "elim _ .",
            "tactic_args": [
                "_goal : Logic.eq false true",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_small_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned y)",
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)",
                "_goal : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned y)) (Z.lt (unsigned y) modulus)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "eapply eqm_trans .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned y)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) ?y",
                "_goal : eqm ?y (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned x) ?y"
            ],
            "tactic_res": [
                "_goal : eqm ?y (unsigned x)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm ?y (unsigned x)",
                "_goal : eqm ?y (unsigned y)"
            ],
            "tactic_res": [
                "_goal : eqm (signed x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : eqm (signed x) (unsigned y)",
                "e : Logic.eq (signed x) (signed y)"
            ],
            "tactic_res": [
                "_goal : eqm (signed y) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : eqm (signed y) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (negb (lt y x)) (orb (lt x y) (eq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt y x)) (orb (lt x y) (eq x y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt y x)) (orb (lt x y) (eq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false) (eq x y))"
            ]
        },
        {
            "tactic_sig": "rewrite signed_eq .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false) (eq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (zeq (signed x) (signed y)))"
            ]
        },
        {
            "tactic_sig": "unfold proj_sumbool .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (zeq (signed x) (signed y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if zlt (signed y) (signed x) then true else false))\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))",
                "y : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true)\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))",
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))",
                "l : Z.lt (signed y) (signed x)",
                "g : Z.ge (signed y) (signed x)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb true)\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true)\n  (orb false (if zeq (signed x) (signed y) then true else false))",
                "_goal : Z.ge (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb true)\n  (orb false (if zeq (signed x) (signed y) then true else false))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true) (orb false false)",
                "_goal : Logic.not (Logic.eq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb true) (orb false false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (signed x) (signed y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (signed x) (signed y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( signed _ ) ( signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false)\n     (if zeq (signed x) (signed y) then true else false))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false) true)",
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false) false)",
                "e : Logic.eq (signed x) (signed y)",
                "n : Logic.not (Logic.eq (signed x) (signed y))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) (orb false true)",
                "_goal : Z.ge (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) (orb false true)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (signed x) (signed y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (signed x) (signed y) then true else false) false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) (orb true false)",
                "_goal : Z.lt (signed x) (signed y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) (orb true false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (signed x) (signed y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (lt y x) (andb (negb (lt x y)) (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (andb (negb (lt x y)) (negb (eq x y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- negb_orb .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (andb (negb (lt x y)) (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (negb (orb (lt x y) (eq x y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- not_lt .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (negb (orb (lt x y) (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (negb (negb (lt y x)))"
            ]
        },
        {
            "tactic_sig": "rewrite negb_involutive .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (negb (negb (lt y x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (lt y x) (lt y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int, Logic.eq (negb (ltu y x)) (orb (ltu x y) (eq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu y x)) (orb (ltu x y) (eq x y))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "unfold ltu , eq .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu y x)) (orb (ltu x y) (eq x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if zlt (unsigned y) (unsigned x) then true else false))\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if zlt (unsigned y) (unsigned x) then true else false))\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))",
                "y : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))",
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))",
                "l : Z.lt (unsigned y) (unsigned x)",
                "g : Z.ge (unsigned y) (unsigned x)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb true)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true)\n  (orb false (if zeq (unsigned x) (unsigned y) then true else false))",
                "_goal : Z.ge (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "rewrite zeq_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb true)\n  (orb false (if zeq (unsigned x) (unsigned y) then true else false))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true) (orb false false)",
                "_goal : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb true) (orb false false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (unsigned x) (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( unsigned _ ) ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false)\n     (if zeq (unsigned x) (unsigned y) then true else false))",
                "x : int",
                "y : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false) true)",
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false) false)",
                "e : Logic.eq (unsigned x) (unsigned y)",
                "n : Logic.not (Logic.eq (unsigned x) (unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) (orb false true)",
                "_goal : Z.ge (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) (orb false true)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (unsigned x) (unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (negb false)\n  (orb (if zlt (unsigned x) (unsigned y) then true else false) false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) (orb true false)",
                "_goal : Z.lt (unsigned x) (unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) (orb true false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (unsigned x) (unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : int,\nLogic.eq (ltu y x) (andb (negb (ltu x y)) (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (andb (negb (ltu x y)) (negb (eq x y)))",
                "x : int",
                "y : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- negb_orb .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (andb (negb (ltu x y)) (negb (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (negb (orb (ltu x y) (eq x y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- not_ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (negb (orb (ltu x y) (eq x y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (negb (negb (ltu y x)))"
            ]
        },
        {
            "tactic_sig": "rewrite negb_involutive .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (negb (negb (ltu y x)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y x) (ltu y x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (ofs1 : int) (sz1 : Z) (ofs2 : int) (sz2 : Z) \n  (base : int) (_ : Z.gt sz1 Z0) (_ : Z.gt sz2 Z0)\n  (_ : Logic.eq (no_overlap ofs1 sz1 ofs2 sz2) true),\nLogic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "H1 : Logic.eq (no_overlap ofs1 sz1 ofs2 sz2) true",
                "H0 : Z.gt sz2 Z0",
                "H : Z.gt sz1 Z0",
                "base : int",
                "sz2 : Z",
                "ofs2 : int",
                "sz1 : Z",
                "ofs1 : int"
            ]
        },
        {
            "tactic_sig": "destruct ( andb_prop _ _ _ ) .",
            "tactic_args": [
                "H1 : Logic.eq (no_overlap ofs1 sz1 ofs2 sz2) true"
            ],
            "tactic_res": [
                "H3 : Logic.eq\n  (orb (zle (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n     (zle (Z.add (unsigned ofs2) sz2) (unsigned ofs1))) true",
                "H2 : Logic.eq\n  (andb (zlt (Z.add (unsigned ofs1) sz1) modulus)\n     (zlt (Z.add (unsigned ofs2) sz2) modulus)) true"
            ]
        },
        {
            "tactic_sig": "clear _ .",
            "tactic_args": [
                "H1 : Logic.eq (no_overlap ofs1 sz1 ofs2 sz2) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( andb_prop _ _ _ ) .",
            "tactic_args": [
                "H2 : Logic.eq\n  (andb (zlt (Z.add (unsigned ofs1) sz1) modulus)\n     (zlt (Z.add (unsigned ofs2) sz2) modulus)) true"
            ],
            "tactic_res": [
                "H4 : Logic.eq (zlt (Z.add (unsigned ofs2) sz2) modulus) true",
                "H1 : Logic.eq (zlt (Z.add (unsigned ofs1) sz1) modulus) true"
            ]
        },
        {
            "tactic_sig": "clear _ .",
            "tactic_args": [
                "H2 : Logic.eq\n  (andb (zlt (Z.add (unsigned ofs1) sz1) modulus)\n     (zlt (Z.add (unsigned ofs2) sz2) modulus)) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply proj_sumbool_true in _ .",
            "tactic_args": [
                "H1 : Logic.eq (zlt (Z.add (unsigned ofs1) sz1) modulus) true"
            ],
            "tactic_res": [
                "H1 : Z.lt (Z.add (unsigned ofs1) sz1) modulus"
            ]
        },
        {
            "tactic_sig": "apply proj_sumbool_true in _ .",
            "tactic_args": [
                "H4 : Logic.eq (zlt (Z.add (unsigned ofs2) sz2) modulus) true"
            ],
            "tactic_res": [
                "H4 : Z.lt (Z.add (unsigned ofs2) sz2) modulus"
            ]
        },
        {
            "tactic_sig": "assert ( unsigned _ + _ <= unsigned _ \\/ unsigned _ + _ <= unsigned _ ) .",
            "tactic_args": [
                "ofs1 : int",
                "sz1 : Z",
                "ofs2 : int",
                "ofs2 : int",
                "sz2 : Z",
                "ofs1 : int"
            ],
            "tactic_res": [
                "_goal : Logic.or (Z.le (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n  (Z.le (Z.add (unsigned ofs2) sz2) (unsigned ofs1))",
                "H2 : Logic.or (Z.le (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n  (Z.le (Z.add (unsigned ofs2) sz2) (unsigned ofs1))"
            ]
        },
        {
            "tactic_sig": "destruct ( orb_prop _ _ _ ) .",
            "tactic_args": [
                "H3 : Logic.eq\n  (orb (zle (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n     (zle (Z.add (unsigned ofs2) sz2) (unsigned ofs1))) true"
            ],
            "tactic_res": [
                "H2 : Logic.eq (zle (Z.add (unsigned ofs1) sz1) (unsigned ofs2)) true",
                "H2 : Logic.eq (zle (Z.add (unsigned ofs2) sz2) (unsigned ofs1)) true"
            ]
        },
        {
            "tactic_sig": "left .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Z.le (Z.add (unsigned ofs1) sz1) (unsigned ofs2)"
            ]
        },
        {
            "tactic_sig": "eapply proj_sumbool_true .",
            "tactic_args": [
                "_goal : Z.le (Z.add (unsigned ofs1) sz1) (unsigned ofs2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq ?a true"
            ]
        },
        {
            "tactic_sig": "eauto .",
            "tactic_args": [
                "_goal : Logic.eq ?a true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "right .",
            "tactic_args": [
                "_goal : Logic.or (Z.le (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n  (Z.le (Z.add (unsigned ofs2) sz2) (unsigned ofs1))"
            ],
            "tactic_res": [
                "_goal : Z.le (Z.add (unsigned ofs2) sz2) (unsigned ofs1)"
            ]
        },
        {
            "tactic_sig": "eapply proj_sumbool_true .",
            "tactic_args": [
                "_goal : Z.le (Z.add (unsigned ofs2) sz2) (unsigned ofs1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq ?a true"
            ]
        },
        {
            "tactic_sig": "eauto .",
            "tactic_args": [
                "_goal : Logic.eq ?a true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "clear _ .",
            "tactic_args": [
                "H3 : Logic.eq\n  (orb (zle (Z.add (unsigned ofs1) sz1) (unsigned ofs2))\n     (zle (Z.add (unsigned ofs2) sz2) (unsigned ofs1))) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "ofs1 : int",
                "ofs2 : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned ofs1))\n         (Z.lt (unsigned ofs1) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned ofs2))\n         (Z.lt (unsigned ofs2) modulus)),\nLogic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ]
        },
        {
            "tactic_sig": "intros P Q .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (unsigned ofs1))\n         (Z.lt (unsigned ofs1) modulus))\n  (_ : Logic.and (Z.le Z0 (unsigned ofs2))\n         (Z.lt (unsigned ofs2) modulus)),\nLogic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "Q : Logic.and (Z.le Z0 (unsigned ofs2)) (Z.lt (unsigned ofs2) modulus)",
                "P : Logic.and (Z.le Z0 (unsigned ofs1)) (Z.lt (unsigned ofs1) modulus)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_add_either _ _ ) ( unsigned_add_either _ _ ) .",
            "tactic_args": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "base : int",
                "ofs1 : int",
                "base : int",
                "ofs2 : int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.or\n         (Logic.eq (unsigned (add base ofs1))\n            (Z.add (unsigned base) (unsigned ofs1)))\n         (Logic.eq (unsigned (add base ofs1))\n            (Z.sub (Z.add (unsigned base) (unsigned ofs1)) modulus)))\n  (_ : Logic.or\n         (Logic.eq (unsigned (add base ofs2))\n            (Z.add (unsigned base) (unsigned ofs2)))\n         (Logic.eq (unsigned (add base ofs2))\n            (Z.sub (Z.add (unsigned base) (unsigned ofs2)) modulus))),\nLogic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ]
        },
        {
            "tactic_sig": "intros [ C|C ] [ D|D ] .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.or\n         (Logic.eq (unsigned (add base ofs1))\n            (Z.add (unsigned base) (unsigned ofs1)))\n         (Logic.eq (unsigned (add base ofs1))\n            (Z.sub (Z.add (unsigned base) (unsigned ofs1)) modulus)))\n  (_ : Logic.or\n         (Logic.eq (unsigned (add base ofs2))\n            (Z.add (unsigned base) (unsigned ofs2)))\n         (Logic.eq (unsigned (add base ofs2))\n            (Z.sub (Z.add (unsigned base) (unsigned ofs2)) modulus))),\nLogic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))",
                "D : Logic.eq (unsigned (add base ofs2))\n  (Z.add (unsigned base) (unsigned ofs2))",
                "C : Logic.eq (unsigned (add base ofs1))\n  (Z.add (unsigned base) (unsigned ofs1))",
                "D : Logic.eq (unsigned (add base ofs2))\n  (Z.sub (Z.add (unsigned base) (unsigned ofs2)) modulus)",
                "C : Logic.eq (unsigned (add base ofs1))\n  (Z.sub (Z.add (unsigned base) (unsigned ofs1)) modulus)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.or\n  (Z.le (Z.add (unsigned (add base ofs1)) sz1)\n     (unsigned (add base ofs2)))\n  (Z.le (Z.add (unsigned (add base ofs2)) sz2)\n     (unsigned (add base ofs1)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold size .",
            "tactic_args": [
                "_goal : Logic.eq (size zero) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Zsize (unsigned zero)) Z0"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Zsize (unsigned zero)) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Zsize Z0) Z0"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Zsize Z0) Z0"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.or (Logic.eq x zero)\n  (Logic.eq (testbit x (Z.pred (size x))) true)"
            ],
            "tactic_res": [
                "_goal : Logic.or (Logic.eq x zero)\n  (Logic.eq (testbit x (Z.pred (size x))) true)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( unsigned _ ) 0 ) .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "e : Logic.eq (unsigned x) Z0",
                "n : Logic.not (Logic.eq (unsigned x) Z0)"
            ]
        },
        {
            "tactic_sig": "left .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq x zero"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq x zero",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) zero"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) zero",
                "e : Logic.eq (unsigned x) Z0"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr Z0) zero"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr Z0) zero"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "right .",
            "tactic_args": [
                "_goal : Logic.or (Logic.eq x zero)\n  (Logic.eq (testbit x (Z.pred (size x))) true)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.pred (size x))) true"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_size_1 .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.pred (size x))) true"
            ],
            "tactic_res": [
                "_goal : Z.lt Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.lt Z0 (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.lt Z0 (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Z) (_ : Z.le (size x) i),\nLogic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x i) false",
                "H : Z.le (size x) i",
                "i : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Ztestbit_size_2 .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x i) false"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (unsigned x)",
                "_goal : Z.ge i (Zsize (unsigned x))"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold ( size _ ) .",
            "tactic_args": [
                "_goal : Z.ge i (Zsize (unsigned x))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Z.ge i (size x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge i (size x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.and (Z.le Z0 (size x)) (Z.le (size x) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (size x)) (Z.le (size x) zwordsize)",
                "x : int"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (size x)) (Z.le (size x) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (size x)",
                "_goal : Z.le (size x) zwordsize"
            ]
        },
        {
            "tactic_sig": "apply Zsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 (size x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( bits_size_1 _ ) .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "H : Logic.eq x zero",
                "H : Logic.eq (testbit x (Z.pred (size x))) true"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "_goal : Z.le (size zero) zwordsize"
            ]
        },
        {
            "tactic_sig": "unfold size .",
            "tactic_args": [
                "_goal : Z.le (size zero) zwordsize"
            ],
            "tactic_res": [
                "_goal : Z.le (Zsize (unsigned zero)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Z.le (Zsize (unsigned zero)) zwordsize"
            ],
            "tactic_res": [
                "_goal : Z.le (Zsize Z0) zwordsize"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Z.le (Zsize Z0) zwordsize"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 zwordsize"
            ]
        },
        {
            "tactic_sig": "generalize wordsize_pos .",
            "tactic_args": [
                "_goal : Z.le Z0 zwordsize"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.gt zwordsize Z0, Z.le Z0 zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zle ( size _ ) zwordsize ) .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "l : Z.le (size x) zwordsize",
                "g : Z.gt (size x) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_above in _ .",
            "tactic_args": [
                "H : Logic.eq (testbit x (Z.pred (size x))) true"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.pred (size x)) zwordsize",
                "H : Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Z.le (size x) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.pred (size x)) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n : Z) (_ : Z.le Z0 n)\n  (_ : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\n       Logic.eq (testbit x i) false), Z.le (size x) n"
            ],
            "tactic_res": [
                "_goal : Z.le (size x) n",
                "H0 : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) false",
                "H : Z.le Z0 n",
                "n : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( zle ( size _ ) _ ) .",
            "tactic_args": [
                "x : int",
                "n : Z"
            ],
            "tactic_res": [
                "l : Z.le (size x) n",
                "g : Z.gt (size x) n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( bits_size_1 _ ) .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "H1 : Logic.eq x zero",
                "H1 : Logic.eq (testbit x (Z.pred (size x))) true"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "x : int"
            ],
            "tactic_res": [
                "_goal : Z.le (size zero) n",
                "H0 : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit zero i) false",
                "g : Z.gt (size zero) n"
            ]
        },
        {
            "tactic_sig": "unfold size .",
            "tactic_args": [
                "_goal : Z.le (size zero) n"
            ],
            "tactic_res": [
                "_goal : Z.le (Zsize (unsigned zero)) n"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_zero .",
            "tactic_args": [
                "_goal : Z.le (Zsize (unsigned zero)) n"
            ],
            "tactic_res": [
                "_goal : Z.le (Zsize Z0) n"
            ]
        },
        {
            "tactic_sig": "assumption .",
            "tactic_args": [
                "_goal : Z.le (Zsize Z0) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( _ ( Z.pred ( size _ ) ) ) in _ .",
            "tactic_args": [
                "H0 : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) false",
                "x : int",
                "H1 : Logic.eq (testbit x (Z.pred (size x))) true"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le n (Z.pred (size x))) (Z.lt (Z.pred (size x)) zwordsize)",
                "H1 : Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Z.le (size x) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( size_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le n (Z.pred (size x))) (Z.lt (Z.pred (size x)) zwordsize)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (size x)) (Z.le (size x) zwordsize),\nLogic.and (Z.le n (Z.pred (size x))) (Z.lt (Z.pred (size x)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (size x)) (Z.le (size x) zwordsize),\nLogic.and (Z.le n (Z.pred (size x))) (Z.lt (Z.pred (size x)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n : Z) (_ : Z.le Z0 n)\n  (_ : Logic.eq (testbit x (Z.pred n)) true)\n  (_ : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\n       Logic.eq (testbit x i) false), Logic.eq (size x) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size x) n",
                "H1 : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) false",
                "H0 : Logic.eq (testbit x (Z.pred n)) true",
                "H : Z.le Z0 n",
                "n : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "assert ( size _ <= _ ) .",
            "tactic_args": [
                "x : int",
                "n : Z"
            ],
            "tactic_res": [
                "_goal : Z.le (size x) n",
                "H2 : Z.le (size x) n"
            ]
        },
        {
            "tactic_sig": "apply bits_size_3 .",
            "tactic_args": [
                "_goal : Z.le (size x) n"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 n",
                "_goal : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le n i) (Z.lt i zwordsize)),\nLogic.eq (testbit x i) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( size _ ) _ ) .",
            "tactic_args": [
                "x : int",
                "n : Z"
            ],
            "tactic_res": [
                "l : Z.lt (size x) n",
                "g : Z.ge (size x) n"
            ]
        },
        {
            "tactic_sig": "rewrite bits_size_2 in _ .",
            "tactic_args": [
                "H0 : Logic.eq (testbit x (Z.pred n)) true"
            ],
            "tactic_res": [
                "_goal : Z.le (size x) (Z.pred n)",
                "H0 : Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (size x) (Z.pred n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (size x) n"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int,\nLogic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p (size x)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p (size x)))",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Zsize_interval_1 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p (size x)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "generalize ( unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (unsigned x)",
                "x : int"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) modulus),\nZ.le Z0 (unsigned x)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (n : Z) (_ : Z.le Z0 n)\n  (_ : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p n))),\nZ.ge n (size x)"
            ],
            "tactic_res": [
                "_goal : Z.ge n (size x)",
                "H0 : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p n))",
                "H : Z.le Z0 n",
                "n : Z",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Zsize_interval_2 .",
            "tactic_args": [
                "_goal : Z.ge n (size x)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 n",
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x)) (Z.lt (unsigned x) (two_p n))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int, Z.le (size (and a b)) (Z.min (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Z.le (size (and a b)) (Z.min (size a) (size b))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "assert ( 0 <= Z.min ( size _ ) ( size _ ) ) .",
            "tactic_args": [
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.min (size a) (size b))",
                "H : Z.le Z0 (Z.min (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "generalize ( size_range _ ) ( size_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.min (size a) (size b))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nZ.le Z0 (Z.min (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nZ.le Z0 (Z.min (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le Z0 z) (Z.le z zwordsize))\n  (_ : Logic.and (Z.le Z0 z0) (Z.le z0 zwordsize)), \nZ.le Z0 z1",
                "H : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z0))",
                "z1 : Z",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le Z0 z) (Z.le z zwordsize))\n  (_ : Logic.and (Z.le Z0 z0) (Z.le z0 zwordsize)), \nZ.le Z0 z1"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_size_3 .",
            "tactic_args": [
                "_goal : Z.le (size (and a b)) (Z.min (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.min (size a) (size b))",
                "_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Z.min (size a) (size b)) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and a b) i) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.min (size a) (size b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Z.min (size a) (size b)) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (and a b) i) false",
                "H0 : Logic.and (Z.le (Z.min (size a) (size b)) i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_and by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (and a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (andb (testbit a i) (testbit b i)) false"
            ]
        },
        {
            "tactic_sig": "rewrite andb_false_iff .",
            "tactic_args": [
                "_goal : Logic.eq (andb (testbit a i) (testbit b i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)"
            ]
        },
        {
            "tactic_sig": "generalize ( bits_size_2 _ _ ) .",
            "tactic_args": [
                "_goal : Logic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)",
                "a : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : forall _ : forall _ : Z.le (size a) i, Logic.eq (testbit a i) false,\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)"
            ]
        },
        {
            "tactic_sig": "generalize ( bits_size_2 _ _ ) .",
            "tactic_args": [
                "_goal : forall _ : forall _ : Z.le (size a) i, Logic.eq (testbit a i) false,\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)",
                "b : int",
                "i : Z"
            ],
            "tactic_res": [
                "_goal : forall (_ : forall _ : Z.le (size b) i, Logic.eq (testbit b i) false)\n  (_ : forall _ : Z.le (size a) i, Logic.eq (testbit a i) false),\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)"
            ]
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : forall (_ : forall _ : Z.le (size b) i, Logic.eq (testbit b i) false)\n  (_ : forall _ : Z.le (size a) i, Logic.eq (testbit a i) false),\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)"
            ],
            "tactic_res": [
                "_goal : forall (_ : forall _ : Z.le z0 i, Logic.eq (testbit b i) false)\n  (_ : forall _ : Z.le z i, Logic.eq (testbit a i) false),\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)",
                "H1 : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z0))",
                "H0 : Logic.and (Z.le z1 i) (Z.lt i zwordsize)",
                "H : Z.le Z0 z1",
                "z1 : Z",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "intuition .",
            "tactic_args": [
                "_goal : forall (_ : forall _ : Z.le z0 i, Logic.eq (testbit b i) false)\n  (_ : forall _ : Z.le z i, Logic.eq (testbit a i) false),\nLogic.or (Logic.eq (testbit a i) false) (Logic.eq (testbit b i) false)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int,\nLogic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "generalize ( size_interval_1 ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (and a b)))\n        (Z.lt (unsigned (and a b)) (two_p (size (and a b)))),\nLogic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (and a b)))\n        (Z.lt (unsigned (and a b)) (two_p (size (and a b)))),\nLogic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))",
                "H : Logic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (size (and a b))))"
            ]
        },
        {
            "tactic_sig": "assert ( two_p ( size ( and _ _ ) ) <= two_p ( Z.min ( size _ ) ( size _ ) ) ) .",
            "tactic_args": [
                "a : int",
                "b : int",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Z.le (two_p (size (and a b))) (two_p (Z.min (size a) (size b)))",
                "H0 : Z.le (two_p (size (and a b))) (two_p (Z.min (size a) (size b)))"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone .",
            "tactic_args": [
                "_goal : Z.le (two_p (size (and a b))) (two_p (Z.min (size a) (size b)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (size (and a b)))\n  (Z.le (size (and a b)) (Z.min (size a) (size b)))"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (size (and a b)))\n  (Z.le (size (and a b)) (Z.min (size a) (size b)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (size (and a b))",
                "_goal : Z.le (size (and a b)) (Z.min (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "generalize ( size_range ( and _ _ ) ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (size (and a b))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (size (and a b)))\n        (Z.le (size (and a b)) zwordsize), Z.le Z0 (size (and a b))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (size (and a b)))\n        (Z.le (size (and a b)) zwordsize), Z.le Z0 (size (and a b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply size_and .",
            "tactic_args": [
                "_goal : Z.le (size (and a b)) (Z.min (size a) (size b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (and a b)))\n  (Z.lt (unsigned (and a b)) (two_p (Z.min (size a) (size b))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int, Logic.eq (size (or a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a b)) (Z.max (size a) (size b))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "generalize ( size_range _ ) ( size_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a b)) (Z.max (size a) (size b))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nLogic.eq (size (or a b)) (Z.max (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nLogic.eq (size (or a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a b)) (Z.max (size a) (size b))",
                "H0 : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)",
                "H : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize)"
            ]
        },
        {
            "tactic_sig": "destruct ( bits_size_1 _ ) .",
            "tactic_args": [
                "a : int"
            ],
            "tactic_res": [
                "H1 : Logic.eq a zero",
                "H1 : Logic.eq (testbit a (Z.pred (size a))) true"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "a : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or zero b)) (Z.max (size zero) (size b))",
                "H : Logic.and (Z.le Z0 (size zero)) (Z.le (size zero) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite size_zero .",
            "tactic_args": [
                "_goal : Logic.eq (size (or zero b)) (Z.max (size zero) (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or zero b)) (Z.max Z0 (size b))"
            ]
        },
        {
            "tactic_sig": "rewrite or_zero_l .",
            "tactic_args": [
                "_goal : Logic.eq (size (or zero b)) (Z.max Z0 (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size b) (Z.max Z0 (size b))"
            ]
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : Logic.eq (size b) (Z.max Z0 (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq z z0",
                "H1 : Logic.or (Logic.and (Z.lt Z0 z) (Logic.eq z0 z))\n  (Logic.and (Z.le z Z0) (Logic.eq z0 Z0))",
                "z0 : Z",
                "H0 : Logic.and (Z.le Z0 z) (Z.le z zwordsize)",
                "Heqz : Logic.eq z (size b)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq z z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( bits_size_1 _ ) .",
            "tactic_args": [
                "b : int"
            ],
            "tactic_res": [
                "H2 : Logic.eq b zero",
                "H2 : Logic.eq (testbit b (Z.pred (size b))) true"
            ]
        },
        {
            "tactic_sig": "subst _ .",
            "tactic_args": [
                "b : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a zero)) (Z.max (size a) (size zero))",
                "H0 : Logic.and (Z.le Z0 (size zero)) (Z.le (size zero) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite size_zero .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a zero)) (Z.max (size a) (size zero))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a zero)) (Z.max (size a) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite or_zero .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a zero)) (Z.max (size a) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size a) (Z.max (size a) Z0)"
            ]
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : Logic.eq (size a) (Z.max (size a) Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq z z0",
                "H2 : Logic.or (Logic.and (Z.lt z Z0) (Logic.eq z0 Z0))\n  (Logic.and (Z.le Z0 z) (Logic.eq z0 z))",
                "z0 : Z",
                "H1 : Logic.eq (testbit a (Z.pred z)) true",
                "H : Logic.and (Z.le Z0 z) (Z.le z zwordsize)",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq z z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a b)) z1",
                "H3 : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z0))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z))",
                "z1 : Z",
                "H2 : Logic.eq (testbit b (Z.pred z0)) true",
                "H1 : Logic.eq (testbit a (Z.pred z)) true",
                "H0 : Logic.and (Z.le Z0 z0) (Z.le z0 zwordsize)",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "H : Logic.and (Z.le Z0 z) (Z.le z zwordsize)",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "destruct _ as [ [ P Q ] | [ P Q ] ] .",
            "tactic_args": [
                "H3 : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z0))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z))"
            ],
            "tactic_res": [
                "Q : Logic.eq z1 z0",
                "P : Z.lt z z0",
                "Q : Logic.eq z1 z",
                "P : Z.le z0 z"
            ]
        },
        {
            "tactic_sig": "subst .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : Logic.eq (size (or a b)) (size b)",
                "P : Z.lt (size a) (size b)",
                "H2 : Logic.eq (testbit b (Z.pred (size b))) true",
                "H1 : Logic.eq (testbit a (Z.pred (size a))) true",
                "H0 : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)",
                "H : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize)"
            ]
        },
        {
            "tactic_sig": "subst .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a b)) z1"
            ],
            "tactic_res": [
                "_goal : Logic.eq (size (or a b)) (size a)",
                "P : Z.le (size b) (size a)"
            ]
        },
        {
            "tactic_sig": "apply bits_size_4 .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a b)) (size b)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (size b)",
                "_goal : Logic.eq (testbit (or a b) (Z.pred (size b))) true",
                "_goal : forall (i : Z) (_ : Logic.and (Z.le (size b) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or a b) i) false"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 (size b)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or a b) (Z.pred (size b))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (testbit a (Z.pred (size b))) (testbit b (Z.pred (size b))))\n  true",
                "_goal : Logic.and (Z.le Z0 (Z.pred (size b)))\n  (Z.lt (Z.pred (size b)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (testbit a (Z.pred (size b))) (testbit b (Z.pred (size b))))\n  true",
                "H2 : Logic.eq (testbit b (Z.pred (size b))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit a (Z.pred (size b))) true) true"
            ]
        },
        {
            "tactic_sig": "apply orb_true_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit a (Z.pred (size b))) true) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.pred (size b)))\n  (Z.lt (Z.pred (size b)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le (size b) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (or a b) i) false",
                "H3 : Logic.and (Z.le (size b) i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit a i) (testbit b i)) false",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite !bits_size_2 .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit a i) (testbit b i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb false false) false",
                "_goal : Z.le (size b) i",
                "_goal : Z.le (size a) i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (size b) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (size a) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_size_4 .",
            "tactic_args": [
                "_goal : Logic.eq (size (or a b)) (size a)"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (size a)",
                "_goal : Logic.eq (testbit (or a b) (Z.pred (size a))) true",
                "_goal : forall (i : Z) (_ : Logic.and (Z.le (size a) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or a b) i) false"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.le Z0 (size a)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or a b) (Z.pred (size a))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (testbit a (Z.pred (size a))) (testbit b (Z.pred (size a))))\n  true",
                "_goal : Logic.and (Z.le Z0 (Z.pred (size a)))\n  (Z.lt (Z.pred (size a)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (testbit a (Z.pred (size a))) (testbit b (Z.pred (size a))))\n  true",
                "H1 : Logic.eq (testbit a (Z.pred (size a))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb true (testbit b (Z.pred (size a)))) true"
            ]
        },
        {
            "tactic_sig": "apply orb_true_l .",
            "tactic_args": [
                "_goal : Logic.eq (orb true (testbit b (Z.pred (size a)))) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zeq ( size _ ) 0 ) .",
            "tactic_args": [
                "a : int"
            ],
            "tactic_res": [
                "e : Logic.eq (size a) Z0",
                "n : Logic.not (Logic.eq (size a) Z0)"
            ]
        },
        {
            "tactic_sig": "unfold testbit in _ .",
            "tactic_args": [
                "H1 : Logic.eq (testbit a (Z.pred (size a))) true"
            ],
            "tactic_res": [
                "H1 : Logic.eq (Z.testbit (unsigned a) (Z.pred (size a))) true"
            ]
        },
        {
            "tactic_sig": "rewrite Z.testbit_neg_r in _ .",
            "tactic_args": [
                "H1 : Logic.eq (Z.testbit (unsigned a) (Z.pred (size a))) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.pred (size a)) Z0",
                "H1 : Logic.eq false true"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.pred (size a)) Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.pred (size a)))\n  (Z.lt (Z.pred (size a)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le (size a) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (or a b) i) false",
                "H3 : Logic.and (Z.le (size a) i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (or a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (testbit a i) (testbit b i)) false",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite !bits_size_2 .",
            "tactic_args": [
                "_goal : Logic.eq (orb (testbit a i) (testbit b i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb false false) false",
                "_goal : Z.le (size b) i",
                "_goal : Z.le (size a) i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (size b) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (size a) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int,\nLogic.and (Z.le Z0 (unsigned (or a b)))\n  (Z.lt (unsigned (or a b)) (two_p (Z.max (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (or a b)))\n  (Z.lt (unsigned (or a b)) (two_p (Z.max (size a) (size b))))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- size_or .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (or a b)))\n  (Z.lt (unsigned (or a b)) (two_p (Z.max (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (or a b)))\n  (Z.lt (unsigned (or a b)) (two_p (size (or a b))))"
            ]
        },
        {
            "tactic_sig": "apply size_interval_1 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (or a b)))\n  (Z.lt (unsigned (or a b)) (two_p (size (or a b))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int, Z.le (size (xor a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Z.le (size (xor a b)) (Z.max (size a) (size b))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "assert ( 0 <= Z.max ( size _ ) ( size _ ) ) .",
            "tactic_args": [
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.max (size a) (size b))",
                "H : Z.le Z0 (Z.max (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "generalize ( size_range _ ) ( size_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.max (size a) (size b))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nZ.le Z0 (Z.max (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le Z0 (size a)) (Z.le (size a) zwordsize))\n  (_ : Logic.and (Z.le Z0 (size b)) (Z.le (size b) zwordsize)),\nZ.le Z0 (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : forall (_ : Logic.and (Z.le Z0 z) (Z.le z zwordsize))\n  (_ : Logic.and (Z.le Z0 z0) (Z.le z0 zwordsize)), \nZ.le Z0 z1",
                "H : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z0))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z))",
                "z1 : Z",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall (_ : Logic.and (Z.le Z0 z) (Z.le z zwordsize))\n  (_ : Logic.and (Z.le Z0 z0) (Z.le z0 zwordsize)), \nZ.le Z0 z1"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_size_3 .",
            "tactic_args": [
                "_goal : Z.le (size (xor a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.max (size a) (size b))",
                "_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Z.max (size a) (size b)) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor a b) i) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.max (size a) (size b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z)\n  (_ : Logic.and (Z.le (Z.max (size a) (size b)) i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (xor a b) i) false",
                "H0 : Logic.and (Z.le (Z.max (size a) (size b)) i) (Z.lt i zwordsize)",
                "i : Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_xor .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (xor a b) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb (testbit a i) (testbit b i)) false",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite !bits_size_2 .",
            "tactic_args": [
                "_goal : Logic.eq (xorb (testbit a i) (testbit b i)) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xorb false false) false",
                "_goal : Z.le (size b) i",
                "_goal : Z.le (size a) i"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (xorb false false) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : Z.le (size b) i"
            ],
            "tactic_res": [
                "_goal : Z.le z0 i",
                "H1 : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z0))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z))",
                "H0 : Logic.and (Z.le z1 i) (Z.lt i zwordsize)",
                "H : Z.le Z0 z1",
                "z1 : Z",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "zify .",
            "tactic_args": [
                "_goal : Z.le (size a) i"
            ],
            "tactic_res": [
                "_goal : Z.le z i",
                "H1 : Logic.or (Logic.and (Z.lt z z0) (Logic.eq z1 z0))\n  (Logic.and (Z.le z0 z) (Logic.eq z1 z))",
                "H0 : Logic.and (Z.le z1 i) (Z.lt i zwordsize)",
                "H : Z.le Z0 z1",
                "z1 : Z",
                "Heqz0 : Logic.eq z0 (size b)",
                "z0 : Z",
                "Heqz : Logic.eq z (size a)",
                "z : Z"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le z i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a b : int,\nLogic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))",
                "a : int",
                "b : int"
            ]
        },
        {
            "tactic_sig": "generalize ( size_interval_1 ( xor _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (xor a b)))\n        (Z.lt (unsigned (xor a b)) (two_p (size (xor a b)))),\nLogic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (unsigned (xor a b)))\n        (Z.lt (unsigned (xor a b)) (two_p (size (xor a b)))),\nLogic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))",
                "H : Logic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (size (xor a b))))"
            ]
        },
        {
            "tactic_sig": "assert ( two_p ( size ( xor _ _ ) ) <= two_p ( Z.max ( size _ ) ( size _ ) ) ) .",
            "tactic_args": [
                "a : int",
                "b : int",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : Z.le (two_p (size (xor a b))) (two_p (Z.max (size a) (size b)))",
                "H0 : Z.le (two_p (size (xor a b))) (two_p (Z.max (size a) (size b)))"
            ]
        },
        {
            "tactic_sig": "apply two_p_monotone .",
            "tactic_args": [
                "_goal : Z.le (two_p (size (xor a b))) (two_p (Z.max (size a) (size b)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (size (xor a b)))\n  (Z.le (size (xor a b)) (Z.max (size a) (size b)))"
            ]
        },
        {
            "tactic_sig": "split .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (size (xor a b)))\n  (Z.le (size (xor a b)) (Z.max (size a) (size b)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (size (xor a b))",
                "_goal : Z.le (size (xor a b)) (Z.max (size a) (size b))"
            ]
        },
        {
            "tactic_sig": "generalize ( size_range ( xor _ _ ) ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (size (xor a b))",
                "a : int",
                "b : int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (size (xor a b)))\n        (Z.le (size (xor a b)) zwordsize), Z.le Z0 (size (xor a b))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (size (xor a b)))\n        (Z.le (size (xor a b)) zwordsize), Z.le Z0 (size (xor a b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply size_xor .",
            "tactic_args": [
                "_goal : Z.le (size (xor a b)) (Z.max (size a) (size b))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned (xor a b)))\n  (Z.lt (unsigned (xor a b)) (two_p (Z.max (size a) (size b))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold wordsize .",
            "tactic_args": [
                "_goal : not (eq wordsize O)"
            ],
            "tactic_res": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "exists ( two_p ( 32 - 5 ) ) .",
            "tactic_args": [
                "_goal : Z.divide (Z.of_nat Int.wordsize) Int.modulus"
            ],
            "tactic_res": [
                "_goal : eq Int.modulus\n  (Z.mul\n     (two_p\n        (Z.sub (Zpos (xO (xO (xO (xO (xO xH)))))) (Zpos (xI (xO xH)))))\n     (Z.of_nat Int.wordsize))"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : eq Int.modulus\n  (Z.mul\n     (two_p\n        (Z.sub (Zpos (xO (xO (xO (xO (xO xH)))))) (Zpos (xI (xO xH)))))\n     (Z.of_nat Int.wordsize))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold wordsize .",
            "tactic_args": [
                "_goal : not (eq wordsize O)"
            ],
            "tactic_res": [
                "_goal : not (eq (S (S (S (S (S (S (S (S O)))))))) O)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : not (eq (S (S (S (S (S (S (S (S O)))))))) O)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold wordsize .",
            "tactic_args": [
                "_goal : not (eq wordsize O)"
            ],
            "tactic_res": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n     O)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n     O)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' x y) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' x y) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shl' .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' x y) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftl (unsigned x) (Int.unsigned y))) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftl (unsigned x) (Int.unsigned y))) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit x (Z.sub i (Int.unsigned y)))",
                "i : Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i) false",
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i)\n  (testbit x (Z.sub i (Int.unsigned y)))",
                "l : Z.lt i (Int.unsigned y)",
                "g : Z.ge i (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply Z.shiftl_spec_low .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i) false"
            ],
            "tactic_res": [
                "_goal : Z.lt i (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt i (Int.unsigned y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z.shiftl_spec_high .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftl (unsigned x) (Int.unsigned y)) i)\n  (testbit x (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 i",
                "_goal : Z.le (Int.unsigned y) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned y) i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' x y) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' x y) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shru' .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' x y) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (unsigned x) (Int.unsigned y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (unsigned x) (Int.unsigned y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (unsigned x) (Int.unsigned y)) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (unsigned x) (Int.unsigned y)) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "fold ( testbit _ ( _ + Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned x) (Z.add i (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)",
                "x : int",
                "i : Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit x (Z.add i (Int.unsigned y))\n   else false)",
                "i : Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y)))\n  (testbit x (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y))) false",
                "l : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y)))\n  (testbit x (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply bits_above .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.add i (Int.unsigned y))) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' x y) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' x y) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : Z",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shr' .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' x y) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (signed x) (Int.unsigned y))) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (repr (Z.shiftr (signed x) (Int.unsigned y))) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (signed x) (Int.unsigned y)) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Z.shiftr_spec .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (Z.shiftr (signed x) (Int.unsigned y)) i)\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (signed x) (Z.add i (Int.unsigned y)))\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Z.le Z0 i"
            ]
        },
        {
            "tactic_sig": "apply bits_signed .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (signed x) (Z.add i (Int.unsigned y)))\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Z.le Z0 (Z.add i (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Z.add i (Int.unsigned y))",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.lt (Int.unsigned y) Int.modulus),\nZ.le Z0 (Z.add i (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.lt (Int.unsigned y) Int.modulus),\nZ.le Z0 (Z.add i (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int),\nLogic.eq (shl' x y) (mul x (repr (two_p (Int.unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' x y) (mul x (repr (two_p (Int.unsigned y))))",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shl' , mul .",
            "tactic_args": [
                "_goal : Logic.eq (shl' x y) (mul x (repr (two_p (Int.unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y))))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.shiftl (unsigned x) (Int.unsigned y))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y)))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zshiftl_mul_two_p .",
            "tactic_args": [
                "_goal : eqm (Z.shiftl (unsigned x) (Int.unsigned y))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y)))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned x) (two_p (Int.unsigned y)))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y)))))",
                "_goal : Z.le Z0 (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply eqm_mult .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned x) (two_p (Int.unsigned y)))\n  (Z.mul (unsigned x) (unsigned (repr (two_p (Int.unsigned y)))))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned x) (unsigned x)",
                "_goal : eqm (two_p (Int.unsigned y)) (unsigned (repr (two_p (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (unsigned x) (unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (two_p (Int.unsigned y)) (unsigned (repr (two_p (Int.unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.le Z0 (Int.unsigned y)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.lt (Int.unsigned y) Int.modulus), Z.le Z0 (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.lt (Int.unsigned y) Int.modulus), Z.le Z0 (Int.unsigned y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall y : Int.int,\nLogic.eq (shl' one y) (repr (two_p (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' one y) (repr (two_p (Int.unsigned y)))",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite shl'_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl' one y) (repr (two_p (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul one (repr (two_p (Int.unsigned y))))\n  (repr (two_p (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_commut .",
            "tactic_args": [
                "_goal : Logic.eq (mul one (repr (two_p (Int.unsigned y))))\n  (repr (two_p (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (repr (two_p (Int.unsigned y))) one)\n  (repr (two_p (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite mul_one .",
            "tactic_args": [
                "_goal : Logic.eq (mul (repr (two_p (Int.unsigned y))) one)\n  (repr (two_p (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (two_p (Int.unsigned y)))\n  (repr (two_p (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (two_p (Int.unsigned y)))\n  (repr (two_p (Int.unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int),\nLogic.eq (shl' x y) (mul x (shl' one y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' x y) (mul x (shl' one y))",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite shl'_one_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl' x y) (mul x (shl' one y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' x y) (mul x (repr (two_p (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "apply shl'_mul_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (shl' x y) (mul x (repr (two_p (Int.unsigned y))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shl' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' x Int.zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shl' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned Int.zero))) x"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned Int.zero))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) Z0)) x"
            ]
        },
        {
            "tactic_sig": "unfold Z.shiftl .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) Z0)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shru' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' x Int.zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned Int.zero))) x"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned Int.zero))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) Z0)) x"
            ]
        },
        {
            "tactic_sig": "unfold Z.shiftr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) Z0)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Z.opp Z0))) x"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Z.opp Z0))) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shr' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' x Int.zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "unfold shr' .",
            "tactic_args": [
                "_goal : Logic.eq (shr' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned Int.zero))) x"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_zero .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned Int.zero))) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) Z0)) x"
            ]
        },
        {
            "tactic_sig": "unfold Z.shiftr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) Z0)) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (signed x) (Z.opp Z0))) x"
            ]
        },
        {
            "tactic_sig": "apply repr_signed .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (signed x) (Z.opp Z0))) x"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq (shrx' x Int.zero) x"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx' x Int.zero) x",
                "x : int"
            ]
        },
        {
            "tactic_sig": "change ( shrx' _ Int.zero ) with ( shrx _ zero ) .",
            "tactic_args": [
                "_goal : Logic.eq (shrx' x Int.zero) x",
                "x : int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx x zero) x"
            ]
        },
        {
            "tactic_sig": "apply shrx_zero .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x zero) x"
            ],
            "tactic_res": [
                "_goal : Z.gt zwordsize (Zpos xH)"
            ]
        },
        {
            "tactic_sig": "compute .",
            "tactic_args": [
                "_goal : Z.gt zwordsize (Zpos xH)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  match\n    match Wordsize_64.wordsize with\n    | O => Z0\n    | S n =>\n        Zpos\n          ((fix of_succ_nat (n0 : nat) : positive :=\n              match n0 with\n              | O => xH\n              | S x =>\n                  (fix succ (x0 : positive) : positive :=\n                     match x0 with\n                     | xI p => xO (succ p)\n                     | xO p => xI p\n                     | xH => xO xH\n                     end) (of_succ_nat x)\n              end) n)\n    end\n  with\n  | Zpos (xI _) | Zpos (xO _) => Gt\n  | Zpos xH => Eq\n  | _ => Lt\n  end Gt"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  match\n    match Wordsize_64.wordsize with\n    | O => Z0\n    | S n =>\n        Zpos\n          ((fix of_succ_nat (n0 : nat) : positive :=\n              match n0 with\n              | O => xH\n              | S x =>\n                  (fix succ (x0 : positive) : positive :=\n                     match x0 with\n                     | xI p => xO (succ p)\n                     | xO p => xI p\n                     | xH => xO xH\n                     end) (of_succ_nat x)\n              end) n)\n    end\n  with\n  | Zpos (xI _) | Zpos (xO _) => Gt\n  | Zpos xH => Eq\n  | _ => Lt\n  end Gt"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int)\n  (_ : Logic.eq\n         (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true),\nLogic.eq (shrx' x y) (add (shr' x y) (shr_carry' x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx' x y) (add (shr' x y) (shr_carry' x y))",
                "H : Logic.eq (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y)\n     (Int.unsigned (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned ( Int.repr 63 ) ) with 63 in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y)\n     (Int.unsigned (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Zpos (xI (xI (xI (xI (xI xH)))))))"
            ]
        },
        {
            "tactic_sig": "set ( y1 := Int64.repr ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "y : Int.int"
            ],
            "tactic_res": [
                "y1 : int"
            ]
        },
        {
            "tactic_sig": "assert ( U : unsigned _ = Int.unsigned _ ) .",
            "tactic_args": [
                "y1 : int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned y1) (Int.unsigned y)",
                "U : Logic.eq (unsigned y1) (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned y1) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.le (Int.unsigned y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( 63 < max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Z.lt (Zpos (xI (xI (xI (xI (xI xH)))))) max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.le (Int.unsigned y) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( shrx _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shrx' x y) (add (shr' x y) (shr_carry' x y))",
                "x : int",
                "y1 : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx' x y) (shrx x y1)",
                "_goal : Logic.eq (shrx x y1) (add (shr' x y) (shr_carry' x y))"
            ]
        },
        {
            "tactic_sig": "unfold shrx' , shrx , shl' , shl .",
            "tactic_args": [
                "_goal : Logic.eq (shrx' x y) (shrx x y1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (divs x (repr (Z.shiftl (unsigned one) (unsigned y1))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (divs x (repr (Z.shiftl (unsigned one) (unsigned y1))))",
                "U : Logic.eq (unsigned y1) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite shrx_carry .",
            "tactic_args": [
                "_goal : Logic.eq (shrx x y1) (add (shr' x y) (shr_carry' x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (shr x y1) (shr_carry x y1))\n  (add (shr' x y) (shr_carry' x y))",
                "_goal : Logic.eq (ltu y1 (repr (Z.sub zwordsize (Zpos xH)))) true"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (add (shr x y1) (shr_carry x y1))\n  (add (shr' x y) (shr_carry' x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr x y1) (shr' x y)",
                "_goal : Logic.eq (shr_carry x y1) (shr_carry' x y)"
            ]
        },
        {
            "tactic_sig": "unfold shr , shr' .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y1) (shr' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y1)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y1)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))",
                "U : Logic.eq (unsigned y1) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned y)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned y)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shr_carry , shr_carry' , shl , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shr_carry x y1) (shr_carry' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (unsigned y1))) one))\n            zero))\n   then one\n   else zero)\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (unsigned y1))) one))\n            zero))\n   then one\n   else zero)\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)",
                "U : Logic.eq (unsigned y1) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)\n  (if\n    andb (lt x zero)\n      (negb\n         (eq\n            (and x\n               (sub (repr (Z.shiftl (unsigned one) (Int.unsigned y)))\n                  one)) zero))\n   then one\n   else zero)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y1 (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned y1) (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned y1) (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned y1) (unsigned (repr (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned y1) (unsigned (repr (Z.sub zwordsize (Zpos xH))))",
                "U : Logic.eq (unsigned y1) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned y) (unsigned (repr (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned y) (unsigned (repr (Z.sub zwordsize (Zpos xH))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y : Int.int)\n  (_ : Logic.eq\n         (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true),\nLogic.eq (shrx' x y)\n  (shr'\n     (add x\n        (shru' (shr' x (Int.repr (Zpos (xI (xI (xI (xI (xI xH))))))))\n           (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n              y))) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shrx' x y)\n  (shr'\n     (add x\n        (shru' (shr' x (Int.repr (Zpos (xI (xI (xI (xI (xI xH))))))))\n           (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n              y))) y)",
                "H : Logic.eq (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true",
                "y : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "set ( z := repr ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "y : Int.int"
            ],
            "tactic_res": [
                "z : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu y (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))) true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y)\n     (Int.unsigned (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned ( Int.repr 63 ) ) with 63 in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y)\n     (Int.unsigned (Int.repr (Zpos (xI (xI (xI (xI (xI xH)))))))))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Zpos (xI (xI (xI (xI (xI xH)))))))"
            ]
        },
        {
            "tactic_sig": "assert ( N1 : 63 < max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "N1 : Z.lt (Zpos (xI (xI (xI (xI (xI xH)))))) max_unsigned"
            ]
        },
        {
            "tactic_sig": "assert ( N2 : 63 < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "N2 : Z.lt (Zpos (xI (xI (xI (xI (xI xH)))))) Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "assert ( A : unsigned _ = Int.unsigned _ ) .",
            "tactic_args": [
                "z : int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned z) (Int.unsigned y)",
                "A : Logic.eq (unsigned z) (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned z) (Int.unsigned y)",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Int.unsigned y))) (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Int.unsigned y))) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.le (Int.unsigned y) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.le (Int.unsigned y) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( B : unsigned ( sub ( repr 64 ) _ ) = Int.unsigned ( Int.sub ( Int.repr 64 ) _ ) ) .",
            "tactic_args": [
                "z : int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) z))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))",
                "B : Logic.eq\n  (unsigned (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) z))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))"
            ]
        },
        {
            "tactic_sig": "unfold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) z))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n        (repr (Int.unsigned y))))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))"
            ]
        },
        {
            "tactic_sig": "unfold sub , Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n        (repr (Int.unsigned y))))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub\n           (unsigned (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub\n           (Int.unsigned\n              (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "change ( unsigned ( repr 64 ) ) with 64 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub\n           (unsigned (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub\n           (Int.unsigned\n              (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (Int.unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH)))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub\n           (Int.unsigned\n              (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned ( Int.repr 64 ) ) with 64 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH)))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub\n           (Int.unsigned\n              (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))))\n           (Int.unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH)))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite ( unsigned_repr ( Int.unsigned _ ) ) by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH)))))))\n           (unsigned (repr (Int.unsigned y))))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr , Int.unsigned_repr by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))\n  (Int.unsigned\n     (Int.repr\n        (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))\n  (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))\n  (Z.sub (Zpos (xO (xO (xO (xO (xO (xO xH))))))) (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shrx' , shr' , shru' , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shrx' x y)\n  (shr'\n     (add x\n        (shru' (shr' x (Int.repr (Zpos (xI (xI (xI (xI (xI xH))))))))\n           (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n              y))) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (Int.unsigned\n                                (Int.repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (Int.unsigned y))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (Int.unsigned\n                                (Int.repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (Int.unsigned y)))",
                "A : Logic.eq (unsigned z) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (Int.unsigned\n                                (Int.repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (unsigned z)))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned ( Int.repr 63 ) ) with ( unsigned ( repr 63 ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (Int.unsigned\n                                (Int.repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (unsigned z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (unsigned\n                                (repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (unsigned z)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (unsigned\n                                (repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (Int.unsigned\n                       (Int.sub\n                          (Int.repr\n                             (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))))))\n        (unsigned z)))",
                "B : Logic.eq\n  (unsigned (sub (repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) z))\n  (Int.unsigned\n     (Int.sub (Int.repr (Zpos (xO (xO (xO (xO (xO (xO xH)))))))) y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (unsigned\n                                (repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (unsigned\n                       (sub\n                          (repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n                          z)))))) (unsigned z)))"
            ]
        },
        {
            "tactic_sig": "apply shrx_shr_2 .",
            "tactic_args": [
                "_goal : Logic.eq (divs x (repr (Z.shiftl (unsigned one) (unsigned z))))\n  (repr\n     (Z.shiftr\n        (signed\n           (add x\n              (repr\n                 (Z.shiftr\n                    (unsigned\n                       (repr\n                          (Z.shiftr (signed x)\n                             (unsigned\n                                (repr\n                                   (Zpos (xI (xI (xI (xI (xI xH)))))))))))\n                    (unsigned\n                       (sub\n                          (repr (Zpos (xO (xO (xO (xO (xO (xO xH))))))))\n                          z)))))) (unsigned z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu z (repr (Z.sub zwordsize (Zpos xH)))) true"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu z (repr (Z.sub zwordsize (Zpos xH)))) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned z) (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned z) (unsigned (repr (Z.sub zwordsize (Zpos xH))))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned z) (unsigned (repr (Z.sub zwordsize (Zpos xH))))"
            ]
        },
        {
            "tactic_sig": "change ( unsigned _ < 63 ) .",
            "tactic_args": [
                "_goal : Z.lt (unsigned z) (unsigned (repr (Z.sub zwordsize (Zpos xH))))",
                "z : int"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned z) (Zpos (xI (xI (xI (xI (xI xH))))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned z) (Zpos (xI (xI (xI (xI (xI xH))))))",
                "A : Logic.eq (unsigned z) (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned y) (Zpos (xI (xI (xI (xI (xI xH))))))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned y) (Zpos (xI (xI (xI (xI (xI xH))))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (y z : Int.int) (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true)\n  (_ : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')),\nlet y' := repr (Int.unsigned y) in\nlet z' := repr (Int.unsigned z) in\nLogic.and (Logic.eq (Int.unsigned y) (unsigned y'))\n  (Logic.and (Logic.eq (Int.unsigned z) (unsigned z'))\n     (Logic.and (Logic.eq (ltu y' iwordsize) true)\n        (Logic.and (Logic.eq (ltu z' iwordsize) true)\n           (Logic.and\n              (Logic.eq (Int.unsigned (Int.add y z))\n                 (unsigned (add y' z')))\n              (Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Logic.eq (Int.unsigned y) (unsigned y'))\n  (Logic.and (Logic.eq (Int.unsigned z) (unsigned z'))\n     (Logic.and (Logic.eq (ltu y' iwordsize) true)\n        (Logic.and (Logic.eq (ltu z' iwordsize) true)\n           (Logic.and\n              (Logic.eq (Int.unsigned (Int.add y z))\n                 (unsigned (add y' z')))\n              (Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z))))))))",
                "z' : int",
                "y' : int",
                "H1 : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H0 : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z))\n  (Z.lt (Int.unsigned z) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with 64 in * .",
            "tactic_args": [],
            "tactic_res": [
                "H1 : Z.le (Int.unsigned (Int.add y z))\n  (Zpos (xO (xO (xO (xO (xO (xO xH)))))))",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z))\n  (Z.lt (Int.unsigned z) (Zpos (xO (xO (xO (xO (xO (xO xH))))))))",
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Zpos (xO (xO (xO (xO (xO (xO xH))))))))"
            ]
        },
        {
            "tactic_sig": "assert ( 128 < max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt (Zpos (xO (xO (xO (xO (xO (xO (xO xH)))))))) max_unsigned"
            ]
        },
        {
            "tactic_sig": "assert ( 128 < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H3 : Z.lt (Zpos (xO (xO (xO (xO (xO (xO (xO xH)))))))) Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "assert ( Y : unsigned _ = Int.unsigned _ ) by ( apply unsigned_repr ; omega ) .",
            "tactic_args": [
                "y' : int",
                "y : Int.int"
            ],
            "tactic_res": [
                "Y : Logic.eq (unsigned y') (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "assert ( Z : unsigned _ = Int.unsigned _ ) by ( apply unsigned_repr ; omega ) .",
            "tactic_args": [
                "z' : int",
                "z : Int.int"
            ],
            "tactic_res": [
                "Z : Logic.eq (unsigned z') (Int.unsigned z)"
            ]
        },
        {
            "tactic_sig": "assert ( P : Int.unsigned ( Int.add _ _ ) = unsigned ( add _ _ ) ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))",
                "P : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ]
        },
        {
            "tactic_sig": "unfold Int.add .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned y) (Int.unsigned z))))\n  (unsigned (add y' z'))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned y) (Int.unsigned z))))\n  (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (unsigned (add y' z'))"
            ]
        },
        {
            "tactic_sig": "unfold add .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (unsigned (repr (Z.add (unsigned y') (unsigned z'))))"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (unsigned (repr (Z.add (unsigned y') (unsigned z'))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (Z.add (unsigned y') (unsigned z'))"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Int.unsigned y) (Int.unsigned z))\n  (Z.add (unsigned y') (unsigned z'))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intuition auto .",
            "tactic_args": [
                "_goal : Logic.and (Logic.eq (Int.unsigned y) (unsigned y'))\n  (Logic.and (Logic.eq (Int.unsigned z) (unsigned z'))\n     (Logic.and (Logic.eq (ltu y' iwordsize) true)\n        (Logic.and (Logic.eq (ltu z' iwordsize) true)\n           (Logic.and\n              (Logic.eq (Int.unsigned (Int.add y z))\n                 (unsigned (add y' z')))\n              (Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y' iwordsize) true",
                "_goal : Logic.eq (ltu z' iwordsize) true",
                "_goal : Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z)))",
                "H6 : Z.lt (Int.unsigned z) (Zpos (xO (xO (xO (xO (xO (xO xH)))))))",
                "H : Z.le Z0 (Int.unsigned z)",
                "H5 : Z.lt (Int.unsigned y) (Zpos (xO (xO (xO (xO (xO (xO xH)))))))",
                "H4 : Z.le Z0 (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y' iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned y') (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned y') (unsigned iwordsize)",
                "Y : Logic.eq (unsigned y') (Int.unsigned y)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned y) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned y) (unsigned iwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (ltu z' iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned z') (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned z') (unsigned iwordsize)",
                "Z : Logic.eq (unsigned z') (Int.unsigned z)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned z) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned z) (unsigned iwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z)))",
                "P : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add y' z') (repr (unsigned (add y' z')))"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (add y' z') (repr (unsigned (add y' z')))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add y' z') (add y' z')"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (add y' z') (add y' z')"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true)\n  (_ : Logic.eq (Int.add y z) iwordsize'),\nLogic.eq (ror x (repr (Int.unsigned z))) (or (shl' x y) (shru' x z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z))) (or (shl' x y) (shru' x z))",
                "H1 : Logic.eq (Int.add y z) iwordsize'",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( int_ltu_2_inv _ _ ) as ( A & B & C & D & E & F ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true",
                "_goal : Logic.eq (Int.ltu z iwordsize') true",
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "F : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add (repr (Int.unsigned y)) (repr (Int.unsigned z))))",
                "D : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true",
                "C : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned (repr (Int.unsigned z)))",
                "A : Logic.eq (Int.unsigned y) (unsigned (repr (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "H1 : Logic.eq (Int.add y z) iwordsize'"
            ],
            "tactic_res": [
                "_goal : Z.le (Int.unsigned iwordsize') (Int.unsigned iwordsize')"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned iwordsize') (Int.unsigned iwordsize')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "replace ( shl' _ _ ) with ( shl _ ( repr ( Int.unsigned _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z))) (or (shl' x y) (shru' x z))",
                "x : int",
                "y : Int.int",
                "x : int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z)))\n  (or (shl x (repr (Int.unsigned y))) (shru' x z))",
                "_goal : Logic.eq (shl x (repr (Int.unsigned y))) (shl' x y)"
            ]
        },
        {
            "tactic_sig": "replace ( shru' _ _ ) with ( shru _ ( repr ( Int.unsigned _ ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z)))\n  (or (shl x (repr (Int.unsigned y))) (shru' x z))",
                "x : int",
                "z : Int.int",
                "x : int",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z)))\n  (or (shl x (repr (Int.unsigned y))) (shru x (repr (Int.unsigned z))))",
                "_goal : Logic.eq (shru x (repr (Int.unsigned z))) (shru' x z)"
            ]
        },
        {
            "tactic_sig": "apply or_ror .",
            "tactic_args": [
                "_goal : Logic.eq (ror x (repr (Int.unsigned z)))\n  (or (shl x (repr (Int.unsigned y))) (shru x (repr (Int.unsigned z))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true",
                "_goal : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true",
                "_goal : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  iwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  iwordsize",
                "F : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "H1 : Logic.eq (Int.add y z) iwordsize'"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int.unsigned iwordsize')) iwordsize"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int.unsigned iwordsize')) iwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shru , shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru x (repr (Int.unsigned z))) (shru' x z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.shiftr (unsigned x) (unsigned (repr (Int.unsigned z)))))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.shiftr (unsigned x) (unsigned (repr (Int.unsigned z)))))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned z)))",
                "B : Logic.eq (Int.unsigned z) (unsigned (repr (Int.unsigned z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned z)))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned z)))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shl , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shl x (repr (Int.unsigned y))) (shl' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr (Z.shiftl (unsigned x) (unsigned (repr (Int.unsigned y)))))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr (Z.shiftl (unsigned x) (unsigned (repr (Int.unsigned y)))))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))",
                "A : Logic.eq (Int.unsigned y) (unsigned (repr (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true)\n  (_ : Logic.eq (Int.ltu (Int.add y z) iwordsize') true),\nLogic.eq (shl' (shl' x y) z) (shl' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (shl' x y) z) (shl' x (Int.add y z))",
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true"
            ],
            "tactic_res": [
                "H1 : Logic.and (Z.le Z0 (Int.unsigned (Int.add y z)))\n  (Z.lt (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "destruct ( int_ltu_2_inv _ _ ) as ( A & B & C & D & E & F ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true",
                "_goal : Logic.eq (Int.ltu z iwordsize') true",
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "F : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add (repr (Int.unsigned y)) (repr (Int.unsigned z))))",
                "D : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true",
                "C : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned (repr (Int.unsigned z)))",
                "A : Logic.eq (Int.unsigned y) (unsigned (repr (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( y' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "y : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add y' (repr (Int.unsigned z))))",
                "C : Logic.eq (ltu y' iwordsize) true",
                "A : Logic.eq (Int.unsigned y) (unsigned y')",
                "y' : int"
            ]
        },
        {
            "tactic_sig": "set ( z' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "z : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))",
                "D : Logic.eq (ltu z' iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned z')",
                "z' : int"
            ]
        },
        {
            "tactic_sig": "replace ( shl' _ _ ) with ( shl _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (shl' x y) z) (shl' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "x : int",
                "y' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (shl x y') z) (shl' x (Int.add y z))",
                "_goal : Logic.eq (shl x y') (shl' x y)"
            ]
        },
        {
            "tactic_sig": "replace ( shl' ( shl _ _ ) _ ) with ( shl ( shl _ _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (shl x y') z) (shl' x (Int.add y z))",
                "x : int",
                "y' : int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (shl x y') z') (shl' x (Int.add y z))",
                "_goal : Logic.eq (shl (shl x y') z') (shl' (shl x y') z)"
            ]
        },
        {
            "tactic_sig": "replace ( shl' _ ( Int.add _ _ ) ) with ( shl _ ( add _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl (shl x y') z') (shl' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl (shl x y') z') (shl x (add y' z'))",
                "_goal : Logic.eq (shl x (add y' z')) (shl' x (Int.add y z))"
            ]
        },
        {
            "tactic_sig": "apply shl_shl .",
            "tactic_args": [
                "_goal : Logic.eq (shl (shl x y') z') (shl x (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y' iwordsize) true",
                "_goal : Logic.eq (ltu z' iwordsize) true",
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu z' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "change ( unsigned iwordsize ) with zwordsize .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shl , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shl x (add y' z')) (shl' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned (Int.add y z))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned (Int.add y z))))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftl (unsigned x) (unsigned (add y' z'))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shl at 1 , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shl (shl x y') z') (shl' (shl x y') z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned (shl x y')) (unsigned z')))\n  (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned (shl x y')) (unsigned z')))\n  (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))",
                "B : Logic.eq (Int.unsigned z) (unsigned z')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))\n  (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))\n  (repr (Z.shiftl (unsigned (shl x y')) (Int.unsigned z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shl , shl' .",
            "tactic_args": [
                "_goal : Logic.eq (shl x y') (shl' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned y')))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (unsigned y')))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))",
                "A : Logic.eq (Int.unsigned y) (unsigned y')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftl (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftl (unsigned x) (Int.unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true)\n  (_ : Logic.eq (Int.ltu (Int.add y z) iwordsize') true),\nLogic.eq (shru' (shru' x y) z) (shru' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shru' x y) z) (shru' x (Int.add y z))",
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true"
            ],
            "tactic_res": [
                "H1 : Logic.and (Z.le Z0 (Int.unsigned (Int.add y z)))\n  (Z.lt (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "destruct ( int_ltu_2_inv _ _ ) as ( A & B & C & D & E & F ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true",
                "_goal : Logic.eq (Int.ltu z iwordsize') true",
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "F : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add (repr (Int.unsigned y)) (repr (Int.unsigned z))))",
                "D : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true",
                "C : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned (repr (Int.unsigned z)))",
                "A : Logic.eq (Int.unsigned y) (unsigned (repr (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( y' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "y : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add y' (repr (Int.unsigned z))))",
                "C : Logic.eq (ltu y' iwordsize) true",
                "A : Logic.eq (Int.unsigned y) (unsigned y')",
                "y' : int"
            ]
        },
        {
            "tactic_sig": "set ( z' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "z : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))",
                "D : Logic.eq (ltu z' iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned z')",
                "z' : int"
            ]
        },
        {
            "tactic_sig": "replace ( shru' _ _ ) with ( shru _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shru' x y) z) (shru' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "x : int",
                "y' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shru x y') z) (shru' x (Int.add y z))",
                "_goal : Logic.eq (shru x y') (shru' x y)"
            ]
        },
        {
            "tactic_sig": "replace ( shru' ( shru _ _ ) _ ) with ( shru ( shru _ _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shru x y') z) (shru' x (Int.add y z))",
                "x : int",
                "y' : int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shru x y') z') (shru' x (Int.add y z))",
                "_goal : Logic.eq (shru (shru x y') z') (shru' (shru x y') z)"
            ]
        },
        {
            "tactic_sig": "replace ( shru' _ ( Int.add _ _ ) ) with ( shru _ ( add _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shru x y') z') (shru' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru (shru x y') z') (shru x (add y' z'))",
                "_goal : Logic.eq (shru x (add y' z')) (shru' x (Int.add y z))"
            ]
        },
        {
            "tactic_sig": "apply shru_shru .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shru x y') z') (shru x (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y' iwordsize) true",
                "_goal : Logic.eq (ltu z' iwordsize) true",
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu z' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "change ( unsigned iwordsize ) with zwordsize .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shru , shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru x (add y' z')) (shru' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned (Int.add y z))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned (Int.add y z))))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (unsigned x) (unsigned (add y' z'))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shru at 1 , shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru (shru x y') z') (shru' (shru x y') z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned (shru x y')) (unsigned z')))\n  (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned (shru x y')) (unsigned z')))\n  (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))",
                "B : Logic.eq (Int.unsigned z) (unsigned z')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))\n  (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))\n  (repr (Z.shiftr (unsigned (shru x y')) (Int.unsigned z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shru , shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru x y') (shru' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned y')))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (unsigned y')))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned y)))",
                "A : Logic.eq (Int.unsigned y) (unsigned y')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned y)))\n  (repr (Z.shiftr (unsigned x) (Int.unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true)\n  (_ : Logic.eq (Int.ltu (Int.add y z) iwordsize') true),\nLogic.eq (shr' (shr' x y) z) (shr' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shr' x y) z) (shr' x (Int.add y z))",
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H1 : Logic.eq (Int.ltu (Int.add y z) iwordsize') true"
            ],
            "tactic_res": [
                "H1 : Logic.and (Z.le Z0 (Int.unsigned (Int.add y z)))\n  (Z.lt (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "destruct ( int_ltu_2_inv _ _ ) as ( A & B & C & D & E & F ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true",
                "_goal : Logic.eq (Int.ltu z iwordsize') true",
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')",
                "F : Logic.eq (add (repr (Int.unsigned y)) (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add (repr (Int.unsigned y)) (repr (Int.unsigned z))))",
                "D : Logic.eq (ltu (repr (Int.unsigned z)) iwordsize) true",
                "C : Logic.eq (ltu (repr (Int.unsigned y)) iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned (repr (Int.unsigned z)))",
                "A : Logic.eq (Int.unsigned y) (unsigned (repr (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.le (Int.unsigned (Int.add y z)) (Int.unsigned iwordsize')"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "set ( y' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "y : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' (repr (Int.unsigned z)))\n  (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z))\n  (unsigned (add y' (repr (Int.unsigned z))))",
                "C : Logic.eq (ltu y' iwordsize) true",
                "A : Logic.eq (Int.unsigned y) (unsigned y')",
                "y' : int"
            ]
        },
        {
            "tactic_sig": "set ( z' := repr ( Int.unsigned _ ) ) in * .",
            "tactic_args": [
                "z : Int.int"
            ],
            "tactic_res": [
                "F : Logic.eq (add y' z') (repr (Int.unsigned (Int.add y z)))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))",
                "D : Logic.eq (ltu z' iwordsize) true",
                "B : Logic.eq (Int.unsigned z) (unsigned z')",
                "z' : int"
            ]
        },
        {
            "tactic_sig": "replace ( shr' _ _ ) with ( shr _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shr' x y) z) (shr' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "x : int",
                "y' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shr x y') z) (shr' x (Int.add y z))",
                "_goal : Logic.eq (shr x y') (shr' x y)"
            ]
        },
        {
            "tactic_sig": "replace ( shr' ( shr _ _ ) _ ) with ( shr ( shr _ _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shr x y') z) (shr' x (Int.add y z))",
                "x : int",
                "y' : int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shr x y') z') (shr' x (Int.add y z))",
                "_goal : Logic.eq (shr (shr x y') z') (shr' (shr x y') z)"
            ]
        },
        {
            "tactic_sig": "replace ( shr' _ ( Int.add _ _ ) ) with ( shr _ ( add _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shr x y') z') (shr' x (Int.add y z))",
                "x : int",
                "y : Int.int",
                "z : Int.int",
                "x : int",
                "y' : int",
                "z' : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr (shr x y') z') (shr x (add y' z'))",
                "_goal : Logic.eq (shr x (add y' z')) (shr' x (Int.add y z))"
            ]
        },
        {
            "tactic_sig": "apply shr_shr .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shr x y') z') (shr x (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu y' iwordsize) true",
                "_goal : Logic.eq (ltu z' iwordsize) true",
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu y' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (ltu z' iwordsize) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (add y' z') iwordsize) true"
            ],
            "tactic_res": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Z.lt (unsigned (add y' z')) (unsigned iwordsize)",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ]
        },
        {
            "tactic_sig": "change ( unsigned iwordsize ) with zwordsize .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) (unsigned iwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned (Int.add y z)) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shr , shr' .",
            "tactic_args": [
                "_goal : Logic.eq (shr x (add y' z')) (shr' x (Int.add y z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (signed x) (Int.unsigned (Int.add y z))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (signed x) (Int.unsigned (Int.add y z))))",
                "E : Logic.eq (Int.unsigned (Int.add y z)) (unsigned (add y' z'))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (signed x) (unsigned (add y' z'))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned (add y' z'))))\n  (repr (Z.shiftr (signed x) (unsigned (add y' z'))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shr at 1 , shr' .",
            "tactic_args": [
                "_goal : Logic.eq (shr (shr x y') z') (shr' (shr x y') z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed (shr x y')) (unsigned z')))\n  (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed (shr x y')) (unsigned z')))\n  (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))",
                "B : Logic.eq (Int.unsigned z) (unsigned z')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))\n  (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))\n  (repr (Z.shiftr (signed (shr x y')) (Int.unsigned z)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold shr , shr' .",
            "tactic_args": [
                "_goal : Logic.eq (shr x y') (shr' x y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y')))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (unsigned y')))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))",
                "A : Logic.eq (Int.unsigned y) (unsigned y')"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned y)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (signed x) (Int.unsigned y)))\n  (repr (Z.shiftr (signed x) (Int.unsigned y)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true),\nLogic.eq (shru' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (zero_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (zero_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H0 : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z))\n  (Z.lt (Int.unsigned z) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in * .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z)) (Z.lt (Int.unsigned z) zwordsize)",
                "H : Logic.and (Z.le Z0 (Int.unsigned y)) (Z.lt (Int.unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (zero_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt (Int.unsigned z) (Int.unsigned y) then true else false\n   then\n    shl' (zero_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))"
            ]
        },
        {
            "tactic_sig": "set ( Y := Int.unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt (Int.unsigned z) (Int.unsigned y) then true else false\n   then\n    shl' (zero_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt (Int.unsigned z) Y then true else false\n   then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))",
                "H : Logic.and (Z.le Z0 Y) (Z.lt Y zwordsize)",
                "Y : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Z := Int.unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt (Int.unsigned z) Y then true else false\n   then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else\n    zero_ext (Z.sub zwordsize (Int.unsigned z)) (shru' x (Int.sub z y)))",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt Z Y then true else false\n   then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y)))",
                "H0 : Logic.and (Z.le Z0 Z) (Z.lt Z zwordsize)",
                "Z : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (shl' x y) z)\n  (if if zlt Z Y then true else false\n   then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned z)) zwordsize\n   then testbit (shl' x y) (Z.add i (Int.unsigned z))\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned z)) zwordsize\n   then testbit (shl' x y) (Z.add i (Int.unsigned z))\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)",
                "Z : BinNums.Z",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit (shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)",
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit (zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)",
                "l : Z.lt Z Y",
                "g : Z.ge Z Y"
            ]
        },
        {
            "tactic_sig": "assert ( A : Int.unsigned ( Int.sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int",
                "Y : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)",
                "A : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit (shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shl' (zero_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)",
                "A : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit (shl' x y) (Z.add i Z))",
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  false",
                "l0 : Z.lt (Z.add i Z) zwordsize",
                "g : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit (shl' x y) (Z.add i Z))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) (Int.unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) (Int.unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (Int.unsigned y)))",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ - _ ) ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))",
                "i : BinNums.Z",
                "Y : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))",
                "g : Z.ge i (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then testbit x (Z.sub i (Z.sub Y Z))\n   else false) (testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then testbit x (Z.sub i (Z.sub Y Z))\n   else false) (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (Z.sub Y Z)))\n  (testbit x (Z.sub (Z.add i Z) Y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub Y Z)) (Z.sub (Z.add i Z) Y)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub Y Z)) (Z.sub (Z.add i Z) Y)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (zero_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))\n  false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else\n    if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n    then testbit x (Z.sub i (Z.sub Y Z))\n    else false) false"
            ]
        },
        {
            "tactic_sig": "rewrite ! zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Z.sub Y Z)\n   then false\n   else\n    if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n    then testbit x (Z.sub i (Z.sub Y Z))\n    else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( A : Int.unsigned ( Int.sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "z : Int.int",
                "y : Int.int",
                "Z : BinNums.Z",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)",
                "A : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ]
        },
        {
            "tactic_sig": "apply Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext , bits_shru' , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (testbit (zero_ext (Z.sub zwordsize Z) (shru' x (Int.sub z y))) i)",
                "A : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (if zlt i (Z.sub zwordsize Z)\n   then\n    if zlt (Z.add i (Z.sub Z Y)) zwordsize\n    then testbit x (Z.add i (Z.sub Z Y))\n    else false\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) zwordsize\n   then testbit (shl' x y) (Z.add i Z)\n   else false)\n  (if zlt i (Z.sub zwordsize Z)\n   then\n    if zlt (Z.add i (Z.sub Z Y)) zwordsize\n    then testbit x (Z.add i (Z.sub Z Y))\n    else false\n   else false)",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' x y) (Z.add i Z))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "l : Z.lt (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' x y) (Z.add i Z))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) (Int.unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (Int.unsigned y)))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) (Int.unsigned y)\n   then false\n   else testbit x (Z.sub (Z.add i Z) (Int.unsigned y)))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Z) Y then false else testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "i : BinNums.Z",
                "Z : BinNums.Z",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)",
                "l0 : Z.lt (Z.add i Z) Y",
                "g0 : Z.ge (Z.add i Z) Y"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then testbit x (Z.add i (Z.sub Z Y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (testbit x (Z.add i (Z.sub Z Y)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub (Z.add i Z) Y))\n  (testbit x (Z.add i (Z.sub Z Y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (y z : Int.int)\n  (_ : Logic.eq (Int.ltu y iwordsize') true)\n  (_ : Logic.eq (Int.ltu z iwordsize') true),\nLogic.eq (shr' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (sign_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (sign_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))",
                "H0 : Logic.eq (Int.ltu z iwordsize') true",
                "H : Logic.eq (Int.ltu y iwordsize') true",
                "y : Int.int",
                "z : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu y iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H0 : Logic.eq (Int.ltu z iwordsize') true"
            ],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z))\n  (Z.lt (Int.unsigned z) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in * .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.and (Z.le Z0 (Int.unsigned z)) (Z.lt (Int.unsigned z) zwordsize)",
                "H : Logic.and (Z.le Z0 (Int.unsigned y)) (Z.lt (Int.unsigned y) zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if Int.ltu z y\n   then\n    shl' (sign_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt (Int.unsigned z) (Int.unsigned y) then true else false\n   then\n    shl' (sign_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))"
            ]
        },
        {
            "tactic_sig": "set ( Y := Int.unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt (Int.unsigned z) (Int.unsigned y) then true else false\n   then\n    shl' (sign_ext (Z.sub zwordsize (Int.unsigned y)) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt (Int.unsigned z) Y then true else false\n   then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))",
                "H : Logic.and (Z.le Z0 Y) (Z.lt Y zwordsize)",
                "Y : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Z := Int.unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt (Int.unsigned z) Y then true else false\n   then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else\n    sign_ext (Z.sub zwordsize (Int.unsigned z)) (shr' x (Int.sub z y)))",
                "z : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt Z Y then true else false\n   then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y)))",
                "H0 : Logic.and (Z.le Z0 Z) (Z.lt Z zwordsize)",
                "Z : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (shl' x y) z)\n  (if if zlt Z Y then true else false\n   then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n   else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y)))"
            ],
            "tactic_res": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : BinNums.Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' (shl' x y) z) i)\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shl' x y)\n     (if zlt (Z.add i (Int.unsigned z)) zwordsize\n      then Z.add i (Int.unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shl' x y)\n     (if zlt (Z.add i (Int.unsigned z)) zwordsize\n      then Z.add i (Int.unsigned z)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shl' x y)\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shl' x y)\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) (Int.unsigned y)\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) (Int.unsigned y)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "fold _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) (Int.unsigned y)\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) (Int.unsigned y)))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit\n     (if if zlt Z Y then true else false\n      then shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)\n      else sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "Z : BinNums.Z",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)",
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)",
                "l : Z.lt Z Y",
                "g : Z.ge Z Y"
            ]
        },
        {
            "tactic_sig": "assert ( A : Int.unsigned ( Int.sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "y : Int.int",
                "z : Int.int",
                "Y : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)",
                "A : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Y Z)) (Z.le (Z.sub Y Z) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shl' , _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shl' (sign_ext (Z.sub zwordsize Y) x) (Int.sub y z)) i)",
                "A : Logic.eq (Int.unsigned (Int.sub y z)) (Z.sub Y Z)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ - _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (if zlt i (Z.sub Y Z)\n   then false\n   else testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "i : BinNums.Z",
                "Y : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y)) false",
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "l0 : Z.lt i (Z.sub Y Z)",
                "g : Z.ge i (Z.sub Y Z)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y)) false"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (if zlt (Z.add i Z) zwordsize\n   then Z.add i Z\n   else Z.sub zwordsize (Zpos xH)) Y"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Z.lt\n  (if zlt (Z.add i Z) zwordsize\n   then Z.add i Z\n   else Z.sub zwordsize (Zpos xH)) Y",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add i Z) Y",
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) Y",
                "l1 : Z.lt (Z.add i Z) zwordsize",
                "g : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i Z) Y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) Y"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Y) x) (Z.sub i (Z.sub Y Z)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n      then Z.sub i (Z.sub Y Z)\n      else Z.sub (Z.sub zwordsize Y) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n      then Z.sub i (Z.sub Y Z)\n      else Z.sub (Z.sub zwordsize Y) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))",
                "l0 : Z.lt (Z.add i Z) zwordsize",
                "g0 : Z.ge (Z.add i Z) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.sub i (Z.sub Y Z))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.sub i (Z.sub Y Z))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.sub i (Z.sub Y Z)) (Z.sub zwordsize Y)\n   then Z.sub i (Z.sub Y Z)\n   else Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.sub (Z.sub zwordsize Y) (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( A : Int.unsigned ( Int.sub _ _ ) = _ - _ ) .",
            "tactic_args": [
                "z : Int.int",
                "y : Int.int",
                "Z : BinNums.Z",
                "Y : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)",
                "A : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ]
        },
        {
            "tactic_sig": "apply Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Z Y)) (Z.le (Z.sub Z Y) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (sign_ext (Z.sub zwordsize Z) (shr' x (Int.sub z y))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shr' x (Int.sub z y))\n     (if zlt i (Z.sub zwordsize Z)\n      then i\n      else Z.sub (Z.sub zwordsize Z) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by ( destruct ( zlt _ ( zwordsize - _ ) ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit (shr' x (Int.sub z y))\n     (if zlt i (Z.sub zwordsize Z)\n      then i\n      else Z.sub (Z.sub zwordsize Z) (Zpos xH)))",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n            (Int.unsigned (Int.sub z y))) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n         (Int.unsigned (Int.sub z y))\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n            (Int.unsigned (Int.sub z y))) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH))\n         (Int.unsigned (Int.sub z y))\n      else Z.sub zwordsize (Zpos xH)))",
                "A : Logic.eq (Int.unsigned (Int.sub z y)) (Z.sub Z Y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by ( destruct ( zlt ( _ + _ ) zwordsize ) ; omega ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i Z) zwordsize\n       then Z.add i Z\n       else Z.sub zwordsize (Zpos xH)) Y\n   then false\n   else\n    testbit x\n      (Z.sub\n         (if zlt (Z.add i Z) zwordsize\n          then Z.add i Z\n          else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.sub\n        (if zlt (Z.add i Z) zwordsize\n         then Z.add i Z\n         else Z.sub zwordsize (Zpos xH)) Y))\n  (testbit x\n     (if\n       zlt\n         (Z.add\n            (if zlt i (Z.sub zwordsize Z)\n             then i\n             else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n            (Z.sub Z Y)) zwordsize\n      then\n       Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt\n      (Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)) zwordsize\n   then\n    Z.add\n      (if zlt i (Z.sub zwordsize Z)\n       then i\n       else Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt\n      (Z.add\n         (if zlt i (Z.sub zwordsize Z)\n          then i\n          else Z.sub (Z.sub zwordsize Z) (Zpos xH)) \n         (Z.sub Z Y)) zwordsize\n   then\n    Z.add\n      (if zlt i (Z.sub zwordsize Z)\n       then i\n       else Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "i : BinNums.Z",
                "Z : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then Z.add i (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))",
                "l : Z.lt i (Z.sub zwordsize Z)",
                "g0 : Z.ge i (Z.sub zwordsize Z)"
            ]
        },
        {
            "tactic_sig": "rewrite ! zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if zlt (Z.add i (Z.sub Z Y)) zwordsize\n   then Z.add i (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Z) Y) (Z.add i (Z.sub Z Y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub\n     (if zlt (Z.add i Z) zwordsize\n      then Z.add i Z\n      else Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (if\n    zlt (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))\n      zwordsize\n   then Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Y)\n  (Z.add (Z.sub (Z.sub zwordsize Z) (Zpos xH)) (Z.sub Z Y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m : Int.int) (x : int) (_ : Z.le Z0 n),\nLogic.eq (shl' (zero_ext n x) m)\n  (zero_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (zero_ext n x) m)\n  (zero_ext (Z.add n (Int.unsigned m)) (shl' x m))",
                "H : Z.le Z0 n",
                "x : int",
                "m : Int.int",
                "n : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (zero_ext n x) m)\n  (zero_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_zero_ext , ! bits_shl' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (zero_ext n x) m) i)\n  (testbit (zero_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (zero_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Z.add n (Int.unsigned m))\n   then\n    if zlt i (Int.unsigned m)\n    then false\n    else testbit x (Z.sub i (Int.unsigned m))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (zero_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Z.add n (Int.unsigned m))\n   then\n    if zlt i (Int.unsigned m)\n    then false\n    else testbit x (Z.sub i (Int.unsigned m))\n   else false)",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false\n  (if zlt i (Z.add n (Int.unsigned m)) then false else false)",
                "_goal : Logic.eq (testbit (zero_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Z.add n (Int.unsigned m))\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)",
                "l : Z.lt i (Int.unsigned m)",
                "g : Z.ge i (Int.unsigned m)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt i (Z.add n (Int.unsigned m)) then false else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Z.add n (Int.unsigned m))\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)\n  (if zlt i (Z.add n (Int.unsigned m))\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.unsigned _ ) _ ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)\n  (if zlt i (Z.add n (Int.unsigned m))\n   then testbit x (Z.sub i (Int.unsigned m))\n   else false)",
                "i : BinNums.Z",
                "m : Int.int",
                "n : BinNums.Z"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m : Int.int) (x : int) (_ : Z.lt Z0 n),\nLogic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))",
                "H : Z.lt Z0 n",
                "x : int",
                "m : Int.int",
                "n : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned m))\n  (Z.lt (Int.unsigned m) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext n x) m)\n  (sign_ext (Z.add n (Int.unsigned m)) (shl' x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , ! bits_shl' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (sign_ext n x) m) i)\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) (shl' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m)\n     (if zlt i (Z.add n (Int.unsigned m))\n      then i\n      else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( _ + Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m)\n     (if zlt i (Z.add n (Int.unsigned m))\n      then i\n      else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))",
                "i : BinNums.Z",
                "n : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) i)",
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))",
                "l : Z.lt i (Z.add n (Int.unsigned m))",
                "g : Z.ge i (Z.add n (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit x (Z.sub i (Int.unsigned m)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit x (Z.sub i (Int.unsigned m)))",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit x (Z.sub i (Int.unsigned m)))",
                "l0 : Z.lt i (Int.unsigned m)",
                "g : Z.ge i (Int.unsigned m)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit x (Z.sub i (Int.unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned m)) n\n      then Z.sub i (Int.unsigned m)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub i (Int.unsigned m)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned m)) n\n      then Z.sub i (Int.unsigned m)\n      else Z.sub n (Zpos xH))) (testbit x (Z.sub i (Int.unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then Z.sub i (Int.unsigned m)\n   else Z.sub n (Zpos xH)) (Z.sub i (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then Z.sub i (Int.unsigned m)\n   else Z.sub n (Zpos xH)) (Z.sub i (Int.unsigned m))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub i (Int.unsigned m)) n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub i (Int.unsigned m)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned m)\n   then false\n   else testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit (shl' x m) (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m)\n   then false\n   else\n    testbit x\n      (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n         (Int.unsigned m)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (if zlt (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m)\n   then false\n   else\n    testbit x\n      (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n         (Int.unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n        (Int.unsigned m)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext n x) (Z.sub i (Int.unsigned m)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n        (Int.unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned m)) n\n      then Z.sub i (Int.unsigned m)\n      else Z.sub n (Zpos xH)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n        (Int.unsigned m)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned m)) n\n      then Z.sub i (Int.unsigned m)\n      else Z.sub n (Zpos xH)))\n  (testbit x\n     (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n        (Int.unsigned m)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then Z.sub i (Int.unsigned m)\n   else Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned m)) n\n   then Z.sub i (Int.unsigned m)\n   else Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub n (Zpos xH))\n  (Z.sub (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)) (Int.unsigned m))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m : Int.int) (x : int) (_ : Z.le Z0 n),\nLogic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))",
                "H : Z.le Z0 n",
                "x : int",
                "m : Int.int",
                "n : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned m))\n  (Z.lt (Int.unsigned m) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "bit_solve ; [ |omega ] .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m)\n  (zero_ext n (shru' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (if zlt i n then testbit (shru' x m) i else false)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru' , bits_zero_ext , bits_shru' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' (zero_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (if zlt i n then testbit (shru' x m) i else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false)\n  (if zlt i n\n   then\n    if zlt (Z.add i (Int.unsigned m)) zwordsize\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false)\n  (if zlt i n\n   then\n    if zlt (Z.add i (Int.unsigned m)) zwordsize\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false)",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then testbit x (Z.add i (Int.unsigned m))\n   else false)\n  (if zlt i n then testbit x (Z.add i (Int.unsigned m)) else false)",
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "l : Z.lt (Z.add i (Int.unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) ; [ rewrite zlt_true by omega|rewrite zlt_false by omega ] ; auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then testbit x (Z.add i (Int.unsigned m))\n   else false)\n  (if zlt i n then testbit x (Z.add i (Int.unsigned m)) else false)",
                "i : BinNums.Z",
                "n : BinNums.Z"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq false (if zlt i n then false else false)",
                "i : BinNums.Z",
                "n : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq false false",
                "l : Z.lt i n",
                "g0 : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m : Int.int) (x : int) (_ : Z.le n (Int.unsigned m)),\nLogic.eq (shru' (zero_ext n x) m) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (zero_ext n x) m) zero",
                "H : Z.le n (Int.unsigned m)",
                "x : int",
                "m : Int.int",
                "n : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (zero_ext n x) m) zero",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shru' (zero_ext n x) m) zero"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shru' (zero_ext n x) m) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (zero_ext n x) m) zero",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned m))\n  (Z.lt (Int.unsigned m) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (zero_ext n x) m) zero"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' (zero_ext n x) m) i) false",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru' , bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' (zero_ext n x) m) i) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (Int.unsigned m)) n\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false) false"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) zwordsize\n   then\n    if zlt (Z.add i (Int.unsigned m)) n\n    then testbit x (Z.add i (Int.unsigned m))\n    else false\n   else false) false",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) n\n   then testbit x (Z.add i (Int.unsigned m))\n   else false) false",
                "_goal : Logic.eq false false",
                "l : Z.lt (Z.add i (Int.unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) n\n   then testbit x (Z.add i (Int.unsigned m))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge (Z.add i (Int.unsigned m)) n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i (Int.unsigned m)) n"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : Z) (m : Int.int) (x : int) (_ : Z.lt Z0 n)\n  (_ : Z.lt (Z.add n (Int.unsigned m)) zwordsize),\nLogic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))",
                "H0 : Z.lt (Z.add n (Int.unsigned m)) zwordsize",
                "H : Z.lt Z0 n",
                "x : int",
                "m : Int.int",
                "n : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned m))\n        (Z.lt (Int.unsigned m) Int.modulus),\nLogic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))",
                "H1 : Logic.and (Z.le Z0 (Int.unsigned m))\n  (Z.lt (Int.unsigned m) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m)\n  (sign_ext n (shr' x m))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr' x m)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr' x m)) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , bits_shr' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' (sign_ext (Z.add n (Int.unsigned m)) x) m) i)\n  (testbit (sign_ext n (shr' x m)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) x)\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (shr' x m) (if zlt i n then i else Z.sub n (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_sign_ext , bits_shr' .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (sign_ext (Z.add n (Int.unsigned m)) x)\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit (shr' x m) (if zlt i n then i else Z.sub n (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (if zlt (Z.add i (Int.unsigned m)) zwordsize\n          then Z.add i (Int.unsigned m)\n          else Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n      then\n       if zlt (Z.add i (Int.unsigned m)) zwordsize\n       then Z.add i (Int.unsigned m)\n       else Z.sub zwordsize (Zpos xH)\n      else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))\n  (testbit x\n     (if\n       zlt\n         (Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n            (Int.unsigned m)) zwordsize\n      then\n       Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n         (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (if zlt (Z.add i (Int.unsigned m)) zwordsize\n          then Z.add i (Int.unsigned m)\n          else Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n      then\n       if zlt (Z.add i (Int.unsigned m)) zwordsize\n       then Z.add i (Int.unsigned m)\n       else Z.sub zwordsize (Zpos xH)\n      else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH)))\n  (testbit x\n     (if\n       zlt\n         (Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n            (Int.unsigned m)) zwordsize\n      then\n       Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n         (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i (Int.unsigned m)) zwordsize\n       then Z.add i (Int.unsigned m)\n       else Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then\n    if zlt (Z.add i (Int.unsigned m)) zwordsize\n    then Z.add i (Int.unsigned m)\n    else Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if\n    zlt\n      (Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n         (Int.unsigned m)) zwordsize\n   then\n    Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) , ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (if zlt (Z.add i (Int.unsigned m)) zwordsize\n       then Z.add i (Int.unsigned m)\n       else Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then\n    if zlt (Z.add i (Int.unsigned m)) zwordsize\n    then Z.add i (Int.unsigned m)\n    else Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if\n    zlt\n      (Z.add (if zlt i n then i else Z.sub n (Zpos xH))\n         (Int.unsigned m)) zwordsize\n   then\n    Z.add (if zlt i n then i else Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "i : BinNums.Z",
                "n : BinNums.Z",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then Z.add i (Int.unsigned m)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add i (Int.unsigned m))",
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then Z.add i (Int.unsigned m)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))",
                "l0 : Z.lt (Z.add i (Int.unsigned m)) zwordsize",
                "l : Z.lt i n",
                "g : Z.ge (Z.add i (Int.unsigned m)) zwordsize",
                "l : Z.lt (Z.add i (Int.unsigned m)) zwordsize",
                "g : Z.ge i n",
                "g0 : Z.ge (Z.add i (Int.unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then Z.add i (Int.unsigned m)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add i (Int.unsigned m))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned m)) (Z.add n (Int.unsigned m))\n   then Z.add i (Int.unsigned m)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) (Z.add n (Int.unsigned m))\n   then Z.sub zwordsize (Zpos xH)\n   else Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (if zlt (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)) zwordsize\n   then Z.add (Z.sub n (Zpos xH)) (Int.unsigned m)\n   else Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add n (Int.unsigned m)) (Zpos xH))\n  (Z.add (Z.sub n (Zpos xH)) (Int.unsigned m))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (if zlt i n then i else Z.sub n (Zpos xH)))\n  (Z.lt (if zlt i n then i else Z.sub n (Zpos xH)) zwordsize)",
                "i : BinNums.Z",
                "n : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)",
                "l : Z.lt i n",
                "g : Z.ge i n"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub n (Zpos xH)))\n  (Z.lt (Z.sub n (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)))\n  (Z.lt\n     (if zlt (Z.add i (Int.unsigned m)) zwordsize\n      then Z.add i (Int.unsigned m)\n      else Z.sub zwordsize (Zpos xH)) zwordsize)",
                "i : BinNums.Z",
                "m : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (Int.unsigned m)))\n  (Z.lt (Z.add i (Int.unsigned m)) zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)",
                "l : Z.lt (Z.add i (Int.unsigned m)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned m)) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i (Int.unsigned m)))\n  (Z.lt (Z.add i (Int.unsigned m)) zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub zwordsize (Zpos xH)))\n  (Z.lt (Z.sub zwordsize (Zpos xH)) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x : int) (n : Int.int)\n  (_ : Logic.eq (Int.ltu n iwordsize') true),\nLogic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shru' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shru' x n))",
                "H : Logic.eq (Int.ltu n iwordsize') true",
                "n : Int.int",
                "x : int",
                "s : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu n iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n)) (Z.lt (Int.unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z.min_case_strong .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shru' x n))"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (Int.unsigned n)),\nLogic.eq (zero_ext s (shru' x n)) (zero_ext s (shru' x n))",
                "_goal : forall _ : Z.le (Z.sub zwordsize (Int.unsigned n)) s,\nLogic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.sub zwordsize (Int.unsigned n)) (shru' x n))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (Int.unsigned n)),\nLogic.eq (zero_ext s (shru' x n)) (zero_ext s (shru' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru' x n)) (zero_ext s (shru' x n))",
                "H0 : Z.le s (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru' x n)) (zero_ext s (shru' x n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le (Z.sub zwordsize (Int.unsigned n)) s,\nLogic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.sub zwordsize (Int.unsigned n)) (shru' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.sub zwordsize (Int.unsigned n)) (shru' x n))",
                "H0 : Z.le (Z.sub zwordsize (Int.unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "bit_solve .",
            "tactic_args": [
                "_goal : Logic.eq (zero_ext s (shru' x n))\n  (zero_ext (Z.sub zwordsize (Int.unsigned n)) (shru' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i s then testbit (shru' x n) i else false)\n  (if zlt i (Z.sub zwordsize (Int.unsigned n))\n   then testbit (shru' x n) i\n   else false)",
                "_goal : Z.le Z0 i",
                "_goal : Z.le Z0 i",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "try omega .",
            "tactic_args": [],
            "tactic_res": []
        },
        {
            "tactic_sig": "try omega .",
            "tactic_args": [
                "_goal : Z.le Z0 i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! bits_shru' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i s then testbit (shru' x n) i else false)\n  (if zlt i (Z.sub zwordsize (Int.unsigned n))\n   then testbit (shru' x n) i\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)\n  (if zlt i (Z.sub zwordsize (Int.unsigned n))\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)\n  (if zlt i (Z.sub zwordsize (Int.unsigned n))\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)",
                "i : BinNums.Z",
                "n : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)",
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false) false",
                "l : Z.lt i (Z.sub zwordsize (Int.unsigned n))",
                "g : Z.ge i (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i s\n   then\n    if zlt (Z.add i (Int.unsigned n)) zwordsize\n    then testbit x (Z.add i (Int.unsigned n))\n    else false\n   else false) false",
                "i : BinNums.Z",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false) false",
                "_goal : Logic.eq false false",
                "l : Z.lt i s",
                "g0 : Z.ge i s"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned n)) zwordsize\n   then testbit x (Z.add i (Int.unsigned n))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x : int) (n : Int.int)\n  (_ : Logic.eq (Int.ltu n iwordsize') true),\nLogic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shr' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shr' x n))",
                "H : Logic.eq (Int.ltu n iwordsize') true",
                "n : Int.int",
                "x : int",
                "s : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu n iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n)) (Z.lt (Int.unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.min_comm .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) (shr' x n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.min (Z.sub zwordsize (Int.unsigned n)) s) (shr' x n))"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.min_spec ( zwordsize - Int.unsigned _ ) _ ) as [ [ A B ] | [ A B ] ] .",
            "tactic_args": [
                "n : Int.int",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))",
                "A : Z.lt (Z.sub zwordsize (Int.unsigned n)) s",
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s) s",
                "A : Z.le s (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.min (Z.sub zwordsize (Int.unsigned n)) s) (shr' x n))",
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sign_ext s (shr' x n)) (sign_ext s (shr' x n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr' x n)) (sign_ext s (shr' x n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (sign_ext s (shr' x n))\n  (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext s (shr' x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (sign_ext s (shr' x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (sign_ext s (shr' x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n)) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_sign_ext by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext s (shr' x n)) i)\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) (shr' x n)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n)\n     (if zlt i (Z.sub zwordsize (Int.unsigned n))\n      then i\n      else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( zwordsize - Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n)\n     (if zlt i (Z.sub zwordsize (Int.unsigned n))\n      then i\n      else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))",
                "i : BinNums.Z",
                "n : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n) i)",
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))",
                "l : Z.lt i (Z.sub zwordsize (Int.unsigned n))",
                "g : Z.ge i (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' x n) i) (testbit (shr' x n) i)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' x n) i) (testbit (shr' x n) i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( C : testbit ( shr' _ _ ) ( zwordsize - Int.unsigned _ - 1 ) = testbit _ ( zwordsize - 1 ) ) .",
            "tactic_args": [
                "x : int",
                "n : Int.int",
                "n : Int.int",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "C : Logic.eq\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n            (Int.unsigned n)) zwordsize\n      then\n       Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n         (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if\n       zlt\n         (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n            (Int.unsigned n)) zwordsize\n      then\n       Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n         (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n        (Int.unsigned n))) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n        (Int.unsigned n))) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n     (Int.unsigned n)) (Z.sub zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))\n     (Int.unsigned n)) (Z.sub zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))",
                "C : Logic.eq\n  (testbit (shr' x n)\n     (Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (shr' x n) (if zlt i s then i else Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' x n) i) (testbit x (Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.eq (testbit (shr' x n) (Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt i s",
                "g0 : Z.ge i s"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' x n) i) (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned n)) zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' x n) (Z.sub s (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add (Z.sub s (Zpos xH)) (Int.unsigned n)) zwordsize\n      then Z.add (Z.sub s (Zpos xH)) (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add i (Int.unsigned n)) zwordsize\n      then Z.add i (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.add (Z.sub s (Zpos xH)) (Int.unsigned n)) zwordsize\n      then Z.add (Z.sub s (Zpos xH)) (Int.unsigned n)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub zwordsize (Zpos xH)))\n  (testbit x (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x : int) (n : Int.int)\n  (_ : Logic.eq (Int.ltu n iwordsize') true),\nLogic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)",
                "H : Logic.eq (Int.ltu n iwordsize') true",
                "n : Int.int",
                "x : int",
                "s : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu n iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n)) (Z.lt (Int.unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z.min_case_strong .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (Int.unsigned n)),\nLogic.eq (shl' (zero_ext s x) n) (shl' (zero_ext s x) n)",
                "_goal : forall _ : Z.le (Z.sub zwordsize (Int.unsigned n)) s,\nLogic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le s (Z.sub zwordsize (Int.unsigned n)),\nLogic.eq (shl' (zero_ext s x) n) (shl' (zero_ext s x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (zero_ext s x) n) (shl' (zero_ext s x) n)",
                "H0 : Z.le s (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (zero_ext s x) n) (shl' (zero_ext s x) n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall _ : Z.le (Z.sub zwordsize (Int.unsigned n)) s,\nLogic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n)",
                "H0 : Z.le (Z.sub zwordsize (Int.unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (zero_ext s x) n)\n  (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (zero_ext s x) n) i)\n  (testbit (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (zero_ext s x) n) i)\n  (testbit (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (zero_ext s x) n) i)\n  (testbit (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_shl' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (zero_ext s x) n) i)\n  (testbit (shl' (zero_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else testbit (zero_ext s x) (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else\n    testbit (zero_ext (Z.sub zwordsize (Int.unsigned n)) x)\n      (Z.sub i (Int.unsigned n)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else testbit (zero_ext s x) (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else\n    testbit (zero_ext (Z.sub zwordsize (Int.unsigned n)) x)\n      (Z.sub i (Int.unsigned n)))",
                "i : BinNums.Z",
                "n : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (zero_ext s x) (Z.sub i (Int.unsigned n)))\n  (testbit (zero_ext (Z.sub zwordsize (Int.unsigned n)) x)\n     (Z.sub i (Int.unsigned n)))",
                "l : Z.lt i (Int.unsigned n)",
                "g : Z.ge i (Int.unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! bits_zero_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (zero_ext s x) (Z.sub i (Int.unsigned n)))\n  (testbit (zero_ext (Z.sub zwordsize (Int.unsigned n)) x)\n     (Z.sub i (Int.unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned n)) s\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.unsigned _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned n)) s\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)",
                "i : BinNums.Z",
                "n : Int.int",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (Int.unsigned n)))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)",
                "_goal : Logic.eq false\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)",
                "l : Z.lt (Z.sub i (Int.unsigned n)) s",
                "g0 : Z.ge (Z.sub i (Int.unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (Int.unsigned n)))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit x (Z.sub i (Int.unsigned n)))\n  (testbit x (Z.sub i (Int.unsigned n)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit x (Z.sub i (Int.unsigned n)))\n  (testbit x (Z.sub i (Int.unsigned n)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq false\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then testbit x (Z.sub i (Int.unsigned n))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (s : Z) (x : int) (n : Int.int)\n  (_ : Logic.eq (Int.ltu n iwordsize') true),\nLogic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)",
                "H : Logic.eq (Int.ltu n iwordsize') true",
                "n : Int.int",
                "x : int",
                "s : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "apply Int.ltu_inv in _ .",
            "tactic_args": [
                "H : Logic.eq (Int.ltu n iwordsize') true"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize in _ .",
            "tactic_args": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.lt (Int.unsigned n) (Int.unsigned iwordsize'))"
            ],
            "tactic_res": [
                "H : Logic.and (Z.le Z0 (Int.unsigned n)) (Z.lt (Int.unsigned n) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.min_comm .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.min s (Z.sub zwordsize (Int.unsigned n))) x) n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.min (Z.sub zwordsize (Int.unsigned n)) s) x) n)"
            ]
        },
        {
            "tactic_sig": "destruct ( Z.min_spec ( zwordsize - Int.unsigned _ ) _ ) as [ [ A B ] | [ A B ] ] .",
            "tactic_args": [
                "n : Int.int",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))",
                "A : Z.lt (Z.sub zwordsize (Int.unsigned n)) s",
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s) s",
                "A : Z.le s (Z.sub zwordsize (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.min (Z.sub zwordsize (Int.unsigned n)) s) x) n)",
                "B : Logic.eq (Z.min (Z.sub zwordsize (Int.unsigned n)) s)\n  (Z.sub zwordsize (Int.unsigned n))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (sign_ext s x) n) (shl' (sign_ext s x) n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext s x) n) (shl' (sign_ext s x) n)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (sign_ext s x) n)\n  (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (sign_ext s x) n) i)\n  (testbit (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (sign_ext s x) n) i)\n  (testbit (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (sign_ext s x) n) i)\n  (testbit (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)",
                "H0 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_shl' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (sign_ext s x) n) i)\n  (testbit (shl' (sign_ext (Z.sub zwordsize (Int.unsigned n)) x) n) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else testbit (sign_ext s x) (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else\n    testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) x)\n      (Z.sub i (Int.unsigned n)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned n)\n   then false\n   else testbit (sign_ext s x) (Z.sub i (Int.unsigned n)))\n  (if zlt i (Int.unsigned n)\n   then false\n   else\n    testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) x)\n      (Z.sub i (Int.unsigned n)))",
                "i : BinNums.Z",
                "n : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (testbit (sign_ext s x) (Z.sub i (Int.unsigned n)))\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) x)\n     (Z.sub i (Int.unsigned n)))",
                "l : Z.lt i (Int.unsigned n)",
                "g : Z.ge i (Int.unsigned n)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ! bits_sign_ext by omega .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (sign_ext s x) (Z.sub i (Int.unsigned n)))\n  (testbit (sign_ext (Z.sub zwordsize (Int.unsigned n)) x)\n     (Z.sub i (Int.unsigned n)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned n)) s\n      then Z.sub i (Int.unsigned n)\n      else Z.sub s (Zpos xH)))\n  (testbit x\n     (if\n       zlt (Z.sub i (Int.unsigned n))\n         (Z.sub zwordsize (Int.unsigned n))\n      then Z.sub i (Int.unsigned n)\n      else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit x\n     (if zlt (Z.sub i (Int.unsigned n)) s\n      then Z.sub i (Int.unsigned n)\n      else Z.sub s (Zpos xH)))\n  (testbit x\n     (if\n       zlt (Z.sub i (Int.unsigned n))\n         (Z.sub zwordsize (Int.unsigned n))\n      then Z.sub i (Int.unsigned n)\n      else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned n)) s\n   then Z.sub i (Int.unsigned n)\n   else Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.unsigned _ ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub i (Int.unsigned n)) s\n   then Z.sub i (Int.unsigned n)\n   else Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))",
                "i : BinNums.Z",
                "n : Int.int",
                "s : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Int.unsigned n))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))",
                "_goal : Logic.eq (Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))",
                "l : Z.lt (Z.sub i (Int.unsigned n)) s",
                "g0 : Z.ge (Z.sub i (Int.unsigned n)) s"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Int.unsigned n))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Int.unsigned n)) (Z.sub i (Int.unsigned n))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Int.unsigned n)) (Z.sub i (Int.unsigned n))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omegaContradiction .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub s (Zpos xH))\n  (if zlt (Z.sub i (Int.unsigned n)) (Z.sub zwordsize (Int.unsigned n))\n   then Z.sub i (Int.unsigned n)\n   else Z.sub (Z.sub zwordsize (Int.unsigned n)) (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x : int) (i : Int.int) (_ : In i (one_bits' x)),\nLogic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu i iwordsize') true",
                "H : In i (one_bits' x)",
                "i : Int.int",
                "x : int"
            ]
        },
        {
            "tactic_sig": "destruct ( list_in_map_inv _ _ _ _ ) as [ i0 [ EQ IN ] ] .",
            "tactic_args": [
                "H : In i (one_bits' x)"
            ],
            "tactic_res": [
                "IN : In i0 (Z_one_bits wordsize (unsigned x) Z0)",
                "EQ : Logic.eq i (Int.repr i0)",
                "i0 : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "exploit Z_one_bits_range .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : In ?Goal1 (Z_one_bits ?Goal ?Goal0 Z0)",
                "_goal : forall _ : Logic.and (Z.le Z0 ?Goal1) (Z.lt ?Goal1 (Z.of_nat ?Goal)),\nLogic.eq (Int.ltu i iwordsize') true"
            ]
        },
        {
            "tactic_sig": "eauto .",
            "tactic_args": [
                "_goal : In ?Goal1 (Z_one_bits ?Goal ?Goal0 Z0)",
                "_goal : forall _ : Logic.and (Z.le Z0 ?Goal1) (Z.lt ?Goal1 (Z.of_nat ?Goal)),\nLogic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 i0) (Z.lt i0 (Z.of_nat wordsize)),\nLogic.eq (Int.ltu i iwordsize') true"
            ]
        },
        {
            "tactic_sig": "fold zwordsize .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 i0) (Z.lt i0 (Z.of_nat wordsize)),\nLogic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.and (Z.le Z0 i0) (Z.lt i0 zwordsize),\nLogic.eq (Int.ltu i iwordsize') true"
            ]
        },
        {
            "tactic_sig": "intros R .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 i0) (Z.lt i0 zwordsize),\nLogic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu i iwordsize') true",
                "R : Logic.and (Z.le Z0 i0) (Z.lt i0 zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu i iwordsize') true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned i) (Int.unsigned iwordsize')\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned i) (Int.unsigned iwordsize')\n   then true\n   else false) true",
                "EQ : Logic.eq i (Int.repr i0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned (Int.repr i0)) (Int.unsigned iwordsize')\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned (Int.repr i0)) (Int.unsigned iwordsize')\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i0 (Int.unsigned iwordsize') then true else false)\n  true",
                "_goal : Logic.and (Z.le Z0 i0) (Z.le i0 Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i0 (Int.unsigned iwordsize') then true else false)\n  true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt i0 zwordsize then true else false) true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt i0 zwordsize then true else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt i0 zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i0 zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i0) (Z.le i0 Int.max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "assert ( REC : forall l , ( forall i , In i l -> 0 <= i < zwordsize ) -> int_of_one_bits' ( List.map Int.repr l ) = repr ( powerserie l ) ) .",
            "tactic_args": [],
            "tactic_res": [
                "_goal : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))",
                "REC : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))"
            ]
        },
        {
            "tactic_sig": "induction l .",
            "tactic_args": [
                "_goal : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i nil),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr nil)) (repr (powerserie nil))",
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (cons a l)),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr (cons a l)))\n  (repr (powerserie (cons a l)))",
                "IHl : forall\n  _ : forall (i : Z) (_ : In i l),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))",
                "l : list Z",
                "a : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i nil),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr nil)) (repr (powerserie nil))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : forall (i : Z) (_ : False),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize), Logic.eq zero (repr Z0)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : False),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize), Logic.eq zero (repr Z0)"
            ],
            "tactic_res": [
                "_goal : Logic.eq zero (repr Z0)",
                "H : forall (i : Z) (_ : False), Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : In i (cons a l)),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr (cons a l)))\n  (repr (powerserie (cons a l)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : forall (i : Z) (_ : Logic.or (Logic.eq a i) (In i l)),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq\n  (add (shl' one (Int.repr a)) (int_of_one_bits' (map Int.repr l)))\n  (repr (Z.add (two_p a) (powerserie l)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : forall (i : Z) (_ : Logic.or (Logic.eq a i) (In i l)),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq\n  (add (shl' one (Int.repr a)) (int_of_one_bits' (map Int.repr l)))\n  (repr (Z.add (two_p a) (powerserie l)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (add (shl' one (Int.repr a)) (int_of_one_bits' (map Int.repr l)))\n  (repr (Z.add (two_p a) (powerserie l)))",
                "H : forall (i : Z) (_ : Logic.or (Logic.eq a i) (In i l)),\nLogic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq zero (repr Z0)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ by eauto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (add (shl' one (Int.repr a)) (int_of_one_bits' (map Int.repr l)))\n  (repr (Z.add (two_p a) (powerserie l)))",
                "IHl : forall\n  _ : forall (i : Z) (_ : In i l),\n      Logic.and (Z.le Z0 i) (Z.lt i zwordsize),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (shl' one (Int.repr a)) (repr (powerserie l)))\n  (repr (Z.add (two_p a) (powerserie l)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (add (shl' one (Int.repr a)) (repr (powerserie l)))\n  (repr (Z.add (two_p a) (powerserie l)))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add (unsigned (shl' one (Int.repr a)))\n     (unsigned (repr (powerserie l)))) (Z.add (two_p a) (powerserie l))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add (unsigned (shl' one (Int.repr a)))\n     (unsigned (repr (powerserie l)))) (Z.add (two_p a) (powerserie l))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (shl' one (Int.repr a))) (two_p a)",
                "_goal : eqm (unsigned (repr (powerserie l))) (powerserie l)"
            ]
        },
        {
            "tactic_sig": "rewrite shl'_one_two_p .",
            "tactic_args": [
                "_goal : eqm (unsigned (shl' one (Int.repr a))) (two_p a)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (two_p (Int.unsigned (Int.repr a))))) (two_p a)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (two_p (Int.unsigned (Int.repr a))))) (two_p a)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (two_p a))) (two_p a)",
                "_goal : Logic.and (Z.le Z0 a) (Z.le a Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (two_p a))) (two_p a)"
            ],
            "tactic_res": [
                "_goal : eqm (two_p a) (unsigned (repr (two_p a)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (two_p a) (unsigned (repr (two_p a)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "exploit ( _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 a) (Z.le a Int.max_unsigned)",
                "H : forall (i : Z) (_ : Logic.or (Logic.eq a i) (In i l)),\nLogic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "a : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.or (Logic.eq a a) (In a l)",
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize),\nLogic.and (Z.le Z0 a) (Z.le a Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.or (Logic.eq a a) (In a l)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Logic.and (Z.le Z0 a) (Z.lt a zwordsize),\nLogic.and (Z.le Z0 a) (Z.le a Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (powerserie l))) (powerserie l)"
            ],
            "tactic_res": [
                "_goal : eqm (powerserie l) (unsigned (repr (powerserie l)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (powerserie l) (unsigned (repr (powerserie l)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : int, Logic.eq x (int_of_one_bits' (one_bits' x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq x (int_of_one_bits' (one_bits' x))",
                "x : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) at 1 .",
            "tactic_args": [
                "_goal : Logic.eq x (int_of_one_bits' (one_bits' x))",
                "x : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) (int_of_one_bits' (one_bits' x))"
            ]
        },
        {
            "tactic_sig": "unfold one_bits' .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) (int_of_one_bits' (one_bits' x))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x))\n  (int_of_one_bits'\n     (map Int.repr (Z_one_bits wordsize (unsigned x) Z0)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x))\n  (int_of_one_bits'\n     (map Int.repr (Z_one_bits wordsize (unsigned x) Z0)))",
                "REC : forall (l : list Z)\n  (_ : forall (i : Z) (_ : In i l),\n       Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (int_of_one_bits' (map Int.repr l)) (repr (powerserie l))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x))\n  (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))",
                "_goal : forall (i : Z) (_ : In i (Z_one_bits wordsize (unsigned x) Z0)),\nLogic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite <- Z_one_bits_powerserie .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x))\n  (repr (powerserie (Z_one_bits wordsize (unsigned x) Z0)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned x)) (repr (unsigned x))",
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned x)) (repr (unsigned x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (unsigned x))\n  (Z.lt (unsigned x) (two_power_nat wordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Z_one_bits_range .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : In i (Z_one_bits wordsize (unsigned x) Z0)),\nLogic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold is_power2' .",
            "tactic_args": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq (is_power2' n) (Some logn)),\nLogic.and (Z.le Z0 (Int.unsigned logn))\n  (Z.lt (Int.unsigned logn) zwordsize)"
            ],
            "tactic_res": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq\n         match Z_one_bits wordsize (unsigned n) Z0 with\n         | nil => None\n         | cons i nil => Some (Int.repr i)\n         | cons i (cons _ _) => None\n         end (Some logn)),\nLogic.and (Z.le Z0 (Int.unsigned logn))\n  (Z.lt (Int.unsigned logn) zwordsize)"
            ]
        },
        {
            "tactic_sig": "intros n logn P2 .",
            "tactic_args": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq\n         match Z_one_bits wordsize (unsigned n) Z0 with\n         | nil => None\n         | cons i nil => Some (Int.repr i)\n         | cons i (cons _ _) => None\n         end (Some logn)),\nLogic.and (Z.le Z0 (Int.unsigned logn))\n  (Z.lt (Int.unsigned logn) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned logn))\n  (Z.lt (Int.unsigned logn) zwordsize)",
                "P2 : Logic.eq\n  match Z_one_bits wordsize (unsigned n) Z0 with\n  | nil => None\n  | cons i nil => Some (Int.repr i)\n  | cons i (cons _ _) => None\n  end (Some logn)",
                "logn : Int.int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "destruct ( Z_one_bits wordsize ( unsigned _ ) 0 ) as [ | i [ | ? ? ] ] eqn : B .",
            "tactic_args": [
                "n : int"
            ],
            "tactic_res": [
                "P2 : Logic.eq None (Some logn)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) nil",
                "P2 : Logic.eq (Some (Int.repr i)) (Some logn)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i nil)",
                "i : BinNums.Z",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i (cons z l))",
                "l : list Z",
                "z : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "P2 : Logic.eq None (Some logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "P2 : Logic.eq (Some (Int.repr i)) (Some logn)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned (Int.repr i)))\n  (Z.lt (Int.unsigned (Int.repr i)) zwordsize)"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned logn))\n  (Z.lt (Int.unsigned logn) zwordsize)",
                "P2 : Logic.eq None (Some logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize ) .",
            "tactic_args": [
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z_one_bits_range with ( unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : In i (Z_one_bits wordsize (unsigned n) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : In i (Z_one_bits wordsize (unsigned n) Z0)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i nil)"
            ],
            "tactic_res": [
                "_goal : In i (cons i nil)"
            ]
        },
        {
            "tactic_sig": "auto with coqlib .",
            "tactic_args": [
                "_goal : In i (cons i nil)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned (Int.repr i)))\n  (Z.lt (Int.unsigned (Int.repr i)) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 i) (Z.le i Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.le i Int.max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq (is_power2' n) (Some logn)),\nLogic.eq (Int.ltu logn iwordsize') true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.ltu logn iwordsize') true",
                "H : Logic.eq (is_power2' n) (Some logn)",
                "logn : Int.int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq (Int.ltu logn iwordsize') true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned logn) (Int.unsigned iwordsize')\n   then true\n   else false) true"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned iwordsize' ) with zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned logn) (Int.unsigned iwordsize')\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (if zlt (Int.unsigned logn) zwordsize then true else false)\n  true"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq (if zlt (Int.unsigned logn) zwordsize then true else false)\n  true"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned logn) zwordsize"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2'_rng _ _ _ ) .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned logn) zwordsize",
                "H : Logic.eq (is_power2' n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned logn))\n        (Z.lt (Int.unsigned logn) zwordsize),\nZ.lt (Int.unsigned logn) zwordsize"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned logn))\n        (Z.lt (Int.unsigned logn) zwordsize),\nZ.lt (Int.unsigned logn) zwordsize"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold is_power2' .",
            "tactic_args": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq (is_power2' n) (Some logn)),\nLogic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ],
            "tactic_res": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq\n         match Z_one_bits wordsize (unsigned n) Z0 with\n         | nil => None\n         | cons i nil => Some (Int.repr i)\n         | cons i (cons _ _) => None\n         end (Some logn)),\nLogic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : int) (logn : Int.int)\n  (_ : Logic.eq\n         match Z_one_bits wordsize (unsigned n) Z0 with\n         | nil => None\n         | cons i nil => Some (Int.repr i)\n         | cons i (cons _ _) => None\n         end (Some logn)),\nLogic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned logn))",
                "H : Logic.eq\n  match Z_one_bits wordsize (unsigned n) Z0 with\n  | nil => None\n  | cons i nil => Some (Int.repr i)\n  | cons i (cons _ _) => None\n  end (Some logn)",
                "logn : Int.int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "destruct ( Z_one_bits wordsize ( unsigned _ ) 0 ) as [ | i [ | ? ? ] ] eqn : B .",
            "tactic_args": [
                "n : int"
            ],
            "tactic_res": [
                "H : Logic.eq None (Some logn)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) nil",
                "H : Logic.eq (Some (Int.repr i)) (Some logn)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i nil)",
                "i : BinNums.Z",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i (cons z l))",
                "l : list Z",
                "z : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "H : Logic.eq None (Some logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "H : Logic.eq (Some (Int.repr i)) (Some logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned (Int.repr i)))"
            ]
        },
        {
            "tactic_sig": "inv _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned logn))",
                "H : Logic.eq None (Some logn)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite ( Z_one_bits_powerserie wordsize ( unsigned _ ) ) by ( apply unsigned_range ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned (Int.repr i)))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (powerserie (Z_one_bits wordsize (unsigned n) Z0))\n  (two_p (Int.unsigned (Int.repr i)))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (powerserie (Z_one_bits wordsize (unsigned n) Z0))\n  (two_p (Int.unsigned (Int.repr i)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (powerserie (Z_one_bits wordsize (unsigned n) Z0)) (two_p i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.le i Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (powerserie (Z_one_bits wordsize (unsigned n) Z0)) (two_p i)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i nil)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (powerserie (cons i nil)) (two_p i)"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : Logic.eq (powerserie (cons i nil)) (two_p i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (two_p i) Z0) (two_p i)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (two_p i) Z0) (two_p i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( 0 <= _ < zwordsize ) .",
            "tactic_args": [
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Z_one_bits_range with ( unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "n : int"
            ],
            "tactic_res": [
                "_goal : In i (Z_one_bits wordsize (unsigned n) Z0)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : In i (Z_one_bits wordsize (unsigned n) Z0)",
                "B : Logic.eq (Z_one_bits wordsize (unsigned n) Z0) (cons i nil)"
            ],
            "tactic_res": [
                "_goal : In i (cons i nil)"
            ]
        },
        {
            "tactic_sig": "auto with coqlib .",
            "tactic_args": [
                "_goal : In i (cons i nil)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize < Int.max_unsigned ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Z.lt zwordsize Int.max_unsigned"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.le i Int.max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n : int) (logn : Int.int)\n  (_ : Logic.eq (is_power2' n) (Some logn)),\nLogic.eq (mul x n) (shl' x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (shl' x logn)",
                "H : Logic.eq (is_power2' n) (Some logn)",
                "logn : Int.int",
                "x : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "rewrite shl'_mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (shl' x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul x n) (mul x (shl' one logn))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (mul x n) (mul x (shl' one logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (shl' one logn)"
            ]
        },
        {
            "tactic_sig": "rewrite shl'_one_two_p .",
            "tactic_args": [
                "_goal : Logic.eq n (shl' one logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq n (repr (two_p (Int.unsigned logn)))"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( repr_unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq n (repr (two_p (Int.unsigned logn)))",
                "n : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned n)) (repr (two_p (Int.unsigned logn)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned n)) (repr (two_p (Int.unsigned logn)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ]
        },
        {
            "tactic_sig": "apply is_power2'_correct .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2' n) (Some logn)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2' n) (Some logn)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x n : int) (logn : Int.int)\n  (_ : Logic.eq (is_power2' n) (Some logn)),\nLogic.eq (divu x n) (shru' x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divu x n) (shru' x logn)",
                "H : Logic.eq (is_power2' n) (Some logn)",
                "logn : Int.int",
                "x : int",
                "n : int"
            ]
        },
        {
            "tactic_sig": "generalize ( is_power2'_correct _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (divu x n) (shru' x logn)",
                "n : int",
                "logn : Int.int",
                "H : Logic.eq (is_power2' n) (Some logn)"
            ],
            "tactic_res": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (Int.unsigned logn)),\nLogic.eq (divu x n) (shru' x logn)"
            ]
        },
        {
            "tactic_sig": "intro .",
            "tactic_args": [
                "_goal : forall _ : Logic.eq (unsigned n) (two_p (Int.unsigned logn)),\nLogic.eq (divu x n) (shru' x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (divu x n) (shru' x logn)",
                "H0 : Logic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (divu x n) (shru' x logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' x logn) (divu x n)"
            ]
        },
        {
            "tactic_sig": "unfold divu .",
            "tactic_args": [
                "_goal : Logic.eq (shru' x logn) (divu x n)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' x logn) (repr (Z.div (unsigned x) (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (shru' x logn) (repr (Z.div (unsigned x) (unsigned n)))",
                "H0 : Logic.eq (unsigned n) (two_p (Int.unsigned logn))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' x logn)\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))"
            ]
        },
        {
            "tactic_sig": "unfold shru' .",
            "tactic_args": [
                "_goal : Logic.eq (shru' x logn)\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned logn)))\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))"
            ]
        },
        {
            "tactic_sig": "rewrite Zshiftr_div_two_p .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.shiftr (unsigned x) (Int.unsigned logn)))\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))",
                "_goal : Z.le Z0 (Int.unsigned logn)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))\n  (repr (Z.div (unsigned x) (two_p (Int.unsigned logn))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "eapply is_power2'_rng .",
            "tactic_args": [
                "_goal : Z.le Z0 (Int.unsigned logn)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (is_power2' ?n) (Some logn)"
            ]
        },
        {
            "tactic_sig": "eauto .",
            "tactic_args": [
                "_goal : Logic.eq (is_power2' ?n) (Some logn)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (loword n) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (loword n) i) (testbit n i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)",
                "i : BinNums.Z",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold loword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (loword n) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (Int.repr (unsigned n)) i) (testbit n i)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.repr (unsigned n)) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned n) i) (testbit n i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned n) i) (testbit n i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (n : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (hiword n) i) (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (hiword n) i) (testbit n (Z.add i Int.zwordsize))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)",
                "i : BinNums.Z",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold hiword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (hiword n) i) (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit (Int.repr (unsigned (shru n (repr Int.zwordsize)))) i)\n  (testbit n (Z.add i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit (Int.repr (unsigned (shru n (repr Int.zwordsize)))) i)\n  (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.testbit (unsigned (shru n (repr Int.zwordsize))) i)\n  (testbit n (Z.add i Int.zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "fold ( testbit ( shru _ ( repr Int.zwordsize ) ) _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.testbit (unsigned (shru n (repr Int.zwordsize))) i)\n  (testbit n (Z.add i Int.zwordsize))",
                "n : int",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru n (repr Int.zwordsize)) i)\n  (testbit n (Z.add i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru n (repr Int.zwordsize)) i)\n  (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned (repr Int.zwordsize))) zwordsize\n   then testbit n (Z.add i (unsigned (repr Int.zwordsize)))\n   else false) (testbit n (Z.add i Int.zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "change ( unsigned ( repr Int.zwordsize ) ) with Int.zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (unsigned (repr Int.zwordsize))) zwordsize\n   then testbit n (Z.add i (unsigned (repr Int.zwordsize)))\n   else false) (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Int.zwordsize) zwordsize\n   then testbit n (Z.add i Int.zwordsize)\n   else false) (testbit n (Z.add i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Int.zwordsize) zwordsize\n   then testbit n (Z.add i Int.zwordsize)\n   else false) (testbit n (Z.add i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Z.lt (Z.add i Int.zwordsize) zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt (Z.add i Int.zwordsize) zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (hi lo : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ofwords hi lo) i)\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ofwords hi lo) i)\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z",
                "hi : Int.int",
                "lo : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold ofwords .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ofwords hi lo) i)\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize))\n        (repr (Int.unsigned lo))) i)\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_or .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize))\n        (repr (Int.unsigned lo))) i)\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (testbit (shl (repr (Int.unsigned hi)) (repr Int.zwordsize)) i)\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_shl .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (testbit (shl (repr (Int.unsigned hi)) (repr Int.zwordsize)) i)\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt i (unsigned (repr Int.zwordsize))\n      then false\n      else\n       testbit (repr (Int.unsigned hi))\n         (Z.sub i (unsigned (repr Int.zwordsize))))\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "change ( unsigned ( repr Int.zwordsize ) ) with Int.zwordsize .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt i (unsigned (repr Int.zwordsize))\n      then false\n      else\n       testbit (repr (Int.unsigned hi))\n         (Z.sub i (unsigned (repr Int.zwordsize))))\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt i Int.zwordsize\n      then false\n      else testbit (repr (Int.unsigned hi)) (Z.sub i Int.zwordsize))\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt i Int.zwordsize\n      then false\n      else testbit (repr (Int.unsigned hi)) (Z.sub i Int.zwordsize))\n     (testbit (repr (Int.unsigned lo)) i))\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb false (testbit (repr (Int.unsigned lo)) i))\n  (Int.testbit lo i)",
                "_goal : Logic.eq\n  (orb (testbit (repr (Int.unsigned hi)) (Z.sub i Int.zwordsize))\n     (testbit (repr (Int.unsigned lo)) i))\n  (Int.testbit hi (Z.sub i Int.zwordsize))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq (orb false (testbit (repr (Int.unsigned lo)) i))\n  (Int.testbit lo i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb false (Z.testbit (Int.unsigned lo) i)) (Int.testbit lo i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (orb false (Z.testbit (Int.unsigned lo) i)) (Int.testbit lo i)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite !testbit_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (testbit (repr (Int.unsigned hi)) (Z.sub i Int.zwordsize))\n     (testbit (repr (Int.unsigned lo)) i))\n  (Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize))\n     (Z.testbit (Int.unsigned lo) i))\n  (Int.testbit hi (Z.sub i Int.zwordsize))",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Z.sub i Int.zwordsize))\n  (Z.lt (Z.sub i Int.zwordsize) zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "fold ( Int.testbit _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize))\n     (Z.testbit (Int.unsigned lo) i))\n  (Int.testbit hi (Z.sub i Int.zwordsize))",
                "lo : Int.int",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize))\n     (Int.testbit lo i)) (Int.testbit hi (Z.sub i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_above .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize))\n     (Int.testbit lo i)) (Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize)) false)\n  (Int.testbit hi (Z.sub i Int.zwordsize))",
                "_goal : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "apply orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Z.testbit (Int.unsigned hi) (Z.sub i Int.zwordsize)) false)\n  (Int.testbit hi (Z.sub i Int.zwordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Z.ge i Int.zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i Int.zwordsize))\n  (Z.lt (Z.sub i Int.zwordsize) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall hi lo : Int.int, Logic.eq (loword (ofwords hi lo)) lo"
            ],
            "tactic_res": [
                "_goal : Logic.eq (loword (ofwords hi lo)) lo",
                "hi : Int.int",
                "lo : Int.int"
            ]
        },
        {
            "tactic_sig": "apply Int.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (loword (ofwords hi lo)) lo"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (loword (ofwords hi lo)) i) (Int.testbit lo i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (loword (ofwords hi lo)) i) (Int.testbit lo i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (loword (ofwords hi lo)) i) (Int.testbit lo i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_loword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (loword (ofwords hi lo)) i) (Int.testbit lo i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ofwords hi lo) i) (Int.testbit lo i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_ofwords .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ofwords hi lo) i) (Int.testbit lo i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize)) (Int.testbit lo i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit lo i\n   else Int.testbit hi (Z.sub i Int.zwordsize)) (Int.testbit lo i)"
            ],
            "tactic_res": [
                "_goal : Z.lt i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt i Int.zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall hi lo : Int.int, Logic.eq (hiword (ofwords hi lo)) hi"
            ],
            "tactic_res": [
                "_goal : Logic.eq (hiword (ofwords hi lo)) hi",
                "hi : Int.int",
                "lo : Int.int"
            ]
        },
        {
            "tactic_sig": "apply Int.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (hiword (ofwords hi lo)) hi"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (hiword (ofwords hi lo)) i) (Int.testbit hi i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (hiword (ofwords hi lo)) i) (Int.testbit hi i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (hiword (ofwords hi lo)) i) (Int.testbit hi i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_hiword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (hiword (ofwords hi lo)) i) (Int.testbit hi i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ofwords hi lo) (Z.add i Int.zwordsize))\n  (Int.testbit hi i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_ofwords .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ofwords hi lo) (Z.add i Int.zwordsize))\n  (Int.testbit hi i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Int.zwordsize) Int.zwordsize\n   then Int.testbit lo (Z.add i Int.zwordsize)\n   else Int.testbit hi (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))\n  (Int.testbit hi i)",
                "_goal : Logic.and (Z.le Z0 (Z.add i Int.zwordsize))\n  (Z.lt (Z.add i Int.zwordsize) zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i Int.zwordsize) Int.zwordsize\n   then Int.testbit lo (Z.add i Int.zwordsize)\n   else Int.testbit hi (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))\n  (Int.testbit hi i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit hi (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))\n  (Int.testbit hi i)",
                "_goal : Z.ge (Z.add i Int.zwordsize) Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit hi (Z.sub (Z.add i Int.zwordsize) Int.zwordsize))\n  (Int.testbit hi i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i Int.zwordsize) Int.zwordsize) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i Int.zwordsize) Int.zwordsize) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge (Z.add i Int.zwordsize) Int.zwordsize"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.add i Int.zwordsize))\n  (Z.lt (Z.add i Int.zwordsize) zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : int, Logic.eq (ofwords (hiword n) (loword n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ofwords (hiword n) (loword n)) n",
                "n : int"
            ]
        },
        {
            "tactic_sig": "apply same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (ofwords (hiword n) (loword n)) n"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ofwords (hiword n) (loword n)) i) (testbit n i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (ofwords (hiword n) (loword n)) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (ofwords (hiword n) (loword n)) i) (testbit n i)",
                "H : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (ofwords (hiword n) (loword n)) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (loword n) i\n   else Int.testbit (hiword n) (Z.sub i Int.zwordsize)) \n  (testbit n i)",
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (loword n) i\n   else Int.testbit (hiword n) (Z.sub i Int.zwordsize)) \n  (testbit n i)",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (loword n) i) (testbit n i)",
                "_goal : Logic.eq (Int.testbit (hiword n) (Z.sub i Int.zwordsize)) (testbit n i)",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "apply bits_loword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (loword n) i) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_hiword .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (hiword n) (Z.sub i Int.zwordsize)) (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit n (Z.add (Z.sub i Int.zwordsize) Int.zwordsize))\n  (testbit n i)",
                "_goal : Logic.and (Z.le Z0 (Z.sub i Int.zwordsize))\n  (Z.lt (Z.sub i Int.zwordsize) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (testbit n (Z.add (Z.sub i Int.zwordsize) Int.zwordsize))\n  (testbit n i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) Int.zwordsize) i"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) Int.zwordsize) i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub i Int.zwordsize))\n  (Z.lt (Z.sub i Int.zwordsize) Int.zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall lo hi : Int.int,\nLogic.eq (ofwords hi lo)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ofwords hi lo)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))",
                "lo : Int.int",
                "hi : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold ofwords .",
            "tactic_args": [
                "_goal : Logic.eq (ofwords hi lo)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize))\n     (repr (Int.unsigned lo)))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ]
        },
        {
            "tactic_sig": "rewrite shifted_or_is_add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (or (shl (repr (Int.unsigned hi)) (repr Int.zwordsize))\n     (repr (Int.unsigned lo)))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (unsigned (repr (Int.unsigned hi)))\n           (two_p Int.zwordsize)) (unsigned (repr (Int.unsigned lo)))))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))",
                "_goal : Logic.and (Z.le Z0 Int.zwordsize) (Z.lt Int.zwordsize zwordsize)",
                "_goal : Z.lt (unsigned (repr (Int.unsigned lo))) (two_p Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (unsigned (repr (Int.unsigned hi)))\n           (two_p Int.zwordsize)) (unsigned (repr (Int.unsigned lo)))))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (unsigned (repr (Int.unsigned hi))) (two_p Int.zwordsize))\n     (unsigned (repr (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (unsigned (repr (Int.unsigned hi))) (two_p Int.zwordsize))\n     (unsigned (repr (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (unsigned (repr (Int.unsigned hi))) (two_p Int.zwordsize))\n  (Z.mul (Int.unsigned hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm (unsigned (repr (Int.unsigned lo))) (Int.unsigned lo)"
            ]
        },
        {
            "tactic_sig": "apply eqm_mult .",
            "tactic_args": [
                "_goal : eqm (Z.mul (unsigned (repr (Int.unsigned hi))) (two_p Int.zwordsize))\n  (Z.mul (Int.unsigned hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (Int.unsigned hi))) (Int.unsigned hi)",
                "_goal : eqm (two_p Int.zwordsize) (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Int.unsigned hi))) (Int.unsigned hi)"
            ],
            "tactic_res": [
                "_goal : eqm (Int.unsigned hi) (unsigned (repr (Int.unsigned hi)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (Int.unsigned hi) (unsigned (repr (Int.unsigned hi)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (two_p Int.zwordsize) (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_sym .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Int.unsigned lo))) (Int.unsigned lo)"
            ],
            "tactic_res": [
                "_goal : eqm (Int.unsigned lo) (unsigned (repr (Int.unsigned lo)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : eqm (Int.unsigned lo) (unsigned (repr (Int.unsigned lo)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "change Int.zwordsize with 32 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 Int.zwordsize) (Z.lt Int.zwordsize zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Zpos (xO (xO (xO (xO (xO xH)))))))\n  (Z.lt (Zpos (xO (xO (xO (xO (xO xH)))))) zwordsize)"
            ]
        },
        {
            "tactic_sig": "change zwordsize with 64 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Zpos (xO (xO (xO (xO (xO xH)))))))\n  (Z.lt (Zpos (xO (xO (xO (xO (xO xH)))))) zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Zpos (xO (xO (xO (xO (xO xH)))))))\n  (Z.lt (Zpos (xO (xO (xO (xO (xO xH))))))\n     (Zpos (xO (xO (xO (xO (xO (xO xH))))))))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Zpos (xO (xO (xO (xO (xO xH)))))))\n  (Z.lt (Zpos (xO (xO (xO (xO (xO xH))))))\n     (Zpos (xO (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Z.lt (unsigned (repr (Int.unsigned lo))) (two_p Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned lo) (two_p Int.zwordsize)",
                "_goal : Logic.and (Z.le Z0 (Int.unsigned lo))\n  (Z.le (Int.unsigned lo) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned lo) (two_p Int.zwordsize)",
                "lo : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned lo))\n        (Z.lt (Int.unsigned lo) Int.modulus),\nZ.lt (Int.unsigned lo) (two_p Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "intros [ A B ] .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned lo))\n        (Z.lt (Int.unsigned lo) Int.modulus),\nZ.lt (Int.unsigned lo) (two_p Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Z.lt (Int.unsigned lo) (two_p Int.zwordsize)",
                "B : Z.lt (Int.unsigned lo) Int.modulus",
                "A : Z.le Z0 (Int.unsigned lo)"
            ]
        },
        {
            "tactic_sig": "exact _ .",
            "tactic_args": [
                "_goal : Z.lt (Int.unsigned lo) (two_p Int.zwordsize)",
                "B : Z.lt (Int.unsigned lo) Int.modulus"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( Int.max_unsigned < max_unsigned ) by ( compute ; auto ) .",
            "tactic_args": [],
            "tactic_res": [
                "H : Z.lt Int.max_unsigned max_unsigned"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range_2 _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned lo))\n  (Z.le (Int.unsigned lo) max_unsigned)",
                "lo : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned lo))\n        (Z.le (Int.unsigned lo) Int.max_unsigned),\nLogic.and (Z.le Z0 (Int.unsigned lo))\n  (Z.le (Int.unsigned lo) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned lo))\n        (Z.le (Int.unsigned lo) Int.max_unsigned),\nLogic.and (Z.le Z0 (Int.unsigned lo))\n  (Z.le (Int.unsigned lo) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall lo hi : Int.int,\nLogic.eq (unsigned (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))",
                "lo : Int.int",
                "hi : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.add\n           (Z.mul (Int.unsigned hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ]
        },
        {
            "tactic_sig": "apply unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned\n     (repr\n        (Z.add\n           (Z.mul (Int.unsigned hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_unsigned)",
                "hi : Int.int",
                "lo : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "change ( two_p 32 ) with Int.modulus .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le Z0\n     (Z.add (Z.mul (Int.unsigned hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.unsigned hi) Int.modulus) (Int.unsigned lo))\n     max_unsigned)"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with 4294967296 .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le Z0\n     (Z.add (Z.mul (Int.unsigned hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.unsigned hi) Int.modulus) (Int.unsigned lo))\n     max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "change max_unsigned with 18446744073709551615 .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo))\n     (Zpos\n        (xI\n           (xI\n              (xI\n                 (xI\n                    (xI\n                       (xI\n                          (xI\n                             (xI\n                                (xI\n                                   (xI\n                                      (xI\n                                         (xI\n                                            (xI\n                                               (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI (xI (xI (xI xH)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned hi))\n         (Z.lt (Int.unsigned hi)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le Z0\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo))\n     (Zpos\n        (xI\n           (xI\n              (xI\n                 (xI\n                    (xI\n                       (xI\n                          (xI\n                             (xI\n                                (xI\n                                   (xI\n                                      (xI\n                                         (xI\n                                            (xI\n                                               (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI (xI (xI (xI xH)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : Z) (_ : Int.eqm x y),\neqm (Z.mul x (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul x (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "H : Int.eqm x y",
                "x : BinNums.Z",
                "y : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "destruct _ as [ k EQ ] .",
            "tactic_args": [
                "H : Int.eqm x y"
            ],
            "tactic_res": [
                "EQ : Logic.eq x (Z.add (Z.mul k Int.modulus) y)",
                "k : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "exists _ .",
            "tactic_args": [
                "_goal : eqm (Z.mul x (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "k : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.mul x (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Z.mul x (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))",
                "EQ : Logic.eq x (Z.add (Z.mul k Int.modulus) y)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k Int.modulus) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with ( two_p 32 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k Int.modulus) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "change modulus with ( two_p 32 * two_p 32 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add (Z.mul k modulus)\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add\n     (Z.mul k\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.mul (Z.add (Z.mul k (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) y)\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.add\n     (Z.mul k\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.mul y (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall lo hi : Int.int,\nLogic.eq (signed (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))",
                "lo : Int.int",
                "hi : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq (signed (ofwords hi lo))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (signed\n     (repr\n        (Z.add\n           (Z.mul (Int.unsigned hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))"
            ]
        },
        {
            "tactic_sig": "replace ( repr ( Int.unsigned _ * two_p 32 + Int.unsigned _ ) ) with ( repr ( Int.signed _ * two_p 32 + Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (signed\n     (repr\n        (Z.add\n           (Z.mul (Int.unsigned hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))",
                "hi : Int.int",
                "lo : Int.int",
                "hi : Int.int",
                "lo : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (signed\n     (repr\n        (Z.add\n           (Z.mul (Int.signed hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))",
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ]
        },
        {
            "tactic_sig": "apply signed_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (signed\n     (repr\n        (Z.add\n           (Z.mul (Int.signed hi)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned lo))))\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le min_signed\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_signed)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.signed_range _ ) ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le min_signed\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_signed)",
                "hi : Int.int",
                "lo : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le min_signed\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_signed)"
            ]
        },
        {
            "tactic_sig": "change ( two_p 32 ) with Int.modulus .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le min_signed\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)) max_signed)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le min_signed\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     max_signed)"
            ]
        },
        {
            "tactic_sig": "change min_signed with ( Int.min_signed * Int.modulus ) .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le min_signed\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     max_signed)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le (Z.mul Int.min_signed Int.modulus)\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     max_signed)"
            ]
        },
        {
            "tactic_sig": "change max_signed with ( Int.max_signed * Int.modulus + Int.modulus - 1 ) .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le (Z.mul Int.min_signed Int.modulus)\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     max_signed)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le (Z.mul Int.min_signed Int.modulus)\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     (Z.sub (Z.add (Z.mul Int.max_signed Int.modulus) Int.modulus)\n        (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with 4294967296 .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo) Int.modulus)),\nLogic.and\n  (Z.le (Z.mul Int.min_signed Int.modulus)\n     (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo)))\n  (Z.le (Z.add (Z.mul (Int.signed hi) Int.modulus) (Int.unsigned lo))\n     (Z.sub (Z.add (Z.mul Int.max_signed Int.modulus) Int.modulus)\n        (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le\n     (Z.mul Int.min_signed\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo))\n     (Z.sub\n        (Z.add\n           (Z.mul Int.max_signed\n              (Zpos\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Int.min_signed (Int.signed hi))\n         (Z.le (Int.signed hi) Int.max_signed))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned lo))\n         (Z.lt (Int.unsigned lo)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.and\n  (Z.le\n     (Z.mul Int.min_signed\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo)))\n  (Z.le\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Int.unsigned lo))\n     (Z.sub\n        (Z.add\n           (Z.mul Int.max_signed\n              (Zpos\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Int.signed hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned hi)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned lo)))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned lo))\n  (Z.add\n     (Z.mul (Int.unsigned hi)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned lo))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Int.unsigned hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm (Int.unsigned lo) (Int.unsigned lo)"
            ]
        },
        {
            "tactic_sig": "apply eqm_mul_2p32 .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Int.signed hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Int.unsigned hi) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.signed hi) (Int.unsigned hi)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_signed_unsigned .",
            "tactic_args": [
                "_goal : Int.eqm (Int.signed hi) (Int.unsigned hi)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Int.unsigned lo) (Int.unsigned lo)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (f : forall (_ : bool) (_ : bool), bool)\n  (f64 : forall (_ : int) (_ : int), int)\n  (f32 : forall (_ : Int.int) (_ : Int.int), Int.int)\n  (xh xl yh yl : Int.int)\n  (_ : forall (x y : int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\n       Logic.eq (testbit (f64 x y) i) (f (testbit x i) (testbit y i)))\n  (_ : forall (x y : Int.int) (i : Z)\n         (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\n       Logic.eq (Int.testbit (f32 x y) i)\n         (f (Int.testbit x i) (Int.testbit y i))),\nLogic.eq (f64 (ofwords xh xl) (ofwords yh yl))\n  (ofwords (f32 xh yh) (f32 xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f64 (ofwords xh xl) (ofwords yh yl))\n  (ofwords (f32 xh yh) (f32 xl yl))",
                "H0 : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (f32 x y) i)\n  (f (Int.testbit x i) (Int.testbit y i))",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f64 x y) i) (f (testbit x i) (testbit y i))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int",
                "f32 : forall (_ : Int.int) (_ : Int.int), Int.int",
                "f64 : forall (_ : int) (_ : int), int",
                "f : forall (_ : bool) (_ : bool), bool"
            ]
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (f64 (ofwords xh xl) (ofwords yh yl))\n  (ofwords (f32 xh yh) (f32 xl yl))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f64 (ofwords xh xl) (ofwords yh yl)) i)\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f64 (ofwords xh xl) (ofwords yh yl)) i)\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (f64 (ofwords xh xl) (ofwords yh yl)) i)\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)",
                "H1 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite _ by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (f64 (ofwords xh xl) (ofwords yh yl)) i)\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)",
                "H : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (f64 x y) i) (f (testbit x i) (testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (testbit (ofwords xh xl) i) (testbit (ofwords yh yl) i))\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)"
            ]
        },
        {
            "tactic_sig": "rewrite ! bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq (f (testbit (ofwords xh xl) i) (testbit (ofwords yh yl) i))\n  (testbit (ofwords (f32 xh yh) (f32 xl yl)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f\n     (if zlt i Int.zwordsize\n      then Int.testbit xl i\n      else Int.testbit xh (Z.sub i Int.zwordsize))\n     (if zlt i Int.zwordsize\n      then Int.testbit yl i\n      else Int.testbit yh (Z.sub i Int.zwordsize)))\n  (if zlt i Int.zwordsize\n   then Int.testbit (f32 xl yl) i\n   else Int.testbit (f32 xh yh) (Z.sub i Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H2 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f\n     (if zlt i Int.zwordsize\n      then Int.testbit xl i\n      else Int.testbit xh (Z.sub i Int.zwordsize))\n     (if zlt i Int.zwordsize\n      then Int.testbit yl i\n      else Int.testbit yh (Z.sub i Int.zwordsize)))\n  (if zlt i Int.zwordsize\n   then Int.testbit (f32 xl yl) i\n   else Int.testbit (f32 xh yh) (Z.sub i Int.zwordsize))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (Int.testbit xl i) (Int.testbit yl i))\n  (Int.testbit (f32 xl yl) i)",
                "_goal : Logic.eq\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))\n  (Int.testbit (f32 xh yh) (Z.sub i Int.zwordsize))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq (f (Int.testbit xl i) (Int.testbit yl i))\n  (Int.testbit (f32 xl yl) i)",
                "H0 : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (f32 x y) i)\n  (f (Int.testbit x i) (Int.testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (f (Int.testbit xl i) (Int.testbit yl i))\n  (f (Int.testbit xl i) (Int.testbit yl i))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (f (Int.testbit xl i) (Int.testbit yl i))\n  (f (Int.testbit xl i) (Int.testbit yl i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite _ by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))\n  (Int.testbit (f32 xh yh) (Z.sub i Int.zwordsize))",
                "H0 : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (f32 x y) i)\n  (f (Int.testbit x i) (Int.testbit y i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))\n  (f (Int.testbit xh (Z.sub i Int.zwordsize))\n     (Int.testbit yh (Z.sub i Int.zwordsize)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (and (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.and xh yh) (Int.and xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (and (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.and xh yh) (Int.and xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "apply decompose_bitwise_binop with andb .",
            "tactic_args": [
                "_goal : Logic.eq (and (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.and xh yh) (Int.and xl yl))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))",
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.and x y) i)\n  (andb (Int.testbit x i) (Int.testbit y i))"
            ]
        },
        {
            "tactic_sig": "apply bits_and .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (and x y) i) (andb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.bits_and .",
            "tactic_args": [
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.and x y) i)\n  (andb (Int.testbit x i) (Int.testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (or (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.or xh yh) (Int.or xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (or (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.or xh yh) (Int.or xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "apply decompose_bitwise_binop with orb .",
            "tactic_args": [
                "_goal : Logic.eq (or (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.or xh yh) (Int.or xl yl))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))",
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.or x y) i)\n  (orb (Int.testbit x i) (Int.testbit y i))"
            ]
        },
        {
            "tactic_sig": "apply bits_or .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (or x y) i) (orb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.bits_or .",
            "tactic_args": [
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.or x y) i)\n  (orb (Int.testbit x i) (Int.testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (xor (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.xor xh yh) (Int.xor xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.xor xh yh) (Int.xor xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "apply decompose_bitwise_binop with xorb .",
            "tactic_args": [
                "_goal : Logic.eq (xor (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.xor xh yh) (Int.xor xl yl))"
            ],
            "tactic_res": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))",
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.xor x y) i)\n  (xorb (Int.testbit x i) (Int.testbit y i))"
            ]
        },
        {
            "tactic_sig": "apply bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (xor x y) i) (xorb (testbit x i) (testbit y i))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.bits_xor .",
            "tactic_args": [
                "_goal : forall (x y : Int.int) (i : Z)\n  (_ : Logic.and (Z.le Z0 i) (Z.lt i Int.zwordsize)),\nLogic.eq (Int.testbit (Int.xor x y) i)\n  (xorb (Int.testbit x i) (Int.testbit y i))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl : Int.int,\nLogic.eq (not (ofwords xh xl)) (ofwords (Int.not xh) (Int.not xl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (not (ofwords xh xl)) (ofwords (Int.not xh) (Int.not xl))",
                "xh : Int.int",
                "xl : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold not , Int.not .",
            "tactic_args": [
                "_goal : Logic.eq (not (ofwords xh xl)) (ofwords (Int.not xh) (Int.not xl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (ofwords xh xl) mone)\n  (ofwords (Int.xor xh Int.mone) (Int.xor xl Int.mone))"
            ]
        },
        {
            "tactic_sig": "rewrite <- decompose_xor .",
            "tactic_args": [
                "_goal : Logic.eq (xor (ofwords xh xl) mone)\n  (ofwords (Int.xor xh Int.mone) (Int.xor xl Int.mone))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (xor (ofwords xh xl) mone)\n  (xor (ofwords xh xl) (ofwords Int.mone Int.mone))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (xor (ofwords xh xl) mone)\n  (xor (ofwords xh xl) (ofwords Int.mone Int.mone))"
            ],
            "tactic_res": [
                "_goal : Logic.eq mone (ofwords Int.mone Int.mone)"
            ]
        },
        {
            "tactic_sig": "apply ( Int64.eq_spec mone ( ofwords Int.mone Int.mone ) ) .",
            "tactic_args": [
                "_goal : Logic.eq mone (ofwords Int.mone Int.mone)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Z0 (Int.unsigned y))\n         (Z.lt (Int.unsigned y) Int.zwordsize)),\nLogic.eq (shl' (ofwords xh xl) y)\n  (ofwords\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Int.shl xl y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (ofwords xh xl) y)\n  (ofwords\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Int.shl xl y))",
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) Int.zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub Int.iwordsize _ ) = Int.zwordsize - Int.unsigned _ ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize Int.wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H1 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (ofwords xh xl) y)\n  (ofwords\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Int.shl xl y))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords\n        (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n        (Int.shl xl y)) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shl xl y) i\n   else\n    Int.testbit\n      (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n      (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shl xl y) i\n   else\n    Int.testbit\n      (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n      (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (Int.shl xl y) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.shl xl y) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false",
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "l0 : Z.lt i (Int.unsigned y)",
                "g : Z.ge i (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xl (Z.sub i (Int.unsigned y)))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_or by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shl xh y) (Int.shru xl (Int.sub Int.iwordsize y)))\n     (Z.sub i Int.zwordsize))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shl xh y) (Z.sub i Int.zwordsize))\n     (Int.testbit (Int.shru xl (Int.sub Int.iwordsize y))\n        (Z.sub i Int.zwordsize)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shl xh y) (Z.sub i Int.zwordsize))\n     (Int.testbit (Int.shru xl (Int.sub Int.iwordsize y))\n        (Z.sub i Int.zwordsize)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (Int.testbit (Int.shru xl (Int.sub Int.iwordsize y))\n        (Z.sub i Int.zwordsize)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shru by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (Int.testbit (Int.shru xl (Int.sub Int.iwordsize y))\n        (Z.sub i Int.zwordsize)))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize y)))\n      else false))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize y)))\n      else false))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.unsigned _ ) ( Int.zwordsize ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false)) (Int.testbit xl (Z.sub i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))",
                "l : Z.lt (Z.sub i (Int.unsigned y)) Int.zwordsize",
                "g0 : Z.ge (Z.sub i (Int.unsigned y)) Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false)) (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false)) (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false)) (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xl\n        (Z.add (Z.sub i Int.zwordsize)\n           (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_l .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xl\n        (Z.add (Z.sub i Int.zwordsize)\n           (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.add (Z.sub i Int.zwordsize)\n        (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.add (Z.sub i Int.zwordsize)\n        (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub i (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub i (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.sub i Int.zwordsize) (Int.unsigned y)\n      then false\n      else\n       Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y))) Int.zwordsize\n      then\n       Int.testbit xl\n         (Z.add (Z.sub i Int.zwordsize)\n            (Z.sub Int.zwordsize (Int.unsigned y)))\n      else false))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     false)\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n     false)\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n         (Z.lt (Int.unsigned y) zwordsize)),\nLogic.eq (shl' (ofwords xh xl) y)\n  (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shl' (ofwords xh xl) y)\n  (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero)",
                "H : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n  (Z.lt (Int.unsigned y) zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub _ Int.iwordsize ) = Int.unsigned _ - Int.zwordsize ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "H1 : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range_2 _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shl' (ofwords xh xl) y)\n  (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero)"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shl' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shl' (ofwords xh xl) y) i)\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (ofwords (Int.shl xl (Int.sub y Int.iwordsize)) Int.zero) i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit Int.zero i\n   else\n    Int.testbit (Int.shl xl (Int.sub y Int.iwordsize))\n      (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit Int.zero i\n   else\n    Int.testbit (Int.shl xl (Int.sub y Int.iwordsize))\n      (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit Int.zero i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (Int.testbit (Int.shl xl (Int.sub y Int.iwordsize))\n     (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit Int.zero i)\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit Int.zero i) false"
            ]
        },
        {
            "tactic_sig": "apply Int.bits_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit Int.zero i) false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit (Int.shl xl (Int.sub y Int.iwordsize))\n     (Z.sub i Int.zwordsize))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize))))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize))))\n  (if zlt i (Int.unsigned y)\n   then false\n   else testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize)))) false",
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize))))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))",
                "l : Z.lt i (Int.unsigned y)",
                "g0 : Z.ge i (Int.unsigned y)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize)))) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.sub i Int.zwordsize)\n      (Int.unsigned (Int.sub y Int.iwordsize))\n   then false\n   else\n    Int.testbit xl\n      (Z.sub (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub y Int.iwordsize))))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (testbit (ofwords xh xl) (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (if zlt (Z.sub i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.sub i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.sub i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xl\n     (Z.sub (Z.sub i Int.zwordsize)\n        (Int.unsigned (Int.sub y Int.iwordsize))))\n  (Int.testbit xl (Z.sub i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.sub (Z.sub i Int.zwordsize)\n     (Int.unsigned (Int.sub y Int.iwordsize)))\n  (Z.sub i (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.sub (Z.sub i Int.zwordsize)\n     (Int.unsigned (Int.sub y Int.iwordsize)))\n  (Z.sub i (Int.unsigned y))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Z0 (Int.unsigned y))\n         (Z.lt (Int.unsigned y) Int.zwordsize)),\nLogic.eq (shru' (ofwords xh xl) y)\n  (ofwords (Int.shru xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (ofwords xh xl) y)\n  (ofwords (Int.shru xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))",
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) Int.zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub Int.iwordsize _ ) = Int.zwordsize - Int.unsigned _ ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize Int.wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H1 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (ofwords xh xl) y)\n  (ofwords (Int.shru xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shru xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then\n    Int.testbit\n      (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i\n   else Int.testbit (Int.shru xh y) (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then\n    Int.testbit\n      (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i\n   else Int.testbit (Int.shru xh y) (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "_goal : Logic.eq (Int.testbit (Int.shru xh y) (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_or by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (Int.testbit (Int.shl xh (Int.sub Int.iwordsize y)) i))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (Int.testbit (Int.shl xh (Int.sub Int.iwordsize y)) i))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shru by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) ( Int.zwordsize ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit xl (Z.add i (Int.unsigned y)))\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (orb false\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "l0 : Z.lt (Z.add i (Int.unsigned y)) Int.zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned y)) Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit xl (Z.add i (Int.unsigned y)))\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (Int.testbit xl (Z.add i (Int.unsigned y))) false)\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Int.testbit xl (Z.add i (Int.unsigned y))) false)\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xl (Z.add i (Int.unsigned y)))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xl (Z.add i (Int.unsigned y)))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_l .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.bits_shru by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.shru xh y) (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false) (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false) false",
                "l : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g0 : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false) (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n         (Z.lt (Int.unsigned y) zwordsize)),\nLogic.eq (shru' (ofwords xh xl) y)\n  (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shru' (ofwords xh xl) y)\n  (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize)))",
                "H : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n  (Z.lt (Int.unsigned y) zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub _ Int.iwordsize ) = Int.unsigned _ - Int.zwordsize ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "H1 : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range_2 _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shru' (ofwords xh xl) y)\n  (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize)))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shru' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shru' (ofwords xh xl) y) i)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (ofwords Int.zero (Int.shru xh (Int.sub y Int.iwordsize))) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shru xh (Int.sub y Int.iwordsize)) i\n   else Int.testbit Int.zero (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shru xh (Int.sub y Int.iwordsize)) i\n   else Int.testbit Int.zero (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (Int.shru xh (Int.sub y Int.iwordsize)) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "_goal : Logic.eq (Int.testbit Int.zero (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shru by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.shru xh (Int.sub y Int.iwordsize)) i)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n      Int.zwordsize\n   then\n    Int.testbit xh (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n      Int.zwordsize\n   then\n    Int.testbit xh (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "H1 : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false)\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false) (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false) false",
                "l0 : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false) (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)) Int.zwordsize\n   then Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Logic.eq false false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq false false"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit Int.zero (Z.sub i Int.zwordsize))\n  (if zlt (Z.add i (Int.unsigned y)) zwordsize\n   then testbit (ofwords xh xl) (Z.add i (Int.unsigned y))\n   else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit Int.zero (Z.sub i Int.zwordsize)) false"
            ]
        },
        {
            "tactic_sig": "apply Int.bits_zero .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit Int.zero (Z.sub i Int.zwordsize)) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Z0 (Int.unsigned y))\n         (Z.lt (Int.unsigned y) Int.zwordsize)),\nLogic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))",
                "H : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.lt (Int.unsigned y) Int.zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub Int.iwordsize _ ) = Int.zwordsize - Int.unsigned _ ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y)))\n  (Z.le (Z.sub (Int.unsigned Int.iwordsize) (Int.unsigned y))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize Int.wordsize_max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall _ : Z.le Int.zwordsize Int.max_unsigned,\nLogic.and (Z.le Z0 (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.le (Z.sub Int.zwordsize (Int.unsigned y)) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H1 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh y)\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shr xh y)\n        (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))))\n     i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then\n    Int.testbit\n      (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i\n   else Int.testbit (Int.shr xh y) (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then\n    Int.testbit\n      (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i\n   else Int.testbit (Int.shr xh y) (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.eq (Int.testbit (Int.shr xh y) (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_or by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit\n     (Int.or (Int.shru xl y) (Int.shl xh (Int.sub Int.iwordsize y))) i)\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (Int.testbit (Int.shl xh (Int.sub Int.iwordsize y)) i))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shl by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (Int.testbit (Int.shl xh (Int.sub Int.iwordsize y)) i))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shru by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit (Int.shru xl y) i)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Int.unsigned (Int.sub Int.iwordsize y))\n      then false\n      else\n       Int.testbit xh\n         (Z.sub i (Int.unsigned (Int.sub Int.iwordsize y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "H0 : Logic.eq (Int.unsigned (Int.sub Int.iwordsize y))\n  (Z.sub Int.zwordsize (Int.unsigned y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) ( Int.zwordsize ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb\n     (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n      then Int.testbit xl (Z.add i (Int.unsigned y))\n      else false)\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb (Int.testbit xl (Z.add i (Int.unsigned y)))\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (orb false\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))",
                "l0 : Z.lt (Z.add i (Int.unsigned y)) Int.zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned y)) Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb (Int.testbit xl (Z.add i (Int.unsigned y)))\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (orb (Int.testbit xl (Z.add i (Int.unsigned y))) false)\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_r .",
            "tactic_args": [
                "_goal : Logic.eq (orb (Int.testbit xl (Z.add i (Int.unsigned y))) false)\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xl (Z.add i (Int.unsigned y)))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xl (Z.add i (Int.unsigned y)))\n  (Int.testbit xl (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (if zlt i (Z.sub Int.zwordsize (Int.unsigned y))\n      then false\n      else\n       Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite orb_false_l .",
            "tactic_args": [
                "_goal : Logic.eq\n  (orb false\n     (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y))))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub i (Z.sub Int.zwordsize (Int.unsigned y)))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.shr xh y) (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g0 : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add (Z.sub i Int.zwordsize) (Int.unsigned y))\n         Int.zwordsize\n      then Z.add (Z.sub i Int.zwordsize) (Int.unsigned y)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (xh xl y : Int.int)\n  (_ : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n         (Z.lt (Int.unsigned y) zwordsize)),\nLogic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n     (Int.shr xh (Int.sub y Int.iwordsize)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n     (Int.shr xh (Int.sub y Int.iwordsize)))",
                "H : Logic.and (Z.le Int.zwordsize (Int.unsigned y))\n  (Z.lt (Int.unsigned y) zwordsize)",
                "xh : Int.int",
                "xl : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( zwordsize = 2 * Int.zwordsize ) by reflexivity .",
            "tactic_args": [],
            "tactic_res": [
                "H0 : Logic.eq zwordsize (Z.mul (Zpos (xO xH)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "assert ( Int.unsigned ( Int.sub _ Int.iwordsize ) = Int.unsigned _ - Int.zwordsize ) .",
            "tactic_args": [
                "y : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "H1 : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned\n     (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)",
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_wordsize .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned Int.iwordsize))\n     Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range_2 _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.le (Z.sub (Int.unsigned y) Int.zwordsize) Int.max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int64.same_bits_eq .",
            "tactic_args": [
                "_goal : Logic.eq (shr' (ofwords xh xl) y)\n  (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n     (Int.shr xh (Int.sub y Int.iwordsize)))"
            ],
            "tactic_res": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (i : Z) (_ : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)),\nLogic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)",
                "H2 : Logic.and (Z.le Z0 i) (Z.lt i zwordsize)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "rewrite bits_shr' by auto .",
            "tactic_args": [
                "_goal : Logic.eq (testbit (shr' (ofwords xh xl) y) i)\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (testbit\n     (ofwords (Int.shr xh (Int.sub Int.iwordsize Int.one))\n        (Int.shr xh (Int.sub y Int.iwordsize))) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shr xh (Int.sub y Int.iwordsize)) i\n   else\n    Int.testbit (Int.shr xh (Int.sub Int.iwordsize Int.one))\n      (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt _ Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt i Int.zwordsize\n   then Int.testbit (Int.shr xh (Int.sub y Int.iwordsize)) i\n   else\n    Int.testbit (Int.shr xh (Int.sub Int.iwordsize Int.one))\n      (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit (Int.shr xh (Int.sub y Int.iwordsize)) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "_goal : Logic.eq\n  (Int.testbit (Int.shr xh (Int.sub Int.iwordsize Int.one))\n     (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt i Int.zwordsize",
                "g : Z.ge i Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite Int.bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit (Int.shr xh (Int.sub y Int.iwordsize)) i)\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n         Int.zwordsize\n      then Z.add i (Int.unsigned (Int.sub y Int.iwordsize))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Int.unsigned (Int.sub y Int.iwordsize)))\n         Int.zwordsize\n      then Z.add i (Int.unsigned (Int.sub y Int.iwordsize))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "H1 : Logic.eq (Int.unsigned (Int.sub y Int.iwordsize))\n  (Z.sub (Int.unsigned y) Int.zwordsize)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))",
                "l0 : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)))\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n  (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt (Z.add i (Z.sub (Int.unsigned y) Int.zwordsize))\n         Int.zwordsize\n      then Z.add i (Z.sub (Int.unsigned y) Int.zwordsize)\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.testbit xh (Z.sub Int.zwordsize (Zpos xH)))\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.bits_shr by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit (Int.shr xh (Int.sub Int.iwordsize Int.one))\n     (Z.sub i Int.zwordsize))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize Int.one)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub Int.iwordsize Int.one))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "change ( Int.unsigned ( Int.sub Int.iwordsize Int.one ) ) with ( Int.zwordsize - 1 ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize)\n            (Int.unsigned (Int.sub Int.iwordsize Int.one)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize)\n         (Int.unsigned (Int.sub Int.iwordsize Int.one))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ + Int.unsigned _ ) zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl)\n     (if zlt (Z.add i (Int.unsigned y)) zwordsize\n      then Z.add i (Int.unsigned y)\n      else Z.sub zwordsize (Zpos xH)))",
                "i : BinNums.Z",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))",
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))",
                "l : Z.lt (Z.add i (Int.unsigned y)) zwordsize",
                "g0 : Z.ge (Z.add i (Int.unsigned y)) zwordsize"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.add i (Int.unsigned y)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "rewrite bits_ofwords by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (testbit (ofwords xh xl) (Z.sub zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.add i (Int.unsigned y)) Int.zwordsize\n   then Int.testbit xl (Z.add i (Int.unsigned y))\n   else Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n      Int.zwordsize\n   then Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n   else Z.sub Int.zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.zwordsize + ( Int.zwordsize - 1 ) ) Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n      Int.zwordsize\n   then Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n   else Z.sub Int.zwordsize (Zpos xH))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))",
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (Z.sub Int.zwordsize (Zpos xH))",
                "l0 : Z.lt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n  Int.zwordsize",
                "g0 : Z.ge (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n  Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.add i (Int.unsigned y)) Int.zwordsize)\n  (Z.sub Int.zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Z.sub zwordsize (Zpos xH)) Int.zwordsize\n   then Int.testbit xl (Z.sub zwordsize (Zpos xH))\n   else\n    Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.testbit xh (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize))\n  (Int.testbit xh\n     (if\n       zlt\n         (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n         Int.zwordsize\n      then\n       Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n      else Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n      Int.zwordsize\n   then Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n   else Z.sub Int.zwordsize (Zpos xH))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( _ - Int.zwordsize + ( Int.zwordsize - 1 ) ) Int.zwordsize ) .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (if\n    zlt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n      Int.zwordsize\n   then Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH))\n   else Z.sub Int.zwordsize (Zpos xH))",
                "i : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))",
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (Z.sub Int.zwordsize (Zpos xH))",
                "l : Z.lt (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n  Int.zwordsize",
                "g1 : Z.ge (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))\n  Int.zwordsize"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (Z.add (Z.sub i Int.zwordsize) (Z.sub Int.zwordsize (Zpos xH)))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Z.sub zwordsize (Zpos xH)) Int.zwordsize)\n  (Z.sub Int.zwordsize (Zpos xH))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (add (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))\n     (Int.add xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (add (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))\n     (Int.add xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (add (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))\n     (Int.add xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))\n     (Int.add xl yl)) (add (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero))\n     (Int.add xl yl)) (add (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.add xl yl))))\n  (add (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "rewrite add_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.add xl yl))))\n  (add (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.add xl yl))))\n  (repr (Z.add (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.add xl yl))))\n  (repr (Z.add (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.add xl yl)))\n  (Z.add (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl)))"
            ]
        },
        {
            "tactic_sig": "rewrite ! ofwords_add' .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.add xl yl)))\n  (Z.add (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl)))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.add xl yl)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))"
            ]
        },
        {
            "tactic_sig": "rewrite ( Int.unsigned_add_carry _ _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.add xl yl)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned (Int.add_carry xl yl Int.zero))\n           Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))"
            ]
        },
        {
            "tactic_sig": "set ( cc := Int.add_carry _ _ Int.zero ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add xh yh) (Int.add_carry xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned (Int.add_carry xl yl Int.zero))\n           Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "cc : Int.int"
            ]
        },
        {
            "tactic_sig": "set ( Xl := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "Xl : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Xh := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xh : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "Xh : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Yl := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl) (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Yl : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Yh := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl) (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl) (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Yh : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with ( two_p 32 ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl) (Z.mul (Int.unsigned cc) Int.modulus)))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl)\n        (Z.mul (Int.unsigned cc)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))"
            ]
        },
        {
            "tactic_sig": "replace ( _ * two_p 32 + _ + ( _ * two_p 32 + _ ) ) with ( ( _ + _ ) * two_p 32 + ( _ + _ ) ) by ring .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl)\n        (Z.mul (Int.unsigned cc)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Xh : BinNums.Z",
                "Xl : BinNums.Z",
                "Yh : BinNums.Z",
                "Yl : BinNums.Z",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl)\n        (Z.mul (Int.unsigned cc)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add Xl Yl))"
            ]
        },
        {
            "tactic_sig": "replace ( Int.unsigned ( Int.add ( Int.add _ _ ) _ ) * two_p 32 + ( _ + _ - Int.unsigned _ * two_p 32 ) ) with ( ( Int.unsigned ( Int.add ( Int.add _ _ ) _ ) - Int.unsigned _ ) * two_p 32 + ( _ + _ ) ) by ring .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub (Z.add Xl Yl)\n        (Z.mul (Int.unsigned cc)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add Xl Yl))",
                "xh : Int.int",
                "yh : Int.int",
                "cc : Int.int",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z",
                "cc : Int.int",
                "xh : Int.int",
                "yh : Int.int",
                "cc : Int.int",
                "cc : Int.int",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc))\n           (Int.unsigned cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Z.add Xl Yl))\n  (Z.add\n     (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add Xl Yl))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc))\n           (Int.unsigned cc))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Z.add Xl Yl))\n  (Z.add\n     (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add Xl Yl))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.mul\n     (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (Int.unsigned cc)) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm (Z.add Xl Yl) (Z.add Xl Yl)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Z.add Xl Yl) (Z.add Xl Yl)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_mul_2p32 .",
            "tactic_args": [
                "_goal : eqm\n  (Z.mul\n     (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc))\n        (Int.unsigned cc)) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc)) (Int.unsigned cc))\n  (Z.add Xh Yh)"
            ]
        },
        {
            "tactic_sig": "replace ( _ + _ ) with ( ( _ + _ + Int.unsigned _ ) - Int.unsigned _ ) by ring .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc)) (Int.unsigned cc))\n  (Z.add Xh Yh)",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "cc : Int.int",
                "cc : Int.int"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc)) (Int.unsigned cc))\n  (Z.sub (Z.add (Z.add Xh Yh) (Int.unsigned cc)) (Int.unsigned cc))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_sub .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Z.sub (Int.unsigned (Int.add (Int.add xh yh) cc)) (Int.unsigned cc))\n  (Z.sub (Z.add (Z.add Xh Yh) (Int.unsigned cc)) (Int.unsigned cc))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.add (Int.add xh yh) cc))\n  (Z.add (Z.add Xh Yh) (Int.unsigned cc))",
                "_goal : Int.eqm (Int.unsigned cc) (Int.unsigned cc)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned cc) (Int.unsigned cc)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.add (Int.add xh yh) cc))\n  (Z.add (Z.add Xh Yh) (Int.unsigned cc))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.add (Int.unsigned (Int.add xh yh)) (Int.unsigned cc))\n  (Z.add (Z.add Xh Yh) (Int.unsigned cc))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_add .",
            "tactic_args": [
                "_goal : Int.eqm (Z.add (Int.unsigned (Int.add xh yh)) (Int.unsigned cc))\n  (Z.add (Z.add Xh Yh) (Int.unsigned cc))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.add xh yh)) (Z.add Xh Yh)",
                "_goal : Int.eqm (Int.unsigned cc) (Int.unsigned cc)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned cc) (Int.unsigned cc)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.add xh yh)) (Z.add Xh Yh)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.add (Int.unsigned xh) (Int.unsigned yh)) (Z.add Xh Yh)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Z.add (Int.unsigned xh) (Int.unsigned yh)) (Z.add Xh Yh)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl)) (sub (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl)) (sub (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.sub xl yl))))\n  (sub (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.sub xl yl))))\n  (sub (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.sub xl yl)))\n  (Z.sub (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl)))"
            ]
        },
        {
            "tactic_sig": "rewrite ! ofwords_add' .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.sub xl yl)))\n  (Z.sub (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl)))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.sub xl yl)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))"
            ]
        },
        {
            "tactic_sig": "rewrite ( Int.unsigned_sub_borrow _ _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.sub xl yl)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned (Int.sub_borrow xl yl Int.zero))\n           Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))"
            ]
        },
        {
            "tactic_sig": "set ( bb := Int.sub_borrow _ _ Int.zero ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned (Int.sub_borrow xl yl Int.zero))\n           Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "bb : Int.int"
            ]
        },
        {
            "tactic_sig": "set ( Xl := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub (Int.unsigned xl) (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned xl))\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "Xl : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Xh := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add\n        (Z.mul (Int.unsigned xh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "xh : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "Xh : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Yl := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl (Int.unsigned yl))\n        (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned yl)))",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl) (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Yl : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( Yh := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl) (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add\n        (Z.mul (Int.unsigned yh)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl) (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Yh : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with ( two_p 32 ) .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl) (Z.mul (Int.unsigned bb) Int.modulus)))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl)\n        (Z.mul (Int.unsigned bb)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))"
            ]
        },
        {
            "tactic_sig": "replace ( _ * two_p 32 + _ - ( _ * two_p 32 + _ ) ) with ( ( _ - _ ) * two_p 32 + ( _ - _ ) ) by ring .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl)\n        (Z.mul (Int.unsigned bb)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.sub\n     (Z.add (Z.mul Xh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Xl)\n     (Z.add (Z.mul Yh (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) Yl))",
                "Xh : BinNums.Z",
                "Xl : BinNums.Z",
                "Yh : BinNums.Z",
                "Yl : BinNums.Z",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl)\n        (Z.mul (Int.unsigned bb)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub Xl Yl))"
            ]
        },
        {
            "tactic_sig": "replace ( Int.unsigned ( Int.sub ( Int.sub _ _ ) _ ) * two_p 32 + ( _ - _ + Int.unsigned _ * two_p 32 ) ) with ( ( Int.unsigned ( Int.sub ( Int.sub _ _ ) _ ) + Int.unsigned _ ) * two_p 32 + ( _ - _ ) ) by ring .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.add (Z.sub Xl Yl)\n        (Z.mul (Int.unsigned bb)\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub Xl Yl))",
                "xh : Int.int",
                "yh : Int.int",
                "bb : Int.int",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z",
                "bb : Int.int",
                "xh : Int.int",
                "yh : Int.int",
                "bb : Int.int",
                "bb : Int.int",
                "Xl : BinNums.Z",
                "Yl : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n           (Int.unsigned bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Z.sub Xl Yl))\n  (Z.add\n     (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub Xl Yl))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n           (Int.unsigned bb))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Z.sub Xl Yl))\n  (Z.add\n     (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Z.sub Xl Yl))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.mul\n     (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (Int.unsigned bb)) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm (Z.sub Xl Yl) (Z.sub Xl Yl)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Z.sub Xl Yl) (Z.sub Xl Yl)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_mul_2p32 .",
            "tactic_args": [
                "_goal : eqm\n  (Z.mul\n     (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n        (Int.unsigned bb)) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.sub Xh Yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb)) (Int.unsigned bb))\n  (Z.sub Xh Yh)"
            ]
        },
        {
            "tactic_sig": "replace ( _ - _ ) with ( ( _ - _ - Int.unsigned _ ) + Int.unsigned _ ) by ring .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb)) (Int.unsigned bb))\n  (Z.sub Xh Yh)",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "Xh : BinNums.Z",
                "Yh : BinNums.Z",
                "bb : Int.int",
                "bb : Int.int"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb)) (Int.unsigned bb))\n  (Z.add (Z.sub (Z.sub Xh Yh) (Int.unsigned bb)) (Int.unsigned bb))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_add .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.sub (Int.sub xh yh) bb)) (Int.unsigned bb))\n  (Z.add (Z.sub (Z.sub Xh Yh) (Int.unsigned bb)) (Int.unsigned bb))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n  (Z.sub (Z.sub Xh Yh) (Int.unsigned bb))",
                "_goal : Int.eqm (Int.unsigned bb) (Int.unsigned bb)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned bb) (Int.unsigned bb)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.sub (Int.sub xh yh) bb))\n  (Z.sub (Z.sub Xh Yh) (Int.unsigned bb))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.sub (Int.unsigned (Int.sub xh yh)) (Int.unsigned bb))\n  (Z.sub (Z.sub Xh Yh) (Int.unsigned bb))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_add .",
            "tactic_args": [
                "_goal : Int.eqm (Z.sub (Int.unsigned (Int.sub xh yh)) (Int.unsigned bb))\n  (Z.sub (Z.sub Xh Yh) (Int.unsigned bb))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.sub xh yh)) (Z.sub Xh Yh)",
                "_goal : Int.eqm (Z.opp (Int.unsigned bb)) (Z.opp (Int.unsigned bb))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Z.opp (Int.unsigned bb)) (Z.opp (Int.unsigned bb))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.sub xh yh)) (Z.sub Xh Yh)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.sub (Int.unsigned xh) (Int.unsigned yh)) (Z.sub Xh Yh)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Z.sub (Int.unsigned xh) (Int.unsigned yh)) (Z.sub Xh Yh)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add xh (Int.not yh))\n        (Int.add_carry xl (Int.not yl) Int.one)) (Int.sub xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add xh (Int.not yh))\n        (Int.add_carry xl (Int.not yl) Int.one)) (Int.sub xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite decompose_sub .",
            "tactic_args": [
                "_goal : Logic.eq (sub (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add xh (Int.not yh))\n        (Int.add_carry xl (Int.not yl) Int.one)) (Int.sub xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl))\n  (ofwords\n     (Int.add (Int.add xh (Int.not yh))\n        (Int.add_carry xl (Int.not yl) Int.one)) (Int.sub xl yl))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n     (Int.sub xl yl))\n  (ofwords\n     (Int.add (Int.add xh (Int.not yh))\n        (Int.add_carry xl (Int.not yl) Int.one)) (Int.sub xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.sub_borrow_add_carry by auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.sub (Int.sub xh yh) (Int.sub_borrow xl yl Int.zero))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.sub (Int.sub xh yh)\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.sub_add_not_3 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.sub (Int.sub xh yh)\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.xor\n           (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n           Int.one) Int.one))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))",
                "_goal : Logic.or\n  (Logic.eq\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one) Int.zero)\n  (Logic.eq\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one) Int.one)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.xor_assoc .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.xor\n           (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n           Int.one) Int.one))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        (Int.xor Int.one Int.one)))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.xor_idem .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        (Int.xor Int.one Int.one)))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.zero))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.xor_zero .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.zero))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one)))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one)))\n  (Int.add (Int.add xh (Int.not yh))\n     (Int.add_carry xl (Int.not yl) Int.one))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.xor_zero_l .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one) Int.zero)\n  (Logic.eq\n     (Int.xor\n        (Int.add_carry xl (Int.not yl) (Int.xor Int.zero Int.one))\n        Int.one) Int.one)"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq (Int.xor (Int.add_carry xl (Int.not yl) Int.one) Int.one)\n     Int.zero)\n  (Logic.eq (Int.xor (Int.add_carry xl (Int.not yl) Int.one) Int.one)\n     Int.one)"
            ]
        },
        {
            "tactic_sig": "unfold Int.add_carry .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq (Int.xor (Int.add_carry xl (Int.not yl) Int.one) Int.one)\n     Int.zero)\n  (Logic.eq (Int.xor (Int.add_carry xl (Int.not yl) Int.one) Int.one)\n     Int.one)"
            ],
            "tactic_res": [
                "_goal : Logic.or\n  (Logic.eq\n     (Int.xor\n        (if\n          zlt\n            (Z.add\n               (Z.add (Int.unsigned xl) (Int.unsigned (Int.not yl)))\n               (Int.unsigned Int.one)) Int.modulus\n         then Int.zero\n         else Int.one) Int.one) Int.zero)\n  (Logic.eq\n     (Int.xor\n        (if\n          zlt\n            (Z.add\n               (Z.add (Int.unsigned xl) (Int.unsigned (Int.not yl)))\n               (Int.unsigned Int.one)) Int.modulus\n         then Int.zero\n         else Int.one) Int.one) Int.one)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.unsigned _ + Int.unsigned ( Int.not _ ) + Int.unsigned Int.one ) Int.modulus ) ; compute ; [ right|left ] ; apply Int.mkint_eq ; auto .",
            "tactic_args": [
                "_goal : Logic.or\n  (Logic.eq\n     (Int.xor\n        (if\n          zlt\n            (Z.add\n               (Z.add (Int.unsigned xl) (Int.unsigned (Int.not yl)))\n               (Int.unsigned Int.one)) Int.modulus\n         then Int.zero\n         else Int.one) Int.one) Int.zero)\n  (Logic.eq\n     (Int.xor\n        (if\n          zlt\n            (Z.add\n               (Z.add (Int.unsigned xl) (Int.unsigned (Int.not yl)))\n               (Int.unsigned Int.one)) Int.modulus\n         then Int.zero\n         else Int.one) Int.one) Int.one)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : Int.int,\nLogic.eq (mul' x y) (ofwords (Int.mulhu x y) (Int.mul x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul' x y) (ofwords (Int.mulhu x y) (Int.mul x y))",
                "x : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq (mul' x y) (ofwords (Int.mulhu x y) (Int.mul x y))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul' x y)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.mulhu x y))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.mul x y))))"
            ]
        },
        {
            "tactic_sig": "unfold mul' , Int.mulhu , Int.mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul' x y)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.mulhu x y))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.mul x y))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Z.mul (Int.unsigned x) (Int.unsigned y)))\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.repr\n                 (Z.div (Z.mul (Int.unsigned x) (Int.unsigned y))\n                    Int.modulus)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned\n           (Int.repr (Z.mul (Int.unsigned x) (Int.unsigned y))))))"
            ]
        },
        {
            "tactic_sig": "set ( p := Int.unsigned _ * Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.mul (Int.unsigned x) (Int.unsigned y)))\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.repr\n                 (Z.div (Z.mul (Int.unsigned x) (Int.unsigned y))\n                    Int.modulus)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned\n           (Int.repr (Z.mul (Int.unsigned x) (Int.unsigned y))))))",
                "x : Int.int",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr p)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr (Z.div p Int.modulus)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))",
                "p : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( ph := _ / Int.modulus ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr p)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr (Z.div p Int.modulus)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))",
                "p : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr p)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr ph))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))",
                "ph : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( pl := _ mod Int.modulus ) .",
            "tactic_args": [
                "p : BinNums.Z"
            ],
            "tactic_res": [
                "pl : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( _ * Int.modulus + _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (repr p)\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr ph))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))",
                "ph : BinNums.Z",
                "pl : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr p) (repr (Z.add (Z.mul ph Int.modulus) pl))",
                "_goal : Logic.eq (repr (Z.add (Z.mul ph Int.modulus) pl))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr ph))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq (repr p) (repr (Z.add (Z.mul ph Int.modulus) pl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq p (Z.add (Z.mul ph Int.modulus) pl)"
            ]
        },
        {
            "tactic_sig": "rewrite Z.mul_comm .",
            "tactic_args": [
                "_goal : Logic.eq p (Z.add (Z.mul ph Int.modulus) pl)"
            ],
            "tactic_res": [
                "_goal : Logic.eq p (Z.add (Z.mul Int.modulus ph) pl)"
            ]
        },
        {
            "tactic_sig": "apply Z_div_mod_eq .",
            "tactic_args": [
                "_goal : Logic.eq p (Z.add (Z.mul Int.modulus ph) pl)"
            ],
            "tactic_res": [
                "_goal : Z.gt Int.modulus Z0"
            ]
        },
        {
            "tactic_sig": "apply Int.modulus_pos .",
            "tactic_args": [
                "_goal : Z.gt Int.modulus Z0"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Z.add (Z.mul ph Int.modulus) pl))\n  (repr\n     (Z.add\n        (Z.mul (Int.unsigned (Int.repr ph))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned (Int.repr p))))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.add (Z.mul ph Int.modulus) pl)\n  (Z.add\n     (Z.mul (Int.unsigned (Int.repr ph))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.repr p)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm (Z.add (Z.mul ph Int.modulus) pl)\n  (Z.add\n     (Z.mul (Int.unsigned (Int.repr ph))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned (Int.repr p)))"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul ph Int.modulus)\n  (Z.mul (Int.unsigned (Int.repr ph))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm pl (Int.unsigned (Int.repr p))"
            ]
        },
        {
            "tactic_sig": "apply eqm_mul_2p32 .",
            "tactic_args": [
                "_goal : eqm (Z.mul ph Int.modulus)\n  (Z.mul (Int.unsigned (Int.repr ph))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : Int.eqm ph (Int.unsigned (Int.repr ph))"
            ]
        },
        {
            "tactic_sig": "auto with ints .",
            "tactic_args": [
                "_goal : Int.eqm ph (Int.unsigned (Int.repr ph))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr_eq .",
            "tactic_args": [
                "_goal : eqm pl (Int.unsigned (Int.repr p))"
            ],
            "tactic_res": [
                "_goal : eqm pl (Z.modulo p Int.modulus)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm pl (Z.modulo p Int.modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) (loword (mul' xl yl)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) (loword (mul' xl yl)))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "set ( pl := loword ( mul' _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) (loword (mul' xl yl)))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) pl)",
                "pl : Int.int"
            ]
        },
        {
            "tactic_sig": "set ( ph := hiword ( mul' _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) pl)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)) pl)",
                "ph : Int.int"
            ]
        },
        {
            "tactic_sig": "assert ( EQ0 : unsigned ( mul' _ _ ) = Int.unsigned _ * two_p 32 + Int.unsigned _ ) .",
            "tactic_args": [
                "xl : Int.int",
                "yl : Int.int",
                "ph : Int.int",
                "pl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (mul' xl yl))\n  (Z.add\n     (Z.mul (Int.unsigned ph)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned pl))",
                "EQ0 : Logic.eq (unsigned (mul' xl yl))\n  (Z.add\n     (Z.mul (Int.unsigned ph)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned pl))"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( ofwords_recompose ( mul' _ _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (mul' xl yl))\n  (Z.add\n     (Z.mul (Int.unsigned ph)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned pl))",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned (ofwords (hiword (mul' xl yl)) (loword (mul' xl yl))))\n  (Z.add\n     (Z.mul (Int.unsigned ph)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned pl))"
            ]
        },
        {
            "tactic_sig": "apply ofwords_add' .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned (ofwords (hiword (mul' xl yl)) (loword (mul' xl yl))))\n  (Z.add\n     (Z.mul (Int.unsigned ph)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned pl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "symmetry .",
            "tactic_args": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)) pl)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)) pl)\n  (mul (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "rewrite ofwords_add .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)) pl)\n  (mul (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl))) (mul (ofwords xh xl) (ofwords yh yl))"
            ]
        },
        {
            "tactic_sig": "unfold mul .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl))) (mul (ofwords xh xl) (ofwords yh yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr (Z.mul (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))))"
            ]
        },
        {
            "tactic_sig": "rewrite !ofwords_add' .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr (Z.mul (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add\n           (Z.mul (Int.unsigned xh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned xl))\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))"
            ]
        },
        {
            "tactic_sig": "set ( XL := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add\n           (Z.mul (Int.unsigned xh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned xl))\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))",
                "xl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add\n           (Z.mul (Int.unsigned xh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))",
                "XL : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( XH := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add\n           (Z.mul (Int.unsigned xh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))",
                "xh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))",
                "XH : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( YL := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n           (Int.unsigned yl))))",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "YL : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( YH := Int.unsigned _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add\n           (Z.mul (Int.unsigned yh)\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "YH : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( PH := Int.unsigned _ ) in * .",
            "tactic_args": [
                "ph : Int.int"
            ],
            "tactic_res": [
                "EQ0 : Logic.eq (unsigned (mul' xl yl))\n  (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned pl))",
                "PH : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "set ( PL := Int.unsigned _ ) in * .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n        (Int.unsigned pl)))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "pl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "EQ0 : Logic.eq (unsigned (mul' xl yl))\n  (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)",
                "PL : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "transitivity ( repr ( ( ( _ + _ * _ ) + _ * _ ) * two_p 32 + _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "PH : BinNums.Z",
                "XL : BinNums.Z",
                "YH : BinNums.Z",
                "XH : BinNums.Z",
                "YL : BinNums.Z",
                "PL : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))",
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul\n           (Int.unsigned\n              (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n  (Z.add\n     (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add\n     (Z.mul\n        (Int.unsigned\n           (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n  (Z.add\n     (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.mul\n     (Int.unsigned\n        (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))",
                "_goal : eqm PL PL"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm PL PL"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply eqm_mul_2p32 .",
            "tactic_args": [
                "_goal : eqm\n  (Z.mul\n     (Int.unsigned\n        (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.add_unsigned .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.add (Int.add ph (Int.mul xl yh)) (Int.mul xh yl)))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Int.unsigned\n     (Int.repr\n        (Z.add (Int.unsigned (Int.add ph (Int.mul xl yh)))\n           (Int.unsigned (Int.mul xh yl)))))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Int.unsigned\n     (Int.repr\n        (Z.add (Int.unsigned (Int.add ph (Int.mul xl yh)))\n           (Int.unsigned (Int.mul xh yl)))))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.add ph (Int.mul xl yh)))\n     (Int.unsigned (Int.mul xh yl)))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_add .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Z.add (Int.unsigned (Int.add ph (Int.mul xl yh)))\n     (Int.unsigned (Int.mul xh yl)))\n  (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.add ph (Int.mul xl yh)))\n  (Z.add PH (Z.mul XL YH))",
                "_goal : Int.eqm (Int.unsigned (Int.mul xh yl)) (Z.mul XH YL)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.add_unsigned .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.add ph (Int.mul xl yh)))\n  (Z.add PH (Z.mul XL YH))"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Int.unsigned\n     (Int.repr (Z.add (Int.unsigned ph) (Int.unsigned (Int.mul xl yh)))))\n  (Z.add PH (Z.mul XL YH))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Int.unsigned\n     (Int.repr (Z.add (Int.unsigned ph) (Int.unsigned (Int.mul xl yh)))))\n  (Z.add PH (Z.mul XL YH))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.add (Int.unsigned ph) (Int.unsigned (Int.mul xl yh)))\n  (Z.add PH (Z.mul XL YH))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_add .",
            "tactic_args": [
                "_goal : Int.eqm (Z.add (Int.unsigned ph) (Int.unsigned (Int.mul xl yh)))\n  (Z.add PH (Z.mul XL YH))"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned ph) PH",
                "_goal : Int.eqm (Int.unsigned (Int.mul xl yh)) (Z.mul XL YH)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned ph) PH"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold Int.mul .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.mul xl yh)) (Z.mul XL YH)"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned xl) (Int.unsigned yh))))\n  (Z.mul XL YH)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned xl) (Int.unsigned yh))))\n  (Z.mul XL YH)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.mul (Int.unsigned xl) (Int.unsigned yh)) (Z.mul XL YH)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Z.mul (Int.unsigned xl) (Int.unsigned yh)) (Z.mul XL YH)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold Int.mul .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.mul xh yl)) (Z.mul XH YL)"
            ],
            "tactic_res": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned xh) (Int.unsigned yl))))\n  (Z.mul XH YL)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : Int.eqm\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned xh) (Int.unsigned yl))))\n  (Z.mul XH YL)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Z.mul (Int.unsigned xh) (Int.unsigned yl)) (Z.mul XH YL)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_refl .",
            "tactic_args": [
                "_goal : Int.eqm (Z.mul (Int.unsigned xh) (Int.unsigned yl)) (Z.mul XH YL)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( repr ( unsigned ( mul' _ _ ) + ( _ * _ + _ * _ ) * two_p 32 ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "xl : Int.int",
                "yl : Int.int",
                "XL : BinNums.Z",
                "YH : BinNums.Z",
                "XH : BinNums.Z",
                "YL : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))",
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))",
                "EQ0 : Logic.eq (unsigned (mul' xl yl))\n  (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add\n        (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ]
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL))\n  (repr\n     (Z.add\n        (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n  (Z.add\n     (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.mul (Z.add (Z.add PH (Z.mul XL YH)) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n  (Z.add\n     (Z.add (Z.mul PH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) PL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( repr ( ( _ * _ + ( _ * _ + _ * _ ) * two_p 32 ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "XL : BinNums.Z",
                "YL : BinNums.Z",
                "XL : BinNums.Z",
                "YH : BinNums.Z",
                "XH : BinNums.Z",
                "YL : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))",
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (unsigned (mul' xl yl))\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add (unsigned (mul' xl yl))\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add (unsigned (mul' xl yl))\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (mul' xl yl)) (Z.mul XL YL)",
                "_goal : eqm\n  (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm\n  (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n  (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n     (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold mul' .",
            "tactic_args": [
                "_goal : eqm (unsigned (mul' xl yl)) (Z.mul XL YL)"
            ],
            "tactic_res": [
                "_goal : eqm (unsigned (repr (Z.mul (Int.unsigned xl) (Int.unsigned yl))))\n  (Z.mul XL YL)"
            ]
        },
        {
            "tactic_sig": "apply eqm_unsigned_repr_l .",
            "tactic_args": [
                "_goal : eqm (unsigned (repr (Z.mul (Int.unsigned xl) (Int.unsigned yl))))\n  (Z.mul XL YL)"
            ],
            "tactic_res": [
                "_goal : eqm (Z.mul (Int.unsigned xl) (Int.unsigned yl)) (Z.mul XL YL)"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm (Z.mul (Int.unsigned xl) (Int.unsigned yl)) (Z.mul XL YL)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( repr ( 0 + ( _ * _ + ( _ * _ + _ * _ ) * two_p 32 ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "XL : BinNums.Z",
                "YL : BinNums.Z",
                "XL : BinNums.Z",
                "YH : BinNums.Z",
                "XH : BinNums.Z",
                "YL : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))",
                "_goal : Logic.eq\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ]
        },
        {
            "tactic_sig": "rewrite Z.add_0_l .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (repr\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "transitivity ( repr ( _ * _ * ( two_p 32 * two_p 32 ) + ( _ * _ + ( _ * _ + _ * _ ) * two_p 32 ) ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))",
                "XH : BinNums.Z",
                "YH : BinNums.Z",
                "XL : BinNums.Z",
                "YL : BinNums.Z",
                "XL : BinNums.Z",
                "YH : BinNums.Z",
                "XH : BinNums.Z",
                "YL : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.add\n        (Z.mul (Z.mul XH YH)\n           (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))",
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.mul XH YH)\n           (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ]
        },
        {
            "tactic_sig": "apply eqm_samerepr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add Z0\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.add\n        (Z.mul (Z.mul XH YH)\n           (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))"
            ],
            "tactic_res": [
                "_goal : eqm\n  (Z.add Z0\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.mul XH YH)\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_add .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add Z0\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.add\n     (Z.mul (Z.mul XH YH)\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))"
            ],
            "tactic_res": [
                "_goal : eqm Z0\n  (Z.mul (Z.mul XH YH)\n     (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))",
                "_goal : eqm\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ]
        },
        {
            "tactic_sig": "apply eqm_refl .",
            "tactic_args": [
                "_goal : eqm\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n  (Z.add (Z.mul XL YL)\n     (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "change ( two_p 32 * two_p 32 ) with modulus .",
            "tactic_args": [
                "_goal : eqm Z0\n  (Z.mul (Z.mul XH YH)\n     (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))"
            ],
            "tactic_res": [
                "_goal : eqm Z0 (Z.mul (Z.mul XH YH) modulus)"
            ]
        },
        {
            "tactic_sig": "exists ( - _ * _ ) .",
            "tactic_args": [
                "_goal : eqm Z0 (Z.mul (Z.mul XH YH) modulus)",
                "XH : BinNums.Z",
                "YH : BinNums.Z"
            ],
            "tactic_res": [
                "_goal : Logic.eq Z0\n  (Z.add (Z.mul (Z.mul (Z.opp XH) YH) modulus)\n     (Z.mul (Z.mul XH YH) modulus))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq Z0\n  (Z.add (Z.mul (Z.mul (Z.opp XH) YH) modulus)\n     (Z.mul (Z.mul XH YH) modulus))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "f_equal .",
            "tactic_args": [
                "_goal : Logic.eq\n  (repr\n     (Z.add\n        (Z.mul (Z.mul XH YH)\n           (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n        (Z.add (Z.mul XL YL)\n           (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n              (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))))\n  (repr\n     (Z.mul\n        (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n        (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.mul (Z.mul XH YH)\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.mul\n     (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n     (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL))"
            ]
        },
        {
            "tactic_sig": "ring .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Z.add\n     (Z.mul (Z.mul XH YH)\n        (Z.mul (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))))\n     (Z.add (Z.mul XL YL)\n        (Z.mul (Z.add (Z.mul XL YH) (Z.mul XH YL))\n           (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))))\n  (Z.mul\n     (Z.add (Z.mul XH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) XL)\n     (Z.add (Z.mul YH (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) YL))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite decompose_mul .",
            "tactic_args": [
                "_goal : Logic.eq (mul (ofwords xh xl) (ofwords yh yl))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) (loword (mul' xl yl)))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ]
        },
        {
            "tactic_sig": "rewrite mul'_mulhu .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add (Int.add (hiword (mul' xl yl)) (Int.mul xl yh))\n        (Int.mul xh yl)) (loword (mul' xl yl)))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add\n        (Int.add (hiword (ofwords (Int.mulhu xl yl) (Int.mul xl yl)))\n           (Int.mul xl yh)) (Int.mul xh yl))\n     (loword (ofwords (Int.mulhu xl yl) (Int.mul xl yl))))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ]
        },
        {
            "tactic_sig": "rewrite hi_ofwords , lo_ofwords .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add\n        (Int.add (hiword (ofwords (Int.mulhu xl yl) (Int.mul xl yl)))\n           (Int.mul xl yh)) (Int.mul xh yl))\n     (loword (ofwords (Int.mulhu xl yl) (Int.mul xl yl))))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))\n  (ofwords\n     (Int.add (Int.add (Int.mulhu xl yl) (Int.mul xl yh))\n        (Int.mul xh yl)) (Int.mul xl yl))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (ltu (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (ltu (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold ltu .",
            "tactic_args": [
                "_goal : Logic.eq (ltu (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite ! ofwords_add' .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned (ofwords xh xl)) (unsigned (ofwords yh yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu , Int.eq .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n   then if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false\n   else if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n   then if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false\n   else if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "e : Logic.eq (Int.unsigned xh) (Int.unsigned yh)",
                "n : Logic.not (Logic.eq (Int.unsigned xh) (Int.unsigned yh))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)",
                "e : Logic.eq (Int.unsigned xh) (Int.unsigned yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false",
                "l : Z.lt (Int.unsigned xl) (Int.unsigned yl)",
                "g : Z.ge (Int.unsigned xl) (Int.unsigned yl)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (two_p (Zpos (xO (xO (xO (xO (xO xH)))))))) \n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "change ( two_p 32 ) with Int.modulus .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.unsigned xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.unsigned yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.unsigned xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.unsigned yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl) Int.modulus)),\nLogic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.unsigned xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.unsigned yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with 4294967296 .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl) Int.modulus)),\nLogic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.unsigned xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.unsigned yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned yl))\n  (Z.lt (Int.unsigned yl)\n     (Zpos\n        (xO\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))",
                "H : Logic.and (Z.le Z0 (Int.unsigned xl))\n  (Z.lt (Int.unsigned xl)\n     (Zpos\n        (xO\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false",
                "l : Z.lt (Int.unsigned xh) (Int.unsigned yh)",
                "g : Z.ge (Int.unsigned xh) (Int.unsigned yh)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.unsigned xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.unsigned xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.unsigned xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.unsigned yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.unsigned xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.unsigned xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.unsigned yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (negb (ltu (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (ltu (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite decompose_ltu .",
            "tactic_args": [
                "_goal : Logic.eq (negb (ltu (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if Int.eq yh xh then Int.ltu yl xl else Int.ltu yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if Int.eq yh xh then Int.ltu yl xl else Int.ltu yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if Int.eq xh yh then Int.ltu yl xl else Int.ltu yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ]
        },
        {
            "tactic_sig": "unfold Int.eq .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if Int.eq xh yh then Int.ltu yl xl else Int.ltu yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb\n     (if\n       if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n      then Int.ltu yl xl\n      else Int.ltu yh xh))\n  (if if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n   then negb (Int.ltu yl xl)\n   else Int.ltu xh yh)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb\n     (if\n       if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n      then Int.ltu yl xl\n      else Int.ltu yh xh))\n  (if if zeq (Int.unsigned xh) (Int.unsigned yh) then true else false\n   then negb (Int.ltu yl xl)\n   else Int.ltu xh yh)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (Int.ltu yl xl)) (negb (Int.ltu yl xl))",
                "_goal : Logic.eq (negb (Int.ltu yh xh)) (Int.ltu xh yh)",
                "e : Logic.eq (Int.unsigned xh) (Int.unsigned yh)",
                "n : Logic.not (Logic.eq (Int.unsigned xh) (Int.unsigned yh))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Int.ltu yl xl)) (negb (Int.ltu yl xl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Int.ltu yh xh)) (Int.ltu xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  (if zlt (Int.unsigned xh) (Int.unsigned yh) then true else false)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  true",
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  false",
                "l : Z.lt (Int.unsigned xh) (Int.unsigned yh)",
                "g : Z.ge (Int.unsigned xh) (Int.unsigned yh)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb\n     (if zlt (Int.unsigned yh) (Int.unsigned xh) then true else false))\n  false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb true) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (lt (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (lt (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold lt .",
            "tactic_args": [
                "_goal : Logic.eq (lt (ofwords xh xl) (ofwords yh yl))\n  (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (signed (ofwords xh xl)) (signed (ofwords yh yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite ! ofwords_add'' .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (signed (ofwords xh xl)) (signed (ofwords yh yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.eq_signed .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (if Int.eq xh yh then Int.ltu xl yl else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n   then Int.ltu xl yl\n   else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( Int.signed _ ) ( Int.signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n   then Int.ltu xl yl\n   else Int.lt xh yh)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.ltu xl yl)",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)",
                "e : Logic.eq (Int.signed xh) (Int.signed yh)",
                "n : Logic.not (Logic.eq (Int.signed xh) (Int.signed yh))"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.ltu xl yl)",
                "e : Logic.eq (Int.signed xh) (Int.signed yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.ltu xl yl)"
            ]
        },
        {
            "tactic_sig": "unfold Int.ltu .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.ltu xl yl)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.unsigned _ ) ( Int.unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.unsigned xl) (Int.unsigned yl) then true else false)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false",
                "l : Z.lt (Int.unsigned xl) (Int.unsigned yl)",
                "g : Z.ge (Int.unsigned xl) (Int.unsigned yl)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh) (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "change ( two_p 32 ) with Int.modulus .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (two_p (Zpos (xO (xO (xO (xO (xO xH))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.signed xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.signed yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.signed xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.signed yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)",
                "xl : Int.int",
                "yl : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl) Int.modulus)),\nLogic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.signed xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.signed yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "change Int.modulus with 4294967296 .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl) Int.modulus))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl) Int.modulus)),\nLogic.eq\n  (if\n    zlt (Z.add (Z.mul (Int.signed xh) Int.modulus) (Int.unsigned xl))\n      (Z.add (Z.mul (Int.signed yh) Int.modulus) (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  (_ : Logic.and (Z.le Z0 (Int.unsigned xl))\n         (Z.lt (Int.unsigned xl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))))\n  (_ : Logic.and (Z.le Z0 (Int.unsigned yl))\n         (Z.lt (Int.unsigned yl)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))),\nLogic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)",
                "H0 : Logic.and (Z.le Z0 (Int.unsigned yl))\n  (Z.lt (Int.unsigned yl)\n     (Zpos\n        (xO\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))",
                "H : Logic.and (Z.le Z0 (Int.unsigned xl))\n  (Z.lt (Int.unsigned xl)\n     (Zpos\n        (xO\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))"
            ]
        },
        {
            "tactic_sig": "unfold Int.lt .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) (Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.signed xh) (Int.signed yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.signed _ ) ( Int.signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false)\n  (if zlt (Int.signed xh) (Int.signed yh) then true else false)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true",
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false",
                "l : Z.lt (Int.signed xh) (Int.signed yh)",
                "g : Z.ge (Int.signed xh) (Int.signed yh)"
            ]
        },
        {
            "tactic_sig": "apply zlt_true .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) true"
            ],
            "tactic_res": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.signed xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.lt\n  (Z.add\n     (Z.mul (Int.signed xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply zlt_false .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if\n    zlt\n      (Z.add\n         (Z.mul (Int.signed xh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned xl))\n      (Z.add\n         (Z.mul (Int.signed yh)\n            (Zpos\n               (xO\n                  (xO\n                     (xO\n                        (xO\n                           (xO\n                              (xO\n                                 (xO\n                                    (xO\n                                       (xO\n                                          (xO\n                                             (xO\n                                                (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n         (Int.unsigned yl))\n   then true\n   else false) false"
            ],
            "tactic_res": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.signed xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Z.ge\n  (Z.add\n     (Z.mul (Int.signed xh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned xl))\n  (Z.add\n     (Z.mul (Int.signed yh)\n        (Zpos\n           (xO\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH))))))))))))))))))))))))))))))))))\n     (Int.unsigned yl))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall xh xl yh yl : Int.int,\nLogic.eq (negb (lt (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (lt (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)",
                "xh : Int.int",
                "xl : Int.int",
                "yh : Int.int",
                "yl : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite decompose_lt .",
            "tactic_args": [
                "_goal : Logic.eq (negb (lt (ofwords yh yl) (ofwords xh xl)))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if Int.eq yh xh then Int.ltu yl xl else Int.lt yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.eq_sym .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if Int.eq yh xh then Int.ltu yl xl else Int.lt yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (if Int.eq xh yh then Int.ltu yl xl else Int.lt yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "rewrite Int.eq_signed .",
            "tactic_args": [
                "_goal : Logic.eq (negb (if Int.eq xh yh then Int.ltu yl xl else Int.lt yh xh))\n  (if Int.eq xh yh then negb (Int.ltu yl xl) else Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb\n     (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n      then Int.ltu yl xl\n      else Int.lt yh xh))\n  (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n   then negb (Int.ltu yl xl)\n   else Int.lt xh yh)"
            ]
        },
        {
            "tactic_sig": "destruct ( zeq ( Int.signed _ ) ( Int.signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb\n     (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n      then Int.ltu yl xl\n      else Int.lt yh xh))\n  (if if zeq (Int.signed xh) (Int.signed yh) then true else false\n   then negb (Int.ltu yl xl)\n   else Int.lt xh yh)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb (Int.ltu yl xl)) (negb (Int.ltu yl xl))",
                "_goal : Logic.eq (negb (Int.lt yh xh)) (Int.lt xh yh)",
                "e : Logic.eq (Int.signed xh) (Int.signed yh)",
                "n : Logic.not (Logic.eq (Int.signed xh) (Int.signed yh))"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Int.ltu yl xl)) (negb (Int.ltu yl xl))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold Int.lt .",
            "tactic_args": [
                "_goal : Logic.eq (negb (Int.lt yh xh)) (Int.lt xh yh)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  (if zlt (Int.signed xh) (Int.signed yh) then true else false)"
            ]
        },
        {
            "tactic_sig": "destruct ( zlt ( Int.signed _ ) ( Int.signed _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  (if zlt (Int.signed xh) (Int.signed yh) then true else false)",
                "xh : Int.int",
                "yh : Int.int"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  true",
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  false",
                "l : Z.lt (Int.signed xh) (Int.signed yh)",
                "g : Z.ge (Int.signed xh) (Int.signed yh)"
            ]
        },
        {
            "tactic_sig": "rewrite zlt_false by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  true"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb false) true"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb false) true"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite zlt_true by omega .",
            "tactic_args": [
                "_goal : Logic.eq\n  (negb (if zlt (Int.signed yh) (Int.signed xh) then true else false))\n  false"
            ],
            "tactic_res": [
                "_goal : Logic.eq (negb true) false"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (negb true) false"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : Int.int,\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) max_unsigned)",
                "x : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "unfold modulus .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))",
                "x : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) Int.modulus),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "unfold Int.modulus in * .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) Int.modulus),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) (two_power_nat Int.wordsize)),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "change ( wordsize ) with 64 % nat in * .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) (two_power_nat Int.wordsize)),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) (Z.sub (two_power_nat wordsize) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) (two_power_nat Int.wordsize)),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (two_power_nat\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "change ( Int.wordsize ) with 32 % nat in * .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x) (two_power_nat Int.wordsize)),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (two_power_nat\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (two_power_nat\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (two_power_nat\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "unfold two_power_nat .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (two_power_nat\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (two_power_nat\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n        (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (Zpos\n              (shift_nat\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n                 xH))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (Zpos\n           (shift_nat\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n              xH)) (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "simpl .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (Zpos\n              (shift_nat\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n                 xH))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Z.sub\n        (Zpos\n           (shift_nat\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n              xH)) (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Zpos\n        (xI\n           (xI\n              (xI\n                 (xI\n                    (xI\n                       (xI\n                          (xI\n                             (xI\n                                (xI\n                                   (xI\n                                      (xI\n                                         (xI\n                                            (xI\n                                               (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI (xI (xI (xI xH)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned x))\n        (Z.lt (Int.unsigned x)\n           (Zpos\n              (xO\n                 (xO\n                    (xO\n                       (xO\n                          (xO\n                             (xO\n                                (xO\n                                   (xO\n                                      (xO\n                                         (xO\n                                            (xO\n                                               (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO\n                                                 (xO (xO (xO (xO xH)))))))))))))))))))))))))))))))))),\nLogic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x)\n     (Zpos\n        (xI\n           (xI\n              (xI\n                 (xI\n                    (xI\n                       (xI\n                          (xI\n                             (xI\n                                (xI\n                                   (xI\n                                      (xI\n                                         (xI\n                                            (xI\n                                               (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI\n                                                 (xI (xI (xI (xI xH)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x : Int.int,\nLogic.eq (unsigned (repr (Int.unsigned x))) (Int.unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Int.unsigned x))) (Int.unsigned x)",
                "x : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Int.unsigned x))) (Int.unsigned x)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned x) (Int.unsigned x)",
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned x) (Int.unsigned x)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply int_unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned x))\n  (Z.le (Int.unsigned x) max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (x y : Int.int) (_ : Logic.eq (Int.ltu x y) true),\nLogic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))",
                "H : Logic.eq (Int.ltu x y) true",
                "x : Int.int",
                "y : Int.int"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.sub_ltu _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))",
                "x : Int.int",
                "y : Int.int",
                "H : Logic.eq (Int.ltu x y) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n        (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x))\n           (Int.unsigned y)),\nLogic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n        (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x))\n           (Int.unsigned y)),\nLogic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))",
                "H0 : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "unfold Int.sub .",
            "tactic_args": [
                "_goal : Logic.eq (Int.unsigned (Int.sub y x))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned x))))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ]
        },
        {
            "tactic_sig": "unfold sub .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned x))))\n  (unsigned (sub (repr (Int.unsigned y)) (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned x))))\n  (unsigned\n     (repr\n        (Z.sub (unsigned (repr (Int.unsigned y)))\n           (unsigned (repr (Int.unsigned x))))))"
            ]
        },
        {
            "tactic_sig": "rewrite Int.unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned y) (Int.unsigned x))))\n  (unsigned\n     (repr\n        (Z.sub (unsigned (repr (Int.unsigned y)))\n           (unsigned (repr (Int.unsigned x))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (unsigned\n     (repr\n        (Z.sub (unsigned (repr (Int.unsigned y)))\n           (unsigned (repr (Int.unsigned x))))))",
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (unsigned\n     (repr\n        (Z.sub (unsigned (repr (Int.unsigned y)))\n           (unsigned (repr (Int.unsigned x))))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (unsigned (repr (Int.unsigned y)))\n     (unsigned (repr (Int.unsigned x))))",
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.sub (unsigned (repr (Int.unsigned y)))\n        (unsigned (repr (Int.unsigned x)))))\n  (Z.le\n     (Z.sub (unsigned (repr (Int.unsigned y)))\n        (unsigned (repr (Int.unsigned x)))) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr by apply int_unsigned_range .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (unsigned (repr (Int.unsigned y)))\n     (unsigned (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x))))"
            ]
        },
        {
            "tactic_sig": "rewrite int_unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (Int.unsigned y) (Int.unsigned x))"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq (Z.sub (Int.unsigned y) (Int.unsigned x))\n  (Z.sub (Int.unsigned y) (Int.unsigned x))"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "rewrite unsigned_repr by apply int_unsigned_range .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0\n     (Z.sub (unsigned (repr (Int.unsigned y)))\n        (unsigned (repr (Int.unsigned x)))))\n  (Z.le\n     (Z.sub (unsigned (repr (Int.unsigned y)))\n        (unsigned (repr (Int.unsigned x)))) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x)))))\n  (Z.le (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x))))\n     max_unsigned)"
            ]
        },
        {
            "tactic_sig": "rewrite int_unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.and\n  (Z.le Z0 (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x)))))\n  (Z.le (Z.sub (Int.unsigned y) (unsigned (repr (Int.unsigned x))))\n     max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "generalize ( int_unsigned_range _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) max_unsigned)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) max_unsigned)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "generalize ( Int.sub_ltu _ _ _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)",
                "x : Int.int",
                "y : Int.int",
                "H : Logic.eq (Int.ltu x y) true"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n        (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x))\n           (Int.unsigned y)),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n        (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x))\n           (Int.unsigned y)),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)",
                "H1 : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) (Int.unsigned y))"
            ]
        },
        {
            "tactic_sig": "generalize ( Int.unsigned_range_2 _ ) .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)",
                "y : Int.int"
            ],
            "tactic_res": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall\n  _ : Logic.and (Z.le Z0 (Int.unsigned y))\n        (Z.le (Int.unsigned y) Int.max_unsigned),\nLogic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)",
                "H2 : Logic.and (Z.le Z0 (Int.unsigned y))\n  (Z.le (Int.unsigned y) Int.max_unsigned)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Z.sub (Int.unsigned y) (Int.unsigned x)))\n  (Z.le (Z.sub (Int.unsigned y) (Int.unsigned x)) Int.max_unsigned)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold wordsize .",
            "tactic_args": [
                "_goal : not (eq wordsize O)"
            ],
            "tactic_res": [
                "_goal : not\n  (eq\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ]
        },
        {
            "tactic_sig": "destruct Archi.ptr64 .",
            "tactic_args": [
                "_goal : not\n  (eq\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ],
            "tactic_res": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n     O)",
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ]
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n     O)"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "congruence .",
            "tactic_args": [
                "_goal : not\n  (eq\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O))))))))))))))))))))))))))))))))\n     O)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold modulus , wordsize .",
            "tactic_args": [
                "_goal : Logic.eq modulus Int.modulus"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_power_nat Wordsize_Ptrofs.wordsize) Int.modulus"
            ]
        },
        {
            "tactic_sig": "change Wordsize_Ptrofs.wordsize with ( if Archi.ptr64 then 64 % nat else 32 % nat ) .",
            "tactic_args": [
                "_goal : Logic.eq (two_power_nat Wordsize_Ptrofs.wordsize) Int.modulus"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (two_power_nat\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int.modulus"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (two_power_nat\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int.modulus",
                "_32 : Logic.eq Archi.ptr64 false"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (two_power_nat\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int.modulus"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq\n  (two_power_nat\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int.modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : Z, iff (Int.eqm x y) (eqm x y)"
            ],
            "tactic_res": [
                "_goal : iff (Int.eqm x y) (eqm x y)",
                "x : BinNums.Z",
                "y : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "unfold Int.eqm , eqm .",
            "tactic_args": [
                "_goal : iff (Int.eqm x y) (eqm x y)"
            ],
            "tactic_res": [
                "_goal : iff (eqmod Int.modulus x y) (eqmod modulus x y)"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq32 .",
            "tactic_args": [
                "_goal : iff (eqmod Int.modulus x y) (eqmod modulus x y)"
            ],
            "tactic_res": [
                "_goal : iff (eqmod Int.modulus x y) (eqmod Int.modulus x y)"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : iff (eqmod Int.modulus x y) (eqmod Int.modulus x y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall i : Z, agree32 (repr i) (Int.repr i)"
            ],
            "tactic_res": [
                "_goal : agree32 (repr i) (Int.repr i)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : agree32 (repr i) (Int.repr i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr i)) (Int.unsigned (Int.repr i))"
            ]
        },
        {
            "tactic_sig": "rewrite Ptrofs.unsigned_repr_eq , Int.unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr i)) (Int.unsigned (Int.repr i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo i modulus) (Z.modulo i Int.modulus)"
            ]
        },
        {
            "tactic_sig": "apply f_equal2 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo i modulus) (Z.modulo i Int.modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq i i",
                "_goal : Logic.eq modulus Int.modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq i i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply modulus_eq32 .",
            "tactic_args": [
                "_goal : Logic.eq modulus Int.modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b),\nLogic.eq (signed a) (Int.signed b)"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (signed a) (Int.signed b)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (signed a) (Int.signed b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed a) (Int.signed b)",
                "H : Logic.eq (unsigned a) (Int.unsigned b)",
                "b : Int.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "unfold signed , Int.signed , half_modulus , Int.half_modulus .",
            "tactic_args": [
                "_goal : Logic.eq (signed a) (Int.signed b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq32 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div Int.modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) Int.modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div Int.modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) Int.modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)",
                "H : Logic.eq (unsigned a) (Int.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)\n  (if zlt (Int.unsigned b) (Z.div Int.modulus (Zpos (xO xH)))\n   then Int.unsigned b\n   else Z.sub (Int.unsigned b) Int.modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold of_int .",
            "tactic_args": [
                "_goal : forall b : Int.int, agree32 (of_int b) b"
            ],
            "tactic_res": [
                "_goal : forall b : Int.int, agree32 (repr (Int.unsigned b)) b"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall b : Int.int, agree32 (repr (Int.unsigned b)) b"
            ],
            "tactic_res": [
                "_goal : agree32 (repr (Int.unsigned b)) b",
                "b : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( Int.repr_unsigned _ ) at 2 .",
            "tactic_args": [
                "_goal : agree32 (repr (Int.unsigned b)) b",
                "b : Int.int"
            ],
            "tactic_res": [
                "_goal : agree32 (repr (Int.unsigned b)) (Int.repr (Int.unsigned b))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : agree32 (repr (Int.unsigned b)) (Int.repr (Int.unsigned b))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall b : Int.int, agree32 (of_ints b) b"
            ],
            "tactic_res": [
                "_goal : agree32 (of_ints b) b",
                "b : Int.int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( Int.repr_signed _ ) at 2 .",
            "tactic_args": [
                "_goal : agree32 (of_ints b) b",
                "b : Int.int"
            ],
            "tactic_res": [
                "_goal : agree32 (of_ints b) (Int.repr (Int.signed b))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : agree32 (of_ints b) (Int.repr (Int.signed b))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , of_int .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b), Logic.eq (of_int b) a"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (repr (Int.unsigned b)) a"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (repr (Int.unsigned b)) a"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int.unsigned b)) a",
                "H : Logic.eq (unsigned a) (Int.unsigned b)",
                "b : Int.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int.unsigned b)) a",
                "H : Logic.eq (unsigned a) (Int.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned a)) a"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned a)) a"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold of_ints .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b),\nLogic.eq (of_ints b) a"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b),\nLogic.eq (repr (Int.signed b)) a"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b),\nLogic.eq (repr (Int.signed b)) a"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int.signed b)) a",
                "H : agree32 a b",
                "b : Int.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "erewrite <- agree32_signed by eauto .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int.signed b)) a"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (signed a)) a"
            ]
        },
        {
            "tactic_sig": "apply repr_signed .",
            "tactic_args": [
                "_goal : Logic.eq (repr (signed a)) a"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , to_int .",
            "tactic_args": [
                "_goal : forall a : int, agree32 a (to_int a)"
            ],
            "tactic_res": [
                "_goal : forall a : int,\nLogic.eq (unsigned a) (Int.unsigned (Int.repr (unsigned a)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a : int,\nLogic.eq (unsigned a) (Int.unsigned (Int.repr (unsigned a)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (Int.unsigned (Int.repr (unsigned a)))",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( agree32_repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (Int.unsigned (Int.repr (unsigned a)))",
                "a : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (unsigned (repr (unsigned a)))"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (unsigned (repr (unsigned a)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (unsigned a)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (unsigned a)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , to_int .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int) (_ : agree32 a b), Logic.eq (to_int a) b"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (Int.repr (unsigned a)) b"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int.int)\n  (_ : Logic.eq (unsigned a) (Int.unsigned b)),\nLogic.eq (Int.repr (unsigned a)) b"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.repr (unsigned a)) b",
                "H : Logic.eq (unsigned a) (Int.unsigned b)",
                "b : Int.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Int.repr (unsigned a)) b",
                "H : Logic.eq (unsigned a) (Int.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.repr (Int.unsigned b)) b"
            ]
        },
        {
            "tactic_sig": "apply Int.repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Int.repr (Int.unsigned b)) b"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , Ptrofs.neg , Int.neg .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (_ : agree32 a1 b1),\nagree32 (neg a1) (Int.neg b1)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1)),\nLogic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1)),\nLogic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "b1 : Int.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (Int.unsigned b1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (Int.unsigned b1))))\n  (Int.unsigned (Int.repr (Z.opp (Int.unsigned b1))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , Ptrofs.add , Int.add .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : agree32 a1 b1) (_ : agree32 a2 b2),\nagree32 (add a1 a2) (Int.add b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "b2 : Int.int",
                "a2 : int",
                "b1 : Int.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.add (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , Ptrofs.sub , Int.sub .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : agree32 a1 b1) (_ : agree32 a2 b2),\nagree32 (sub a1 a2) (Int.sub b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "b2 : Int.int",
                "a2 : int",
                "b1 : Int.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.sub (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree32 , Ptrofs.mul , Int.mul .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : agree32 a1 b1) (_ : agree32 a2 b2),\nagree32 (mul a1 a2) (Int.mul b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : Logic.eq (unsigned a1) (Int.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int.unsigned b2)),\nLogic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "b2 : Int.int",
                "a2 : int",
                "b1 : Int.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))",
                "H : Logic.eq (unsigned a1) (Int.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))\n  (Int.unsigned (Int.repr (Z.mul (Int.unsigned b1) (Int.unsigned b2))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int.int) (a2 : int) (b2 : Int.int)\n  (_ : agree32 a1 b1) (_ : agree32 a2 b2),\nagree32 (divs a1 a2) (Int.divs b1 b2)"
            ],
            "tactic_res": [
                "_goal : agree32 (divs a1 a2) (Int.divs b1 b2)",
                "H0 : agree32 a2 b2",
                "H : agree32 a1 b1",
                "b2 : Int.int",
                "a2 : int",
                "b1 : Int.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "unfold agree32 , Ptrofs.divs , Int.divs .",
            "tactic_args": [
                "_goal : agree32 (divs a1 a2) (Int.divs b1 b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (signed a1) (signed a2))))\n  (Int.unsigned (Int.repr (Z.quot (Int.signed b1) (Int.signed b2))))"
            ]
        },
        {
            "tactic_sig": "erewrite ! agree32_signed by eauto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (signed a1) (signed a2))))\n  (Int.unsigned (Int.repr (Z.quot (Int.signed b1) (Int.signed b2))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (Int.signed b1) (Int.signed b2))))\n  (Int.unsigned (Int.repr (Z.quot (Int.signed b1) (Int.signed b2))))"
            ]
        },
        {
            "tactic_sig": "apply agree32_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (Int.signed b1) (Int.signed b2))))\n  (Int.unsigned (Int.repr (Z.quot (Int.signed b1) (Int.signed b2))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : int, Logic.eq (of_int (to_int n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (of_int (to_int n)) n",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold of_int , to_int .",
            "tactic_args": [
                "_goal : Logic.eq (of_int (to_int n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int.unsigned (Int.repr (unsigned n)))) n"
            ]
        },
        {
            "tactic_sig": "apply eqm_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int.unsigned (Int.repr (unsigned n)))) n"
            ],
            "tactic_res": [
                "_goal : eqm (Int.unsigned (Int.repr (unsigned n))) (unsigned n)"
            ]
        },
        {
            "tactic_sig": "rewrite <- eqm32 .",
            "tactic_args": [
                "_goal : eqm (Int.unsigned (Int.repr (unsigned n))) (unsigned n)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (Int.unsigned (Int.repr (unsigned n))) (unsigned n)"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_sym .",
            "tactic_args": [
                "_goal : Int.eqm (Int.unsigned (Int.repr (unsigned n))) (unsigned n)"
            ],
            "tactic_res": [
                "_goal : Int.eqm (unsigned n) (Int.unsigned (Int.repr (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "apply Int.eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : Int.eqm (unsigned n) (Int.unsigned (Int.repr (unsigned n)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : Int.int, Logic.eq (to_int (of_int n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (to_int (of_int n)) n",
                "n : Int.int"
            ]
        },
        {
            "tactic_sig": "unfold of_int , to_int .",
            "tactic_args": [
                "_goal : Logic.eq (to_int (of_int n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.repr (unsigned (repr (Int.unsigned n)))) n"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int.repr (unsigned (repr (Int.unsigned n)))) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int.repr (Int.unsigned n)) n",
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "apply Int.repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Int.repr (Int.unsigned n)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq32 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) (Z.sub Int.modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( Int.unsigned_range _ ) .",
            "tactic_args": [
                "n : Int.int"
            ],
            "tactic_res": [
                "H0 : Z.lt (Int.unsigned n) Int.modulus",
                "H : Z.le Z0 (Int.unsigned n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int.unsigned n))\n  (Z.le (Int.unsigned n) (Z.sub Int.modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold modulus , wordsize .",
            "tactic_args": [
                "_goal : Logic.eq modulus Int64.modulus"
            ],
            "tactic_res": [
                "_goal : Logic.eq (two_power_nat Wordsize_Ptrofs.wordsize) Int64.modulus"
            ]
        },
        {
            "tactic_sig": "change Wordsize_Ptrofs.wordsize with ( if Archi.ptr64 then 64 % nat else 32 % nat ) .",
            "tactic_args": [
                "_goal : Logic.eq (two_power_nat Wordsize_Ptrofs.wordsize) Int64.modulus"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (two_power_nat\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int64.modulus"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (two_power_nat\n     (if Archi.ptr64\n      then\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n      else\n       S\n         (S\n            (S\n               (S\n                  (S\n                     (S\n                        (S\n                           (S\n                              (S\n                                 (S\n                                    (S\n                                       (S\n                                          (S\n                                             (S\n                                                (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))\n  Int64.modulus",
                "_64 : Logic.eq Archi.ptr64 true"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (two_power_nat\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n  Int64.modulus"
            ]
        },
        {
            "tactic_sig": "reflexivity .",
            "tactic_args": [
                "_goal : Logic.eq\n  (two_power_nat\n     (S\n        (S\n           (S\n              (S\n                 (S\n                    (S\n                       (S\n                          (S\n                             (S\n                                (S\n                                   (S\n                                      (S\n                                         (S\n                                            (S\n                                               (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S\n                                                 (S (S (S (S (S O)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\n  Int64.modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall x y : Z, iff (Int64.eqm x y) (eqm x y)"
            ],
            "tactic_res": [
                "_goal : iff (Int64.eqm x y) (eqm x y)",
                "x : BinNums.Z",
                "y : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "unfold Int64.eqm , eqm .",
            "tactic_args": [
                "_goal : iff (Int64.eqm x y) (eqm x y)"
            ],
            "tactic_res": [
                "_goal : iff (eqmod Int64.modulus x y) (eqmod modulus x y)"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq64 .",
            "tactic_args": [
                "_goal : iff (eqmod Int64.modulus x y) (eqmod modulus x y)"
            ],
            "tactic_res": [
                "_goal : iff (eqmod Int64.modulus x y) (eqmod Int64.modulus x y)"
            ]
        },
        {
            "tactic_sig": "tauto .",
            "tactic_args": [
                "_goal : iff (eqmod Int64.modulus x y) (eqmod Int64.modulus x y)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall i : Z, agree64 (repr i) (Int64.repr i)"
            ],
            "tactic_res": [
                "_goal : agree64 (repr i) (Int64.repr i)",
                "i : BinNums.Z"
            ]
        },
        {
            "tactic_sig": "red .",
            "tactic_args": [
                "_goal : agree64 (repr i) (Int64.repr i)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr i)) (Int64.unsigned (Int64.repr i))"
            ]
        },
        {
            "tactic_sig": "rewrite Ptrofs.unsigned_repr_eq , Int64.unsigned_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr i)) (Int64.unsigned (Int64.repr i))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Z.modulo i modulus) (Z.modulo i Int64.modulus)"
            ]
        },
        {
            "tactic_sig": "apply f_equal2 .",
            "tactic_args": [
                "_goal : Logic.eq (Z.modulo i modulus) (Z.modulo i Int64.modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq i i",
                "_goal : Logic.eq modulus Int64.modulus"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq i i"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "apply modulus_eq64 .",
            "tactic_args": [
                "_goal : Logic.eq modulus Int64.modulus"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int) (_ : agree64 a b),\nLogic.eq (signed a) (Int64.signed b)"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (signed a) (Int64.signed b)"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (signed a) (Int64.signed b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (signed a) (Int64.signed b)",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)",
                "b : Int64.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "unfold signed , Int64.signed , half_modulus , Int64.half_modulus .",
            "tactic_args": [
                "_goal : Logic.eq (signed a) (Int64.signed b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq64 .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div Int64.modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) Int64.modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (unsigned a) (Z.div Int64.modulus (Zpos (xO xH)))\n   then unsigned a\n   else Z.sub (unsigned a) Int64.modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)\n  (if zlt (Int64.unsigned b) (Z.div Int64.modulus (Zpos (xO xH)))\n   then Int64.unsigned b\n   else Z.sub (Int64.unsigned b) Int64.modulus)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold of_int64 .",
            "tactic_args": [
                "_goal : forall b : Int64.int, agree64 (of_int64 b) b"
            ],
            "tactic_res": [
                "_goal : forall b : Int64.int, agree64 (repr (Int64.unsigned b)) b"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall b : Int64.int, agree64 (repr (Int64.unsigned b)) b"
            ],
            "tactic_res": [
                "_goal : agree64 (repr (Int64.unsigned b)) b",
                "b : Int64.int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( Int64.repr_unsigned _ ) at 2 .",
            "tactic_args": [
                "_goal : agree64 (repr (Int64.unsigned b)) b",
                "b : Int64.int"
            ],
            "tactic_res": [
                "_goal : agree64 (repr (Int64.unsigned b)) (Int64.repr (Int64.unsigned b))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : agree64 (repr (Int64.unsigned b)) (Int64.repr (Int64.unsigned b))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , of_int64 .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int) (_ : agree64 a b),\nLogic.eq (of_int64 b) a"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (repr (Int64.unsigned b)) a"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (repr (Int64.unsigned b)) a"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int64.unsigned b)) a",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)",
                "b : Int64.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- _ .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int64.unsigned b)) a",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (unsigned a)) a"
            ]
        },
        {
            "tactic_sig": "apply repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (repr (unsigned a)) a"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , to_int64 .",
            "tactic_args": [
                "_goal : forall a : int, agree64 a (to_int64 a)"
            ],
            "tactic_res": [
                "_goal : forall a : int,\nLogic.eq (unsigned a) (Int64.unsigned (Int64.repr (unsigned a)))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall a : int,\nLogic.eq (unsigned a) (Int64.unsigned (Int64.repr (unsigned a)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (Int64.unsigned (Int64.repr (unsigned a)))",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite <- ( agree64_repr ( unsigned _ ) ) .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (Int64.unsigned (Int64.repr (unsigned a)))",
                "a : int"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (unsigned (repr (unsigned a)))"
            ]
        },
        {
            "tactic_sig": "rewrite repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (unsigned (repr (unsigned a)))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned a) (unsigned a)"
            ]
        },
        {
            "tactic_sig": "auto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned a) (unsigned a)"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , to_int64 .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int) (_ : agree64 a b),\nLogic.eq (to_int64 a) b"
            ],
            "tactic_res": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (Int64.repr (unsigned a)) b"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a : int) (b : Int64.int)\n  (_ : Logic.eq (unsigned a) (Int64.unsigned b)),\nLogic.eq (Int64.repr (unsigned a)) b"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int64.repr (unsigned a)) b",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)",
                "b : Int64.int",
                "a : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (Int64.repr (unsigned a)) b",
                "H : Logic.eq (unsigned a) (Int64.unsigned b)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int64.repr (Int64.unsigned b)) b"
            ]
        },
        {
            "tactic_sig": "apply Int64.repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Int64.repr (Int64.unsigned b)) b"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , Ptrofs.neg , Int64.neg .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (_ : agree64 a1 b1),\nagree64 (neg a1) (Int64.neg b1)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1)),\nLogic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1)),\nLogic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "b1 : Int64.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (unsigned a1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (Int64.unsigned b1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.opp (Int64.unsigned b1))))\n  (Int64.unsigned (Int64.repr (Z.opp (Int64.unsigned b1))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , Ptrofs.add , Int.add .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : agree64 a1 b1) (_ : agree64 a2 b2),\nagree64 (add a1 a2) (Int64.add b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.add b1 b2))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.add b1 b2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.add b1 b2))",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "b2 : Int64.int",
                "a2 : int",
                "b1 : Int64.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.add (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.add b1 b2))",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.add (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.add b1 b2))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.add (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.add b1 b2))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , Ptrofs.sub , Int.sub .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : agree64 a1 b1) (_ : agree64 a2 b2),\nagree64 (sub a1 a2) (Int64.sub b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.sub b1 b2))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.sub b1 b2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.sub b1 b2))",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "b2 : Int64.int",
                "a2 : int",
                "b1 : Int64.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.sub (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.sub b1 b2))",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.sub (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.sub b1 b2))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.sub (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.sub b1 b2))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "unfold agree64 , Ptrofs.mul , Int.mul .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : agree64 a1 b1) (_ : agree64 a2 b2),\nagree64 (mul a1 a2) (Int64.mul b1 b2)"
            ],
            "tactic_res": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.mul b1 b2))"
            ]
        },
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : Logic.eq (unsigned a1) (Int64.unsigned b1))\n  (_ : Logic.eq (unsigned a2) (Int64.unsigned b2)),\nLogic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.mul b1 b2))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.mul b1 b2))",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "b2 : Int64.int",
                "a2 : int",
                "b1 : Int64.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "rewrite _ , _ .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.mul (unsigned a1) (unsigned a2))))\n  (Int64.unsigned (Int64.mul b1 b2))",
                "H : Logic.eq (unsigned a1) (Int64.unsigned b1)",
                "H0 : Logic.eq (unsigned a2) (Int64.unsigned b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.mul (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.mul b1 b2))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : Logic.eq\n  (unsigned (repr (Z.mul (Int64.unsigned b1) (Int64.unsigned b2))))\n  (Int64.unsigned (Int64.mul b1 b2))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall (a1 : int) (b1 : Int64.int) (a2 : int) (b2 : Int64.int)\n  (_ : agree64 a1 b1) (_ : agree64 a2 b2),\nagree64 (divs a1 a2) (Int64.divs b1 b2)"
            ],
            "tactic_res": [
                "_goal : agree64 (divs a1 a2) (Int64.divs b1 b2)",
                "H0 : agree64 a2 b2",
                "H : agree64 a1 b1",
                "b2 : Int64.int",
                "a2 : int",
                "b1 : Int64.int",
                "a1 : int"
            ]
        },
        {
            "tactic_sig": "unfold agree64 , Ptrofs.divs , Int64.divs .",
            "tactic_args": [
                "_goal : agree64 (divs a1 a2) (Int64.divs b1 b2)"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (signed a1) (signed a2))))\n  (Int64.unsigned\n     (Int64.repr (Z.quot (Int64.signed b1) (Int64.signed b2))))"
            ]
        },
        {
            "tactic_sig": "erewrite ! agree64_signed by eauto .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (signed a1) (signed a2))))\n  (Int64.unsigned\n     (Int64.repr (Z.quot (Int64.signed b1) (Int64.signed b2))))"
            ],
            "tactic_res": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (Int64.signed b1) (Int64.signed b2))))\n  (Int64.unsigned\n     (Int64.repr (Z.quot (Int64.signed b1) (Int64.signed b2))))"
            ]
        },
        {
            "tactic_sig": "apply agree64_repr .",
            "tactic_args": [
                "_goal : Logic.eq (unsigned (repr (Z.quot (Int64.signed b1) (Int64.signed b2))))\n  (Int64.unsigned\n     (Int64.repr (Z.quot (Int64.signed b1) (Int64.signed b2))))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : int, Logic.eq (of_int64 (to_int64 n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (of_int64 (to_int64 n)) n",
                "n : int"
            ]
        },
        {
            "tactic_sig": "unfold of_int64 , to_int64 .",
            "tactic_args": [
                "_goal : Logic.eq (of_int64 (to_int64 n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (repr (Int64.unsigned (Int64.repr (unsigned n)))) n"
            ]
        },
        {
            "tactic_sig": "apply eqm_repr_eq .",
            "tactic_args": [
                "_goal : Logic.eq (repr (Int64.unsigned (Int64.repr (unsigned n)))) n"
            ],
            "tactic_res": [
                "_goal : eqm (Int64.unsigned (Int64.repr (unsigned n))) (unsigned n)"
            ]
        },
        {
            "tactic_sig": "rewrite <- eqm64 .",
            "tactic_args": [
                "_goal : eqm (Int64.unsigned (Int64.repr (unsigned n))) (unsigned n)"
            ],
            "tactic_res": [
                "_goal : Int64.eqm (Int64.unsigned (Int64.repr (unsigned n))) (unsigned n)"
            ]
        },
        {
            "tactic_sig": "apply Int64.eqm_sym .",
            "tactic_args": [
                "_goal : Int64.eqm (Int64.unsigned (Int64.repr (unsigned n))) (unsigned n)"
            ],
            "tactic_res": [
                "_goal : Int64.eqm (unsigned n) (Int64.unsigned (Int64.repr (unsigned n)))"
            ]
        },
        {
            "tactic_sig": "apply Int64.eqm_unsigned_repr .",
            "tactic_args": [
                "_goal : Int64.eqm (unsigned n) (Int64.unsigned (Int64.repr (unsigned n)))"
            ],
            "tactic_res": []
        }
    ],
    [
        {
            "tactic_sig": "intros .",
            "tactic_args": [
                "_goal : forall n : Int64.int, Logic.eq (to_int64 (of_int64 n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (to_int64 (of_int64 n)) n",
                "n : Int64.int"
            ]
        },
        {
            "tactic_sig": "unfold of_int64 , to_int64 .",
            "tactic_args": [
                "_goal : Logic.eq (to_int64 (of_int64 n)) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int64.repr (unsigned (repr (Int64.unsigned n)))) n"
            ]
        },
        {
            "tactic_sig": "rewrite unsigned_repr .",
            "tactic_args": [
                "_goal : Logic.eq (Int64.repr (unsigned (repr (Int64.unsigned n)))) n"
            ],
            "tactic_res": [
                "_goal : Logic.eq (Int64.repr (Int64.unsigned n)) n",
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) max_unsigned)"
            ]
        },
        {
            "tactic_sig": "apply Int64.repr_unsigned .",
            "tactic_args": [
                "_goal : Logic.eq (Int64.repr (Int64.unsigned n)) n"
            ],
            "tactic_res": []
        },
        {
            "tactic_sig": "unfold max_unsigned .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) max_unsigned)"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) (Z.sub modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "rewrite modulus_eq64 .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) (Z.sub modulus (Zpos xH)))"
            ],
            "tactic_res": [
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) (Z.sub Int64.modulus (Zpos xH)))"
            ]
        },
        {
            "tactic_sig": "destruct ( Int64.unsigned_range _ ) .",
            "tactic_args": [
                "n : Int64.int"
            ],
            "tactic_res": [
                "H0 : Z.lt (Int64.unsigned n) Int64.modulus",
                "H : Z.le Z0 (Int64.unsigned n)"
            ]
        },
        {
            "tactic_sig": "omega .",
            "tactic_args": [
                "_goal : Logic.and (Z.le Z0 (Int64.unsigned n))\n  (Z.le (Int64.unsigned n) (Z.sub Int64.modulus (Zpos xH)))"
            ],
            "tactic_res": []
        }
    ]
]