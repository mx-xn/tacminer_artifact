atpl/pi_calculus.v
-----
atpl/pi_calculus_compr.v
-----
Ltac custom_tac0 H0 := inversion H0; subst.
-----
cong_end
Proof. intros. split. - intros. induction H. + unfold step_process. destruct IHstep_process_cong as [P1']. destruct H0 as [P2']. exists (compose P1' P3). exists (compose P2' P3). destruct H0 as [CP1 H0]. destruct H0 as [CP2 SPB]. repeat split. * assert (compose P1 P3 = fill (c_compose_l c_hole P3) P1); eauto. assert (compose P1' P3 = fill (c_compose_l c_hole P3) P1'); eauto. rewrite H0; rewrite H1. eapply cong_context. eapply CP1. * assert (compose P2 P3 = fill (c_compose_l c_hole P3) P2); eauto. assert (compose P2' P3 = fill (c_compose_l c_hole P3) P2'); eauto. rewrite H0; rewrite H1. eapply cong_context. eapply CP2. * constructor. eapply SPB. + unfold step_process. exists (compose (output c z Q) (input c P)). exists (compose Q (open z P)). repeat split; try (eapply cong_refl); constructor. + destruct IHstep_process_cong as [P1]. destruct H2 as [Q1]. exists P1. exists Q1. repeat split. * eapply cong_trans. eapply cong_symm; eauto. eapply H2. * eapply cong_trans. eapply cong_symm; eauto. eapply H2. * eapply H2. - intros. destruct H as [P']. destruct H as [Q']. destruct H as [CPP' H]. destruct H as [CQQ' H]. apply step_cong with (P := P') (Q := Q'). generalize dependent P. generalize dependent Q. induction H. + intros. eapply step_composition_cong. eapply IHstep_process_base. eapply cong_refl. eapply cong_refl. + intros. eapply step_communication_cong. + eapply cong_symm; eauto. + eapply cong_symm; eauto. Qed.
lts_input_helper
Proof. intros. remember (recv_label c1 c2). induction H; try (inversion Heql; subst). - apply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose S Q). split. + apply cong_trans with (Q := (compose (compose (input c1 R) S) Q)). assert (compose P Q = fill (c_compose_l c_hole Q) P); eauto. assert (compose (compose (input c1 R) S) Q = fill (c_compose_l c_hole Q) (compose (input c1 R) S)); eauto. rewrite H1; rewrite H2; eapply cong_context. eapply H0. eapply cong_symm; eapply cong_compose_assoc. + apply cong_trans with (Q := (compose (compose (open c2 R) S) Q)). assert (compose P' Q = fill (c_compose_l c_hole Q) P'); eauto. assert (compose (compose (open c2 R) S) Q = fill (c_compose_l c_hole Q) (compose (open c2 R) S)); eauto. rewrite H1; rewrite H2; eapply cong_context. eapply H0. eapply cong_symm; eapply cong_compose_assoc. - apply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose P S). split. + eapply cong_trans with (Q := (compose P (compose (input c1 R) S))). assert (compose P Q = fill (c_compose_r P c_hole) Q); eauto. assert (compose P (compose (input c1 R) S) = fill (c_compose_r P c_hole) (compose (input c1 R) S)); eauto. rewrite H1; rewrite H2; eapply cong_context. eapply H0. eapply cong_trans. eapply cong_compose_assoc. eapply cong_trans with (Q := (compose (compose (input c1 R) P) S)). assert (compose (compose P (input c1 R)) S = fill (c_compose_l c_hole S) (compose P (input c1 R))); eauto. assert (compose (compose (input c1 R) P) S = fill (c_compose_l c_hole S) (compose (input c1 R) P)); eauto. rewrite H1; rewrite H2; eapply cong_context. eapply cong_compose_comm. eapply cong_symm; eapply cong_compose_assoc. + apply cong_trans with (Q := (compose P (compose (open c2 R) S))). assert (compose P Q' = fill (c_compose_r P c_hole) Q'); eauto. assert (compose P (compose (open c2 R) S) = fill (c_compose_r P c_hole) (compose (open c2 R) S)); eauto. rewrite H1; rewrite H2; eapply cong_context; eapply H0. eapply cong_trans. eapply cong_compose_assoc. eapply cong_trans. assert (compose (compose P (open c2 R)) S = fill (c_compose_l c_hole S) (compose P (open c2 R))); eauto. rewrite H1; eapply cong_context. eapply cong_compose_comm. simpl. eapply cong_symm; eapply cong_compose_assoc. - inversion Heql; subst. exists P. exists stop. split. eapply cong_symm; eapply cong_zero. eapply cong_symm; eapply cong_zero. - eapply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose S (replicate P)). split. + eapply cong_trans. eapply cong_replicate. eapply cong_trans. assert (compose P (replicate P) = fill (c_compose_l c_hole (replicate P)) P); eauto. rewrite H1. eapply cong_context. eapply H0. simpl. eapply cong_symm. eapply cong_compose_assoc. + eapply cong_trans. assert (compose P' (replicate P) = fill (c_compose_l c_hole (replicate P)) P'); eauto. rewrite H1; eapply cong_context. eapply H0. simpl. eapply cong_symm; eapply cong_compose_assoc. Qed.
lts_output_helper
Proof. intros. remember (send_label c1 c2). induction H; try (inversion Heql; subst). - apply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose S Q). split. + eapply cong_trans. assert (compose P Q = fill (c_compose_l c_hole Q) P); eauto. rewrite H1. eapply cong_context. eapply H0. simpl. eapply cong_symm; eapply cong_compose_assoc. + eapply cong_trans. assert (compose P' Q = fill (c_compose_l c_hole Q) P'); eauto. rewrite H1. eapply cong_context. eapply H0. simpl. eapply cong_symm; eapply cong_compose_assoc. - apply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose P S). split. + eapply cong_trans. assert (compose P Q = fill (c_compose_r P c_hole) Q); eauto. rewrite H1; eapply cong_context. eapply H0. simpl. eapply cong_trans. eapply cong_compose_assoc. eapply cong_trans. assert (compose (compose P (output c1 c2 R)) S = fill (c_compose_l c_hole S) (compose P (output c1 c2 R))); eauto. rewrite H1; eapply cong_context. eapply cong_compose_comm. simpl. eapply cong_symm; eapply cong_compose_assoc. + eapply cong_trans. assert (compose P Q' = fill (c_compose_r P c_hole) Q'); eauto. rewrite H1; eapply cong_context. eapply H0. simpl. eapply cong_trans. eapply cong_compose_assoc. eapply cong_trans. assert (compose (compose P R) S = fill (c_compose_l c_hole S) (compose P R)); eauto. rewrite H1; eapply cong_context. eapply cong_compose_comm. simpl. eapply cong_symm; eapply cong_compose_assoc. - exists P. exists stop. split. eapply cong_symm; eapply cong_zero. eapply cong_symm; eapply cong_zero. - eapply IHlts in H0. destruct H0 as [R]. destruct H0 as [S]. exists R. exists (compose S (replicate P)). split. + eapply cong_trans. eapply cong_replicate. eapply cong_trans. assert (compose P (replicate P) = fill (c_compose_l c_hole (replicate P)) P); eauto. rewrite H1; eapply cong_context. apply H0. simpl. eapply cong_symm; eapply cong_compose_assoc. + eapply cong_trans. assert (compose P' (replicate P) = fill (c_compose_l c_hole (replicate P)) P'); eauto. rewrite H1; eapply cong_context. apply H0. simpl. eapply cong_symm; eapply cong_compose_assoc. Qed.
lts_tau_step
Proof. intros. destruct H as [P']. destruct H as [Q']. destruct H as [CPP' H]; destruct H as [CQQ' S]. unfold lts_cong. exists P'. exists Q'. repeat split; eauto. clear CPP'; clear CQQ'. induction S. - eapply lts_comp_left. eapply IHS. - eapply lts_comm_left. constructor. constructor. Qed.
tau_lts_comm_step
Proof. intros. eapply lts_input_helper in H0. eapply lts_output_helper in H. destruct H as [R]. destruct H as [S]. destruct H. destruct H0 as [R']. destruct H0 as [S']. destruct H0. unfold step_process. exists (compose (compose (output c n R) (input c R')) (compose S S')). exists (compose (compose R (open n R')) (compose S S')). repeat split. + eapply cong_trans. assert (compose P Q = fill (c_compose_l c_hole Q) P); eauto. rewrite H3. eapply cong_context. eapply H. simpl. eapply cong_trans. assert (compose (compose (output c n R) S) Q = fill (c_compose_r (compose (output c n R) S) c_hole) Q); eauto. rewrite H3. eapply cong_context. eapply H0. simpl. eapply cong_trans. eapply cong_symm. eapply cong_compose_assoc. eapply cong_trans. assert (compose (output c n R) (compose S (compose (input c R') S')) = fill (c_compose_r (output c n R) c_hole) (compose S (compose (input c R') S'))); eauto. rewrite H3. eapply cong_context. eapply cong_compose_assoc. simpl. eapply cong_trans. assert (compose (output c n R) (compose (compose S (input c R')) S') = fill (c_compose_r (output c n R) (c_compose_l c_hole S')) (compose S (input c R'))); eauto. rewrite H3. eapply cong_context. eapply cong_compose_comm. simpl. eapply cong_trans. assert (compose (output c n R) (compose (compose (input c R') S) S') = fill (c_compose_r (output c n R) c_hole) (compose (compose (input c R') S) S')); eauto. rewrite H3; eapply cong_context. eapply cong_symm; eapply cong_compose_assoc. simpl. eapply cong_compose_assoc. + eapply cong_trans. assert (compose P' Q' = fill (c_compose_l c_hole Q') P'); eauto. rewrite H3. eapply cong_context. eapply H1. simpl. eapply cong_trans. assert (compose (compose R S) Q' = fill (c_compose_r (compose R S) c_hole) Q'); eauto. rewrite H3. eapply cong_context. eapply H2. simpl. eapply cong_trans. eapply cong_symm. eapply cong_compose_assoc. eapply cong_trans. assert (compose R (compose S (compose (open n R') S')) = fill (c_compose_r R c_hole) (compose S (compose (open n R') S'))); eauto. rewrite H3. eapply cong_context. eapply cong_compose_assoc. simpl. eapply cong_trans. assert (compose R (compose (compose S (open n R')) S') = fill (c_compose_r R (c_compose_l c_hole S')) (compose S (open n R'))); eauto. rewrite H3. eapply cong_context. eapply cong_compose_comm. simpl. eapply cong_trans. assert (compose R (compose (compose (open n R') S) S') = fill (c_compose_r R c_hole) (compose (compose (open n R') S) S')); eauto. rewrite H3; eapply cong_context. eapply cong_symm; eapply cong_compose_assoc. simpl. eapply cong_compose_assoc. + constructor. constructor. Qed.
tau_lts_step
Proof. intros. remember tau_label. induction H; inversion Heql; subst. - unfold step_process. eapply IHlts in H0. destruct H0 as [P0']. destruct H0 as [Q']. exists (compose P0' Q). exists (compose Q' Q). repeat split. + assert (compose P Q = fill (c_compose_l c_hole Q) P); eauto. assert (compose P0' Q = fill (c_compose_l c_hole Q) P0'); eauto. rewrite H1. rewrite H2. eapply cong_context. eapply H0. + assert (compose P' Q = fill (c_compose_l c_hole Q) P'); eauto. assert (compose Q' Q = fill (c_compose_l c_hole Q) Q'); eauto. rewrite H1. rewrite H2. eapply cong_context. eapply H0. + eapply step_composition. eapply H0. - unfold step_process. eapply IHlts in H0. destruct H0 as [X]. destruct H0 as [Y]. exists (compose X P). exists (compose Y P). repeat split. + eapply cong_trans. apply cong_compose_comm. assert (compose Q P = fill (c_compose_l c_hole P) Q); eauto. assert (compose X P = fill (c_compose_l c_hole P) X); eauto. rewrite H1. rewrite H2. eapply cong_context. eapply H0. + eapply cong_trans. apply cong_compose_comm. assert (compose Q' P = fill (c_compose_l c_hole P) Q'); eauto. assert (compose Y P = fill (c_compose_l c_hole P) Y); eauto. rewrite H1. rewrite H2. eapply cong_context. eapply H0. + eapply step_composition. eapply H0. - eapply tau_lts_comm_step. eapply H. eapply H0. - eapply tau_lts_comm_step in H. destruct H as [P0]. destruct H as [Q0]. exists P0. exists Q0. repeat split; eauto. + eapply cong_trans. eapply cong_compose_comm. eapply H. + eapply cong_trans. eapply cong_compose_comm. eapply H. + eapply H. + eauto. - eapply IHlts in H0. unfold step_process in *. clear IHlts. destruct H0 as [P'0]. destruct H0 as [Q]. exists (compose P'0 (replicate P)). exists (compose Q (replicate P)). repeat split. + eapply cong_trans. eapply cong_replicate. assert (compose P (replicate P) = fill (c_compose_l c_hole (replicate P)) P); eauto. rewrite H1. eapply cong_trans. eapply cong_context. eapply H0. simpl. eapply cong_refl. + assert (compose P' (replicate P) = fill (c_compose_l c_hole (replicate P)) P'); eauto. rewrite H1. eapply cong_trans. eapply cong_context. eapply H0. simpl. eapply cong_refl. + eapply step_composition. eapply H0. - eapply tau_lts_comm_step in H; eauto. destruct H as [P0]. destruct H as [P0']. unfold step_process. exists (compose P0 (replicate P)). exists (compose P0' (replicate P)). repeat split. + eapply cong_trans. eapply cong_replicate. eapply cong_trans. assert (compose P (replicate P) = fill (c_compose_r P c_hole) (replicate P)); eauto. rewrite H1; eapply cong_context. eapply cong_replicate. simpl. eapply cong_trans. eapply cong_compose_assoc. eapply cong_trans. assert (compose (compose P P) (replicate P) = fill (c_compose_l c_hole (replicate P)) (compose P P)); eauto. rewrite H1; eapply cong_context. eapply H. simpl; eapply cong_refl. + assert (compose (compose P' P'') (replicate P) = fill (c_compose_l c_hole (replicate P)) (compose P' P'')); eauto. eapply cong_trans. rewrite H1; eapply cong_context. eapply H. simpl. eapply cong_refl. + eapply step_composition. eapply H. Qed.
early_bisimilarity_symm
Proof. intros. destruct H as [R]. destruct H. unfold early_bisimilar. exists R. split. eauto. unfold early_bisimulation in H. destruct H. apply H. apply H0. Qed.
early_bisimilarity_refl
Proof. intros. unfold early_bisimilar. exists (fun p q => p = q). split; eauto. unfold early_bisimulation. split; eauto. intros; subst; eauto. Qed.
early_bisimilarity_trans
Proof. intros. unfold early_bisimilar in *. destruct H as [R1]; destruct H0 as [R2]. destruct H; destruct H0. exists (clos_trans process (fun p q => (R1 p q \/ R2 p q))). split. - unfold early_bisimulation in *. split. + intros. induction H3. destruct H3. eapply t_step. left; apply H; eauto. eapply t_step. right; apply H0; eauto. eapply t_trans. eapply IHclos_trans2. eapply IHclos_trans1. + intros. generalize dependent P1'. induction H3. * destruct H3. destruct H. intros. eapply H4 in H5. destruct H5. exists x0. split. destruct H5. apply H5. eapply t_step. destruct H5. left; apply H6. apply H3. intros. eapply H0 in H4. destruct H4. destruct H4. exists x0. split. apply H4. eapply t_step. right; apply H5. apply H3. * intros. apply IHclos_trans1 in H4. destruct H4. destruct H3. apply IHclos_trans2 in H3. destruct H3. destruct H3. exists x1. split. apply H3. eapply t_trans. apply H4. apply H5. - eapply t_trans. eapply t_step. left; apply H1. eapply t_step. right; apply H2. Qed.
progresses_subset_left
Proof. intros. unfold progresses in *. repeat split; eauto. - destruct H0. intros. eapply H0 in H2. destruct H2 as [Q'0]. exists Q'0. split; eapply H2. apply H. apply H3. - destruct H0. intros. eapply H1 in H2. destruct H2 as [Q'0]. exists Q'0. eapply H2. apply H. apply H3. Qed.
progresses_subset_right
Proof. intros. unfold progresses in *. repeat split; eauto. - destruct H0. intros. eapply H0 in H2. destruct H2 as [P']. exists P'. split. eapply H2. eapply H. eapply H2. eapply H3. - destruct H0. intros. eapply H1 in H2. destruct H2 as [Q']. exists Q'. split. eapply H2. eapply H. eapply H2. eapply H3. Qed.
apply_n_symm
Proof. intros. induction n. - simpl; eauto. - simpl. unfold symmetric. intros. destruct H1. left; eauto. right; eauto. eapply H0 in IHn. eauto. Qed.
apply_n_subset
Proof. intros. simpl. unfold subset. intros. left; eapply H. Qed.
progresses_union
Proof. intros. unfold progresses. repeat split. - intros. destruct H as [H _]. destruct H0 as [H0 _]. destruct H2. + eapply H in H1. apply H1. apply H2. + eapply H0 in H1. apply H1. apply H2. - intros. destruct H as [_ H]. destruct H0 as [_ H0]. destruct H2. + eapply H in H1. eapply H1. apply H2. + eapply H0 in H1. eapply H1. apply H2. Qed.
apply_n_progresses
Proof. intros. induction n. - simpl. eapply progresses_subset_right; try (apply H0). unfold subset. intros; eauto. - simpl in *. eapply progresses_union. + eapply progresses_subset_right; try (apply IHn). unfold subset. intros. left. apply H1. + eapply progresses_subset_right with (F (fun P Q => apply_n n R F P Q \/ F (apply_n n R F) P Q)). unfold symmetric. intros. unfold subset; intros. right; eauto. eapply H in IHn. apply IHn. unfold subset; intros. left; eauto. Qed.
strongly_safe_in_bisimulation
Proof. intros. unfold early_bisimulation. unfold progresses in H2. split. - intros. destruct H3 as [n]. generalize dependent P1. generalize dependent P2. induction n. + intros. simpl in H3. exists 0; simpl; eauto. + intros. simpl in H3. destruct H3. * eapply IHn; eauto. * exists (S n). simpl. right. assert (symmetric (apply_n n R F)). { eapply apply_n_symm. apply H0. apply H. } apply H in H4. apply H4. apply H3. - intros. destruct H3 as [n]. eapply apply_n_progresses in H3; eauto. destruct H3 as [P2']. exists P2'. split. eapply H3. exists (S n); eapply H3. Qed.
iterate_sum
Proof. intros. generalize dependent P. induction n. - intros. simpl. simpl in H. exists A; eauto. - intros. simpl. simpl in H. simpl in IHn. inversion H; subst. exists x. split. eapply H1. eapply IHn. eapply H1. Qed.
closure_compose
Proof. intros. destruct H. destruct H0. exists (1 + x + x0). eapply iterate_sum. eapply H. eapply H0. Qed.
iterate_progresses
Proof. intros. generalize dependent R. generalize dependent S. induction n. - intros; split. + simpl. unfold closure. unfold subset. intros. eapply H0; eauto. + simpl. unfold closure. unfold progresses. repeat split. * intros. eapply H0 in H1; eauto. eapply H1. eapply H3. eapply H4. * intros. eapply H0 in H1; eauto. eapply H1. eapply H3. eapply H4. - intros. split. + unfold subset. simpl. intros. destruct H3 as [A]; subst. destruct H3. assert (progresses R S); eauto. apply IHn in H2; eauto. destruct H2 as [H2 H2']. eapply H2 in H4. eapply H0 in H1; eauto. destruct H1. eapply H1 in H3. destruct H3 as [n']. destruct H4 as [n'']. exists (1 + (n' + n'')). eapply iterate_sum; eauto. + repeat split. * intros. simpl in H4. destruct H4 as [A]. destruct H4. assert (subset R S); eauto. eapply IHn in H6; eauto. assert (subset R S); eauto. eapply H0 in H7; eauto. destruct H7. destruct H8 as [H8 _]. destruct H6 as [_ H6]. destruct H6 as [H6 _]. eapply H6 in H5. destruct H5. destruct H5. eapply H8 in H4. destruct H4. destruct H4. -- exists x0. split. ++ eapply H4. ++ eapply closure_compose. eapply H10. eapply H9. -- eapply H5. -- eapply H3. * intros. simpl in H4. destruct H4 as [A]. destruct H4. assert (subset R S); eauto. eapply IHn in H6; eauto. assert (subset R S); eauto. eapply H0 in H7; eauto. destruct H7. destruct H8 as [_ H8]. destruct H6 as [_ H6]. destruct H6 as [_ H6]. eapply H8 in H4. destruct H4. destruct H4. eapply H6 in H5. destruct H5. destruct H5. exists x0. split. eapply H5. eapply closure_compose. eapply H9. eapply H10. eapply H4. eapply H3. Qed.
closure_safe
Proof. intros. unfold closure. unfold strongly_safe. intros. split. - unfold subset. intros. destruct H3 as [n]. eapply iterate_progresses; eauto. - unfold progresses. repeat split. + intros. destruct H4. eapply iterate_progresses in H1; eauto. eapply H1; eauto. + intros. destruct H4. eapply iterate_progresses in H1; eauto. eapply H1; eauto. Qed.
ni_compose_fill
Proof. intros. induction nc1; try (simpl; rewrite IHnc1; eauto). - simpl. eauto. Qed.
ni_context_helper
Proof. intros. generalize dependent P. generalize dependent Q. induction x; simpl in *. - intros. destruct H as [C']. destruct H as [P']. destruct H as [Q']. exists (ni_compose C C'). exists P'. exists Q'. repeat split. + eapply H. + destruct H. destruct H0. rewrite H0. rewrite ni_compose_fill. eauto. + destruct H. destruct H0. rewrite H1. rewrite ni_compose_fill. eauto. - intros. destruct H. destruct H. eapply IHx in H0. destruct H as [C']. destruct H as [P']. destruct H as [Q']. unfold r_compose. exists (ni_fill C x0). split; try (eapply H0). exists (ni_compose C C'). exists P'. exists Q'. repeat split. + eapply H. + destruct H. destruct H1. rewrite H1. rewrite ni_compose_fill. eauto. + destruct H. destruct H1. rewrite H2. rewrite ni_compose_fill. eauto. Qed.
ni_context_progresses
Proof. intros. generalize dependent l. generalize dependent P'. induction C. - intros. simpl in *. inversion H1; subst. exists (ni_fill C Q). split. constructor. exists 0. simpl. exists C. exists P. exists Q. repeat split. eapply H. eapply H2. - intros. simpl in *. inversion H1; subst. + eapply IHC in H4. destruct H4 as [Q']. destruct H3. exists (compose Q' (replicate (ni_fill C Q))). split. * eapply lts_rep_act. eapply H3. * destruct H4. exists (1 + x). simpl. exists (compose P'0 (replicate (ni_fill C Q))). split. exists (ni_compose_r P'0 (ni_replicate C)). exists P. exists Q. repeat split. eauto. apply ni_context_helper with (C := (ni_compose_l ni_hole (replicate (ni_fill C Q)))) in H4. eapply H4. + eapply IHC in H4. eapply IHC in H5. destruct H4. destruct H3. destruct H5. destruct H5. exists (compose (compose x x0) (replicate (ni_fill C Q))). split. * eapply lts_rep_comm. eapply H3. eapply H5. * destruct H4 as [m]. destruct H6 as [m'']. exists (2 + m + m''). simpl. exists (compose (compose P'0 P'') (replicate (ni_fill C Q))). split. exists (ni_compose_r (compose P'0 P'') (ni_replicate C)). exists P. exists Q. repeat split. eauto. eapply iterate_sum. apply ni_context_helper with (C := (ni_compose_l (ni_compose_l ni_hole P'') (replicate (ni_fill C Q)))) in H4. eapply H4. simpl. apply ni_context_helper with (C := (ni_compose_l (ni_compose_r x ni_hole) (replicate (ni_fill C Q)))) in H6. eapply H6. - intros. inversion H1; subst. + eapply IHC in H7. destruct H7. destruct H3. exists (compose x p). split. * simpl. eapply lts_comp_left. eapply H3. * destruct H4. exists (x0). apply ni_context_helper with (C := (ni_compose_l ni_hole p)) in H4. eapply H4. + simpl in *. exists (compose (ni_fill C Q) Q'). split. * eapply lts_comp_right. eapply H7. * exists 0. simpl. exists (ni_compose_l C Q'). exists P. exists Q. repeat split; eauto. + eapply IHC in H5. destruct H5 as [Q0]. destruct H3. simpl. exists (compose Q0 Q'). split. * eapply lts_comm_left. eapply H3. eapply H8. * destruct H4. exists x. apply ni_context_helper with (C := ni_compose_l ni_hole Q') in H4. eapply H4. + eapply IHC in H5. destruct H5 as [Q0]. destruct H3. simpl. exists (compose Q0 Q'). split. * eapply lts_comm_right; eauto. * destruct H4 as [n']. exists n'. apply ni_context_helper with (C := ni_compose_l ni_hole Q') in H4. eapply H4. - intros. inversion H1; subst. + simpl in *. exists (compose P'0 (ni_fill C Q)). split. * eapply lts_comp_left. eapply H7. * exists 0. simpl. exists (ni_compose_r P'0 C). exists P. exists Q. repeat split; eauto. + eapply IHC in H7. destruct H7. destruct H3. exists (compose p x). split. * simpl. eapply lts_comp_right. eapply H3. * destruct H4. exists (x0). apply ni_context_helper with (C := (ni_compose_r p ni_hole)) in H4. eapply H4. + eapply IHC in H8. destruct H8 as [Q0]. destruct H3. simpl. exists (compose P'0 Q0). split. * eapply lts_comm_left. eapply H5. eapply H3. * destruct H4. exists x. apply ni_context_helper with (C := ni_compose_r P'0 ni_hole) in H4. eapply H4. + eapply IHC in H8. destruct H8 as [Q0]. destruct H3. simpl. exists (compose P'0 Q0). split. * eapply lts_comm_right; eauto. * destruct H4 as [n']. exists n'. apply ni_context_helper with (C := ni_compose_r P'0 ni_hole) in H4. eapply H4. - intros. simpl in *. eapply H0 in H1; eauto. destruct H1 as [Q']. exists Q'. split. eapply H1. exists 0. simpl. exists ni_hole. simpl. exists P'. exists Q'. repeat split; eauto. eapply H1. Qed.
ni_context_progresses'
Proof. intros. generalize dependent l. generalize dependent Q'. induction C. - intros. simpl in *. custom_tac0 H1. exists (ni_fill C P). split. constructor. exists 0. simpl. exists C. exists P. exists Q. repeat split. eauto. - intros. simpl in *. custom_tac0 H1. + eapply IHC in H4. destruct H4 as [ Q']. destruct H3. exists (compose Q' (replicate (ni_fill C P))). split. * eapply lts_rep_act. eapply H3. * destruct H4. exists (1 + x). simpl. exists (compose Q' (replicate (ni_fill C Q))). split. exists (ni_compose_r Q' (ni_replicate C)). exists P. exists Q. repeat split. eauto. apply ni_context_helper with (C := (ni_compose_l ni_hole (replicate (ni_fill C Q)))) in H4. eapply H4. + eapply IHC in H4. eapply IHC in H5. destruct H4. destruct H3. destruct H5. destruct H5. exists (compose (compose x x0) (replicate (ni_fill C P))). split. * eapply lts_rep_comm. eapply H3. eapply H5. * destruct H4 as [ m]. destruct H6 as [ m'']. exists (2 + m + m''). simpl. exists (compose (compose x x0) (replicate (ni_fill C Q))). split. exists (ni_compose_r (compose x x0) (ni_replicate C)). exists P. exists Q. repeat split. eauto. eapply iterate_sum. apply ni_context_helper with (C := (ni_compose_l (ni_compose_l ni_hole x0) (replicate (ni_fill C Q)))) in H4. simpl in H4. eapply H4. simpl. apply ni_context_helper with (C := (ni_compose_l (ni_compose_r P' ni_hole) (replicate (ni_fill C Q)))) in H6. eapply H6. - intros. custom_tac0 H1. + eapply IHC in H7. destruct H7. destruct H3. exists (compose x p). split. * simpl. eapply lts_comp_left. eapply H3. * destruct H4. exists (x0). apply ni_context_helper with (C := (ni_compose_l ni_hole p)) in H4. eapply H4. + simpl in *. exists (compose (ni_fill C P) Q'0). split. * eapply lts_comp_right. eapply H7. * exists 0. simpl. exists (ni_compose_l C Q'0). exists P. exists Q. repeat split; eauto. + eapply IHC in H5. destruct H5 as [ Q0]. destruct H3. simpl. exists (compose Q0 Q'0). split. * eapply lts_comm_left. eapply H3. eapply H8. * destruct H4. exists x. apply ni_context_helper with (C := ni_compose_l ni_hole Q'0) in H4. eapply H4. + eapply IHC in H5. destruct H5 as [ Q0]. destruct H3. simpl. exists (compose Q0 Q'0). split. * eapply lts_comm_right; eauto. * destruct H4 as [ n']. exists n'. apply ni_context_helper with (C := ni_compose_l ni_hole Q'0) in H4. eapply H4. - intros. custom_tac0 H1. + simpl in *. exists (compose P' (ni_fill C P)). split. * eapply lts_comp_left. eapply H7. * exists 0. simpl. exists (ni_compose_r P' C). exists P. exists Q. repeat split; eauto. + eapply IHC in H7. destruct H7. destruct H3. exists (compose p x). split. * simpl. eapply lts_comp_right. eapply H3. * destruct H4. exists (x0). apply ni_context_helper with (C := (ni_compose_r p ni_hole)) in H4. eapply H4. + eapply IHC in H8. destruct H8 as [ Q0]. destruct H3. simpl. exists (compose P' Q0). split. * eapply lts_comm_left. eapply H5. eapply H3. * destruct H4. exists x. apply ni_context_helper with (C := ni_compose_r P' ni_hole) in H4. eapply H4. + eapply IHC in H8. destruct H8 as [ Q0]. destruct H3. simpl. exists (compose P' Q0). split. * eapply lts_comm_right; eauto. * destruct H4 as [ n']. exists n'. apply ni_context_helper with (C := ni_compose_r P' ni_hole) in H4. eapply H4. - intros. simpl in *. destruct H0. eapply H0 in H1; eauto. destruct H1 as [ P']. exists P'. split. eapply H1. exists 0. simpl. exists ni_hole. simpl. exists P'. exists Q'. repeat split; eauto. eapply H1. Qed.
strongly_safe_ni_context
Proof. eapply closure_safe. - intros. unfold symmetric. intros. unfold ni_context_relation. unfold ni_context_relation in H0. destruct H0 as [C]. destruct H0 as [P']. destruct H0 as [Q']. exists C. exists Q'. exists P'. destruct H0. destruct H1. repeat split; eauto. - intros. split. + unfold subset. intros. exists 0. simpl. unfold ni_context_relation in *. destruct H1 as [C]. destruct H1 as [P']. destruct H1 as [Q']. exists C. exists P'. exists Q'. destruct H1. destruct H2. repeat split; eauto. + unfold progresses. split. * intros. destruct H2 as [C]. destruct H2 as [P']. destruct H2 as [Q_fill]. destruct H2. destruct H3. subst. eapply ni_context_progresses'; eauto. * intros. destruct H2 as [C]. destruct H2 as [P_fill]. destruct H2 as [Q']. destruct H2. destruct H3. subst. eapply ni_context_progresses; eauto. Qed.
