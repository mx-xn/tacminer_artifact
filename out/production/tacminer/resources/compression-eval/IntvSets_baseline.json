[
    {
        "lemma_name": "mem_In",
        "proof": [
            {
                "tactic_sig": "induction 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s : t) (_ : ok s), iff (eq (mem x s) true) (In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (eq false true) False",
                    "_goal : iff (eq (if zlt x h then zle l x else mem x s) true)\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "x : Z",
                    "IHok : iff (eq (mem x s) true) (In x s)",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "intuition congruence .",
                "tactic_sig_no_out_arg": "intuition congruence .",
                "tactic_args": [
                    "_goal : iff (eq false true) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff (eq (if zlt x h then zle l x else mem x s) true)\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "x : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff (eq (zle l x) true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : iff (eq (mem x s) true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l0 : Z.lt x h",
                    "g : Z.ge x h"
                ]
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) ; simpl as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff (eq (zle l x) true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l : Z",
                    "x : Z"
                ],
                "tactic_res": [
                    "_goal : iff (eq true true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : iff (eq false true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l1 : Z.le l x",
                    "g : Z.gt l x"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff (eq true true) (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split ; intros .",
                "tactic_sig_no_out_arg": "split ; intros .",
                "tactic_args": [
                    "_goal : iff (eq false true) (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "_goal : eq false true",
                    "H0 : eq false true",
                    "H0 : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ]
            },
            {
                "tactic_sig": "congruence .",
                "tactic_sig_no_out_arg": "congruence .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H0 : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": [
                    "H0 : and (Z.le l x) (Z.lt x h)",
                    "H0 : In x s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (eq (mem x s) true) (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "IHok : iff (eq (mem x s) true) (In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (In x s) (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (In x s) (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "contains_In",
        "proof": [
            {
                "tactic_sig": "induction 2 ; simpl .",
                "tactic_sig_no_out_arg": "induction 2 ; simpl .",
                "tactic_args": [
                    "_goal : forall (l0 h0 : Z) (_ : Z.lt l0 h0) (s : t) (_ : ok s),\niff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (eq false true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), False)",
                    "_goal : iff (eq (orb (andb (zle h0 h) (zle l l0)) (contains l0 h0 s)) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "H : Z.lt l0 h0",
                    "l0 : Z",
                    "h0 : Z",
                    "IHok : iff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)",
                    "H0 : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (eq false true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), False)"
                ],
                "tactic_res": [
                    "_goal : eq false true",
                    "H0 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), False"
                ]
            },
            {
                "tactic_sig": "elim ( _i _i ) ; lia .",
                "tactic_sig_no_out_arg": "elim ( _i _i ) ; lia .",
                "tactic_args": [
                    "_goal : eq false true",
                    "H0 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), False",
                    "l0 : Z"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) ; simpl as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff (eq (orb (andb (zle h0 h) (zle l l0)) (contains l0 h0 s)) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff (eq (orb (zle l l0) (contains l0 h0 s)) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : iff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l1 : Z.le h0 h",
                    "g : Z.gt h0 h"
                ]
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) ; simpl as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff (eq (orb (zle l l0) (contains l0 h0 s)) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff (eq true true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l2 : Z.le l l0",
                    "g : Z.gt l l0"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (eq true true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "IHok : iff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "H6 : Z.lt x h0",
                    "H5 : Z.le l0 x",
                    "x : Z",
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "H2 : forall _ : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s,\neq (contains l0 h0 s) true",
                    "H1 : forall (_ : eq (contains l0 h0 s) true) (x : Z)\n  (_ : and (Z.le l0 x) (Z.lt x h0)), In x s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) ; auto as [_o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) ; auto .",
                "tactic_args": [
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "x : Z"
                ],
                "tactic_res": [
                    "H4 : and (Z.le l x) (Z.lt x h)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : and (Z.le l0 l0) (Z.lt l0 h0)",
                    "H7 : and (Z.le l l0) (Z.lt l0 h)",
                    "H7 : In l0 s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and (Z.le l0 l0) (Z.lt l0 h0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h l0, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h l0, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "IHok : iff (eq (contains l0 h0 s) true)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s)\n  (forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\n   or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "H6 : Z.lt x h0",
                    "H5 : Z.le l0 x",
                    "x : Z",
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "H2 : forall _ : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)), In x s,\neq (contains l0 h0 s) true",
                    "H1 : forall (_ : eq (contains l0 h0 s) true) (x : Z)\n  (_ : and (Z.le l0 x) (Z.lt x h0)), In x s"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) ; auto as [_o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) ; auto .",
                "tactic_args": [
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "x : Z"
                ],
                "tactic_res": [
                    "H4 : and (Z.le l x) (Z.lt x h)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) .",
                "tactic_args": [
                    "H3 : forall (x : Z) (_ : and (Z.le l0 x) (Z.lt x h0)),\nor (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : and (Z.le l0 h) (Z.lt h h0)",
                    "H7 : and (Z.le l h) (Z.lt h h)",
                    "H7 : In h s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : and (Z.le l0 h) (Z.lt h h0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h h, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h h, False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_add",
        "proof": [
            {
                "tactic_sig": "induction 1 ; simpl ; intros .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl ; intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s : t) (_ : ok s) (l0 h0 : Z),\niff (In x (add l0 h0 s)) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) False)\n  (or (and (Z.le l0 x) (Z.lt x h0)) False)",
                    "_goal : iff\n  (In x\n     (if zlt h l0\n      then Cons l h (add l0 h0 s)\n      else\n       if zlt h0 l\n       then Cons l0 h0 (Cons l h s)\n       else add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "x : Z",
                    "l0 : Z",
                    "h0 : Z",
                    "IHok : forall l0 h0 : Z,\niff (In x (add l0 h0 s)) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) False)\n  (or (and (Z.le l0 x) (Z.lt x h0)) False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt h l0\n      then Cons l h (add l0 h0 s)\n      else\n       if zlt h0 l\n       then Cons l0 h0 (Cons l h s)\n       else add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (Cons l h (add l0 h0 s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff\n  (In x\n     (if zlt h0 l\n      then Cons l0 h0 (Cons l h s)\n      else add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt h l0",
                    "g : Z.ge h l0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l h (add l0 h0 s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (add l0 h0 s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (add l0 h0 s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "IHok : forall l0 h0 : Z,\niff (In x (add l0 h0 s)) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt h0 l\n      then Cons l0 h0 (Cons l h s)\n      else add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (Cons l0 h0 (Cons l h s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff (In x (add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt h0 l",
                    "g0 : Z.ge h0 l"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l0 h0 (Cons l h s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (In x (add (Z.min l l0) (Z.max h h0) s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "IHok : forall l0 h0 : Z,\niff (In x (add l0 h0 s)) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le (Z.min l l0) x) (Z.lt x (Z.max h h0))) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "intuition idtac .",
                "tactic_sig_no_out_arg": "intuition idtac .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le (Z.min l l0) x) (Z.lt x (Z.max h h0))) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l0 x) (Z.lt x h0))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : or (and (Z.le (Z.min l l0) x) (Z.lt x (Z.max h h0))) (In x s)",
                    "_goal : or (and (Z.le (Z.min l l0) x) (Z.lt x (Z.max h h0))) (In x s)",
                    "H2 : Z.lt x (Z.max h h0)",
                    "H0 : Z.le (Z.min l l0) x",
                    "H2 : Z.lt x h0",
                    "H0 : Z.le l0 x",
                    "H2 : Z.lt x h",
                    "H1 : Z.le l x"
                ]
            },
            {
                "tactic_sig": "assert ( _i <= _i < _i \\/ _i <= _i < _i ) by extlia .",
                "tactic_sig_no_out_arg": "assert ( _i <= _i < _i \\/ _i <= _i < _i ) by extlia .",
                "tactic_args": [
                    "l0 : Z",
                    "x : Z",
                    "h0 : Z",
                    "l : Z",
                    "x : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "H1 : or (and (Z.le l0 x) (Z.lt x h0)) (and (Z.le l x) (Z.lt x h))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : or (and (Z.le l0 x) (Z.lt x h0))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left ; extlia .",
                "tactic_sig_no_out_arg": "left ; extlia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "left ; extlia .",
                "tactic_sig_no_out_arg": "left ; extlia .",
                "tactic_args": [
                    "_goal : or (and (Z.le (Z.min l l0) x) (Z.lt x (Z.max h h0))) (In x s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "add_ok",
        "proof": [
            {
                "tactic_sig": "induction 1 ; simpl ; intros .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl ; intros .",
                "tactic_args": [
                    "_goal : forall (s : t) (_ : ok s) (l0 h0 : Z) (_ : Z.lt l0 h0),\nok (add l0 h0 s)"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l0 h0 Nil)",
                    "_goal : ok\n  (if zlt h l0\n   then Cons l h (add l0 h0 s)\n   else\n    if zlt h0 l\n    then Cons l0 h0 (Cons l h s)\n    else add (Z.min l l0) (Z.max h h0) s)",
                    "H : Z.lt l0 h0",
                    "l0 : Z",
                    "h0 : Z",
                    "H0 : Z.lt l0 h0",
                    "IHok : forall (l0 h0 : Z) (_ : Z.lt l0 h0), ok (add l0 h0 s)",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l0 h0 Nil)"
                ],
                "tactic_res": [
                    "_goal : Z.lt l0 h0",
                    "_goal : forall (x : Z) (_ : In x Nil), Z.lt h0 x",
                    "_goal : ok Nil"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt l0 h0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x Nil), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h0 x",
                    "H0 : In x Nil",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "_goal : Z.lt h0 x",
                    "H0 : In x Nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt h l0\n   then Cons l h (add l0 h0 s)\n   else\n    if zlt h0 l\n    then Cons l0 h0 (Cons l h s)\n    else add (Z.min l l0) (Z.max h h0) s)",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h (add l0 h0 s))",
                    "_goal : ok\n  (if zlt h0 l\n   then Cons l0 h0 (Cons l h s)\n   else add (Z.min l l0) (Z.max h h0) s)",
                    "l1 : Z.lt h l0",
                    "g : Z.ge h l0"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h (add l0 h0 s))"
                ],
                "tactic_res": [
                    "_goal : forall (x : Z) (_ : In x (add l0 h0 s)), Z.lt h x"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (add l0 h0 s)), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h x",
                    "H1 : In x (add l0 h0 s)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_add in _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite In_add in _i ; auto .",
                "tactic_args": [
                    "H1 : In x (add l0 h0 s)"
                ],
                "tactic_res": [
                    "H1 : or (and (Z.le l0 x) (Z.lt x h0)) (In x s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H1 : or (and (Z.le l0 x) (Z.lt x h0)) (In x s)"
                ],
                "tactic_res": [
                    "H1 : and (Z.le l0 x) (Z.lt x h0)",
                    "H1 : In x s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt h x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt h0 l\n   then Cons l0 h0 (Cons l h s)\n   else add (Z.min l l0) (Z.max h h0) s)",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l0 h0 (Cons l h s))",
                    "_goal : ok (add (Z.min l l0) (Z.max h h0) s)",
                    "l1 : Z.lt h0 l",
                    "g0 : Z.ge h0 l"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l0 h0 (Cons l h s))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l0 h0",
                    "_goal : forall (x : Z) (_ : In x (Cons l h s)), Z.lt h0 x",
                    "_goal : ok (Cons l h s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt l0 h0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl ; intros .",
                "tactic_sig_no_out_arg": "simpl ; intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (Cons l h s)), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h0 x",
                    "H1 : or (and (Z.le l x) (Z.lt x h)) (In x s)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H1 : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": [
                    "H1 : and (Z.le l x) (Z.lt x h)",
                    "H1 : In x s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : Z.lt h0 x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, Z.lt h0 x"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, Z.lt h0 x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l h s)"
                ],
                "tactic_res": [
                    "_goal : Z.lt l h",
                    "_goal : forall (x : Z) (_ : In x s), Z.lt h x",
                    "_goal : ok s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt l h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : ok (add (Z.min l l0) (Z.max h h0) s)",
                    "IHok : forall (l0 h0 : Z) (_ : Z.lt l0 h0), ok (add l0 h0 s)"
                ],
                "tactic_res": [
                    "_goal : Z.lt (Z.min l l0) (Z.max h h0)"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [
                    "_goal : Z.lt (Z.min l l0) (Z.max h h0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_remove",
        "proof": [
            {
                "tactic_sig": "induction 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (x l0 h0 : Z) (s : t) (_ : ok s),\niff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff False (and (not (and (Z.le l0 x) (Z.lt x h0))) False)",
                    "_goal : iff\n  (In x\n     (if zlt h l0\n      then Cons l h (remove l0 h0 s)\n      else\n       if zlt h0 l\n       then Cons l h s\n       else\n        if zlt l l0\n        then\n         if zlt h0 h\n         then Cons l l0 (Cons h0 h s)\n         else Cons l l0 (remove l0 h0 s)\n        else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "x : Z",
                    "l0 : Z",
                    "h0 : Z",
                    "IHok : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff False (and (not (and (Z.le l0 x) (Z.lt x h0))) False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt h l0\n      then Cons l h (remove l0 h0 s)\n      else\n       if zlt h0 l\n       then Cons l h s\n       else\n        if zlt l l0\n        then\n         if zlt h0 h\n         then Cons l l0 (Cons h0 h s)\n         else Cons l l0 (remove l0 h0 s)\n        else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (Cons l h (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff\n  (In x\n     (if zlt h0 l\n      then Cons l h s\n      else\n       if zlt l l0\n       then\n        if zlt h0 h\n        then Cons l l0 (Cons h0 h s)\n        else Cons l l0 (remove l0 h0 s)\n       else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt h l0",
                    "g : Z.ge h l0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l h (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "IHok : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "intuition lia .",
                "tactic_sig_no_out_arg": "intuition lia .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt h0 l\n      then Cons l h s\n      else\n       if zlt l l0\n       then\n        if zlt h0 h\n        then Cons l l0 (Cons h0 h s)\n        else Cons l l0 (remove l0 h0 s)\n       else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (Cons l h s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff\n  (In x\n     (if zlt l l0\n      then\n       if zlt h0 h\n       then Cons l l0 (Cons h0 h s)\n       else Cons l l0 (remove l0 h0 s)\n      else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt h0 l",
                    "g0 : Z.ge h0 l"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l h s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H5 : Z.lt x h0",
                    "H4 : Z.le l0 x",
                    "H3 : In x s",
                    "H2 : forall (_ : forall _ : and (Z.le l0 x) (Z.lt x h0), False) (_ : In x s),\nIn x (remove l0 h0 s)",
                    "H0 : forall _ : In x (remove l0 h0 s),\nand (forall _ : and (Z.le l0 x) (Z.lt x h0), False) (In x s)"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt l l0\n      then\n       if zlt h0 h\n       then Cons l l0 (Cons h0 h s)\n       else Cons l l0 (remove l0 h0 s)\n      else if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (In x\n     (if zlt h0 h\n      then Cons l l0 (Cons h0 h s)\n      else Cons l l0 (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff (In x (if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt l l0",
                    "g1 : Z.ge l l0"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) ; simpl as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zlt h0 h\n      then Cons l l0 (Cons h0 h s)\n      else Cons l l0 (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x l0))\n     (or (and (Z.le h0 x) (Z.lt x h)) (In x s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff (or (and (Z.le l x) (Z.lt x l0)) (In x (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l2 : Z.lt h0 h",
                    "g1 : Z.ge h0 h"
                ]
            },
            {
                "tactic_sig": "clear _i .",
                "tactic_sig_no_out_arg": "clear _i .",
                "tactic_args": [
                    "IHok : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x l0))\n     (or (and (Z.le h0 x) (Z.lt x h)) (In x s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : forall\n  _ : or (and (Z.le l x) (Z.lt x l0))\n        (or (and (Z.le h0 x) (Z.lt x h)) (In x s)),\nand (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : forall\n  _ : and (not (and (Z.le l0 x) (Z.lt x h0)))\n        (or (and (Z.le l x) (Z.lt x h)) (In x s)),\nor (and (Z.le l x) (Z.lt x l0))\n  (or (and (Z.le h0 x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ A | [ A | A ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : or (and (Z.le l x) (Z.lt x l0))\n        (or (and (Z.le h0 x) (Z.lt x h)) (In x s)),\nand (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : and (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : and (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : and (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "A : and (Z.le l x) (Z.lt x l0)",
                    "A : and (Z.le h0 x) (Z.lt x h)",
                    "A : In x s"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))",
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [],
                "tactic_res": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))",
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and (not (and (Z.le l0 x) (Z.lt x h0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))",
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : not (and (Z.le l0 x) (Z.lt x h0))",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, not (and (Z.le l0 x) (Z.lt x h0))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, not (and (Z.le l0 x) (Z.lt x h0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x h)) (In x s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros [ A [ B | B ] ] .",
                "tactic_args": [
                    "_goal : forall\n  _ : and (not (and (Z.le l0 x) (Z.lt x h0)))\n        (or (and (Z.le l x) (Z.lt x h)) (In x s)),\nor (and (Z.le l x) (Z.lt x l0))\n  (or (and (Z.le h0 x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l x) (Z.lt x l0))\n  (or (and (Z.le h0 x) (Z.lt x h)) (In x s))",
                    "_goal : or (and (Z.le l x) (Z.lt x l0))\n  (or (and (Z.le h0 x) (Z.lt x h)) (In x s))",
                    "B : and (Z.le l x) (Z.lt x h)",
                    "A : not (and (Z.le l0 x) (Z.lt x h0))",
                    "B : In x s"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "x : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "l3 : Z.lt x l0",
                    "g1 : Z.ge x l0"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "right ; left ; lia .",
                "tactic_sig_no_out_arg": "right ; left ; lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x l0))\n  (or (and (Z.le h0 x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition lia .",
                "tactic_sig_no_out_arg": "intuition lia .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x l0)) (In x (remove l0 h0 s)))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) ; simpl as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff (In x (if zlt h0 h then Cons h0 h s else remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le h0 x) (Z.lt x h)) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "l1 : Z.lt h0 h",
                    "g2 : Z.ge h0 h"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le h0 x) (Z.lt x h)) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : False",
                    "H5 : Z.lt x h0",
                    "H4 : Z.le l0 x",
                    "H3 : In x s",
                    "H2 : forall (_ : forall _ : and (Z.le l0 x) (Z.lt x h0), False) (_ : In x s),\nIn x (remove l0 h0 s)",
                    "H0 : forall _ : In x (remove l0 h0 s),\nand (forall _ : and (Z.le l0 x) (Z.lt x h0), False) (In x s)"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "IHok : iff (In x (remove l0 h0 s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s))\n  (and (not (and (Z.le l0 x) (Z.lt x h0)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "H2 : forall (_ : Z.le l0 x) (_ : Z.lt x h0), False",
                    "H1 : forall _ : In x s, In x (remove l0 h0 s)",
                    "H5 : Z.lt x h",
                    "H4 : Z.le l x",
                    "H0 : forall _ : In x (remove l0 h0 s),\nand (forall _ : and (Z.le l0 x) (Z.lt x h0), False) (In x s)"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "remove_ok",
        "proof": [
            {
                "tactic_sig": "induction 2 ; simpl .",
                "tactic_sig_no_out_arg": "induction 2 ; simpl .",
                "tactic_args": [
                    "_goal : forall (l0 h0 : Z) (_ : Z.lt l0 h0) (s : t) (_ : ok s),\nok (remove l0 h0 s)"
                ],
                "tactic_res": [
                    "_goal : ok Nil",
                    "_goal : ok\n  (if zlt h l0\n   then Cons l h (remove l0 h0 s)\n   else\n    if zlt h0 l\n    then Cons l h s\n    else\n     if zlt l l0\n     then\n      if zlt h0 h\n      then Cons l l0 (Cons h0 h s)\n      else Cons l l0 (remove l0 h0 s)\n     else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "H : Z.lt l0 h0",
                    "l0 : Z",
                    "h0 : Z",
                    "IHok : ok (remove l0 h0 s)",
                    "H0 : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt h l0\n   then Cons l h (remove l0 h0 s)\n   else\n    if zlt h0 l\n    then Cons l h s\n    else\n     if zlt l l0\n     then\n      if zlt h0 h\n      then Cons l l0 (Cons h0 h s)\n      else Cons l l0 (remove l0 h0 s)\n     else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h (remove l0 h0 s))",
                    "_goal : ok\n  (if zlt h0 l\n   then Cons l h s\n   else\n    if zlt l l0\n    then\n     if zlt h0 h\n     then Cons l l0 (Cons h0 h s)\n     else Cons l l0 (remove l0 h0 s)\n    else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "l1 : Z.lt h l0",
                    "g : Z.ge h l0"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h (remove l0 h0 s))"
                ],
                "tactic_res": [
                    "_goal : forall (x : Z) (_ : In x (remove l0 h0 s)), Z.lt h x"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ; apply _i .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (remove l0 h0 s)), Z.lt h x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "H1 : In x (remove l0 h0 s)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_remove in _i ; tauto .",
                "tactic_sig_no_out_arg": "rewrite In_remove in _i ; tauto .",
                "tactic_args": [
                    "_goal : In x s",
                    "H1 : In x (remove l0 h0 s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt h0 l\n   then Cons l h s\n   else\n    if zlt l l0\n    then\n     if zlt h0 h\n     then Cons l l0 (Cons h0 h s)\n     else Cons l l0 (remove l0 h0 s)\n    else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h s)",
                    "_goal : ok\n  (if zlt l l0\n   then\n    if zlt h0 h\n    then Cons l l0 (Cons h0 h s)\n    else Cons l l0 (remove l0 h0 s)\n   else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "l1 : Z.lt h0 l",
                    "g0 : Z.ge h0 l"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt l l0\n   then\n    if zlt h0 h\n    then Cons l l0 (Cons h0 h s)\n    else Cons l l0 (remove l0 h0 s)\n   else if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok\n  (if zlt h0 h\n   then Cons l l0 (Cons h0 h s)\n   else Cons l l0 (remove l0 h0 s))",
                    "_goal : ok (if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "l1 : Z.lt l l0",
                    "g1 : Z.ge l l0"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zlt h0 h\n   then Cons l l0 (Cons h0 h s)\n   else Cons l l0 (remove l0 h0 s))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l l0 (Cons h0 h s))",
                    "_goal : ok (Cons l l0 (remove l0 h0 s))",
                    "l2 : Z.lt h0 h",
                    "g1 : Z.ge h0 h"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l l0 (Cons h0 h s))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l l0",
                    "_goal : forall (x : Z) (_ : In x (Cons h0 h s)), Z.lt l0 x",
                    "_goal : ok (Cons h0 h s)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt l l0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (Cons h0 h s)), Z.lt l0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt l0 x",
                    "H1 : In x (Cons h0 h s)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "inv _i .",
                "tactic_sig_no_out_arg": "inv _i .",
                "tactic_args": [
                    "H1 : In x (Cons h0 h s)"
                ],
                "tactic_res": [
                    "H2 : and (Z.le h0 x) (Z.lt x h)",
                    "H2 : In x s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : Z.lt l0 x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, Z.lt l0 x"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, Z.lt l0 x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons h0 h s)"
                ],
                "tactic_res": [
                    "_goal : Z.lt h0 h",
                    "_goal : forall (x : Z) (_ : In x s), Z.lt h x",
                    "_goal : ok s"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt h0 h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l l0 (remove l0 h0 s))"
                ],
                "tactic_res": [
                    "_goal : forall (x : Z) (_ : In x (remove l0 h0 s)), Z.lt l0 x"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (remove l0 h0 s)), Z.lt l0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt l0 x",
                    "H1 : In x (remove l0 h0 s)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_remove in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite In_remove in _i by auto .",
                "tactic_args": [
                    "H1 : In x (remove l0 h0 s)"
                ],
                "tactic_res": [
                    "H1 : and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s)"
                ]
            },
            {
                "tactic_sig": "destruct _i as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct _i .",
                "tactic_args": [
                    "H1 : and (not (and (Z.le l0 x) (Z.lt x h0))) (In x s)"
                ],
                "tactic_res": [
                    "H2 : In x s",
                    "H1 : not (and (Z.le l0 x) (Z.lt x h0))"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : Z.lt l0 x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, Z.lt l0 x"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, Z.lt l0 x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : ok (if zlt h0 h then Cons h0 h s else remove l0 h0 s)",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons h0 h s)",
                    "_goal : ok (remove l0 h0 s)",
                    "l1 : Z.lt h0 h",
                    "g2 : Z.ge h0 h"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons h0 h s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok (remove l0 h0 s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_inter",
        "proof": [
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s1 : t) (_ : ok s1) (s2 : t) (_ : ok s2),\niff (In x (inter s1 s2)) (and (In x s1) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x (inter Nil s2)) (and (In x Nil) (In x s2))",
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x (inter (Cons l h s) s2)) (and (In x (Cons l h s)) (In x s2))",
                    "x : Z",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (In x (inter s s2)) (and (In x s) (In x s2))",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x (inter Nil s2)) (and (In x Nil) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x ((fix intr (s0 : t) : t := Nil) s2)) (and False (In x s2))"
                ]
            },
            {
                "tactic_sig": "induction 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x ((fix intr (s0 : t) : t := Nil) s2)) (and False (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff False (and False False)",
                    "_goal : iff False (and False (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "IHok : iff (In x ((fix intr (s2 : t) : t := Nil) s)) (and False (In x s))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff False (and False False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff False (and False (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( ok ( Cons _i _i _i ) ) by ( constructor ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( ok ( Cons _i _i _i ) ) by ( constructor ; auto ) .",
                "tactic_args": [
                    "l : Z",
                    "h : Z",
                    "s : True"
                ],
                "tactic_res": [
                    "H0 : ok (Cons l h s)"
                ]
            },
            {
                "tactic_sig": "induction 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (s2 : t) (_ : ok s2),\niff (In x (inter (Cons l h s) s2)) (and (In x (Cons l h s)) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff False (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)",
                    "_goal : iff\n  (In x\n     (if zle h l0\n      then inter s (Cons l0 h0 s0)\n      else\n       if zle h0 l\n       then\n        (fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0\n       else\n        if zle l l0\n        then\n         if zle h0 h\n         then\n          Cons l0 h0\n            ((fix intr (s2 : t) : t :=\n                match s2 with\n                | Nil => Nil\n                | Cons l2 h2 s2' =>\n                    if zle h l2\n                    then inter s s2\n                    else\n                     if zle h2 l\n                     then intr s2'\n                     else\n                      if zle l l2\n                      then\n                       if zle h2 h\n                       then Cons l2 h2 (intr s2')\n                       else Cons l2 h (inter s s2)\n                      else\n                       if zle h h2\n                       then Cons l h (inter s s2)\n                       else Cons l h2 (intr s2')\n                end) s0)\n         else Cons l0 h (inter s (Cons l0 h0 s0))\n        else\n         if zle h h0\n         then Cons l h (inter s (Cons l0 h0 s0))\n         else\n          Cons l h0\n            ((fix intr (s2 : t) : t :=\n                match s2 with\n                | Nil => Nil\n                | Cons l2 h2 s2' =>\n                    if zle h l2\n                    then inter s s2\n                    else\n                     if zle h2 l\n                     then intr s2'\n                     else\n                      if zle l l2\n                      then\n                       if zle h2 h\n                       then Cons l2 h2 (intr s2')\n                       else Cons l2 h (inter s s2)\n                      else\n                       if zle h h2\n                       then Cons l h (inter s s2)\n                       else Cons l h2 (intr s2')\n                end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))",
                    "H1 : ok s0",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x",
                    "BOUNDS0 : Z.lt l0 h0",
                    "s0 : True",
                    "l0 : Z",
                    "h0 : Z"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff False (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( ok ( Cons _i _i _i ) ) by ( constructor ; auto ) .",
                "tactic_sig_no_out_arg": "assert ( ok ( Cons _i _i _i ) ) by ( constructor ; auto ) .",
                "tactic_args": [
                    "l0 : Z",
                    "h0 : Z",
                    "s0 : True"
                ],
                "tactic_res": [
                    "H2 : ok (Cons l0 h0 s0)"
                ]
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zle h l0\n      then inter s (Cons l0 h0 s0)\n      else\n       if zle h0 l\n       then\n        (fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0\n       else\n        if zle l l0\n        then\n         if zle h0 h\n         then\n          Cons l0 h0\n            ((fix intr (s2 : t) : t :=\n                match s2 with\n                | Nil => Nil\n                | Cons l2 h2 s2' =>\n                    if zle h l2\n                    then inter s s2\n                    else\n                     if zle h2 l\n                     then intr s2'\n                     else\n                      if zle l l2\n                      then\n                       if zle h2 h\n                       then Cons l2 h2 (intr s2')\n                       else Cons l2 h (inter s s2)\n                      else\n                       if zle h h2\n                       then Cons l h (inter s s2)\n                       else Cons l h2 (intr s2')\n                end) s0)\n         else Cons l0 h (inter s (Cons l0 h0 s0))\n        else\n         if zle h h0\n         then Cons l h (inter s (Cons l0 h0 s0))\n         else\n          Cons l h0\n            ((fix intr (s2 : t) : t :=\n                match s2 with\n                | Nil => Nil\n                | Cons l2 h2 s2' =>\n                    if zle h l2\n                    then inter s s2\n                    else\n                     if zle h2 l\n                     then intr s2'\n                     else\n                      if zle l l2\n                      then\n                       if zle h2 h\n                       then Cons l2 h2 (intr s2')\n                       else Cons l2 h (inter s s2)\n                      else\n                       if zle h h2\n                       then Cons l h (inter s s2)\n                       else Cons l h2 (intr s2')\n                end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (inter s (Cons l0 h0 s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "_goal : iff\n  (In x\n     (if zle h0 l\n      then\n       (fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0\n      else\n       if zle l l0\n       then\n        if zle h0 h\n        then\n         Cons l0 h0\n           ((fix intr (s2 : t) : t :=\n               match s2 with\n               | Nil => Nil\n               | Cons l2 h2 s2' =>\n                   if zle h l2\n                   then inter s s2\n                   else\n                    if zle h2 l\n                    then intr s2'\n                    else\n                     if zle l l2\n                     then\n                      if zle h2 h\n                      then Cons l2 h2 (intr s2')\n                      else Cons l2 h (inter s s2)\n                     else\n                      if zle h h2\n                      then Cons l h (inter s s2)\n                      else Cons l h2 (intr s2')\n               end) s0)\n        else Cons l0 h (inter s (Cons l0 h0 s0))\n       else\n        if zle h h0\n        then Cons l h (inter s (Cons l0 h0 s0))\n        else\n         Cons l h0\n           ((fix intr (s2 : t) : t :=\n               match s2 with\n               | Nil => Nil\n               | Cons l2 h2 s2' =>\n                   if zle h l2\n                   then inter s s2\n                   else\n                    if zle h2 l\n                    then intr s2'\n                    else\n                     if zle l l2\n                     then\n                      if zle h2 h\n                      then Cons l2 h2 (intr s2')\n                      else Cons l2 h (inter s s2)\n                     else\n                      if zle h h2\n                      then Cons l h (inter s s2)\n                      else Cons l h2 (intr s2')\n               end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l1 : Z.le h l0",
                    "g : Z.gt h l0"
                ]
            },
            {
                "tactic_sig": "rewrite _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite _i ; auto .",
                "tactic_args": [
                    "_goal : iff (In x (inter s (Cons l0 h0 s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (In x (inter s s2)) (and (In x s) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff (and (In x s) (In x (Cons l0 h0 s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (and (In x s) (In x (Cons l0 h0 s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "_goal : In x s",
                    "H9 : Z.lt x h0",
                    "H7 : Z.le l0 x",
                    "H8 : Z.lt x h",
                    "H6 : Z.le l x",
                    "H5 : forall (_ : In x (Cons l h s)) (_ : In x s0),\nIn x (inter (Cons l h s) s0)",
                    "H3 : forall _ : In x (inter (Cons l h s) s0),\nand (In x (Cons l h s)) (In x s0)",
                    "H4 : In x s0"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : In x s",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 x, In x s"
                ]
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 x, In x s"
                ],
                "tactic_res": [
                    "_goal : In x s",
                    "H7 : Z.lt h0 x"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zle h0 l\n      then\n       (fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0\n      else\n       if zle l l0\n       then\n        if zle h0 h\n        then\n         Cons l0 h0\n           ((fix intr (s2 : t) : t :=\n               match s2 with\n               | Nil => Nil\n               | Cons l2 h2 s2' =>\n                   if zle h l2\n                   then inter s s2\n                   else\n                    if zle h2 l\n                    then intr s2'\n                    else\n                     if zle l l2\n                     then\n                      if zle h2 h\n                      then Cons l2 h2 (intr s2')\n                      else Cons l2 h (inter s s2)\n                     else\n                      if zle h h2\n                      then Cons l h (inter s s2)\n                      else Cons l h2 (intr s2')\n               end) s0)\n        else Cons l0 h (inter s (Cons l0 h0 s0))\n       else\n        if zle h h0\n        then Cons l h (inter s (Cons l0 h0 s0))\n        else\n         Cons l h0\n           ((fix intr (s2 : t) : t :=\n               match s2 with\n               | Nil => Nil\n               | Cons l2 h2 s2' =>\n                   if zle h l2\n                   then inter s s2\n                   else\n                    if zle h2 l\n                    then intr s2'\n                    else\n                     if zle l l2\n                     then\n                      if zle h2 h\n                      then Cons l2 h2 (intr s2')\n                      else Cons l2 h (inter s s2)\n                     else\n                      if zle h h2\n                      then Cons l h (inter s s2)\n                      else Cons l h2 (intr s2')\n               end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (In x\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "_goal : iff\n  (In x\n     (if zle l l0\n      then\n       if zle h0 h\n       then\n        Cons l0 h0\n          ((fix intr (s2 : t) : t :=\n              match s2 with\n              | Nil => Nil\n              | Cons l2 h2 s2' =>\n                  if zle h l2\n                  then inter s s2\n                  else\n                   if zle h2 l\n                   then intr s2'\n                   else\n                    if zle l l2\n                    then\n                     if zle h2 h\n                     then Cons l2 h2 (intr s2')\n                     else Cons l2 h (inter s s2)\n                    else\n                     if zle h h2\n                     then Cons l h (inter s s2)\n                     else Cons l h2 (intr s2')\n              end) s0)\n       else Cons l0 h (inter s (Cons l0 h0 s0))\n      else\n       if zle h h0\n       then Cons l h (inter s (Cons l0 h0 s0))\n       else\n        Cons l h0\n          ((fix intr (s2 : t) : t :=\n              match s2 with\n              | Nil => Nil\n              | Cons l2 h2 s2' =>\n                  if zle h l2\n                  then inter s s2\n                  else\n                   if zle h2 l\n                   then intr s2'\n                   else\n                    if zle l l2\n                    then\n                     if zle h2 h\n                     then Cons l2 h2 (intr s2')\n                     else Cons l2 h (inter s s2)\n                    else\n                     if zle h h2\n                     then Cons l h (inter s s2)\n                     else Cons l h2 (intr s2')\n              end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l1 : Z.le h0 l",
                    "g0 : Z.gt h0 l"
                ]
            },
            {
                "tactic_sig": "simpl in _i ; rewrite _i .",
                "tactic_sig_no_out_arg": "simpl in _i ; rewrite _i .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))"
                ],
                "tactic_res": [
                    "_goal : iff (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff\n  (In x\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : In x s0",
                    "_goal : In x s0",
                    "H5 : forall _ : In x s0,\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "H10 : Z.lt x h0",
                    "H8 : Z.le l0 x",
                    "H9 : Z.lt x h",
                    "H7 : Z.le l x",
                    "H6 : forall (_ : In x s) (_ : In x s0),\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "H3 : forall\n  _ : In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0),\nand (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)",
                    "H7 : forall _ : In x s0,\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "H9 : Z.lt x h0",
                    "H4 : In x s",
                    "H5 : forall (_ : Z.le l x) (_ : Z.lt x h) (_ : In x s0),\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : In x s0",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x, In x s0"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros ; extlia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x, In x s0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zle l l0\n      then\n       if zle h0 h\n       then\n        Cons l0 h0\n          ((fix intr (s2 : t) : t :=\n              match s2 with\n              | Nil => Nil\n              | Cons l2 h2 s2' =>\n                  if zle h l2\n                  then inter s s2\n                  else\n                   if zle h2 l\n                   then intr s2'\n                   else\n                    if zle l l2\n                    then\n                     if zle h2 h\n                     then Cons l2 h2 (intr s2')\n                     else Cons l2 h (inter s s2)\n                    else\n                     if zle h h2\n                     then Cons l h (inter s s2)\n                     else Cons l h2 (intr s2')\n              end) s0)\n       else Cons l0 h (inter s (Cons l0 h0 s0))\n      else\n       if zle h h0\n       then Cons l h (inter s (Cons l0 h0 s0))\n       else\n        Cons l h0\n          ((fix intr (s2 : t) : t :=\n              match s2 with\n              | Nil => Nil\n              | Cons l2 h2 s2' =>\n                  if zle h l2\n                  then inter s s2\n                  else\n                   if zle h2 l\n                   then intr s2'\n                   else\n                    if zle l l2\n                    then\n                     if zle h2 h\n                     then Cons l2 h2 (intr s2')\n                     else Cons l2 h (inter s s2)\n                    else\n                     if zle h h2\n                     then Cons l h (inter s s2)\n                     else Cons l h2 (intr s2')\n              end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (In x\n     (if zle h0 h\n      then\n       Cons l0 h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)\n      else Cons l0 h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "_goal : iff\n  (In x\n     (if zle h h0\n      then Cons l h (inter s (Cons l0 h0 s0))\n      else\n       Cons l h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l1 : Z.le l l0",
                    "g1 : Z.gt l l0"
                ]
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zle h0 h\n      then\n       Cons l0 h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)\n      else Cons l0 h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (In x\n     (Cons l0 h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "_goal : iff (In x (Cons l0 h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l2 : Z.le h0 h",
                    "g1 : Z.gt h0 h"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (Cons l0 h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i ; rewrite _i .",
                "tactic_sig_no_out_arg": "simpl in _i ; rewrite _i .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff\n  (In x\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h0))\n     (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l0 h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h)) (In x (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite _i ; auto .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h)) (In x (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (In x (inter s s2)) (and (In x s) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h))\n     (and (In x s) (In x (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h))\n     (and (In x s) (In x (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h))\n     (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l0 x) (Z.lt x h))\n     (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l0 x) (Z.lt x h))\n  (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "H4 : In x s0",
                    "H8 : Z.lt x h",
                    "H6 : Z.le l x",
                    "H5 : forall (_ : In x (Cons l h s)) (_ : In x s0),\nIn x (inter (Cons l h s) s0)",
                    "H3 : forall _ : In x (inter (Cons l h s) s0),\nand (In x (Cons l h s)) (In x s0)"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : or (and (Z.le l0 x) (Z.lt x h))\n  (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 x,\nor (and (Z.le l0 x) (Z.lt x h))\n  (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros ; extlia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 x,\nor (and (Z.le l0 x) (Z.lt x h))\n  (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (if zle h h0\n      then Cons l h (inter s (Cons l0 h0 s0))\n      else\n       Cons l h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "h : Z",
                    "h0 : Z"
                ],
                "tactic_res": [
                    "_goal : iff (In x (Cons l h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "_goal : iff\n  (In x\n     (Cons l h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "l1 : Z.le h h0",
                    "g2 : Z.gt h h0"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff (In x (Cons l h (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "rewrite _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite _i ; auto .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x (inter s (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (In x (inter s s2)) (and (In x s) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h)) (and (In x s) (In x (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h)) (and (In x s) (In x (Cons l0 h0 s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h))\n     (and (In x s) (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (In x\n     (Cons l h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h0))\n     (In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ]
            },
            {
                "tactic_sig": "simpl in _i ; rewrite _i .",
                "tactic_sig_no_out_arg": "simpl in _i ; rewrite _i .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h0))\n     (In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))",
                    "IHok0 : iff (In x (inter (Cons l h s) s0)) (and (In x (Cons l h s)) (In x s0))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h0))\n     (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "IHok0 : iff\n  (In x\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff\n  (or (and (Z.le l x) (Z.lt x h0))\n     (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l x) (Z.lt x h0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))",
                    "H7 : forall _ : In x s0,\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "H9 : Z.lt x h0",
                    "H8 : Z.le l0 x",
                    "H4 : In x s",
                    "H5 : forall (_ : Z.le l x) (_ : Z.lt x h) (_ : In x s0),\nIn x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "H3 : forall\n  _ : In x\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0),\nand (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0)"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : or (and (Z.le l x) (Z.lt x h0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h x,\nor (and (Z.le l x) (Z.lt x h0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "intros .",
                "tactic_sig_no_out_arg": "intros ; extlia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h x,\nor (and (Z.le l x) (Z.lt x h0))\n  (and (or (and (Z.le l x) (Z.lt x h)) (In x s)) (In x s0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "inter_ok",
        "proof": [
            {
                "tactic_sig": "induction 1 .",
                "tactic_sig_no_out_arg": "induction 1 .",
                "tactic_args": [
                    "_goal : forall (s1 : t) (_ : ok s1) (s2 : t) (_ : ok s2), ok (inter s1 s2)"
                ],
                "tactic_res": [
                    "_goal : forall (s2 : t) (_ : ok s2), ok (inter Nil s2)",
                    "_goal : forall (s2 : t) (_ : ok s2), ok (inter (Cons l h s) s2)",
                    "IHok : forall (s2 : t) (_ : ok s2), ok (inter s s2)",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros ; simpl .",
                "tactic_args": [
                    "_goal : forall (s2 : t) (_ : ok s2), ok (inter Nil s2)"
                ],
                "tactic_res": [
                    "_goal : ok ((fix intr (s2 : t) : t := Nil) s2)",
                    "H : ok s2",
                    "s2 : True"
                ]
            },
            {
                "tactic_sig": "destruct _i ; constructor as ] .",
                "tactic_sig_no_out_arg": "destruct _i ; constructor .",
                "tactic_args": [
                    "_goal : ok ((fix intr (s2 : t) : t := Nil) s2)",
                    "s2 : True"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( ok ( Cons _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( ok ( Cons _i _i _i ) ) .",
                "tactic_args": [
                    "l : Z",
                    "h : Z",
                    "s : True"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h s)",
                    "H0 : ok (Cons l h s)"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "induction 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (s2 : t) (_ : ok s2), ok (inter (Cons l h s) s2)"
                ],
                "tactic_res": [
                    "_goal : ok Nil",
                    "_goal : ok\n  (if zle h l0\n   then inter s (Cons l0 h0 s0)\n   else\n    if zle h0 l\n    then\n     (fix intr (s2 : t) : t :=\n        match s2 with\n        | Nil => Nil\n        | Cons l2 h2 s2' =>\n            if zle h l2\n            then inter s s2\n            else\n             if zle h2 l\n             then intr s2'\n             else\n              if zle l l2\n              then\n               if zle h2 h\n               then Cons l2 h2 (intr s2')\n               else Cons l2 h (inter s s2)\n              else\n               if zle h h2\n               then Cons l h (inter s s2)\n               else Cons l h2 (intr s2')\n        end) s0\n    else\n     if zle l l0\n     then\n      if zle h0 h\n      then\n       Cons l0 h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)\n      else Cons l0 h (inter s (Cons l0 h0 s0))\n     else\n      if zle h h0\n      then Cons l h (inter s (Cons l0 h0 s0))\n      else\n       Cons l h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0))",
                    "IHok0 : ok (inter (Cons l h s) s0)",
                    "H1 : ok s0",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x",
                    "BOUNDS0 : Z.lt l0 h0",
                    "s0 : True",
                    "l0 : Z",
                    "h0 : Z"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "assert ( ok ( Cons _i _i _i ) ) .",
                "tactic_sig_no_out_arg": "assert ( ok ( Cons _i _i _i ) ) .",
                "tactic_args": [
                    "l0 : Z",
                    "h0 : Z",
                    "s0 : True"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l0 h0 s0)",
                    "H2 : ok (Cons l0 h0 s0)"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l0 h0 s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zle h l0\n   then inter s (Cons l0 h0 s0)\n   else\n    if zle h0 l\n    then\n     (fix intr (s2 : t) : t :=\n        match s2 with\n        | Nil => Nil\n        | Cons l2 h2 s2' =>\n            if zle h l2\n            then inter s s2\n            else\n             if zle h2 l\n             then intr s2'\n             else\n              if zle l l2\n              then\n               if zle h2 h\n               then Cons l2 h2 (intr s2')\n               else Cons l2 h (inter s s2)\n              else\n               if zle h h2\n               then Cons l h (inter s s2)\n               else Cons l h2 (intr s2')\n        end) s0\n    else\n     if zle l l0\n     then\n      if zle h0 h\n      then\n       Cons l0 h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)\n      else Cons l0 h (inter s (Cons l0 h0 s0))\n     else\n      if zle h h0\n      then Cons l h (inter s (Cons l0 h0 s0))\n      else\n       Cons l h0\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0))",
                    "h : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok (inter s (Cons l0 h0 s0))",
                    "_goal : ok\n  (if zle h0 l\n   then\n    (fix intr (s2 : t) : t :=\n       match s2 with\n       | Nil => Nil\n       | Cons l2 h2 s2' =>\n           if zle h l2\n           then inter s s2\n           else\n            if zle h2 l\n            then intr s2'\n            else\n             if zle l l2\n             then\n              if zle h2 h\n              then Cons l2 h2 (intr s2')\n              else Cons l2 h (inter s s2)\n             else\n              if zle h h2\n              then Cons l h (inter s s2)\n              else Cons l h2 (intr s2')\n       end) s0\n   else\n    if zle l l0\n    then\n     if zle h0 h\n     then\n      Cons l0 h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)\n     else Cons l0 h (inter s (Cons l0 h0 s0))\n    else\n     if zle h h0\n     then Cons l h (inter s (Cons l0 h0 s0))\n     else\n      Cons l h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0))",
                    "l1 : Z.le h l0",
                    "g : Z.gt h l0"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok (inter s (Cons l0 h0 s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zle h0 l\n   then\n    (fix intr (s2 : t) : t :=\n       match s2 with\n       | Nil => Nil\n       | Cons l2 h2 s2' =>\n           if zle h l2\n           then inter s s2\n           else\n            if zle h2 l\n            then intr s2'\n            else\n             if zle l l2\n             then\n              if zle h2 h\n              then Cons l2 h2 (intr s2')\n              else Cons l2 h (inter s s2)\n             else\n              if zle h h2\n              then Cons l h (inter s s2)\n              else Cons l h2 (intr s2')\n       end) s0\n   else\n    if zle l l0\n    then\n     if zle h0 h\n     then\n      Cons l0 h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0)\n     else Cons l0 h (inter s (Cons l0 h0 s0))\n    else\n     if zle h h0\n     then Cons l h (inter s (Cons l0 h0 s0))\n     else\n      Cons l h0\n        ((fix intr (s2 : t) : t :=\n            match s2 with\n            | Nil => Nil\n            | Cons l2 h2 s2' =>\n                if zle h l2\n                then inter s s2\n                else\n                 if zle h2 l\n                 then intr s2'\n                 else\n                  if zle l l2\n                  then\n                   if zle h2 h\n                   then Cons l2 h2 (intr s2')\n                   else Cons l2 h (inter s s2)\n                  else\n                   if zle h h2\n                   then Cons l h (inter s s2)\n                   else Cons l h2 (intr s2')\n            end) s0))",
                    "h0 : Z",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : ok\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "_goal : ok\n  (if zle l l0\n   then\n    if zle h0 h\n    then\n     Cons l0 h0\n       ((fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0)\n    else Cons l0 h (inter s (Cons l0 h0 s0))\n   else\n    if zle h h0\n    then Cons l h (inter s (Cons l0 h0 s0))\n    else\n     Cons l h0\n       ((fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0))",
                    "l1 : Z.le h0 l",
                    "g0 : Z.gt h0 l"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zle l l0\n   then\n    if zle h0 h\n    then\n     Cons l0 h0\n       ((fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0)\n    else Cons l0 h (inter s (Cons l0 h0 s0))\n   else\n    if zle h h0\n    then Cons l h (inter s (Cons l0 h0 s0))\n    else\n     Cons l h0\n       ((fix intr (s2 : t) : t :=\n           match s2 with\n           | Nil => Nil\n           | Cons l2 h2 s2' =>\n               if zle h l2\n               then inter s s2\n               else\n                if zle h2 l\n                then intr s2'\n                else\n                 if zle l l2\n                 then\n                  if zle h2 h\n                  then Cons l2 h2 (intr s2')\n                  else Cons l2 h (inter s s2)\n                 else\n                  if zle h h2\n                  then Cons l h (inter s s2)\n                  else Cons l h2 (intr s2')\n           end) s0))",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok\n  (if zle h0 h\n   then\n    Cons l0 h0\n      ((fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0)\n   else Cons l0 h (inter s (Cons l0 h0 s0)))",
                    "_goal : ok\n  (if zle h h0\n   then Cons l h (inter s (Cons l0 h0 s0))\n   else\n    Cons l h0\n      ((fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0))",
                    "l1 : Z.le l l0",
                    "g1 : Z.gt l l0"
                ]
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zle h0 h\n   then\n    Cons l0 h0\n      ((fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0)\n   else Cons l0 h (inter s (Cons l0 h0 s0)))",
                    "h0 : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : ok\n  (Cons l0 h0\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))",
                    "_goal : ok (Cons l0 h (inter s (Cons l0 h0 s0)))",
                    "l2 : Z.le h0 h",
                    "g1 : Z.gt h0 h"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok\n  (Cons l0 h0\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))"
                ],
                "tactic_res": [
                    "_goal : forall (x : Z)\n  (_ : In x\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)), Z.lt h0 x"
                ]
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z)\n  (_ : In x\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h0 x",
                    "H3 : In x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "assert ( In _i ( inter ( Cons _i _i _i ) _i ) ) by exact _i .",
                "tactic_sig_no_out_arg": "assert ( In _i ( inter ( Cons _i _i _i ) _i ) ) by exact _i .",
                "tactic_args": [
                    "x : Z",
                    "l : Z",
                    "h : Z",
                    "s : True",
                    "s0 : True",
                    "H3 : In x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ],
                "tactic_res": [
                    "H4 : In x (inter (Cons l h s) s0)"
                ]
            },
            {
                "tactic_sig": "rewrite In_inter in _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite In_inter in _i ; auto .",
                "tactic_args": [
                    "H4 : In x (inter (Cons l h s) s0)"
                ],
                "tactic_res": [
                    "H4 : and (In x (Cons l h s)) (In x s0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Z.lt h0 x",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : In x s0"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : In x s0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l0 h (inter s (Cons l0 h0 s0)))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l0 h",
                    "_goal : forall (x : Z) (_ : In x (inter s (Cons l0 h0 s0))), Z.lt h x",
                    "_goal : ok (inter s (Cons l0 h0 s0))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt l0 h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (inter s (Cons l0 h0 s0))), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h x",
                    "H3 : In x (inter s (Cons l0 h0 s0))",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_inter in _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite In_inter in _i ; auto .",
                "tactic_args": [
                    "H3 : In x (inter s (Cons l0 h0 s0))"
                ],
                "tactic_res": [
                    "H3 : and (In x s) (In x (Cons l0 h0 s0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Z.lt h x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : In x s"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok (inter s (Cons l0 h0 s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zle _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zle _i _i ) .",
                "tactic_args": [
                    "_goal : ok\n  (if zle h h0\n   then Cons l h (inter s (Cons l0 h0 s0))\n   else\n    Cons l h0\n      ((fix intr (s2 : t) : t :=\n          match s2 with\n          | Nil => Nil\n          | Cons l2 h2 s2' =>\n              if zle h l2\n              then inter s s2\n              else\n               if zle h2 l\n               then intr s2'\n               else\n                if zle l l2\n                then\n                 if zle h2 h\n                 then Cons l2 h2 (intr s2')\n                 else Cons l2 h (inter s s2)\n                else\n                 if zle h h2\n                 then Cons l h (inter s s2)\n                 else Cons l h2 (intr s2')\n          end) s0))",
                    "h : Z",
                    "h0 : Z"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h (inter s (Cons l0 h0 s0)))",
                    "_goal : ok\n  (Cons l h0\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))",
                    "l1 : Z.le h h0",
                    "g2 : Z.gt h h0"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok (Cons l h (inter s (Cons l0 h0 s0)))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l h",
                    "_goal : forall (x : Z) (_ : In x (inter s (Cons l0 h0 s0))), Z.lt h x",
                    "_goal : ok (inter s (Cons l0 h0 s0))"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt l h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : In x (inter s (Cons l0 h0 s0))), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h x",
                    "H3 : In x (inter s (Cons l0 h0 s0))",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_inter in _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite In_inter in _i ; auto .",
                "tactic_args": [
                    "H3 : In x (inter s (Cons l0 h0 s0))"
                ],
                "tactic_res": [
                    "H3 : and (In x s) (In x (Cons l0 h0 s0))"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Z.lt h x",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : In x s"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok (inter s (Cons l0 h0 s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok\n  (Cons l h0\n     ((fix intr (s2 : t) : t :=\n         match s2 with\n         | Nil => Nil\n         | Cons l2 h2 s2' =>\n             if zle h l2\n             then inter s s2\n             else\n              if zle h2 l\n              then intr s2'\n              else\n               if zle l l2\n               then\n                if zle h2 h\n                then Cons l2 h2 (intr s2')\n                else Cons l2 h (inter s s2)\n               else\n                if zle h h2\n                then Cons l h (inter s s2)\n                else Cons l h2 (intr s2')\n         end) s0))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l h0",
                    "_goal : forall (x : Z)\n  (_ : In x\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)), Z.lt h0 x",
                    "_goal : ok\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : Z.lt l h0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall (x : Z)\n  (_ : In x\n         ((fix intr (s2 : t) : t :=\n             match s2 with\n             | Nil => Nil\n             | Cons l2 h2 s2' =>\n                 if zle h l2\n                 then inter s s2\n                 else\n                  if zle h2 l\n                  then intr s2'\n                  else\n                   if zle l l2\n                   then\n                    if zle h2 h\n                    then Cons l2 h2 (intr s2')\n                    else Cons l2 h (inter s s2)\n                   else\n                    if zle h h2\n                    then Cons l h (inter s s2)\n                    else Cons l h2 (intr s2')\n             end) s0)), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : Z.lt h0 x",
                    "H3 : In x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "assert ( In _i ( inter ( Cons _i _i _i ) _i ) ) by exact _i .",
                "tactic_sig_no_out_arg": "assert ( In _i ( inter ( Cons _i _i _i ) _i ) ) by exact _i .",
                "tactic_args": [
                    "x : Z",
                    "l : Z",
                    "h : Z",
                    "s : True",
                    "s0 : True",
                    "H3 : In x\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ],
                "tactic_res": [
                    "H4 : In x (inter (Cons l h s) s0)"
                ]
            },
            {
                "tactic_sig": "rewrite In_inter in _i ; auto .",
                "tactic_sig_no_out_arg": "rewrite In_inter in _i ; auto .",
                "tactic_args": [
                    "H4 : In x (inter (Cons l h s) s0)"
                ],
                "tactic_res": [
                    "H4 : and (In x (Cons l h s)) (In x s0)"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : Z.lt h0 x",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : In x s0"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : In x s0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok\n  ((fix intr (s2 : t) : t :=\n      match s2 with\n      | Nil => Nil\n      | Cons l2 h2 s2' =>\n          if zle h l2\n          then inter s s2\n          else\n           if zle h2 l\n           then intr s2'\n           else\n            if zle l l2\n            then\n             if zle h2 h\n             then Cons l2 h2 (intr s2')\n             else Cons l2 h (inter s s2)\n            else\n             if zle h h2\n             then Cons l h (inter s s2)\n             else Cons l h2 (intr s2')\n      end) s0)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_ok_union",
        "proof": [
            {
                "tactic_sig": "induction 1 ; destruct 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; destruct 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (s1 : t) (_ : ok s1) (s2 : t) (_ : ok s2),\nand (ok (union s1 s2))\n  (forall x : Z, iff (or (In x s1) (In x s2)) (In x (union s1 s2)))"
                ],
                "tactic_res": [
                    "_goal : and (ok Nil) (forall _ : Z, iff (or False False) False)",
                    "_goal : and (ok (Cons l h s))\n  (forall x : Z,\n   iff (or False (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : and (ok (Cons l h s))\n  (forall x : Z,\n   iff (or (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : and (ok (add l h (add l0 h0 (union s s0))))\n  (forall x : Z,\n   iff\n     (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n        (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n     (In x (add l h (add l0 h0 (union s s0)))))",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z",
                    "IHok : forall (s2 : t) (_ : ok s2),\nand (ok (union s s2))\n  (forall x : Z, iff (or (In x s) (In x s2)) (In x (union s s2)))",
                    "H0 : ok s0",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x",
                    "BOUNDS0 : Z.lt l0 h0",
                    "s0 : True",
                    "l0 : Z",
                    "h0 : Z"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and (ok Nil) (forall _ : Z, iff (or False False) False)"
                ],
                "tactic_res": [
                    "_goal : ok Nil",
                    "_goal : forall _ : Z, iff (or False False) False"
                ]
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : forall _ : Z, iff (or False False) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and (ok (Cons l h s))\n  (forall x : Z,\n   iff (or False (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h s)",
                    "_goal : forall x : Z,\niff (or False (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : forall x : Z,\niff (or False (or (and (Z.le l x) (Z.lt x h)) (In x s)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and (ok (Cons l h s))\n  (forall x : Z,\n   iff (or (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)\n     (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : ok (Cons l h s)",
                    "_goal : forall x : Z,\niff (or (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : ok (Cons l h s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : forall x : Z,\niff (or (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)\n  (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( _i _i ) as [ A B ] ; auto .",
                "tactic_sig_no_out_arg": "destruct ( _i _i ) as [ A B ] ; auto .",
                "tactic_args": [
                    "IHok : forall (s2 : t) (_ : ok s2),\nand (ok (union s s2))\n  (forall x : Z, iff (or (In x s) (In x s2)) (In x (union s s2)))",
                    "s0 : True"
                ],
                "tactic_res": [
                    "B : forall x : Z, iff (or (In x s) (In x s0)) (In x (union s s0))",
                    "A : ok (union s s0)"
                ]
            },
            {
                "tactic_sig": "split .",
                "tactic_sig_no_out_arg": "split .",
                "tactic_args": [
                    "_goal : and (ok (add l h (add l0 h0 (union s s0))))\n  (forall x : Z,\n   iff\n     (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n        (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n     (In x (add l h (add l0 h0 (union s s0)))))"
                ],
                "tactic_res": [
                    "_goal : ok (add l h (add l0 h0 (union s s0)))",
                    "_goal : forall x : Z,\niff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (In x (add l h (add l0 h0 (union s s0))))"
                ]
            },
            {
                "tactic_sig": "apply add_ok ; auto .",
                "tactic_sig_no_out_arg": "apply add_ok ; auto .",
                "tactic_args": [
                    "_goal : ok (add l h (add l0 h0 (union s s0)))"
                ],
                "tactic_res": [
                    "_goal : ok (add l0 h0 (union s s0))"
                ]
            },
            {
                "tactic_sig": "apply add_ok ; auto .",
                "tactic_sig_no_out_arg": "apply add_ok ; auto .",
                "tactic_args": [
                    "_goal : ok (add l0 h0 (union s s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x : Z,\niff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (In x (add l h (add l0 h0 (union s s0))))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (In x (add l h (add l0 h0 (union s s0))))",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "rewrite In_add .",
                "tactic_sig_no_out_arg": "rewrite In_add .",
                "tactic_args": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (In x (add l h (add l0 h0 (union s s0))))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x (add l0 h0 (union s s0))))",
                    "_goal : ok (add l0 h0 (union s s0))"
                ]
            },
            {
                "tactic_sig": "rewrite In_add .",
                "tactic_sig_no_out_arg": "rewrite In_add .",
                "tactic_args": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h)) (In x (add l0 h0 (union s s0))))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x (union s s0))))",
                    "_goal : ok (union s s0)"
                ]
            },
            {
                "tactic_sig": "rewrite <- _i .",
                "tactic_sig_no_out_arg": "rewrite <- _i .",
                "tactic_args": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x (union s s0))))",
                    "B : forall x : Z, iff (or (In x s) (In x s0)) (In x (union s s0))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (or (In x s) (In x s0))))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff\n  (or (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))\n  (or (and (Z.le l x) (Z.lt x h))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (or (In x s) (In x s0))))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok (union s s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply add_ok ; auto .",
                "tactic_sig_no_out_arg": "apply add_ok ; auto .",
                "tactic_args": [
                    "_goal : ok (add l0 h0 (union s s0))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "beq_spec",
        "proof": [
            {
                "tactic_sig": "induction 1 ; destruct 1 ; simpl .",
                "tactic_sig_no_out_arg": "induction 1 ; destruct 1 ; simpl .",
                "tactic_args": [
                    "_goal : forall (s1 : t) (_ : ok s1) (s2 : t) (_ : ok s2),\niff (eq (beq s1 s2) true) (forall x : Z, iff (In x s1) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff (eq true true) (forall _ : Z, iff False False)",
                    "_goal : iff (eq false true)\n  (forall x : Z, iff False (or (and (Z.le l x) (Z.lt x h)) (In x s)))",
                    "_goal : iff (eq false true)\n  (forall x : Z, iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)",
                    "_goal : iff (eq (andb (andb (zeq l l0) (zeq h h0)) (beq s s0)) true)\n  (forall x : Z,\n   iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))",
                    "H : ok s",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x",
                    "BOUNDS : Z.lt l h",
                    "s : True",
                    "l : Z",
                    "h : Z",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (eq (beq s s2) true) (forall x : Z, iff (In x s) (In x s2))",
                    "H0 : ok s0",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x",
                    "BOUNDS0 : Z.lt l0 h0",
                    "s0 : True",
                    "l0 : Z",
                    "h0 : Z"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff (eq true true) (forall _ : Z, iff False False)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split ; intros .",
                "tactic_sig_no_out_arg": "split ; intros .",
                "tactic_args": [
                    "_goal : iff (eq false true)\n  (forall x : Z, iff False (or (and (Z.le l x) (Z.lt x h)) (In x s)))"
                ],
                "tactic_res": [
                    "_goal : iff False (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "_goal : eq false true",
                    "x : Z",
                    "H0 : eq false true",
                    "H0 : forall x : Z, iff False (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : iff False (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "_goal : False",
                    "H0 : forall x : Z, iff False (or (and (Z.le l x) (Z.lt x h)) (In x s))",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split ; intros .",
                "tactic_sig_no_out_arg": "split ; intros .",
                "tactic_args": [
                    "_goal : iff (eq false true)\n  (forall x : Z, iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False)"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False",
                    "_goal : eq false true",
                    "x : Z",
                    "H0 : eq false true",
                    "H0 : forall x : Z, iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False"
                ]
            },
            {
                "tactic_sig": "discriminate .",
                "tactic_sig_no_out_arg": "discriminate .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq false true"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "apply ( _i _i ) .",
                "tactic_sig_no_out_arg": "apply ( _i _i ) .",
                "tactic_args": [
                    "_goal : False",
                    "H0 : forall x : Z, iff (or (and (Z.le l x) (Z.lt x h)) (In x s)) False",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split ; intros .",
                "tactic_sig_no_out_arg": "split ; intros .",
                "tactic_args": [
                    "_goal : iff (eq (andb (andb (zeq l l0) (zeq h h0)) (beq s s0)) true)\n  (forall x : Z,\n   iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n     (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0)))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "_goal : eq (andb (andb (zeq l l0) (zeq h h0)) (beq s s0)) true",
                    "x : Z",
                    "H1 : eq (andb (andb (zeq l l0) (zeq h h0)) (beq s s0)) true",
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "InvBooleans .",
                "tactic_sig_no_out_arg": "InvBooleans .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : eq l l0",
                    "H2 : eq h h0",
                    "H3 : eq (beq s s0) true"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "BOUNDS : Z.lt l0 h0",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h0 x"
                ]
            },
            {
                "tactic_sig": "rewrite _i in _i by auto .",
                "tactic_sig_no_out_arg": "rewrite _i in _i by auto .",
                "tactic_args": [
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (eq (beq s s2) true) (forall x : Z, iff (In x s) (In x s2))",
                    "H3 : eq (beq s s0) true"
                ],
                "tactic_res": [
                    "H3 : forall x : Z, iff (In x s) (In x s0)"
                ]
            },
            {
                "tactic_sig": "rewrite _i .",
                "tactic_sig_no_out_arg": "rewrite _i .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "H3 : forall x : Z, iff (In x s) (In x s0)"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( zeq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zeq _i _i ) .",
                "tactic_args": [
                    "_goal : eq (andb (andb (zeq l l0) (zeq h h0)) (beq s s0)) true",
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq (andb (andb (left e) (zeq h h0)) (beq s s0)) true",
                    "_goal : eq (andb (andb (right n) (zeq h h0)) (beq s s0)) true",
                    "e : eq l l0",
                    "n : not (eq l l0)"
                ]
            },
            {
                "tactic_sig": "destruct ( zeq _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zeq _i _i ) .",
                "tactic_args": [
                    "_goal : eq (andb (andb (left e) (zeq h h0)) (beq s s0)) true",
                    "h : Z",
                    "h0 : Z"
                ],
                "tactic_res": [
                    "_goal : eq (andb (andb (left e) (left e0)) (beq s s0)) true",
                    "_goal : eq (andb (andb (left e) (right n)) (beq s s0)) true",
                    "e0 : eq h h0",
                    "n : not (eq h h0)"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : eq (andb (andb (left e) (left e0)) (beq s s0)) true"
                ],
                "tactic_res": [
                    "_goal : eq (beq s s0) true"
                ]
            },
            {
                "tactic_sig": "subst .",
                "tactic_sig_no_out_arg": "subst .",
                "tactic_args": [],
                "tactic_res": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "BOUNDS : Z.lt l0 h0",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h0 x"
                ]
            },
            {
                "tactic_sig": "apply _i .",
                "tactic_sig_no_out_arg": "apply _i .",
                "tactic_args": [
                    "_goal : eq (beq s s0) true",
                    "IHok : forall (s2 : t) (_ : ok s2),\niff (eq (beq s s2) true) (forall x : Z, iff (In x s) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : ok s0",
                    "_goal : forall x : Z, iff (In x s) (In x s0)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : ok s0"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros ; split ; intros .",
                "tactic_args": [
                    "_goal : forall x : Z, iff (In x s) (In x s0)"
                ],
                "tactic_res": [
                    "_goal : In x s0",
                    "_goal : In x s",
                    "H2 : In x s",
                    "x : Z",
                    "H2 : In x s0"
                ]
            },
            {
                "tactic_sig": "destruct ( proj1 ( _i _i ) ) ; auto as [_o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj1 ( _i _i ) ) ; auto .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "x : Z"
                ],
                "tactic_res": [
                    "H3 : and (Z.le l0 x) (Z.lt x h0)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : In x s0"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 x, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 x, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( proj2 ( _i _i ) ) ; auto as [_o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj2 ( _i _i ) ) ; auto .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l0 x) (Z.lt x h0)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "x : Z"
                ],
                "tactic_res": [
                    "H3 : and (Z.le l0 x) (Z.lt x h0)"
                ]
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : In x s"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 x, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 x, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq (andb (andb (left e) (right n)) (beq s s0)) true"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "subst _i .",
                "tactic_sig_no_out_arg": "subst _i .",
                "tactic_args": [
                    "l0 : Z"
                ],
                "tactic_res": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l x) (Z.lt x h0)) (In x s0))",
                    "BOUNDS0 : Z.lt l h0"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "h : Z",
                    "h0 : Z"
                ],
                "tactic_res": [
                    "l0 : Z.lt h h0",
                    "g : Z.ge h h0"
                ]
            },
            {
                "tactic_sig": "destruct ( proj2 ( _i _i ) ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj2 ( _i _i ) ) .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l x) (Z.lt x h0)) (In x s0))",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l h) (Z.lt h h0)) (In h s0)",
                    "H2 : and (Z.le l h) (Z.lt h h)",
                    "H2 : In h s"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l h) (Z.lt h h0)) (In h s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h h, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h h, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( proj1 ( _i _i ) ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj1 ( _i _i ) ) .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l x) (Z.lt x h0)) (In x s0))",
                    "h0 : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l h0) (Z.lt h0 h)) (In h0 s)",
                    "H2 : and (Z.le l h0) (Z.lt h0 h0)",
                    "H2 : In h0 s0"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l h0) (Z.lt h0 h)) (In h0 s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 h0, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 h0, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "exfalso .",
                "tactic_sig_no_out_arg": "exfalso .",
                "tactic_args": [
                    "_goal : eq (andb (andb (right n) (zeq h h0)) (beq s s0)) true"
                ],
                "tactic_res": [
                    "_goal : False"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "l : Z",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "l1 : Z.lt l l0",
                    "g : Z.ge l l0"
                ]
            },
            {
                "tactic_sig": "destruct ( proj1 ( _i _i ) ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj1 ( _i _i ) ) .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "l : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)",
                    "H2 : and (Z.le l0 l) (Z.lt l h0)",
                    "H2 : In l s0"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l l) (Z.lt l h)) (In l s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "BELOW0 : forall (x : Z) (_ : In x s0), Z.lt h0 x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h0 l, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h0 l, False"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "destruct ( proj2 ( _i _i ) ) as [| _o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( proj2 ( _i _i ) ) .",
                "tactic_args": [
                    "H1 : forall x : Z,\niff (or (and (Z.le l x) (Z.lt x h)) (In x s))\n  (or (and (Z.le l0 x) (Z.lt x h0)) (In x s0))",
                    "l0 : Z"
                ],
                "tactic_res": [
                    "_goal : or (and (Z.le l0 l0) (Z.lt l0 h0)) (In l0 s0)",
                    "H2 : and (Z.le l l0) (Z.lt l0 h)",
                    "H2 : In l0 s"
                ]
            },
            {
                "tactic_sig": "left ; lia .",
                "tactic_sig_no_out_arg": "left ; lia .",
                "tactic_args": [
                    "_goal : or (and (Z.le l0 l0) (Z.lt l0 h0)) (In l0 s0)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [],
                "tactic_res": []
            },
            {
                "tactic_sig": "exploit _i ; eauto .",
                "tactic_sig_no_out_arg": "exploit _i ; eauto .",
                "tactic_args": [
                    "_goal : False",
                    "BELOW : forall (x : Z) (_ : In x s), Z.lt h x"
                ],
                "tactic_res": [
                    "_goal : forall _ : Z.lt h l0, False"
                ]
            },
            {
                "tactic_sig": "lia .",
                "tactic_sig_no_out_arg": "lia .",
                "tactic_args": [
                    "_goal : forall _ : Z.lt h l0, False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_empty",
        "proof": [
            {
                "tactic_sig": "unfold In ; intros ; simpl .",
                "tactic_sig_no_out_arg": "unfold In ; intros ; simpl .",
                "tactic_args": [
                    "_goal : forall x : Z, not (In x empty)"
                ],
                "tactic_res": [
                    "_goal : not False",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "tauto .",
                "tactic_sig_no_out_arg": "tauto .",
                "tactic_args": [
                    "_goal : not False"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "constructor ; auto .",
                "tactic_sig_no_out_arg": "constructor ; auto .",
                "tactic_args": [
                    "_goal : R.ok (R.Cons l h R.Nil)"
                ],
                "tactic_res": [
                    "_goal : forall (x : Z) (_ : R.In x R.Nil), Z.lt h x",
                    "_goal : ok Nil"
                ]
            },
            {
                "tactic_sig": "simpl ; tauto .",
                "tactic_sig_no_out_arg": "simpl ; tauto .",
                "tactic_args": [
                    "_goal : forall (x : Z) (_ : R.In x R.Nil), Z.lt h x"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "constructor .",
                "tactic_sig_no_out_arg": "constructor .",
                "tactic_args": [
                    "_goal : ok Nil"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_interval",
        "proof": [
            {
                "tactic_sig": "intros _o _o _o .",
                "tactic_sig_no_out_arg": "intros .",
                "tactic_args": [
                    "_goal : forall x l h : Z, iff (In x (interval l h)) (and (Z.le l x) (Z.lt x h))"
                ],
                "tactic_res": [
                    "_goal : iff (In x (interval l h)) (and (Z.le l x) (Z.lt x h))",
                    "x : Z",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "unfold In , interval ; destruct ( zlt _i _i ) ; simpl .",
                "tactic_sig_no_out_arg": "unfold In , interval ; destruct ( zlt _i _i ) ; simpl .",
                "tactic_args": [
                    "_goal : iff (In x (interval l h)) (and (Z.le l x) (Z.lt x h))",
                    "l : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) False) (and (Z.le l x) (Z.lt x h))",
                    "_goal : iff False (and (Z.le l x) (Z.lt x h))",
                    "l0 : Z.lt l h",
                    "g : Z.ge l h"
                ]
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (or (and (Z.le l x) (Z.lt x h)) False) (and (Z.le l x) (Z.lt x h))"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff False (and (Z.le l x) (Z.lt x h))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "apply R.add_ok .",
                "tactic_sig_no_out_arg": "apply R.add_ok .",
                "tactic_args": [
                    "_goal : R.ok (R.add l h (proj1_sig s))"
                ],
                "tactic_res": [
                    "_goal : R.ok (proj1_sig s)",
                    "_goal : Z.lt l h"
                ]
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt l h"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_add",
        "proof": [
            {
                "tactic_sig": "unfold add , In ; intros .",
                "tactic_sig_no_out_arg": "unfold add , In ; intros .",
                "tactic_args": [
                    "_goal : forall (x l h : Z) (s : t),\niff (In x (add l h s)) (or (and (Z.le l x) (Z.lt x h)) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        match zlt l h with\n        | left x =>\n            exist (fun r : R.t => R.ok r) (R.add l h (proj1_sig s))\n              (add_obligation_1 l h s x)\n        | right _ => s\n        end)) (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))",
                    "s : True",
                    "x : Z",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        match zlt l h with\n        | left x =>\n            exist (fun r : R.t => R.ok r) (R.add l h (proj1_sig s))\n              (add_obligation_1 l h s x)\n        | right _ => s\n        end)) (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))",
                    "l : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        (exist (fun r : R.t => R.ok r) (R.add l h (proj1_sig s))\n           (add_obligation_1 l h s l0))))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))",
                    "_goal : iff (R.In x (proj1_sig s))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))",
                    "l0 : Z.lt l h",
                    "g : Z.ge l h"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        (exist (fun r : R.t => R.ok r) (R.add l h (proj1_sig s))\n           (add_obligation_1 l h s l0))))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": [
                    "_goal : iff (R.In x (R.add l h (proj1_sig s)))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))"
                ]
            },
            {
                "tactic_sig": "apply R.In_add .",
                "tactic_sig_no_out_arg": "apply R.In_add .",
                "tactic_args": [
                    "_goal : iff (R.In x (R.add l h (proj1_sig s)))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": [
                    "_goal : R.ok (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (R.In x (proj1_sig s))\n  (or (and (Z.le l x) (Z.lt x h)) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": [
                    "_goal : R.In x (proj1_sig s)",
                    "H1 : Z.lt x h",
                    "H : Z.le l x"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [
                    "_goal : R.In x (proj1_sig s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "apply R.remove_ok .",
                "tactic_sig_no_out_arg": "apply R.remove_ok .",
                "tactic_args": [
                    "_goal : R.ok (R.remove l h (proj1_sig s))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l h",
                    "_goal : R.ok (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt l h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_remove",
        "proof": [
            {
                "tactic_sig": "unfold remove , In ; intros .",
                "tactic_sig_no_out_arg": "unfold remove , In ; intros .",
                "tactic_args": [
                    "_goal : forall (x l h : Z) (s : t),\niff (In x (remove l h s))\n  (and (not (and (Z.le l x) (Z.lt x h))) (In x s))"
                ],
                "tactic_res": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        match zlt l h with\n        | left x =>\n            exist (fun r : R.t => R.ok r) (R.remove l h (proj1_sig s))\n              (remove_obligation_1 l h s x)\n        | right _ => s\n        end))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))",
                    "s : True",
                    "x : Z",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        match zlt l h with\n        | left x =>\n            exist (fun r : R.t => R.ok r) (R.remove l h (proj1_sig s))\n              (remove_obligation_1 l h s x)\n        | right _ => s\n        end))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))",
                    "l : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        (exist (fun r : R.t => R.ok r) (R.remove l h (proj1_sig s))\n           (remove_obligation_1 l h s l0))))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))",
                    "_goal : iff (R.In x (proj1_sig s))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))",
                    "l0 : Z.lt l h",
                    "g : Z.ge l h"
                ]
            },
            {
                "tactic_sig": "simpl .",
                "tactic_sig_no_out_arg": "simpl .",
                "tactic_args": [
                    "_goal : iff\n  (R.In x\n     (proj1_sig\n        (exist (fun r : R.t => R.ok r) (R.remove l h (proj1_sig s))\n           (remove_obligation_1 l h s l0))))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": [
                    "_goal : iff (R.In x (R.remove l h (proj1_sig s)))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))"
                ]
            },
            {
                "tactic_sig": "apply R.In_remove .",
                "tactic_sig_no_out_arg": "apply R.In_remove .",
                "tactic_args": [
                    "_goal : iff (R.In x (R.remove l h (proj1_sig s)))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": [
                    "_goal : R.ok (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "intuition .",
                "tactic_sig_no_out_arg": "intuition .",
                "tactic_args": [
                    "_goal : iff (R.In x (proj1_sig s))\n  (and (not (and (Z.le l x) (Z.lt x h))) (R.In x (proj1_sig s)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "apply R.inter_ok ; apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply R.inter_ok ; apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (R.inter (proj1_sig s1) (proj1_sig s2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_inter",
        "proof": [
            {
                "tactic_sig": "unfold inter , In ; intros ; simpl .",
                "tactic_sig_no_out_arg": "unfold inter , In ; intros ; simpl .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s1 s2 : t),\niff (In x (inter s1 s2)) (and (In x s1) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff (R.In x (R.inter (proj1_sig s1) (proj1_sig s2)))\n  (and (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))",
                    "s1 : True",
                    "s2 : True",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "apply R.In_inter ; apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply R.In_inter ; apply proj2_sig .",
                "tactic_args": [
                    "_goal : iff (R.In x (R.inter (proj1_sig s1) (proj1_sig s2)))\n  (and (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": null,
        "proof": [
            {
                "tactic_sig": "destruct ( R.In_ok_union _ ( proj2_sig _i ) _ ( proj2_sig _i ) ) as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( R.In_ok_union _ ( proj2_sig _i ) _ ( proj2_sig _i ) ) .",
                "tactic_args": [
                    "s1 : True",
                    "s2 : True"
                ],
                "tactic_res": [
                    "H0 : forall x : Z,\niff (or (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))\n  (R.In x (R.union (proj1_sig s1) (proj1_sig s2)))",
                    "H : R.ok (R.union (proj1_sig s1) (proj1_sig s2))"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : R.ok (R.union (proj1_sig s1) (proj1_sig s2))"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "In_union",
        "proof": [
            {
                "tactic_sig": "unfold union , In ; intros ; simpl .",
                "tactic_sig_no_out_arg": "unfold union , In ; intros ; simpl .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s1 s2 : t),\niff (In x (union s1 s2)) (or (In x s1) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff (R.In x (R.union (proj1_sig s1) (proj1_sig s2)))\n  (or (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))",
                    "s1 : True",
                    "s2 : True",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( R.In_ok_union _ ( proj2_sig _i ) _ ( proj2_sig _i ) ) as [_o _o ] .",
                "tactic_sig_no_out_arg": "destruct ( R.In_ok_union _ ( proj2_sig _i ) _ ( proj2_sig _i ) ) .",
                "tactic_args": [
                    "s1 : True",
                    "s2 : True"
                ],
                "tactic_res": [
                    "H0 : forall x : Z,\niff (or (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))\n  (R.In x (R.union (proj1_sig s1) (proj1_sig s2)))",
                    "H : R.ok (R.union (proj1_sig s1) (proj1_sig s2))"
                ]
            },
            {
                "tactic_sig": "generalize ( _i _i ) ; tauto .",
                "tactic_sig_no_out_arg": "generalize ( _i _i ) ; tauto .",
                "tactic_args": [
                    "_goal : iff (R.In x (R.union (proj1_sig s1) (proj1_sig s2)))\n  (or (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))",
                    "H0 : forall x : Z,\niff (or (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))\n  (R.In x (R.union (proj1_sig s1) (proj1_sig s2)))",
                    "x : Z"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "mem_spec",
        "proof": [
            {
                "tactic_sig": "unfold mem , In ; intros .",
                "tactic_sig_no_out_arg": "unfold mem , In ; intros .",
                "tactic_args": [
                    "_goal : forall (x : Z) (s : t), iff (eq (mem x s) true) (In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (eq (R.mem x (proj1_sig s)) true) (R.In x (proj1_sig s))",
                    "s : True",
                    "x : Z"
                ]
            },
            {
                "tactic_sig": "apply R.mem_In .",
                "tactic_sig_no_out_arg": "apply R.mem_In .",
                "tactic_args": [
                    "_goal : iff (eq (R.mem x (proj1_sig s)) true) (R.In x (proj1_sig s))"
                ],
                "tactic_res": [
                    "_goal : R.ok (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "contains_spec",
        "proof": [
            {
                "tactic_sig": "unfold contains , In ; intros .",
                "tactic_sig_no_out_arg": "unfold contains , In ; intros .",
                "tactic_args": [
                    "_goal : forall (l h : Z) (s : t),\niff (eq (contains l h s) true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), In x s)"
                ],
                "tactic_res": [
                    "_goal : iff (eq (if zlt l h then R.contains l h (proj1_sig s) else true) true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))",
                    "s : True",
                    "l : Z",
                    "h : Z"
                ]
            },
            {
                "tactic_sig": "destruct ( zlt _i _i ) as [_o | _o ] .",
                "tactic_sig_no_out_arg": "destruct ( zlt _i _i ) .",
                "tactic_args": [
                    "_goal : iff (eq (if zlt l h then R.contains l h (proj1_sig s) else true) true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))",
                    "l : Z",
                    "h : Z"
                ],
                "tactic_res": [
                    "_goal : iff (eq (R.contains l h (proj1_sig s)) true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))",
                    "_goal : iff (eq true true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))",
                    "l0 : Z.lt l h",
                    "g : Z.ge l h"
                ]
            },
            {
                "tactic_sig": "apply R.contains_In .",
                "tactic_sig_no_out_arg": "apply R.contains_In .",
                "tactic_args": [
                    "_goal : iff (eq (R.contains l h (proj1_sig s)) true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))"
                ],
                "tactic_res": [
                    "_goal : Z.lt l h",
                    "_goal : R.ok (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : Z.lt l h"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply proj2_sig .",
                "tactic_args": [
                    "_goal : R.ok (proj1_sig s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "split ; intros .",
                "tactic_sig_no_out_arg": "split ; intros .",
                "tactic_args": [
                    "_goal : iff (eq true true)\n  (forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s))"
                ],
                "tactic_res": [
                    "_goal : R.In x (proj1_sig s)",
                    "_goal : eq true true",
                    "H0 : and (Z.le l x) (Z.lt x h)",
                    "x : Z",
                    "H : eq true true",
                    "H : forall (x : Z) (_ : and (Z.le l x) (Z.lt x h)), R.In x (proj1_sig s)"
                ]
            },
            {
                "tactic_sig": "extlia .",
                "tactic_sig_no_out_arg": "extlia .",
                "tactic_args": [
                    "_goal : R.In x (proj1_sig s)"
                ],
                "tactic_res": []
            },
            {
                "tactic_sig": "auto .",
                "tactic_sig_no_out_arg": "auto .",
                "tactic_args": [
                    "_goal : eq true true"
                ],
                "tactic_res": []
            }
        ]
    },
    {
        "lemma_name": "beq_spec",
        "proof": [
            {
                "tactic_sig": "unfold mem , In ; intros .",
                "tactic_sig_no_out_arg": "unfold mem , In ; intros .",
                "tactic_args": [
                    "_goal : forall s1 s2 : t,\niff (eq (beq s1 s2) true) (forall x : Z, iff (In x s1) (In x s2))"
                ],
                "tactic_res": [
                    "_goal : iff (eq (beq s1 s2) true)\n  (forall x : Z, iff (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))",
                    "s1 : True",
                    "s2 : True"
                ]
            },
            {
                "tactic_sig": "apply R.beq_spec ; apply proj2_sig .",
                "tactic_sig_no_out_arg": "apply R.beq_spec ; apply proj2_sig .",
                "tactic_args": [
                    "_goal : iff (eq (beq s1 s2) true)\n  (forall x : Z, iff (R.In x (proj1_sig s1)) (R.In x (proj1_sig s2)))"
                ],
                "tactic_res": []
            }
        ]
    }
]